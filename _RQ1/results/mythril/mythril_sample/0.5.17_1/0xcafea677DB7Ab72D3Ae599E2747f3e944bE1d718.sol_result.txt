==== Multiple Calls in a Single Transaction ====
SWC ID: 113
Severity: Low
Contract: Claims
Function name: changeDependentContractAddress()
PC address: 1316
Estimated Gas Usage: 61034 - 482575
Multiple calls are executed in the same transaction.
This call is executed following another call within the same transaction. It is possible that the call never gets executed if a prior call fails permanently. This might be caused intentionally by a malicious callee. If possible, refactor the code such that each transaction only executes one external call or make sure that all callees can be trusted (i.e. they’re part of your own codebase).
--------------------
In file: /bdata2/sc/dataset/mainnet/0xcafea677DB7Ab72D3Ae599E2747f3e944bE1d718.sol:9328

ms.getLatestAddress("TD")

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [ATTACKER], function: changeMasterAddress(address), txdata: 0xd46655f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4, value: 0x0
Caller: [CREATOR], function: changeDependentContractAddress(), txdata: 0x0ea9c984, value: 0x0

==== Exception State ====
SWC ID: 110
Severity: Medium
Contract: Gateway
Function name: buyCover(address,address,uint256,uint16,uint8,bytes)
PC address: 4296
Estimated Gas Usage: 5554 - 75338
An assertion violation was triggered.
It is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).
--------------------
In file: /bdata2/sc/dataset/mainnet/0xcafea677DB7Ab72D3Ae599E2747f3e944bE1d718.sol:638

function buyCover (
    address contractAddress,
    address coverAsset,
    uint sumAssured,
    uint16 coverPeriod,
    CoverType coverType,
    bytes calldata data
  ) external payable onlyMember whenNotPaused returns (uint) {

    // only 1 cover type supported at this time
    require(coverType == CoverType.SIGNED_QUOTE_CONTRACT_COVER, "Gateway: Unsupported cover type");
    require(sumAssured % 10 ** assetDecimals(coverAsset) == 0, "Gateway: Only whole unit sumAssured supported");

    {
      (
      uint[] memory coverDetails,
      uint8 _v,
      bytes32 _r,
      bytes32 _s
      ) = convertToLegacyQuote(sumAssured, data, coverAsset);

      {
        uint premiumAmount = coverDetails[1];
        if (coverAsset == ETH) {
          require(msg.value == premiumAmount, "Gateway: ETH amount does not match premium");
          // solhint-disable-next-line avoid-low-level-calls, avoid-call-value
          (bool ok, /* data */) = address(pool).call.value(premiumAmount)("");
          require(ok, "Gateway: Transfer to Pool failed");
        } else {
          IERC20 token = IERC20(coverAsset);
          token.safeTransferFrom(msg.sender, address(pool), premiumAmount);
        }
      }

      quotation.createCover(
        msg.sender,
        contractAddress,
        getCurrencyFromAssetAddress(coverAsset),
        coverDetails,
        coverPeriod, _v, _r, _s
      );
    }

    uint coverId = quotationData.getCoverLength().sub(1);
    emit CoverBought(coverId, msg.sender, contractAddress, coverAsset, sumAssured, coverPeriod, coverType, data);
    return coverId;
  }

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [SOMEGUY], function: changeMasterAddress(address), txdata: 0xd46655f40000000000000000000000000000000000000000000000000000000000000000, decoded_data: ('0x0000000000000000000000000000000000000000',), value: 0x0
Caller: [SOMEGUY], function: buyCover(address,address,uint256,uint16,uint8,bytes), txdata: 0x04836c4a666666666666666666666666666666666666666666666666666666666666666666666666000000000000000000000000000000000000000000000000000000000000000266666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666010000000000000000000000000000000000000000000000000000000000000024, value: 0x0

==== Dependence on predictable environment variable ====
SWC ID: 116
Severity: Low
Contract: Governance
Function name: closeProposal(uint256)
PC address: 4883
Estimated Gas Usage: 2974 - 3449
A control flow decision is made based on The block.timestamp environment variable.
The block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.
--------------------
In file: /bdata2/sc/dataset/mainnet/0xcafea677DB7Ab72D3Ae599E2747f3e944bE1d718.sol:8415

allProposalData[_proposalId].dateUpd.add(maxDraftTime) <= now &&
      allProposalData[_proposalId].propStatus < uint(ProposalStatus.VotingStarted)

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [ATTACKER], function: closeProposal(uint256), txdata: 0x0386a0160000000000000000000000000000000000000000000000000000008000000100, decoded_data: (549755814144,), value: 0x0

==== Dependence on predictable environment variable ====
SWC ID: 116
Severity: Low
Contract: Claims
Function name: submitCAVote(uint256,int8)
PC address: 5520
Estimated Gas Usage: 15554 - 224904
A control flow decision is made based on The block.timestamp environment variable.
The block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.
--------------------
In file: /bdata2/sc/dataset/mainnet/0xcafea677DB7Ab72D3Ae599E2747f3e944bE1d718.sol:9383

require(cd.userClaimVotePausedOn(msg.sender).add(cd.pauseDaysCA()) < now)

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [SOMEGUY], function: changeMasterAddress(address), txdata: 0xd46655f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4, value: 0x0
Caller: [ATTACKER], function: changeDependentContractAddress(), txdata: 0x0ea9c984, value: 0x0
Caller: [SOMEGUY], function: submitCAVote(uint256,int8), txdata: 0xbfa52b1201010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101, value: 0x0

==== Multiple Calls in a Single Transaction ====
SWC ID: 113
Severity: Low
Contract: Gateway
Function name: changeDependentContractAddress()
PC address: 6440
Estimated Gas Usage: 75226 - 572224
Multiple calls are executed in the same transaction.
This call is executed following another call within the same transaction. It is possible that the call never gets executed if a prior call fails permanently. This might be caused intentionally by a malicious callee. If possible, refactor the code such that each transaction only executes one external call or make sure that all callees can be trusted (i.e. they’re part of your own codebase).
--------------------
In file: /bdata2/sc/dataset/mainnet/0xcafea677DB7Ab72D3Ae599E2747f3e944bE1d718.sol:605

master.tokenAddress()

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [ATTACKER], function: changeMasterAddress(address), txdata: 0xd46655f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4, value: 0x0
Caller: [SOMEGUY], function: changeDependentContractAddress(), txdata: 0x0ea9c984, value: 0x0

==== Exception State ====
SWC ID: 110
Severity: Medium
Contract: ClaimsData
Function name: getVoteVerdict(uint256,uint256,uint8)
PC address: 8056
Estimated Gas Usage: 1289 - 1574
An assertion violation was triggered.
It is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).
--------------------
In file: /bdata2/sc/dataset/mainnet/0xcafea677DB7Ab72D3Ae599E2747f3e944bE1d718.sol:7578

function getVoteVerdict(
    uint _claimId,
    uint _index,
    uint8 _ca
  )
  external
  view
  returns (int8 ver)
  {
    if (_ca == 1)
      ver = allvotes[claimVoteCA[_claimId][_index]].verdict;
    else
      ver = allvotes[claimVoteMember[_claimId][_index]].verdict;
  }

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [ATTACKER], function: getVoteVerdict(uint256,uint256,uint8), txdata: 0x21fffaea000000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001, decoded_data: (0, 7067388259113537318333190002971674063309935587502475832486424805170479104, 1), value: 0x0

==== Exception State ====
SWC ID: 110
Severity: Medium
Contract: ClaimsData
Function name: getClaimFromNewStart(uint256,address)
PC address: 8737
Estimated Gas Usage: 2103 - 2198
An assertion violation was triggered.
It is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).
--------------------
In file: /bdata2/sc/dataset/mainnet/0xcafea677DB7Ab72D3Ae599E2747f3e944bE1d718.sol:4611

function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [SOMEGUY], function: getClaimFromNewStart(uint256,address), txdata: 0x3aee2f7c000000000000000000000000000000000000000000000001000000000001ffff0000000000000000000000000000000004000080200000022010000000100220, decoded_data: (18446744073709682687, '0x0000000004000080200000022010000000100220'), value: 0x0

==== Exception State ====
SWC ID: 110
Severity: Medium
Contract: Incidents
Function name: incidents(uint256)
PC address: 9032
Estimated Gas Usage: 1112 - 1207
An assertion violation was triggered.
It is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).
--------------------
In file: /bdata2/sc/dataset/mainnet/0xcafea677DB7Ab72D3Ae599E2747f3e944bE1d718.sol:4267

Incident[] public incidents

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [ATTACKER], function: incidents(uint256), txdata: 0xa6c6a8f30000000020080204200010040000000000000000000000000000000000000000, decoded_data: (3373287582277611555025009115691349223379251672137423083187887669248,), value: 0x0

==== Exception State ====
SWC ID: 110
Severity: Medium
Contract: ClaimsData
Function name: getVoteDetails(uint256)
PC address: 10250
Estimated Gas Usage: 1235 - 1330
An assertion violation was triggered.
It is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).
--------------------
In file: /bdata2/sc/dataset/mainnet/0xcafea677DB7Ab72D3Ae599E2747f3e944bE1d718.sol:7499

function getVoteDetails(uint _voteid)
  external view
  returns (
    uint tokens,
    uint claimId,
    int8 verdict,
    bool rewardClaimed
  )
  {
    return (
    allvotes[_voteid].tokens,
    allvotes[_voteid].claimId,
    allvotes[_voteid].verdict,
    allvotes[_voteid].rewardClaimed
    );
  }

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [CREATOR], function: getVoteDetails(uint256), txdata: 0x54a1b4310000000000000000000000000000000000000000000000000000001000002040, decoded_data: (68719484992,), value: 0x0

==== Exception State ====
SWC ID: 110
Severity: Low
Contract: Incidents
Function name: redeemPayout(uint256,uint256,uint256)
PC address: 10399
Estimated Gas Usage: 2355 - 3443
An assertion violation was triggered.
It is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values). This issue is reported for internal compiler generated code.
--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [SOMEGUY], function: redeemPayout(uint256,uint256,uint256), txdata: 0xf8b6b5fb000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, decoded_data: (1, 0, 0), value: 0x0

==== Exception State ====
SWC ID: 110
Severity: Medium
Contract: ClaimsData
Function name: getClaimDateUpd(uint256)
PC address: 10417
Estimated Gas Usage: 1117 - 1212
An assertion violation was triggered.
It is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).
--------------------
In file: /bdata2/sc/dataset/mainnet/0xcafea677DB7Ab72D3Ae599E2747f3e944bE1d718.sol:7404

function getClaimDateUpd(uint _claimId) external view returns (uint dateupd) {
    dateupd = allClaims[_claimId].dateUpd;
  }

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [ATTACKER], function: getClaimDateUpd(uint256), txdata: 0x54d0f8d80000000000000000000000000000000000000000000080000000000000000000, decoded_data: (604462909807314587353088,), value: 0x0

==== Exception State ====
SWC ID: 110
Severity: Medium
Contract: ClaimsData
Function name: getClaim(uint256)
PC address: 10465
Estimated Gas Usage: 1157 - 1252
An assertion violation was triggered.
It is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).
--------------------
In file: /bdata2/sc/dataset/mainnet/0xcafea677DB7Ab72D3Ae599E2747f3e944bE1d718.sol:7527

function getClaim(
    uint _claimId
  )
  external
  view
  returns (
    uint claimId,
    uint coverId,
    int8 vote,
    uint status,
    uint dateUpd,
    uint state12Count
  )
  {
    return (
    _claimId,
    allClaims[_claimId].coverId,
    claimVote[_claimId],
    claimsStatus[_claimId],
    allClaims[_claimId].dateUpd,
    claimState12Count[_claimId]
    );
  }

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [ATTACKER], function: getClaim(uint256), txdata: 0x5aef24470000000000000000000000000000000000000000000000000000000000000001, decoded_data: (1,), value: 0x0

==== Exception State ====
SWC ID: 110
Severity: Medium
Contract: ClaimsData
Function name: getVoteToken(uint256,uint256,uint8)
PC address: 10910
Estimated Gas Usage: 1355 - 1640
An assertion violation was triggered.
It is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).
--------------------
In file: /bdata2/sc/dataset/mainnet/0xcafea677DB7Ab72D3Ae599E2747f3e944bE1d718.sol:7598

function getVoteToken(
    uint _claimId,
    uint _index,
    uint8 _ca
  )
  external
  view
  returns (uint tok)
  {
    if (_ca == 1)
      tok = allvotes[claimVoteCA[_claimId][_index]].tokens;
    else
      tok = allvotes[claimVoteMember[_claimId][_index]].tokens;
  }

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [ATTACKER], function: getVoteToken(uint256,uint256,uint8), txdata: 0x5d2462e4000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001, decoded_data: (1393796574908163946345982392040522594123776, 0, 1), value: 0x0

==== Exception State ====
SWC ID: 110
Severity: Medium
Contract: ClaimsData
Function name: getRewardStatus(uint256)
PC address: 11053
Estimated Gas Usage: 1208 - 1303
An assertion violation was triggered.
It is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).
--------------------
In file: /bdata2/sc/dataset/mainnet/0xcafea677DB7Ab72D3Ae599E2747f3e944bE1d718.sol:7390

function getRewardStatus(uint statusNumber) external view returns (uint percCA, uint percMV) {
    return (rewardStatus[statusNumber].percCA, rewardStatus[statusNumber].percMV);
  }

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [SOMEGUY], function: getRewardStatus(uint256), txdata: 0x5f39579d0000000000000000000200000000000000000000000000000000000000000000, decoded_data: (191561942608236107294793378393788647952342390272950272,), value: 0x0

==== Exception State ====
SWC ID: 110
Severity: Medium
Contract: Governance
Function name: getSolutionAction(uint256,uint256)
PC address: 11329
Estimated Gas Usage: 1249 - 1534
An assertion violation was triggered.
It is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).
--------------------
In file: /bdata2/sc/dataset/mainnet/0xcafea677DB7Ab72D3Ae599E2747f3e944bE1d718.sol:8673

function getSolutionAction(uint _proposalId, uint _solution) external view returns (uint, bytes memory) {
    return (
    _solution,
    allProposalSolutions[_proposalId][_solution]
    );
  }

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [CREATOR], function: getSolutionAction(uint256,uint256), txdata: 0x2f54243a00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000, decoded_data: (1, 0), value: 0x0

==== Multiple Calls in a Single Transaction ====
SWC ID: 113
Severity: Low
Contract: Claims
Function name: checkVoteClosing(uint256)
PC address: 11907
Estimated Gas Usage: 10728 - 150670
Multiple calls are executed in the same transaction.
This call is executed following another call within the same transaction. It is possible that the call never gets executed if a prior call fails permanently. This might be caused intentionally by a malicious callee. If possible, refactor the code such that each transaction only executes one external call or make sure that all callees can be trusted (i.e. they’re part of your own codebase).
--------------------
In file: /bdata2/sc/dataset/mainnet/0xcafea677DB7Ab72D3Ae599E2747f3e944bE1d718.sol:9447

cd.getClaimDateUpd(claimId)

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [SOMEGUY], function: changeMasterAddress(address), txdata: 0xd46655f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4, value: 0x0
Caller: [SOMEGUY], function: changeDependentContractAddress(), txdata: 0x0ea9c984, value: 0x0
Caller: [CREATOR], function: checkVoteClosing(uint256), txdata: 0xef154cf20101010101010101010101010101010101010101010101010101010104010101, decoded_data: (454086624460063511464984254936031011189294057512315937409637584344807702785,), value: 0x0

==== Dependence on predictable environment variable ====
SWC ID: 116
Severity: Low
Contract: Claims
Function name: checkVoteClosing(uint256)
PC address: 12165
Estimated Gas Usage: 7875 - 112644
A control flow decision is made based on The block.timestamp environment variable.
The block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.
--------------------
In file: /bdata2/sc/dataset/mainnet/0xcafea677DB7Ab72D3Ae599E2747f3e944bE1d718.sol:9448

if (status == 12 && dateUpd.add(cd.payoutRetryTime()) < now) {
      if (cd.getClaimState12Count(claimId) < 60)
        close = 1;
    }

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [CREATOR], function: changeMasterAddress(address), txdata: 0xd46655f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4, value: 0x0
Caller: [CREATOR], function: changeDependentContractAddress(), txdata: 0x0ea9c984, value: 0x0
Caller: [CREATOR], function: checkVoteClosing(uint256), txdata: 0xef154cf20104080104010101010101010101010101010101010101010101010201010104, decoded_data: (459435478194763073405917750823049788965954963922433273191535874385429725444,), value: 0x0

==== Exception State ====
SWC ID: 110
Severity: Medium
Contract: ClaimsData
Function name: getUserClaimByIndex(uint256,address)
PC address: 12252
Estimated Gas Usage: 1289 - 1574
An assertion violation was triggered.
It is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).
--------------------
In file: /bdata2/sc/dataset/mainnet/0xcafea677DB7Ab72D3Ae599E2747f3e944bE1d718.sol:7698

function getUserClaimByIndex(
    uint _index,
    address _add
  )
  external
  view
  returns (
    uint status,
    uint coverid,
    uint claimId
  )
  {
    claimId = allClaimsByAddress[_add][_index];
    status = claimsStatus[claimId];
    coverid = allClaims[claimId].coverId;
  }

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [CREATOR], function: getUserClaimByIndex(uint256,address), txdata: 0x6e3979e200000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004002100010, decoded_data: (191561942608236107294793378393788647952342390272950272, '0x0000000000000000000000000000004002100010'), value: 0x0

==== Exception State ====
SWC ID: 110
Severity: Low
Contract: Governance
Function name: getPendingReward(address)
PC address: 12406
Estimated Gas Usage: 2144 - 2902
An assertion violation was triggered.
It is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values). This issue is reported for internal compiler generated code.
--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [ATTACKER], function: getPendingReward(address), txdata: 0x4df9d6ba0000000000000000000000000000000000000000000000000000000480048080, decoded_data: ('0x0000000000000000000000000000000480048080',), value: 0x0

==== Dependence on predictable environment variable ====
SWC ID: 116
Severity: Low
Contract: Claims
Function name: checkVoteClosing(uint256)
PC address: 12617
Estimated Gas Usage: 7973 - 112742
A control flow decision is made based on The block.timestamp environment variable.
The block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.
--------------------
In file: /bdata2/sc/dataset/mainnet/0xcafea677DB7Ab72D3Ae599E2747f3e944bE1d718.sol:9455

if (status != 12 && dateUpd.add(cd.maxVotingTime()) <= now) {
      close = 1;
    } else if (status != 12 && dateUpd.add(cd.minVotingTime()) >= now) {
      close = 0;
    } else if (status == 0 || (status >= 1 && status <= 5)) {
      close = _checkVoteClosingFinal(claimId, status);
    }

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [ATTACKER], function: changeMasterAddress(address), txdata: 0xd46655f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4, value: 0x0
Caller: [ATTACKER], function: changeDependentContractAddress(), txdata: 0x0ea9c984, value: 0x0
Caller: [CREATOR], function: checkVoteClosing(uint256), txdata: 0xef154cf20104200108010101010101010101010201010101010101010101010201010140, decoded_data: (459601120528335213611044931755416548651777886734284207534430827415813030208,), value: 0x0

==== Dependence on predictable environment variable ====
SWC ID: 116
Severity: Low
Contract: Claims
Function name: checkVoteClosing(uint256)
PC address: 12828
Estimated Gas Usage: 10585 - 150151
A control flow decision is made based on The block.timestamp environment variable.
The block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.
--------------------
In file: /bdata2/sc/dataset/mainnet/0xcafea677DB7Ab72D3Ae599E2747f3e944bE1d718.sol:9457

if (status != 12 && dateUpd.add(cd.minVotingTime()) >= now) {
      close = 0;
    } else if (status == 0 || (status >= 1 && status <= 5)) {
      close = _checkVoteClosingFinal(claimId, status);
    }

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [ATTACKER], function: changeMasterAddress(address), txdata: 0xd46655f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4, value: 0x0
Caller: [CREATOR], function: changeDependentContractAddress(), txdata: 0x0ea9c984, value: 0x0
Caller: [CREATOR], function: checkVoteClosing(uint256), txdata: 0xef154cf201010101010008400401010101010101fffff7fffffffffffffffffe01010101, decoded_data: (454086624459663779422932881679871849823183191417556682833295737961442246913,), value: 0x0

==== Integer Arithmetic Bugs ====
SWC ID: 101
Severity: High
Contract: Claims
Function name: checkVoteClosing(uint256)
PC address: 13178
Estimated Gas Usage: 10703 - 150550
The arithmetic operator can overflow.
It is possible to cause an integer overflow or underflow in the arithmetic operation. 
--------------------
In file: /bdata2/sc/dataset/mainnet/0xcafea677DB7Ab72D3Ae599E2747f3e944bE1d718.sol:4612

a + b

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [ATTACKER], function: changeMasterAddress(address), txdata: 0xd46655f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4, value: 0x0
Caller: [SOMEGUY], function: changeDependentContractAddress(), txdata: 0x0ea9c984, value: 0x0
Caller: [CREATOR], function: checkVoteClosing(uint256), txdata: 0xef154cf20000000000000000000000000000000180000000000000000000800100000000, decoded_data: (510423550381407695195062051889435639808,), value: 0x0

==== Exception State ====
SWC ID: 110
Severity: Medium
Contract: ClaimsData
Function name: getClaimOfEmergencyPauseByIndex(uint256)
PC address: 14235
Estimated Gas Usage: 1209 - 1304
An assertion violation was triggered.
It is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).
--------------------
In file: /bdata2/sc/dataset/mainnet/0xcafea677DB7Ab72D3Ae599E2747f3e944bE1d718.sol:7299

function getClaimOfEmergencyPauseByIndex(
    uint _index
  )
  external
  view
  returns (
    uint coverId,
    uint dateUpd,
    bool submit
  )
  {
    coverId = claimPause[_index].coverid;
    dateUpd = claimPause[_index].dateUpd;
    submit = claimPause[_index].submit;
  }

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [SOMEGUY], function: getClaimOfEmergencyPauseByIndex(uint256), txdata: 0x965bfafb0000000000000000000000000000000000000000000000000000000000800408, decoded_data: (8389640,), value: 0x0

==== Exception State ====
SWC ID: 110
Severity: Medium
Contract: ClaimsData
Function name: getClaimCoverId(uint256)
PC address: 14358
Estimated Gas Usage: 1231 - 1326
An assertion violation was triggered.
It is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).
--------------------
In file: /bdata2/sc/dataset/mainnet/0xcafea677DB7Ab72D3Ae599E2747f3e944bE1d718.sol:7802

function getClaimCoverId(uint _claimId) external view returns (uint claimId, uint coverid) {
    return (_claimId, allClaims[_claimId].coverId);
  }

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [CREATOR], function: getClaimCoverId(uint256), txdata: 0x96ff592f0000010000000000000000000000000000000000000000000000000000000000, decoded_data: (6901746346790563787434755862277025452451108972170386555162524223799296,), value: 0x0

==== Dependence on predictable environment variable ====
SWC ID: 116
Severity: Low
Contract: Claims
Function name: submitClaim(uint256)
PC address: 15045
Estimated Gas Usage: 15338 - 224688
A control flow decision is made based on The block.timestamp environment variable.
The block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.
--------------------
In file: /bdata2/sc/dataset/mainnet/0xcafea677DB7Ab72D3Ae599E2747f3e944bE1d718.sol:9363

require(expirationDate.add(gracePeriod) > now, "Claims: Grace period has expired")

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [ATTACKER], function: changeMasterAddress(address), txdata: 0xd46655f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4, value: 0x0
Caller: [ATTACKER], function: changeDependentContractAddress(), txdata: 0x0ea9c984, value: 0x0
Caller: [ATTACKER], function: submitClaim(uint256), txdata: 0x6aa14a960101010101010101010101010101010101010101010101010101010101010101, decoded_data: (454086624460063511464984254936031011189294057512315937409637584344757371137,), value: 0x0

==== Exception State ====
SWC ID: 110
Severity: Medium
Contract: ClaimsData
Function name: getPendingClaimDetailsByIndex(uint256)
PC address: 16519
Estimated Gas Usage: 1166 - 1261
An assertion violation was triggered.
It is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).
--------------------
In file: /bdata2/sc/dataset/mainnet/0xcafea677DB7Ab72D3Ae599E2747f3e944bE1d718.sol:7902

function getPendingClaimDetailsByIndex(
    uint _index
  )
  external
  view
  returns (
    uint claimId,
    uint pendingTime,
    bool voting
  )
  {
    claimId = claimPauseVotingEP[_index].claimid;
    pendingTime = claimPauseVotingEP[_index].pendingTime;
    voting = claimPauseVotingEP[_index].voting;
  }

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [ATTACKER], function: getPendingClaimDetailsByIndex(uint256), txdata: 0xa40d35180000000000000000000000000004008000000000000000020000040080000000, decoded_data: (89246536937088372689466221933837259968086016,), value: 0x0

==== Multiple Calls in a Single Transaction ====
SWC ID: 113
Severity: Low
Contract: Claims
Function name: setClaimStatus(uint256,uint256)
PC address: 17881
Estimated Gas Usage: 15465 - 225197
Multiple calls are executed in the same transaction.
This call is executed following another call within the same transaction. It is possible that the call never gets executed if a prior call fails permanently. This might be caused intentionally by a malicious callee. If possible, refactor the code such that each transaction only executes one external call or make sure that all callees can be trusted (i.e. they’re part of your own codebase).
--------------------
In file: /bdata2/sc/dataset/mainnet/0xcafea677DB7Ab72D3Ae599E2747f3e944bE1d718.sol:9509

cd.getClaim(claimId)

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [SOMEGUY], function: changeMasterAddress(address), txdata: 0xd46655f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4, value: 0x0
Caller: [SOMEGUY], function: changeDependentContractAddress(), txdata: 0x0ea9c984, value: 0x0
Caller: [CREATOR], function: setClaimStatus(uint256,uint256), txdata: 0xf511bdfe0000000000000000000000000000000000000000000000000000000001010101000000000000000000000000000000000000000000000000000000000000000c, decoded_data: (16843009, 12), value: 0x0

==== Exception State ====
SWC ID: 110
Severity: Medium
Contract: ClaimsData
Function name: getVoteVoter(uint256,uint256,uint8)
PC address: 18157
Estimated Gas Usage: 1353 - 1638
An assertion violation was triggered.
It is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).
--------------------
In file: /bdata2/sc/dataset/mainnet/0xcafea677DB7Ab72D3Ae599E2747f3e944bE1d718.sol:7618

function getVoteVoter(
    uint _claimId,
    uint _index,
    uint8 _ca
  )
  external
  view
  returns (address voter)
  {
    if (_ca == 1)
      voter = allvotes[claimVoteCA[_claimId][_index]].voter;
    else
      voter = allvotes[claimVoteMember[_claimId][_index]].voter;
  }

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [ATTACKER], function: getVoteVoter(uint256,uint256,uint8), txdata: 0xb32c7879000000000000000000000000000000000000000002000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001, decoded_data: (618970019642690137449562112, 205688069665150755269371147819668813122841983204197482918576128, 1), value: 0x0

==== External Call To User-Supplied Address ====
SWC ID: 107
Severity: Low
Contract: Claims
Function name: setClaimStatus(uint256,uint256)
PC address: 18352
Estimated Gas Usage: 15465 - 225197
A call to a user-supplied address is executed.
An external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.
--------------------
In file: /bdata2/sc/dataset/mainnet/0xcafea677DB7Ab72D3Ae599E2747f3e944bE1d718.sol:9513

cd.updateState12Count(claimId, 1)

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [ATTACKER], function: changeMasterAddress(address), txdata: 0xd46655f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4, value: 0x0
Caller: [SOMEGUY], function: changeDependentContractAddress(), txdata: 0x0ea9c984, value: 0x0
Caller: [CREATOR], function: setClaimStatus(uint256,uint256), txdata: 0xf511bdfe0000000000000000000000000000000000000000000000000000000001010101000000000000000000000000000000000000000000000000000000000000000c, decoded_data: (16843009, 12), value: 0x0

==== State access after external call ====
SWC ID: 107
Severity: Medium
Contract: Claims
Function name: setClaimStatus(uint256,uint256)
PC address: 18380
Estimated Gas Usage: 15465 - 225197
Read of persistent state following external call
The contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.
--------------------
In file: /bdata2/sc/dataset/mainnet/0xcafea677DB7Ab72D3Ae599E2747f3e944bE1d718.sol:9515

cd

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [ATTACKER], function: changeMasterAddress(address), txdata: 0xd46655f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4, value: 0x0
Caller: [CREATOR], function: changeDependentContractAddress(), txdata: 0x0ea9c984, value: 0x0
Caller: [CREATOR], function: setClaimStatus(uint256,uint256), txdata: 0xf511bdfe0000000000000000000000000000000000000000000000000000000001010101000000000000000000000000000000000000000000000000000000000000000c, decoded_data: (16843009, 12), value: 0x0

==== External Call To User-Supplied Address ====
SWC ID: 107
Severity: Low
Contract: Claims
Function name: setClaimStatus(uint256,uint256)
PC address: 18502
Estimated Gas Usage: 15465 - 225197
A call to a user-supplied address is executed.
An external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.
--------------------
In file: /bdata2/sc/dataset/mainnet/0xcafea677DB7Ab72D3Ae599E2747f3e944bE1d718.sol:9515

cd.setClaimStatus(claimId, stat)

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [ATTACKER], function: changeMasterAddress(address), txdata: 0xd46655f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4, value: 0x0
Caller: [SOMEGUY], function: changeDependentContractAddress(), txdata: 0x0ea9c984, value: 0x0
Caller: [CREATOR], function: setClaimStatus(uint256,uint256), txdata: 0xf511bdfe0000000000000000000000000000000000000000000000000000000001010101000000000000000000000000000000000000000000000000000000000000000c, decoded_data: (16843009, 12), value: 0x0

==== State access after external call ====
SWC ID: 107
Severity: Medium
Contract: Claims
Function name: setClaimStatus(uint256,uint256)
PC address: 18502
Estimated Gas Usage: 15465 - 225197
Write to persistent state following external call
The contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.
--------------------
In file: /bdata2/sc/dataset/mainnet/0xcafea677DB7Ab72D3Ae599E2747f3e944bE1d718.sol:9515

cd.setClaimStatus(claimId, stat)

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [ATTACKER], function: changeMasterAddress(address), txdata: 0xd46655f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4, value: 0x0
Caller: [CREATOR], function: changeDependentContractAddress(), txdata: 0x0ea9c984, value: 0x0
Caller: [CREATOR], function: setClaimStatus(uint256,uint256), txdata: 0xf511bdfe0000000000000000000000000000000000000000000000000000000001010101000000000000000000000000000000000000000000000000000000000000000c, decoded_data: (16843009, 12), value: 0x0

==== State access after external call ====
SWC ID: 107
Severity: Medium
Contract: Claims
Function name: setClaimStatus(uint256,uint256)
PC address: 18551
Estimated Gas Usage: 15465 - 225197
Read of persistent state following external call
The contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.
--------------------
In file: /bdata2/sc/dataset/mainnet/0xcafea677DB7Ab72D3Ae599E2747f3e944bE1d718.sol:9518

cd

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [ATTACKER], function: changeMasterAddress(address), txdata: 0xd46655f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4, value: 0x0
Caller: [CREATOR], function: changeDependentContractAddress(), txdata: 0x0ea9c984, value: 0x0
Caller: [CREATOR], function: setClaimStatus(uint256,uint256), txdata: 0xf511bdfe0000000000000000000000000000000000000000000000000000000001010101000000000000000000000000000000000000000000000000000000000000000c, decoded_data: (16843009, 12), value: 0x0

==== External Call To User-Supplied Address ====
SWC ID: 107
Severity: Low
Contract: Claims
Function name: setClaimStatus(uint256,uint256)
PC address: 18674
Estimated Gas Usage: 15465 - 225197
A call to a user-supplied address is executed.
An external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.
--------------------
In file: /bdata2/sc/dataset/mainnet/0xcafea677DB7Ab72D3Ae599E2747f3e944bE1d718.sol:9518

cd.setClaimStatus(claimId, 13)

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [ATTACKER], function: changeMasterAddress(address), txdata: 0xd46655f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4, value: 0x0
Caller: [SOMEGUY], function: changeDependentContractAddress(), txdata: 0x0ea9c984, value: 0x0
Caller: [CREATOR], function: setClaimStatus(uint256,uint256), txdata: 0xf511bdfe0000000000000000000000000000000000000000000000000000000001010101000000000000000000000000000000000000000000000000000000000000000c, decoded_data: (16843009, 12), value: 0x0

==== State access after external call ====
SWC ID: 107
Severity: Medium
Contract: Claims
Function name: setClaimStatus(uint256,uint256)
PC address: 18674
Estimated Gas Usage: 15465 - 225197
Write to persistent state following external call
The contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.
--------------------
In file: /bdata2/sc/dataset/mainnet/0xcafea677DB7Ab72D3Ae599E2747f3e944bE1d718.sol:9518

cd.setClaimStatus(claimId, 13)

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [ATTACKER], function: changeMasterAddress(address), txdata: 0xd46655f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4, value: 0x0
Caller: [CREATOR], function: changeDependentContractAddress(), txdata: 0x0ea9c984, value: 0x0
Caller: [CREATOR], function: setClaimStatus(uint256,uint256), txdata: 0xf511bdfe0000000000000000000000000000000000000000000000000000000001010101000000000000000000000000000000000000000000000000000000000000000c, decoded_data: (16843009, 12), value: 0x0

==== State access after external call ====
SWC ID: 107
Severity: Medium
Contract: Claims
Function name: setClaimStatus(uint256,uint256)
PC address: 18701
Estimated Gas Usage: 15465 - 225197
Read of persistent state following external call
The contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.
--------------------
In file: /bdata2/sc/dataset/mainnet/0xcafea677DB7Ab72D3Ae599E2747f3e944bE1d718.sol:9519

qd

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [ATTACKER], function: changeMasterAddress(address), txdata: 0xd46655f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4, value: 0x0
Caller: [CREATOR], function: changeDependentContractAddress(), txdata: 0x0ea9c984, value: 0x0
Caller: [CREATOR], function: setClaimStatus(uint256,uint256), txdata: 0xf511bdfe0000000000000000000000000000000000000000000000000000000001010101000000000000000000000000000000000000000000000000000000000000000c, decoded_data: (16843009, 12), value: 0x0

==== External Call To User-Supplied Address ====
SWC ID: 107
Severity: Low
Contract: Claims
Function name: setClaimStatus(uint256,uint256)
PC address: 18841
Estimated Gas Usage: 15465 - 225197
A call to a user-supplied address is executed.
An external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.
--------------------
In file: /bdata2/sc/dataset/mainnet/0xcafea677DB7Ab72D3Ae599E2747f3e944bE1d718.sol:9519

qd.changeCoverStatusNo(coverId, uint8(QuotationData.CoverStatus.ClaimDenied))

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [ATTACKER], function: changeMasterAddress(address), txdata: 0xd46655f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4, value: 0x0
Caller: [SOMEGUY], function: changeDependentContractAddress(), txdata: 0x0ea9c984, value: 0x0
Caller: [CREATOR], function: setClaimStatus(uint256,uint256), txdata: 0xf511bdfe0000000000000000000000000000000000000000000000000000000001010101000000000000000000000000000000000000000000000000000000000000000c, decoded_data: (16843009, 12), value: 0x0

==== State access after external call ====
SWC ID: 107
Severity: Medium
Contract: Claims
Function name: setClaimStatus(uint256,uint256)
PC address: 18841
Estimated Gas Usage: 15465 - 225197
Write to persistent state following external call
The contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.
--------------------
In file: /bdata2/sc/dataset/mainnet/0xcafea677DB7Ab72D3Ae599E2747f3e944bE1d718.sol:9519

qd.changeCoverStatusNo(coverId, uint8(QuotationData.CoverStatus.ClaimDenied))

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [ATTACKER], function: changeMasterAddress(address), txdata: 0xd46655f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4, value: 0x0
Caller: [CREATOR], function: changeDependentContractAddress(), txdata: 0x0ea9c984, value: 0x0
Caller: [CREATOR], function: setClaimStatus(uint256,uint256), txdata: 0xf511bdfe0000000000000000000000000000000000000000000000000000000001010101000000000000000000000000000000000000000000000000000000000000000c, decoded_data: (16843009, 12), value: 0x0

==== State access after external call ====
SWC ID: 107
Severity: Medium
Contract: Claims
Function name: setClaimStatus(uint256,uint256)
PC address: 18869
Estimated Gas Usage: 15465 - 225197
Read of persistent state following external call
The contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.
--------------------
In file: /bdata2/sc/dataset/mainnet/0xcafea677DB7Ab72D3Ae599E2747f3e944bE1d718.sol:9522

cd

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [ATTACKER], function: changeMasterAddress(address), txdata: 0xd46655f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4, value: 0x0
Caller: [CREATOR], function: changeDependentContractAddress(), txdata: 0x0ea9c984, value: 0x0
Caller: [CREATOR], function: setClaimStatus(uint256,uint256), txdata: 0xf511bdfe0000000000000000000000000000000000000000000000000000000001010101000000000000000000000000000000000000000000000000000000000000000c, decoded_data: (16843009, 12), value: 0x0

==== External Call To User-Supplied Address ====
SWC ID: 107
Severity: Low
Contract: Claims
Function name: setClaimStatus(uint256,uint256)
PC address: 18991
Estimated Gas Usage: 15465 - 225197
A call to a user-supplied address is executed.
An external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.
--------------------
In file: /bdata2/sc/dataset/mainnet/0xcafea677DB7Ab72D3Ae599E2747f3e944bE1d718.sol:9522

cd.setClaimdateUpd(claimId, now)

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [ATTACKER], function: changeMasterAddress(address), txdata: 0xd46655f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4, value: 0x0
Caller: [SOMEGUY], function: changeDependentContractAddress(), txdata: 0x0ea9c984, value: 0x0
Caller: [CREATOR], function: setClaimStatus(uint256,uint256), txdata: 0xf511bdfe0000000000000000000000000000000000000000000000000000000001010101000000000000000000000000000000000000000000000000000000000000000c, decoded_data: (16843009, 12), value: 0x0

==== State access after external call ====
SWC ID: 107
Severity: Medium
Contract: Claims
Function name: setClaimStatus(uint256,uint256)
PC address: 18991
Estimated Gas Usage: 15465 - 225197
Write to persistent state following external call
The contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.
--------------------
In file: /bdata2/sc/dataset/mainnet/0xcafea677DB7Ab72D3Ae599E2747f3e944bE1d718.sol:9522

cd.setClaimdateUpd(claimId, now)

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [ATTACKER], function: changeMasterAddress(address), txdata: 0xd46655f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4, value: 0x0
Caller: [CREATOR], function: changeDependentContractAddress(), txdata: 0x0ea9c984, value: 0x0
Caller: [CREATOR], function: setClaimStatus(uint256,uint256), txdata: 0xf511bdfe0000000000000000000000000000000000000000000000000000000001010101000000000000000000000000000000000000000000000000000000000000000c, decoded_data: (16843009, 12), value: 0x0

==== Exception State ====
SWC ID: 110
Severity: Medium
Contract: Governance
Function name: allDelegation(uint256)
PC address: 19914
Estimated Gas Usage: 1156 - 1251
An assertion violation was triggered.
It is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).
--------------------
In file: /bdata2/sc/dataset/mainnet/0xcafea677DB7Ab72D3Ae599E2747f3e944bE1d718.sol:8162

DelegateVote[] public allDelegation

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [ATTACKER], function: allDelegation(uint256), txdata: 0xbb73c5620000000000000000000000000000000000000000000000000000000000000001, decoded_data: (1,), value: 0x0

==== Exception State ====
SWC ID: 110
Severity: Medium
Contract: ClaimsData
Function name: getVoterVote(uint256)
PC address: 20819
Estimated Gas Usage: 1181 - 1276
An assertion violation was triggered.
It is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).
--------------------
In file: /bdata2/sc/dataset/mainnet/0xcafea677DB7Ab72D3Ae599E2747f3e944bE1d718.sol:7519

function getVoterVote(uint _voteid) external view returns (address voter) {
    return allvotes[_voteid].voter;
  }

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [ATTACKER], function: getVoterVote(uint256), txdata: 0xd654c6bc0000000000000000000000000000000000000000000000000000000000000001, decoded_data: (1,), value: 0x0

==== Exception State ====
SWC ID: 110
Severity: Medium
Contract: ClaimsData
Function name: getVoteAddressMember(address,uint256)
PC address: 22609
Estimated Gas Usage: 1237 - 1522
An assertion violation was triggered.
It is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).
--------------------
In file: /bdata2/sc/dataset/mainnet/0xcafea677DB7Ab72D3Ae599E2747f3e944bE1d718.sol:7850

function getVoteAddressMember(address _voter, uint index) external view returns (uint) {
    return voteAddressMember[_voter][index];
  }

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [CREATOR], function: getVoteAddressMember(address,uint256), txdata: 0xf2d16e2a00000000000000000000000000000000000000000000000000000001000000008000000000000000000000000000000000000000000000000020800004004080, decoded_data: ('0x0000000000000000000000000000000100000000', 57896044618658097711785492504343953926634992332820282019728801151893375041664), value: 0x0

==== Exception State ====
SWC ID: 110
Severity: Medium
Contract: ClaimsData
Function name: getVoteAddressCA(address,uint256)
PC address: 23415
Estimated Gas Usage: 1325 - 1610
An assertion violation was triggered.
It is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).
--------------------
In file: /bdata2/sc/dataset/mainnet/0xcafea677DB7Ab72D3Ae599E2747f3e944bE1d718.sol:7842

function getVoteAddressCA(address _voter, uint index) external view returns (uint) {
    return voteAddressCA[_voter][index];
  }

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [ATTACKER], function: getVoteAddressCA(address,uint256), txdata: 0xfc57c9bb00010200800000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000401000800104014001, value: 0x0

==== Exception State ====
SWC ID: 110
Severity: Medium
Contract: ClaimsData
Function name: getAllClaimsByIndex(uint256)
PC address: 23455
Estimated Gas Usage: 1236 - 1331
An assertion violation was triggered.
It is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).
--------------------
In file: /bdata2/sc/dataset/mainnet/0xcafea677DB7Ab72D3Ae599E2747f3e944bE1d718.sol:7318

function getAllClaimsByIndex(
    uint _claimId
  )
  external
  view
  returns (
    uint coverId,
    int8 vote,
    uint status,
    uint dateUpd,
    uint state12Count
  )
  {
    return (
    allClaims[_claimId].coverId,
    claimVote[_claimId],
    claimsStatus[_claimId],
    allClaims[_claimId].dateUpd,
    claimState12Count[_claimId]
    );
  }

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , decoded_data: , value: 0x0
Caller: [CREATOR], function: getAllClaimsByIndex(uint256), txdata: 0xfd61265e0000010000000000000000000000000000000000000000000000000000000000, decoded_data: (6901746346790563787434755862277025452451108972170386555162524223799296,), value: 0x0


