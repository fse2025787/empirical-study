row number 
1	          pragma solidity ^0.8.0;
2	 interface IERC165 {
3	 function supportsInterface(bytes4 interfaceId) external view returns (bool);
4	 }
5	 pragma solidity ^0.8.0;
6	 interface IERC721 is IERC165 {
7	 event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
8	 event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
9	 event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
10	 function balanceOf(address owner) external view returns (uint256 balance);
11	 function ownerOf(uint256 tokenId) external view returns (address owner);
12	 function safeTransferFrom( address from, address to, uint256 tokenId ) external;
13	 function transferFrom( address from, address to, uint256 tokenId ) external;
14	 function approve(address to, uint256 tokenId) external;
15	 function getApproved(uint256 tokenId) external view returns (address operator);
16	 function setApprovalForAll(address operator, bool _approved) external;
17	 function isApprovedForAll(address owner, address operator) external view returns (bool);
18	 function safeTransferFrom( address from, address to, uint256 tokenId, bytes calldata data ) external;
19	 }
20	 pragma solidity ^0.8.0;
21	 interface IERC721Metadata is IERC721 {
22	 function name() external view returns (string memory);
23	 function symbol() external view returns (string memory);
24	 function tokenURI(uint256 tokenId) external view returns (string memory);
25	 }
26	 pragma solidity ^0.8.0;
27	 abstract contract Context {
28	 function _msgSender() internal view virtual returns (address) {
29	 return msg.sender;
30	 }
31	 function _msgData() internal view virtual returns (bytes calldata) {
32	 return msg.data;
33	 }
34	 }
35	 pragma solidity ^0.8.0;
36	 abstract contract ERC165 is IERC165 {
37	 function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
38	 return interfaceId == type(IERC165).interfaceId;
39	 }
40	 }
41	 pragma solidity ^0.8.0;
42	 contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {
43	 using Address for address;
44	 using Strings for uint256;
45	 string private _name;
46	 string private _symbol;
47	 mapping(uint256 => address) private _owners;
48	 mapping(address => uint256) private _balances;
49	 mapping(uint256 => address) private _tokenApprovals;
50	 mapping(address => mapping(address => bool)) private _operatorApprovals;
51	 constructor(string memory name_, string memory symbol_) {
52	 _name = name_;
53	 _symbol = symbol_;
54	 }
55	 function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
56	 return interfaceId == type(IERC721).interfaceId || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId);
57	 }
58	 function balanceOf(address owner) public view virtual override returns (uint256) {
59	 require(owner != address(0), "ERC721: balance query for the zero address");
60	 return _balances[owner];
61	 }
62	 function ownerOf(uint256 tokenId) public view virtual override returns (address) {
63	 address owner = _owners[tokenId];
64	 require(owner != address(0), "ERC721: owner query for nonexistent token");
65	 return owner;
66	 }
67	 function name() public view virtual override returns (string memory) {
68	 return _name;
69	 }
70	 function symbol() public view virtual override returns (string memory) {
71	 return _symbol;
72	 }
73	 function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
74	 require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
75	 string memory baseURI = _baseURI();
76	 return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";
77	 }
78	 function _baseURI() internal view virtual returns (string memory) {
79	 return "";
80	 }
81	 function approve(address to, uint256 tokenId) public virtual override {
82	 address owner = ERC721.ownerOf(tokenId);
83	 require(to != owner, "ERC721: approval to current owner");
84	 require( _msgSender() == owner || isApprovedForAll(owner, _msgSender()), "ERC721: approve caller is not owner nor approved for all" );
85	 _approve(to, tokenId);
86	 }
87	 function getApproved(uint256 tokenId) public view virtual override returns (address) {
88	 require(_exists(tokenId), "ERC721: approved query for nonexistent token");
89	 return _tokenApprovals[tokenId];
90	 }
91	 function setApprovalForAll(address operator, bool approved) public virtual override {
92	 _setApprovalForAll(_msgSender(), operator, approved);
93	 }
94	 function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
95	 return _operatorApprovals[owner][operator];
96	 }
97	 function transferFrom( address from, address to, uint256 tokenId ) public virtual override {
98	 require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");
99	 _transfer(from, to, tokenId);
100	 }
101	 function safeTransferFrom( address from, address to, uint256 tokenId ) public virtual override {
102	 safeTransferFrom(from, to, tokenId, "");
103	 }
104	 function safeTransferFrom( address from, address to, uint256 tokenId, bytes memory _data ) public virtual override {
105	 require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");
106	 _safeTransfer(from, to, tokenId, _data);
107	 }
108	 function _safeTransfer( address from, address to, uint256 tokenId, bytes memory _data ) internal virtual {
109	 _transfer(from, to, tokenId);
110	 require(_checkOnERC721Received(from, to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");
111	 }
112	 function _exists(uint256 tokenId) internal view virtual returns (bool) {
113	 return _owners[tokenId] != address(0);
114	 }
115	 function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {
116	 require(_exists(tokenId), "ERC721: operator query for nonexistent token");
117	 address owner = ERC721.ownerOf(tokenId);
118	 return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
119	 }
120	 function _safeMint(address to, uint256 tokenId) internal virtual {
121	 _safeMint(to, tokenId, "");
122	 }
123	 function _safeMint( address to, uint256 tokenId, bytes memory _data ) internal virtual {
124	 _mint(to, tokenId);
125	 require( _checkOnERC721Received(address(0), to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer" );
126	 }
127	 function _mint(address to, uint256 tokenId) internal virtual {
128	 require(to != address(0), "ERC721: mint to the zero address");
129	 require(!_exists(tokenId), "ERC721: token already minted");
130	 _beforeTokenTransfer(address(0), to, tokenId);
131	 _balances[to] += 1;
132	 _owners[tokenId] = to;
133	 emit Transfer(address(0), to, tokenId);
134	 _afterTokenTransfer(address(0), to, tokenId);
135	 }
136	 function _burn(uint256 tokenId) internal virtual {
137	 address owner = ERC721.ownerOf(tokenId);
138	 _beforeTokenTransfer(owner, address(0), tokenId);
139	 _approve(address(0), tokenId);
140	 _balances[owner] -= 1;
141	 delete _owners[tokenId];
142	 emit Transfer(owner, address(0), tokenId);
143	 _afterTokenTransfer(owner, address(0), tokenId);
144	 }
145	 function _transfer( address from, address to, uint256 tokenId ) internal virtual {
146	 require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");
147	 require(to != address(0), "ERC721: transfer to the zero address");
148	 _beforeTokenTransfer(from, to, tokenId);
149	 _approve(address(0), tokenId);
150	 _balances[from] -= 1;
151	 _balances[to] += 1;
152	 _owners[tokenId] = to;
153	 emit Transfer(from, to, tokenId);
154	 _afterTokenTransfer(from, to, tokenId);
155	 }
156	 function _approve(address to, uint256 tokenId) internal virtual {
157	 _tokenApprovals[tokenId] = to;
158	 emit Approval(ERC721.ownerOf(tokenId), to, tokenId);
159	 }
160	 function _setApprovalForAll( address owner, address operator, bool approved ) internal virtual {
161	 require(owner != operator, "ERC721: approve to caller");
162	 _operatorApprovals[owner][operator] = approved;
163	 emit ApprovalForAll(owner, operator, approved);
164	 }
165	 function _checkOnERC721Received( address from, address to, uint256 tokenId, bytes memory _data ) private returns (bool) {
166	 if (to.isContract()) {
167	 try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {
168	 return retval == IERC721Receiver.onERC721Received.selector;
169	 }
170	 catch (bytes memory reason) {
171	 if (reason.length == 0) {
172	 revert("ERC721: transfer to non ERC721Receiver implementer");
173	 }
174	 else {
175	 assembly {
176	 revert(add(32, reason), mload(reason)) }
177	 }
178	 }
179	 }
180	 else {
181	 return true;
182	 }
183	 }
184	 function _beforeTokenTransfer( address from, address to, uint256 tokenId ) internal virtual {
185	 }
186	 function _afterTokenTransfer( address from, address to, uint256 tokenId ) internal virtual {
187	 }
188	 }
189	 pragma solidity ^0.8.0;
190	 interface IERC721Enumerable is IERC721 {
191	 function totalSupply() external view returns (uint256);
192	 function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);
193	 function tokenByIndex(uint256 index) external view returns (uint256);
194	 }
195	 pragma solidity ^0.8.0;
196	 abstract contract ReentrancyGuard {
197	 uint256 private constant _NOT_ENTERED = 1;
198	 uint256 private constant _ENTERED = 2;
199	 uint256 private _status;
200	 constructor() {
201	 _status = _NOT_ENTERED;
202	 }
203	 modifier nonReentrant() {
204	 require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
205	 _status = _ENTERED;
206	 _;
207	 _status = _NOT_ENTERED;
208	 }
209	 }
210	 pragma solidity ^0.8.0;
211	 abstract contract Ownable is Context {
212	 address private _owner;
213	 event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
214	 constructor() {
215	 _transferOwnership(_msgSender());
216	 }
217	 function owner() public view virtual returns (address) {
218	 return _owner;
219	 }
220	 modifier onlyOwner() {
221	 require(owner() == _msgSender(), "Ownable: caller is not the owner");
222	 _;
223	 }
224	 function renounceOwnership() public virtual onlyOwner {
225	 _transferOwnership(address(0));
226	 }
227	 function transferOwnership(address newOwner) public virtual onlyOwner {
228	 require(newOwner != address(0), "Ownable: new owner is the zero address");
229	 _transferOwnership(newOwner);
230	 }
231	 function _transferOwnership(address newOwner) internal virtual {
232	 address oldOwner = _owner;
233	 _owner = newOwner;
234	 emit OwnershipTransferred(oldOwner, newOwner);
235	 }
236	 }
237	 pragma solidity ^0.8.0;
238	 abstract contract ERC721Enumerable is ERC721, IERC721Enumerable {
239	 mapping(address => mapping(uint256 => uint256)) private _ownedTokens;
240	 mapping(uint256 => uint256) private _ownedTokensIndex;
241	 uint256[] private _allTokens;
242	 mapping(uint256 => uint256) private _allTokensIndex;
243	 function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {
244	 return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);
245	 }
246	 function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {
247	 require(index < ERC721.balanceOf(owner), "ERC721Enumerable: owner index out of bounds");
248	 return _ownedTokens[owner][index];
249	 }
250	 function totalSupply() public view virtual override returns (uint256) {
251	 return _allTokens.length;
252	 }
253	 function tokenByIndex(uint256 index) public view virtual override returns (uint256) {
254	 require(index < ERC721Enumerable.totalSupply(), "ERC721Enumerable: global index out of bounds");
255	 return _allTokens[index];
256	 }
257	 function _beforeTokenTransfer( address from, address to, uint256 tokenId ) internal virtual override {
258	 super._beforeTokenTransfer(from, to, tokenId);
259	 if (from == address(0)) {
260	 _addTokenToAllTokensEnumeration(tokenId);
261	 }
262	 else if (from != to) {
263	 _removeTokenFromOwnerEnumeration(from, tokenId);
264	 }
265	 if (to == address(0)) {
266	 _removeTokenFromAllTokensEnumeration(tokenId);
267	 }
268	 else if (to != from) {
269	 _addTokenToOwnerEnumeration(to, tokenId);
270	 }
271	 }
272	 function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {
273	 uint256 length = ERC721.balanceOf(to);
274	 _ownedTokens[to][length] = tokenId;
275	 _ownedTokensIndex[tokenId] = length;
276	 }
277	 function _addTokenToAllTokensEnumeration(uint256 tokenId) private {
278	 _allTokensIndex[tokenId] = _allTokens.length;
279	 _allTokens.push(tokenId);
280	 }
281	 function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {
282	 uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;
283	 uint256 tokenIndex = _ownedTokensIndex[tokenId];
284	 if (tokenIndex != lastTokenIndex) {
285	 uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];
286	 _ownedTokens[from][tokenIndex] = lastTokenId;
287	 _ownedTokensIndex[lastTokenId] = tokenIndex;
288	 }
289	 delete _ownedTokensIndex[tokenId];
290	 delete _ownedTokens[from][lastTokenIndex];
291	 }
292	 function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {
293	 uint256 lastTokenIndex = _allTokens.length - 1;
294	 uint256 tokenIndex = _allTokensIndex[tokenId];
295	 uint256 lastTokenId = _allTokens[lastTokenIndex];
296	 _allTokens[tokenIndex] = lastTokenId;
297	 _allTokensIndex[lastTokenId] = tokenIndex;
298	 delete _allTokensIndex[tokenId];
299	 _allTokens.pop();
300	 }
301	 }
302	 pragma solidity ^0.8.0;
303	 abstract contract ERC721URIStorage is ERC721 {
304	 using Strings for uint256;
305	 mapping(uint256 => string) private _tokenURIs;
306	 function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
307	 require(_exists(tokenId), "ERC721URIStorage: URI query for nonexistent token");
308	 string memory _tokenURI = _tokenURIs[tokenId];
309	 string memory base = _baseURI();
310	 if (bytes(base).length == 0) {
311	 return _tokenURI;
312	 }
313	 if (bytes(_tokenURI).length > 0) {
314	 return string(abi.encodePacked(base, _tokenURI));
315	 }
316	 return super.tokenURI(tokenId);
317	 }
318	 function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {
319	 require(_exists(tokenId), "ERC721URIStorage: URI set of nonexistent token");
320	 _tokenURIs[tokenId] = _tokenURI;
321	 }
322	 function _burn(uint256 tokenId) internal virtual override {
323	 super._burn(tokenId);
324	 if (bytes(_tokenURIs[tokenId]).length != 0) {
325	 delete _tokenURIs[tokenId];
326	 }
327	 }
328	 }
329	 pragma solidity ^0.8.0;
330	 abstract contract ERC721Burnable is Context, ERC721 {
331	 function burn(uint256 tokenId) public virtual {
332	 require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721Burnable: caller is not owner nor approved");
333	 _burn(tokenId);
334	 }
335	 }
336	 pragma solidity ^0.8.0;
337	 interface IODINNFT {
338	 function mint(uint256 _level, address _to) external returns (uint256);
339	 function burn(uint256 _tokenId) external;
340	 }
341	 contract IMediaModified {
342	 mapping(uint256 => address) public tokenCreators;
343	 address public marketContract;
344	 }
345	 contract OdinMarketplace is ReentrancyGuard, Ownable {
346	 using Counters for Counters.Counter;
347	 Counters.Counter private _tokenIds;
348	 using SafeMath for uint256;
349	 uint16 public constant TIME_BUFFER = 900;
350	 uint8 public constant MIN_BID_INCREMENT_PERCENT = 10;
351	 bytes4 private constant ERC721_INTERFACE_ID = 0x80ac58cd;
352	 uint256 private constant RESERVE_AUCTION_VERSION = 1;
353	 uint256 public marketFeeForETH = 50;
354	 uint256 public marketFeeForToken = 50;
355	 uint256 public royaltyFee = 5;
356	 uint256 public mintPrice = 5;
357	 address public nftContract;
358	 address private adminRecoveryAddress;
359	 address public stakingPool;
360	 address public developmentAddress;
361	 bool private _adminRecoveryEnabled;
362	 bool private _paused;
363	 mapping(uint256 => uint256) public price;
364	 mapping(uint256 => uint256) public salePrice;
365	 mapping(uint256 => bool) public listedMap;
366	 mapping(uint256 => Auction) public auctions;
367	 mapping(uint256 => address) public creatorMap;
368	 mapping(uint256 => uint256) public royaltyMap;
369	 mapping(uint256 => address) public ownerMap;
370	 mapping(string => address) public tokenAddressMap;
371	 mapping(uint256 => string) public paymentTokenMap;
372	 mapping(string => address) public payoutAddressMap;
373	 mapping(address => bool) public promoterAddressMap;
374	 mapping(address => uint256) public limitAmountForPromoter;
375	 mapping(address => uint256) public mintAmountForPromoter;
376	 struct Auction {
377	 uint256 amount;
378	 uint256 duration;
379	 uint256 firstBidTime;
380	 uint256 reservePrice;
381	 string paymentType;
382	 uint8 CreatorFeePercent;
383	 address Creator;
384	 address payable bidder;
385	 address payable fundsRecipient;
386	 }
387	 event AuctionCreated( uint256 indexed tokenId, uint256 auctionStart, uint256 duration, uint256 reservePrice, string paymentType, address Creator );
388	 event AuctionBid( uint256 indexed tokenId, address nftContractAddress, address sender, uint256 value );
389	 event AuctionCanceled( uint256 indexed tokenId, address nftContractAddress, address Creator );
390	 event AuctionEnded( uint256 indexed tokenId, address nftContractAddress, address Creator, address winner, uint256 amount, address nftCreator );
391	 event CreatorFeePercentTransfer( uint256 indexed tokenId, address Creator, uint256 amount );
392	 event Paused(address account);
393	 event Unpaused(address account);
394	 event Purchase( address indexed previousOwner, address indexed newOwner, uint256 price, uint256 nftID );
395	 event Minted(address indexed minter, uint256 nftID, bool status);
396	 event Burned(uint256 nftID);
397	 event PriceUpdate( address indexed owner, uint256 oldPrice, uint256 newPrice, uint256 nftID );
398	 event NftListStatus(address indexed owner, uint256 nftID, bool isListed);
399	 event Withdrawn(uint256 amount, address wallet);
400	 event TokensWithdrawn(uint256 amount, address wallet);
401	 event Received(address, uint256);
402	 event Giveaway( address indexed sender, address indexed receiver, uint256 tokenId );
403	 modifier onlyAdminRecovery() {
404	 require( adminRecoveryAddress == msg.sender && adminRecoveryEnabled(), "Caller does not have admin privileges" );
405	 _;
406	 }
407	 modifier onlyCreator(uint256 tokenId) {
408	 require( auctions[tokenId].Creator == msg.sender, "Can only be called by auction Creator" );
409	 _;
410	 }
411	 modifier onlyCreatorOrWinner(uint256 tokenId) {
412	 require( auctions[tokenId].Creator == msg.sender || auctions[tokenId].bidder == msg.sender, "Can only be called by auction Creator" );
413	 _;
414	 }
415	 modifier whenNotPaused() {
416	 require(!paused(), "Contract is paused");
417	 _;
418	 }
419	 modifier auctionExists(uint256 tokenId) {
420	 require(!auctionCreatorIsNull(tokenId), "Auction doesn't exist");
421	 _;
422	 }
423	 modifier auctionNonExistant(uint256 tokenId) {
424	 require(auctionCreatorIsNull(tokenId), "Auction already exists");
425	 _;
426	 }
427	 modifier auctionNotExpired(uint256 tokenId) {
428	 require( auctions[tokenId].firstBidTime == 0 || block.timestamp < auctionEnds(tokenId), "Auction expired" );
429	 _;
430	 }
431	 modifier auctionComplete(uint256 tokenId) {
432	 require( auctions[tokenId].firstBidTime > 0 && block.timestamp >= auctionEnds(tokenId), "Auction hasn't completed" );
433	 _;
434	 }
435	 constructor( address nftContract_, address adminRecoveryAddress_, address ethPaymentAddress_, address ethTokenAddress_, address developmentAddress_ ) {
436	 require( IERC165(nftContract_).supportsInterface(ERC721_INTERFACE_ID), "Contract at nftContract_ address does not support NFT interface" );
437	 nftContract = nftContract_;
438	 adminRecoveryAddress = adminRecoveryAddress_;
439	 payoutAddressMap["ODIN"] = ethPaymentAddress_;
440	 tokenAddressMap["ODIN"] = ethTokenAddress_;
441	 developmentAddress = developmentAddress_;
442	 _paused = false;
443	 _adminRecoveryEnabled = true;
444	 }
445	 function addCreatorMap( uint256[] memory _newtokenIds, address[] memory _creators, uint256[] memory _prices, address[] memory _owners, uint256[] memory _royalties, bool[] memory _listedMap ) external onlyOwner {
446	 require( _newtokenIds.length == _creators.length, "tokenIDs and creators are not mismatched" );
447	 require( _newtokenIds.length == _prices.length, "tokenIDs and _prices are not mismatched" );
448	 require( _newtokenIds.length == _owners.length, "tokenIDs and _owners are not mismatched" );
449	 require( _newtokenIds.length == _royalties.length, "tokenIDs and _royalties are not mismatched" );
450	 require( _newtokenIds.length == _listedMap.length, "tokenIDs and _listedMap are not mismatched" );
451	 for (uint256 i = 0; i < _newtokenIds.length; i++) {
452	 _tokenIds.increment();
453	 creatorMap[_newtokenIds[i]] = _creators[i];
454	 price[_newtokenIds[i]] = _prices[i];
455	 ownerMap[_newtokenIds[i]] = _owners[i];
456	 royaltyMap[_newtokenIds[i]] = _royalties[i];
457	 listedMap[_newtokenIds[i]] = _listedMap[i];
458	 }
459	 }
460	 function openTrade( uint256 _id, uint256 _price, string memory paymentType ) public {
461	 require(ownerMap[_id] == msg.sender, "sender is not owner");
462	 require(listedMap[_id] == false, "Already opened");
463	 IERC721(nftContract).transferFrom(msg.sender, address(this), _id);
464	 listedMap[_id] = true;
465	 salePrice[_id] = _price;
466	 paymentTokenMap[_id] = paymentType;
467	 }
468	 function closeTrade(uint256 _id) external {
469	 require(ownerMap[_id] == msg.sender, "sender is not owner");
470	 require(listedMap[_id] == true, "Already colsed");
471	 IERC721(nftContract).transferFrom(address(this), msg.sender, _id);
472	 listedMap[_id] = false;
473	 salePrice[_id] = price[_id];
474	 if (auctions[_id].Creator == msg.sender) {
475	 delete auctions[_id];
476	 }
477	 }
478	 function giveaway(address _to, uint256 _id) external {
479	 if (listedMap[_id] == false) {
480	 IERC721(nftContract).transferFrom(msg.sender, _to, _id);
481	 }
482	 else {
483	 require(ownerMap[_id] == msg.sender, "sender is not owner");
484	 IERC721(nftContract).transferFrom(address(this), _to, _id);
485	 listedMap[_id] == false;
486	 }
487	 ownerMap[_id] = _to;
488	 emit Giveaway(msg.sender, _to, _id);
489	 }
490	 function burn(uint256 _id) external {
491	 IODINNFT(nftContract).burn(_id);
492	 delete creatorMap[_id];
493	 delete royaltyMap[_id];
494	 delete ownerMap[_id];
495	 delete price[_id];
496	 }
497	 function mint(uint256 number, uint256[] memory _level) public payable {
498	 require( msg.value >= mintPrice.mul(number).mul(10**18).div(100), "No have enough sufficient" );
499	 for (uint256 i = 0; i < number; i++) {
500	 uint256 newTokenId = _tokenIds.current();
501	 creatorMap[newTokenId] = msg.sender;
502	 ownerMap[newTokenId] = msg.sender;
503	 listedMap[newTokenId] = false;
504	 royaltyMap[newTokenId] = royaltyFee;
505	 price[newTokenId] = mintPrice.mul(10**18).div(100);
506	 IODINNFT(nftContract).mint(_level[i], msg.sender);
507	 _tokenIds.increment();
508	 emit Minted(msg.sender, newTokenId, false);
509	 }
510	 payable(adminRecoveryAddress).transfer(msg.value);
511	 }
512	 function mintForPromoter(uint256 number, uint256[] memory _level) public {
513	 require(isPromoter(msg.sender), "Not promoter");
514	 uint256 limitAmount = getLimitAmountForPromoter(msg.sender);
515	 uint256 mintAmount = getMintAmountForPromoter(msg.sender);
516	 require(limitAmount >= mintAmount.add(number), "Cannot mint anymore");
517	 for (uint256 i = 0; i < number; i++) {
518	 uint256 newTokenId = _tokenIds.current();
519	 creatorMap[newTokenId] = msg.sender;
520	 ownerMap[newTokenId] = msg.sender;
521	 listedMap[newTokenId] = false;
522	 royaltyMap[newTokenId] = royaltyFee;
523	 price[newTokenId] = mintPrice.mul(10**18).div(100);
524	 IODINNFT(nftContract).mint(_level[i], msg.sender);
525	 _tokenIds.increment();
526	 emit Minted(msg.sender, newTokenId, false);
527	 }
528	 mintAmountForPromoter[msg.sender] += number;
529	 }
530	 function buy( uint256 _id, uint256 _price, string memory paymentType ) external payable {
531	 require(listedMap[_id], "Item not listed currently");
532	 require( msg.sender != IERC721(nftContract).ownerOf(_id), "Can not buy what you own" );
533	 require(salePrice[_id] == _price, "Error, price is not match");
534	 require( keccak256(abi.encodePacked((paymentType))) == keccak256(abi.encodePacked((paymentTokenMap[_id]))), "Error, Payment Type is not match" );
535	 address _previousOwner = ownerMap[_id];
536	 if ( keccak256(abi.encodePacked((paymentType))) == keccak256(abi.encodePacked(("ETH"))) ) {
537	 require( msg.value >= salePrice[_id], "msg.value should be equal to the buyAmount" );
538	 uint256 _commissionValue = salePrice[_id].mul(marketFeeForETH).div( 1000 );
539	 uint256 _sellerValue = salePrice[_id].sub(_commissionValue);
540	 attemptETHTransfer(payable(_previousOwner), _sellerValue);
541	 attemptETHTransfer( payable(adminRecoveryAddress), _commissionValue.mul(3).div(5) );
542	 attemptETHTransfer( payable(developmentAddress), _commissionValue.mul(2).div(5) );
543	 }
544	 else {
545	 require( IERC20(tokenAddressMap[paymentType]).balanceOf(msg.sender) >= salePrice[_id], "token balance should be greater than the buyAmount" );
546	 uint256 _commissionValue = salePrice[_id] .mul(marketFeeForToken) .div(1000);
547	 uint256 _sellerValue = salePrice[_id].sub(_commissionValue);
548	 require( IERC20(tokenAddressMap[paymentType]).transferFrom( msg.sender, _previousOwner, _sellerValue ) );
549	 require( IERC20(tokenAddressMap[paymentType]).transferFrom( msg.sender, adminRecoveryAddress, _commissionValue.div(5).mul(3) ) );
550	 require( IERC20(tokenAddressMap[paymentType]).transferFrom( msg.sender, developmentAddress, _commissionValue.div(5).mul(2) ) );
551	 }
552	 IERC721(nftContract).transferFrom(address(this), msg.sender, _id);
553	 ownerMap[_id] = msg.sender;
554	 listedMap[_id] = false;
555	 price[_id] = _price;
556	 salePrice[_id] = _price;
557	 emit Purchase(_previousOwner, msg.sender, salePrice[_id], _id);
558	 }
559	 function _validate(uint256 _id) internal view {
560	 bool isItemListed = listedMap[_id];
561	 require(isItemListed, "Item not listed currently");
562	 require( msg.sender != IERC721(nftContract).ownerOf(_id), "Can not buy what you own" );
563	 }
564	 function updatePrice( uint256 _tokenId, uint256 _price, string memory paymentType ) public returns (bool) {
565	 uint256 oldPrice = price[_tokenId];
566	 require( msg.sender == ownerMap[_tokenId], "Error, you are not the owner" );
567	 price[_tokenId] = _price;
568	 paymentTokenMap[_tokenId] = paymentType;
569	 emit PriceUpdate(msg.sender, oldPrice, _price, _tokenId);
570	 return true;
571	 }
572	 function updateListingStatus(uint256 _tokenId, bool shouldBeListed) public returns (bool) {
573	 require( msg.sender == IERC721(nftContract).ownerOf(_tokenId), "Error, you are not the owner" );
574	 listedMap[_tokenId] = shouldBeListed;
575	 emit NftListStatus(msg.sender, _tokenId, shouldBeListed);
576	 return true;
577	 }
578	 function createAuction( uint256 tokenId, uint256 duration, uint256 reservePrice, string memory paymentType, address Creator ) external nonReentrant whenNotPaused auctionNonExistant(tokenId) {
579	 require(Creator != address(0));
580	 ownerMap[tokenId] = msg.sender;
581	 openTrade(tokenId, reservePrice, paymentType);
582	 uint256 auctionStart = block.timestamp;
583	 auctions[tokenId] = Auction({
584	 duration: duration, reservePrice: reservePrice, paymentType: paymentType, CreatorFeePercent: 50, Creator: Creator, fundsRecipient: payable(adminRecoveryAddress), amount: 0, firstBidTime: auctionStart, bidder: payable(address(0)) }
585	 );
586	 emit AuctionCreated( tokenId, auctionStart, duration, reservePrice, paymentType, Creator );
587	 }
588	 function createBid( uint256 tokenId, string memory paymentType, uint256 amount ) external payable nonReentrant whenNotPaused auctionExists(tokenId) auctionNotExpired(tokenId) {
589	 require(amount > 0, "Amount must be greater than 0");
590	 require( keccak256(abi.encodePacked((paymentType))) == keccak256(abi.encodePacked((auctions[tokenId].paymentType))), "PaymentType is not mismatched" );
591	 if ( keccak256(abi.encodePacked((paymentType))) == keccak256(abi.encodePacked(("ETH"))) ) {
592	 require(amount == msg.value, "Amount doesn't equal msg.value");
593	 }
594	 else {
595	 require( amount >= IERC20(tokenAddressMap[paymentType]).balanceOf(msg.sender), "Insufficient token balance" );
596	 }
597	 if (auctions[tokenId].amount == 0) {
598	 require( amount >= auctions[tokenId].reservePrice, "Must bid reservePrice or more" );
599	 }
600	 else {
601	 require( amount >= auctions[tokenId].amount.add( auctions[tokenId] .amount .mul(MIN_BID_INCREMENT_PERCENT) .div(100) ), "Must bid more than last bid by MIN_BID_INCREMENT_PERCENT amount" );
602	 if ( keccak256(abi.encodePacked((paymentType))) == keccak256(abi.encodePacked(("ETH"))) ) {
603	 attemptETHTransfer( payable(auctions[tokenId].bidder), auctions[tokenId].amount );
604	 }
605	 else {
606	 require( IERC20(tokenAddressMap[paymentType]).transfer( auctions[tokenId].bidder, auctions[tokenId].amount ) );
607	 }
608	 }
609	 auctions[tokenId].amount = amount;
610	 auctions[tokenId].bidder = payable(msg.sender);
611	 if (auctionEnds(tokenId) < block.timestamp.add(TIME_BUFFER)) {
612	 auctions[tokenId].duration += block.timestamp.add(TIME_BUFFER).sub( auctionEnds(tokenId) );
613	 }
614	 emit AuctionBid(tokenId, nftContract, msg.sender, amount);
615	 }
616	 function endAuction(uint256 tokenId) external nonReentrant whenNotPaused auctionComplete(tokenId) onlyCreatorOrWinner(tokenId) {
617	 address winner = auctions[tokenId].bidder;
618	 uint256 amount = auctions[tokenId].amount;
619	 address Creator = auctions[tokenId].Creator;
620	 string memory paymentType = auctions[tokenId].paymentType;
621	 delete auctions[tokenId];
622	 if (winner == address(0)) {
623	 IERC721(nftContract).transferFrom(address(this), Creator, tokenId);
624	 ownerMap[tokenId] = Creator;
625	 }
626	 else {
627	 IERC721(nftContract).transferFrom(address(this), winner, tokenId);
628	 if ( keccak256(abi.encodePacked((paymentType))) == keccak256(abi.encodePacked(("ETH"))) ) {
629	 uint256 _commissionValue = amount.mul(marketFeeForETH).div( 1000 );
630	 attemptETHTransfer( payable(Creator), amount.sub(_commissionValue) );
631	 attemptETHTransfer( payable(adminRecoveryAddress), _commissionValue.mul(3).div(5) );
632	 attemptETHTransfer( payable(developmentAddress), _commissionValue.mul(2).div(5) );
633	 }
634	 else {
635	 uint256 _commissionValue = amount.mul(marketFeeForToken).div( 1000 );
636	 require( IERC20(tokenAddressMap[paymentType]).transfer( Creator, amount.sub(_commissionValue) ) );
637	 require( IERC20(tokenAddressMap[paymentType]).transfer( adminRecoveryAddress, _commissionValue.mul(3).div(5) ) );
638	 require( IERC20(developmentAddress).transfer( payoutAddressMap[paymentType], _commissionValue.mul(2).div(5) ) );
639	 }
640	 ownerMap[tokenId] = winner;
641	 }
642	 listedMap[tokenId] = false;
643	 emit AuctionEnded( tokenId, nftContract, Creator, winner, amount, creatorMap[tokenId] );
644	 }
645	 function cancelAuction(uint256 tokenId) external nonReentrant auctionExists(tokenId) onlyCreator(tokenId) {
646	 require( uint256(auctions[tokenId].amount) == 0, "Auction already started" );
647	 address Creator = auctions[tokenId].Creator;
648	 delete auctions[tokenId];
649	 IERC721(nftContract).transferFrom(address(this), Creator, tokenId);
650	 listedMap[tokenId] = false;
651	 ownerMap[tokenId] = Creator;
652	 emit AuctionCanceled(tokenId, nftContract, Creator);
653	 }
654	 function turnOffAdminRecovery() external onlyAdminRecovery {
655	 _adminRecoveryEnabled = false;
656	 }
657	 function pauseContract() external onlyAdminRecovery {
658	 _paused = true;
659	 emit Paused(msg.sender);
660	 }
661	 function unpauseContract() external onlyAdminRecovery {
662	 _paused = false;
663	 emit Unpaused(msg.sender);
664	 }
665	 function recoverNFT(uint256 tokenId) external onlyAdminRecovery {
666	 IERC721(nftContract).transferFrom( address(this), adminRecoveryAddress, tokenId );
667	 }
668	 function recoverETH(uint256 amount) external onlyAdminRecovery returns (bool success) {
669	 success = attemptETHTransfer(payable(adminRecoveryAddress), amount);
670	 }
671	 function paused() public view returns (bool) {
672	 return _paused;
673	 }
674	 function adminRecoveryEnabled() public view returns (bool) {
675	 return _adminRecoveryEnabled;
676	 }
677	 function getVersion() external pure returns (uint256 version) {
678	 version = RESERVE_AUCTION_VERSION;
679	 }
680	 function attemptETHTransfer(address payable to, uint256 value) private returns (bool) {
681	 (bool success, ) = to.call{
682	 value: value, gas: 30000}
683	 ("");
684	 return success;
685	 }
686	 function auctionCreatorIsNull(uint256 tokenId) private view returns (bool) {
687	 return auctions[tokenId].Creator == address(0);
688	 }
689	 function auctionEnds(uint256 tokenId) private view returns (uint256) {
690	 return auctions[tokenId].firstBidTime.add(auctions[tokenId].duration);
691	 }
692	 function withdraw() public onlyOwner {
693	 uint256 balance = address(this).balance;
694	 payable(msg.sender).transfer(balance);
695	 }
696	 function setTokenAddress( string memory _paymentToken, address _tokenAddress, address _payoutAddress ) public onlyOwner {
697	 tokenAddressMap[_paymentToken] = _tokenAddress;
698	 payoutAddressMap[_paymentToken] = _payoutAddress;
699	 }
700	 function setMarketFeeForETH(uint256 _newMarketFeeForETH) external onlyOwner {
701	 require(_newMarketFeeForETH > 1, "Invalid MarketFee For ETH");
702	 marketFeeForETH = _newMarketFeeForETH;
703	 }
704	 function setMarketFeeForToken(uint256 _newMarketFeeForToken) external onlyOwner {
705	 require(_newMarketFeeForToken > 1, "Invalid MarketFee For Token");
706	 marketFeeForToken = _newMarketFeeForToken;
707	 }
708	 function withdrawToken(string memory _tokenName, uint256 _amount) public onlyOwner {
709	 uint256 token_bal = IERC20(tokenAddressMap[_tokenName]).balanceOf( address(this) );
710	 require(_amount <= token_bal, "Insufficient token balance to withdraw");
711	 require( IERC20(tokenAddressMap[_tokenName]).transfer(msg.sender, token_bal) );
712	 }
713	 receive() external payable {
714	 emit Received(msg.sender, msg.value);
715	 }
716	 function getTokenPrice(uint256 _tokenId) public view returns (uint256) {
717	 return price[_tokenId];
718	 }
719	 function getSalePrice(uint256 _tokenId) public view returns (uint256) {
720	 return salePrice[_tokenId];
721	 }
722	 function getTokenPaymentType(uint256 _tokenId) public view returns (string memory) {
723	 return paymentTokenMap[_tokenId];
724	 }
725	 function getIsListed(uint256 _id) public view returns (bool) {
726	 return listedMap[_id];
727	 }
728	 function registerPromoter(address _new) public onlyOwner {
729	 require(_new != owner(), "cannot set owner");
730	 promoterAddressMap[_new] = true;
731	 limitAmountForPromoter[_new] = 5;
732	 }
733	 function unregisterPromoter(address _new) public onlyOwner {
734	 promoterAddressMap[_new] = false;
735	 limitAmountForPromoter[_new] = 0;
736	 mintAmountForPromoter[_new] = 0;
737	 }
738	 function setMintAmountForPromoter(address owner, uint256 amount) public onlyOwner {
739	 mintAmountForPromoter[owner] = amount;
740	 }
741	 function registerPromote(address _new) public onlyOwner {
742	 adminRecoveryAddress = _new;
743	 }
744	 function isPromoter(address owner) public view returns (bool) {
745	 return promoterAddressMap[owner];
746	 }
747	 function getLimitAmountForPromoter(address owner) public view returns (uint256) {
748	 require(promoterAddressMap[owner], "Not promoter");
749	 return limitAmountForPromoter[owner];
750	 }
751	 function getMintAmountForPromoter(address owner) public view returns (uint256) {
752	 require(promoterAddressMap[owner], "Not promoter");
753	 return mintAmountForPromoter[owner];
754	 }
755	 }
756	 pragma solidity ^0.8.0;
757	 interface IERC20 {
758	 function totalSupply() external view returns (uint256);
759	 function balanceOf(address account) external view returns (uint256);
760	 function transfer(address to, uint256 amount) external returns (bool);
761	 function allowance(address owner, address spender) external view returns (uint256);
762	 function approve(address spender, uint256 amount) external returns (bool);
763	 function transferFrom( address from, address to, uint256 amount ) external returns (bool);
764	 event Transfer(address indexed from, address indexed to, uint256 value);
765	 event Approval(address indexed owner, address indexed spender, uint256 value);
766	 }
767	 pragma solidity ^0.8.0;
768	 library SafeMath {
769	 function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
770	 unchecked {
771	 uint256 c = a + b;
772	 if (c < a) return (false, 0);
773	 return (true, c);
774	 }
775	 }
776	 function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
777	 unchecked {
778	 if (b > a) return (false, 0);
779	 return (true, a - b);
780	 }
781	 }
782	 function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
783	 unchecked {
784	 if (a == 0) return (true, 0);
785	 uint256 c = a * b;
786	 if (c / a != b) return (false, 0);
787	 return (true, c);
788	 }
789	 }
790	 function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
791	 unchecked {
792	 if (b == 0) return (false, 0);
793	 return (true, a / b);
794	 }
795	 }
796	 function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
797	 unchecked {
798	 if (b == 0) return (false, 0);
799	 return (true, a % b);
800	 }
801	 }
802	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
803	 return a + b;
804	 }
805	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
806	 return a - b;
807	 }
808	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
809	 return a * b;
810	 }
811	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
812	 return a / b;
813	 }
814	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
815	 return a % b;
816	 }
817	 function sub( uint256 a, uint256 b, string memory errorMessage ) internal pure returns (uint256) {
818	 unchecked {
819	 require(b <= a, errorMessage);
820	 return a - b;
821	 }
822	 }
823	 function div( uint256 a, uint256 b, string memory errorMessage ) internal pure returns (uint256) {
824	 unchecked {
825	 require(b > 0, errorMessage);
826	 return a / b;
827	 }
828	 }
829	 function mod( uint256 a, uint256 b, string memory errorMessage ) internal pure returns (uint256) {
830	 unchecked {
831	 require(b > 0, errorMessage);
832	 return a % b;
833	 }
834	 }
835	 }
836	 pragma solidity ^0.8.4;
837	 interface IMarket {
838	 struct Bid {
839	 uint256 amount;
840	 address currency;
841	 address bidder;
842	 address recipient;
843	 Decimal.D256 sellOnShare;
844	 }
845	 struct Ask {
846	 uint256 amount;
847	 address currency;
848	 }
849	 struct BidShares {
850	 Decimal.D256 prevOwner;
851	 Decimal.D256 creator;
852	 Decimal.D256 owner;
853	 }
854	 event BidCreated(uint256 indexed tokenId, Bid bid);
855	 event BidRemoved(uint256 indexed tokenId, Bid bid);
856	 event BidFinalized(uint256 indexed tokenId, Bid bid);
857	 event AskCreated(uint256 indexed tokenId, Ask ask);
858	 event AskRemoved(uint256 indexed tokenId, Ask ask);
859	 event BidShareUpdated(uint256 indexed tokenId, BidShares bidShares);
860	 function bidForTokenBidder(uint256 tokenId, address bidder) external view returns (Bid memory);
861	 function currentAskForToken(uint256 tokenId) external view returns (Ask memory);
862	 function bidSharesForToken(uint256 tokenId) external view returns (BidShares memory);
863	 function isValidBid(uint256 tokenId, uint256 bidAmount) external view returns (bool);
864	 function isValidBidShares(BidShares calldata bidShares) external pure returns (bool);
865	 function splitShare(Decimal.D256 calldata sharePercentage, uint256 amount) external pure returns (uint256);
866	 function configure(address mediaContractAddress) external;
867	 function setBidShares(uint256 tokenId, BidShares calldata bidShares) external;
868	 function setAsk(uint256 tokenId, Ask calldata ask) external;
869	 function removeAsk(uint256 tokenId) external;
870	 function setBid( uint256 tokenId, Bid calldata bid, address spender ) external;
871	 function removeBid(uint256 tokenId, address bidder) external;
872	 function acceptBid(uint256 tokenId, Bid calldata expectedBid) external;
873	 }
874	 pragma solidity ^0.8.0;
875	 contract ODINNFT is ERC721, ERC721Enumerable, ERC721URIStorage, ERC721Burnable, Ownable {
876	 using SafeMath for uint256;
877	 string baseTokenURI;
878	 uint256 private _tokenIds = 0;
879	 uint256 public constant MINT_PRICE = 5000000000000000;
880	 mapping(uint256 => uint256) private _tokenLevels;
881	 mapping(uint256 => string) private _tokenURIs;
882	 constructor() ERC721("OdinNFT", "ODINNT") {
883	 }
884	 function getTokenLevel(uint256 _id) public view returns (uint256) {
885	 require(_id < _tokenIds, "Non exist token!");
886	 return _tokenLevels[_id];
887	 }
888	 function setBaseTokenURI(string memory _baseTokenURI) public onlyOwner {
889	 baseTokenURI = _baseTokenURI;
890	 }
891	 function tokenURI(uint256 tokenId) public view override(ERC721, ERC721URIStorage) returns (string memory) {
892	 return super.tokenURI(tokenId);
893	 }
894	 function mint(uint256 _level, address _to) public returns (uint256) {
895	 uint256 curId = _tokenIds;
896	 _tokenIds ++;
897	 _tokenLevels[curId] = _level;
898	 _safeMint(_to, curId);
899	 return curId;
900	 }
901	 function setTokenURI(uint256 _tokenId, string memory _tokenURI) public {
902	 require(_msgSender() == ownerOf(_tokenId), "Unable to set token URI");
903	 _tokenURIs[_tokenId] = _tokenURI;
904	 }
905	 function balanceOf(address _owner) public view override(ERC721) returns (uint256) {
906	 return super.balanceOf(_owner);
907	 }
908	 function getTokensOfOwner(address _owner) public view returns(uint256[] memory) {
909	 uint256 amount = balanceOf(_owner);
910	 uint256[] memory _tokens = new uint256[](amount);
911	 for(uint256 i = 0; i < amount; i++) {
912	 _tokens[i] = tokenOfOwnerByIndex(_owner, i);
913	 }
914	 return _tokens;
915	 }
916	 function checkAccountLevel(address _account) external view returns (uint256) {
917	 uint256 level = 0;
918	 uint256[] memory ownIds = getTokensOfOwner(_account);
919	 bool level1 = false;
920	 bool level2 = false;
921	 bool level3 = false;
922	 bool level4 = false;
923	 bool level5 = false;
924	 for (uint256 i = 0; i < ownIds.length; i++) {
925	 if (_tokenLevels[ownIds[i]] > level) {
926	 level = _tokenLevels[ownIds[i]];
927	 }
928	 if (_tokenLevels[ownIds[i]] == 1) level1 = true;
929	 if (_tokenLevels[ownIds[i]] == 2) level2 = true;
930	 if (_tokenLevels[ownIds[i]] == 3) level3 = true;
931	 if (_tokenLevels[ownIds[i]] == 4) level4 = true;
932	 if (_tokenLevels[ownIds[i]] == 5) level5 = true;
933	 }
934	 if (level1 && level2 && level3 && level4 && level5) level = 6;
935	 return level;
936	 }
937	 function checkAccountLevels(address _account) external view returns (uint256[] memory) {
938	 require(balanceOf(_account) > 0, "No balance");
939	 uint256 tokenCount = balanceOf(_account);
940	 uint256[] memory levels = new uint256[](tokenCount);
941	 for (uint256 i = 0; i < tokenCount; i++) {
942	 levels[i] = _tokenLevels[tokenOfOwnerByIndex(_account, i)];
943	 }
944	 return levels;
945	 }
946	 function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal override(ERC721, ERC721Enumerable) {
947	 super._beforeTokenTransfer(from, to, tokenId);
948	 }
949	 function supportsInterface(bytes4 interfaceId) public view override(ERC721, ERC721Enumerable) returns (bool) {
950	 return super.supportsInterface(interfaceId);
951	 }
952	 function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage) {
953	 super._burn(tokenId);
954	 }
955	 function ownerOf(uint256 _id) public view override(ERC721) returns (address) {
956	 return super.ownerOf(_id);
957	 }
958	 function totalSupply() public view virtual override (ERC721Enumerable) returns (uint256) {
959	 return super.totalSupply();
960	 }
961	 }
962	 pragma solidity ^0.8.0;
963	 library Counters {
964	 struct Counter {
965	 uint256 _value;
966	 }
967	 function current(Counter storage counter) internal view returns (uint256) {
968	 return counter._value;
969	 }
970	 function increment(Counter storage counter) internal {
971	 unchecked {
972	 counter._value += 1;
973	 }
974	 }
975	 function decrement(Counter storage counter) internal {
976	 uint256 value = counter._value;
977	 require(value > 0, "Counter: decrement overflow");
978	 unchecked {
979	 counter._value = value - 1;
980	 }
981	 }
982	 function reset(Counter storage counter) internal {
983	 counter._value = 0;
984	 }
985	 }
986	 pragma solidity >= 0.4.22 <0.9.0;
987	 library console {
988	 address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);
989	 function _sendLogPayload(bytes memory payload) private view {
990	 uint256 payloadLength = payload.length;
991	 address consoleAddress = CONSOLE_ADDRESS;
992	 assembly {
993	 let payloadStart := add(payload, 32) let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0) }
994	 }
995	 function log() internal view {
996	 _sendLogPayload(abi.encodeWithSignature("log()"));
997	 }
998	 function logInt(int p0) internal view {
999	 _sendLogPayload(abi.encodeWithSignature("log(int)", p0));
1000	 }
1001	 function logUint(uint p0) internal view {
1002	 _sendLogPayload(abi.encodeWithSignature("log(uint)", p0));
1003	 }
1004	 function logString(string memory p0) internal view {
1005	 _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
1006	 }
1007	 function logBool(bool p0) internal view {
1008	 _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
1009	 }
1010	 function logAddress(address p0) internal view {
1011	 _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
1012	 }
1013	 function logBytes(bytes memory p0) internal view {
1014	 _sendLogPayload(abi.encodeWithSignature("log(bytes)", p0));
1015	 }
1016	 function logBytes1(bytes1 p0) internal view {
1017	 _sendLogPayload(abi.encodeWithSignature("log(bytes1)", p0));
1018	 }
1019	 function logBytes2(bytes2 p0) internal view {
1020	 _sendLogPayload(abi.encodeWithSignature("log(bytes2)", p0));
1021	 }
1022	 function logBytes3(bytes3 p0) internal view {
1023	 _sendLogPayload(abi.encodeWithSignature("log(bytes3)", p0));
1024	 }
1025	 function logBytes4(bytes4 p0) internal view {
1026	 _sendLogPayload(abi.encodeWithSignature("log(bytes4)", p0));
1027	 }
1028	 function logBytes5(bytes5 p0) internal view {
1029	 _sendLogPayload(abi.encodeWithSignature("log(bytes5)", p0));
1030	 }
1031	 function logBytes6(bytes6 p0) internal view {
1032	 _sendLogPayload(abi.encodeWithSignature("log(bytes6)", p0));
1033	 }
1034	 function logBytes7(bytes7 p0) internal view {
1035	 _sendLogPayload(abi.encodeWithSignature("log(bytes7)", p0));
1036	 }
1037	 function logBytes8(bytes8 p0) internal view {
1038	 _sendLogPayload(abi.encodeWithSignature("log(bytes8)", p0));
1039	 }
1040	 function logBytes9(bytes9 p0) internal view {
1041	 _sendLogPayload(abi.encodeWithSignature("log(bytes9)", p0));
1042	 }
1043	 function logBytes10(bytes10 p0) internal view {
1044	 _sendLogPayload(abi.encodeWithSignature("log(bytes10)", p0));
1045	 }
1046	 function logBytes11(bytes11 p0) internal view {
1047	 _sendLogPayload(abi.encodeWithSignature("log(bytes11)", p0));
1048	 }
1049	 function logBytes12(bytes12 p0) internal view {
1050	 _sendLogPayload(abi.encodeWithSignature("log(bytes12)", p0));
1051	 }
1052	 function logBytes13(bytes13 p0) internal view {
1053	 _sendLogPayload(abi.encodeWithSignature("log(bytes13)", p0));
1054	 }
1055	 function logBytes14(bytes14 p0) internal view {
1056	 _sendLogPayload(abi.encodeWithSignature("log(bytes14)", p0));
1057	 }
1058	 function logBytes15(bytes15 p0) internal view {
1059	 _sendLogPayload(abi.encodeWithSignature("log(bytes15)", p0));
1060	 }
1061	 function logBytes16(bytes16 p0) internal view {
1062	 _sendLogPayload(abi.encodeWithSignature("log(bytes16)", p0));
1063	 }
1064	 function logBytes17(bytes17 p0) internal view {
1065	 _sendLogPayload(abi.encodeWithSignature("log(bytes17)", p0));
1066	 }
1067	 function logBytes18(bytes18 p0) internal view {
1068	 _sendLogPayload(abi.encodeWithSignature("log(bytes18)", p0));
1069	 }
1070	 function logBytes19(bytes19 p0) internal view {
1071	 _sendLogPayload(abi.encodeWithSignature("log(bytes19)", p0));
1072	 }
1073	 function logBytes20(bytes20 p0) internal view {
1074	 _sendLogPayload(abi.encodeWithSignature("log(bytes20)", p0));
1075	 }
1076	 function logBytes21(bytes21 p0) internal view {
1077	 _sendLogPayload(abi.encodeWithSignature("log(bytes21)", p0));
1078	 }
1079	 function logBytes22(bytes22 p0) internal view {
1080	 _sendLogPayload(abi.encodeWithSignature("log(bytes22)", p0));
1081	 }
1082	 function logBytes23(bytes23 p0) internal view {
1083	 _sendLogPayload(abi.encodeWithSignature("log(bytes23)", p0));
1084	 }
1085	 function logBytes24(bytes24 p0) internal view {
1086	 _sendLogPayload(abi.encodeWithSignature("log(bytes24)", p0));
1087	 }
1088	 function logBytes25(bytes25 p0) internal view {
1089	 _sendLogPayload(abi.encodeWithSignature("log(bytes25)", p0));
1090	 }
1091	 function logBytes26(bytes26 p0) internal view {
1092	 _sendLogPayload(abi.encodeWithSignature("log(bytes26)", p0));
1093	 }
1094	 function logBytes27(bytes27 p0) internal view {
1095	 _sendLogPayload(abi.encodeWithSignature("log(bytes27)", p0));
1096	 }
1097	 function logBytes28(bytes28 p0) internal view {
1098	 _sendLogPayload(abi.encodeWithSignature("log(bytes28)", p0));
1099	 }
1100	 function logBytes29(bytes29 p0) internal view {
1101	 _sendLogPayload(abi.encodeWithSignature("log(bytes29)", p0));
1102	 }
1103	 function logBytes30(bytes30 p0) internal view {
1104	 _sendLogPayload(abi.encodeWithSignature("log(bytes30)", p0));
1105	 }
1106	 function logBytes31(bytes31 p0) internal view {
1107	 _sendLogPayload(abi.encodeWithSignature("log(bytes31)", p0));
1108	 }
1109	 function logBytes32(bytes32 p0) internal view {
1110	 _sendLogPayload(abi.encodeWithSignature("log(bytes32)", p0));
1111	 }
1112	 function log(uint p0) internal view {
1113	 _sendLogPayload(abi.encodeWithSignature("log(uint)", p0));
1114	 }
1115	 function log(string memory p0) internal view {
1116	 _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
1117	 }
1118	 function log(bool p0) internal view {
1119	 _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
1120	 }
1121	 function log(address p0) internal view {
1122	 _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
1123	 }
1124	 function log(uint p0, uint p1) internal view {
1125	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint)", p0, p1));
1126	 }
1127	 function log(uint p0, string memory p1) internal view {
1128	 _sendLogPayload(abi.encodeWithSignature("log(uint,string)", p0, p1));
1129	 }
1130	 function log(uint p0, bool p1) internal view {
1131	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool)", p0, p1));
1132	 }
1133	 function log(uint p0, address p1) internal view {
1134	 _sendLogPayload(abi.encodeWithSignature("log(uint,address)", p0, p1));
1135	 }
1136	 function log(string memory p0, uint p1) internal view {
1137	 _sendLogPayload(abi.encodeWithSignature("log(string,uint)", p0, p1));
1138	 }
1139	 function log(string memory p0, string memory p1) internal view {
1140	 _sendLogPayload(abi.encodeWithSignature("log(string,string)", p0, p1));
1141	 }
1142	 function log(string memory p0, bool p1) internal view {
1143	 _sendLogPayload(abi.encodeWithSignature("log(string,bool)", p0, p1));
1144	 }
1145	 function log(string memory p0, address p1) internal view {
1146	 _sendLogPayload(abi.encodeWithSignature("log(string,address)", p0, p1));
1147	 }
1148	 function log(bool p0, uint p1) internal view {
1149	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint)", p0, p1));
1150	 }
1151	 function log(bool p0, string memory p1) internal view {
1152	 _sendLogPayload(abi.encodeWithSignature("log(bool,string)", p0, p1));
1153	 }
1154	 function log(bool p0, bool p1) internal view {
1155	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool)", p0, p1));
1156	 }
1157	 function log(bool p0, address p1) internal view {
1158	 _sendLogPayload(abi.encodeWithSignature("log(bool,address)", p0, p1));
1159	 }
1160	 function log(address p0, uint p1) internal view {
1161	 _sendLogPayload(abi.encodeWithSignature("log(address,uint)", p0, p1));
1162	 }
1163	 function log(address p0, string memory p1) internal view {
1164	 _sendLogPayload(abi.encodeWithSignature("log(address,string)", p0, p1));
1165	 }
1166	 function log(address p0, bool p1) internal view {
1167	 _sendLogPayload(abi.encodeWithSignature("log(address,bool)", p0, p1));
1168	 }
1169	 function log(address p0, address p1) internal view {
1170	 _sendLogPayload(abi.encodeWithSignature("log(address,address)", p0, p1));
1171	 }
1172	 function log(uint p0, uint p1, uint p2) internal view {
1173	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint)", p0, p1, p2));
1174	 }
1175	 function log(uint p0, uint p1, string memory p2) internal view {
1176	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string)", p0, p1, p2));
1177	 }
1178	 function log(uint p0, uint p1, bool p2) internal view {
1179	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool)", p0, p1, p2));
1180	 }
1181	 function log(uint p0, uint p1, address p2) internal view {
1182	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address)", p0, p1, p2));
1183	 }
1184	 function log(uint p0, string memory p1, uint p2) internal view {
1185	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint)", p0, p1, p2));
1186	 }
1187	 function log(uint p0, string memory p1, string memory p2) internal view {
1188	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,string)", p0, p1, p2));
1189	 }
1190	 function log(uint p0, string memory p1, bool p2) internal view {
1191	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool)", p0, p1, p2));
1192	 }
1193	 function log(uint p0, string memory p1, address p2) internal view {
1194	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,address)", p0, p1, p2));
1195	 }
1196	 function log(uint p0, bool p1, uint p2) internal view {
1197	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint)", p0, p1, p2));
1198	 }
1199	 function log(uint p0, bool p1, string memory p2) internal view {
1200	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string)", p0, p1, p2));
1201	 }
1202	 function log(uint p0, bool p1, bool p2) internal view {
1203	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool)", p0, p1, p2));
1204	 }
1205	 function log(uint p0, bool p1, address p2) internal view {
1206	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address)", p0, p1, p2));
1207	 }
1208	 function log(uint p0, address p1, uint p2) internal view {
1209	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint)", p0, p1, p2));
1210	 }
1211	 function log(uint p0, address p1, string memory p2) internal view {
1212	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,string)", p0, p1, p2));
1213	 }
1214	 function log(uint p0, address p1, bool p2) internal view {
1215	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool)", p0, p1, p2));
1216	 }
1217	 function log(uint p0, address p1, address p2) internal view {
1218	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,address)", p0, p1, p2));
1219	 }
1220	 function log(string memory p0, uint p1, uint p2) internal view {
1221	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint)", p0, p1, p2));
1222	 }
1223	 function log(string memory p0, uint p1, string memory p2) internal view {
1224	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,string)", p0, p1, p2));
1225	 }
1226	 function log(string memory p0, uint p1, bool p2) internal view {
1227	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool)", p0, p1, p2));
1228	 }
1229	 function log(string memory p0, uint p1, address p2) internal view {
1230	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,address)", p0, p1, p2));
1231	 }
1232	 function log(string memory p0, string memory p1, uint p2) internal view {
1233	 _sendLogPayload(abi.encodeWithSignature("log(string,string,uint)", p0, p1, p2));
1234	 }
1235	 function log(string memory p0, string memory p1, string memory p2) internal view {
1236	 _sendLogPayload(abi.encodeWithSignature("log(string,string,string)", p0, p1, p2));
1237	 }
1238	 function log(string memory p0, string memory p1, bool p2) internal view {
1239	 _sendLogPayload(abi.encodeWithSignature("log(string,string,bool)", p0, p1, p2));
1240	 }
1241	 function log(string memory p0, string memory p1, address p2) internal view {
1242	 _sendLogPayload(abi.encodeWithSignature("log(string,string,address)", p0, p1, p2));
1243	 }
1244	 function log(string memory p0, bool p1, uint p2) internal view {
1245	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint)", p0, p1, p2));
1246	 }
1247	 function log(string memory p0, bool p1, string memory p2) internal view {
1248	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,string)", p0, p1, p2));
1249	 }
1250	 function log(string memory p0, bool p1, bool p2) internal view {
1251	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool)", p0, p1, p2));
1252	 }
1253	 function log(string memory p0, bool p1, address p2) internal view {
1254	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,address)", p0, p1, p2));
1255	 }
1256	 function log(string memory p0, address p1, uint p2) internal view {
1257	 _sendLogPayload(abi.encodeWithSignature("log(string,address,uint)", p0, p1, p2));
1258	 }
1259	 function log(string memory p0, address p1, string memory p2) internal view {
1260	 _sendLogPayload(abi.encodeWithSignature("log(string,address,string)", p0, p1, p2));
1261	 }
1262	 function log(string memory p0, address p1, bool p2) internal view {
1263	 _sendLogPayload(abi.encodeWithSignature("log(string,address,bool)", p0, p1, p2));
1264	 }
1265	 function log(string memory p0, address p1, address p2) internal view {
1266	 _sendLogPayload(abi.encodeWithSignature("log(string,address,address)", p0, p1, p2));
1267	 }
1268	 function log(bool p0, uint p1, uint p2) internal view {
1269	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint)", p0, p1, p2));
1270	 }
1271	 function log(bool p0, uint p1, string memory p2) internal view {
1272	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string)", p0, p1, p2));
1273	 }
1274	 function log(bool p0, uint p1, bool p2) internal view {
1275	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool)", p0, p1, p2));
1276	 }
1277	 function log(bool p0, uint p1, address p2) internal view {
1278	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address)", p0, p1, p2));
1279	 }
1280	 function log(bool p0, string memory p1, uint p2) internal view {
1281	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint)", p0, p1, p2));
1282	 }
1283	 function log(bool p0, string memory p1, string memory p2) internal view {
1284	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,string)", p0, p1, p2));
1285	 }
1286	 function log(bool p0, string memory p1, bool p2) internal view {
1287	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool)", p0, p1, p2));
1288	 }
1289	 function log(bool p0, string memory p1, address p2) internal view {
1290	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,address)", p0, p1, p2));
1291	 }
1292	 function log(bool p0, bool p1, uint p2) internal view {
1293	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint)", p0, p1, p2));
1294	 }
1295	 function log(bool p0, bool p1, string memory p2) internal view {
1296	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string)", p0, p1, p2));
1297	 }
1298	 function log(bool p0, bool p1, bool p2) internal view {
1299	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool)", p0, p1, p2));
1300	 }
1301	 function log(bool p0, bool p1, address p2) internal view {
1302	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address)", p0, p1, p2));
1303	 }
1304	 function log(bool p0, address p1, uint p2) internal view {
1305	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint)", p0, p1, p2));
1306	 }
1307	 function log(bool p0, address p1, string memory p2) internal view {
1308	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,string)", p0, p1, p2));
1309	 }
1310	 function log(bool p0, address p1, bool p2) internal view {
1311	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool)", p0, p1, p2));
1312	 }
1313	 function log(bool p0, address p1, address p2) internal view {
1314	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,address)", p0, p1, p2));
1315	 }
1316	 function log(address p0, uint p1, uint p2) internal view {
1317	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint)", p0, p1, p2));
1318	 }
1319	 function log(address p0, uint p1, string memory p2) internal view {
1320	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,string)", p0, p1, p2));
1321	 }
1322	 function log(address p0, uint p1, bool p2) internal view {
1323	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool)", p0, p1, p2));
1324	 }
1325	 function log(address p0, uint p1, address p2) internal view {
1326	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,address)", p0, p1, p2));
1327	 }
1328	 function log(address p0, string memory p1, uint p2) internal view {
1329	 _sendLogPayload(abi.encodeWithSignature("log(address,string,uint)", p0, p1, p2));
1330	 }
1331	 function log(address p0, string memory p1, string memory p2) internal view {
1332	 _sendLogPayload(abi.encodeWithSignature("log(address,string,string)", p0, p1, p2));
1333	 }
1334	 function log(address p0, string memory p1, bool p2) internal view {
1335	 _sendLogPayload(abi.encodeWithSignature("log(address,string,bool)", p0, p1, p2));
1336	 }
1337	 function log(address p0, string memory p1, address p2) internal view {
1338	 _sendLogPayload(abi.encodeWithSignature("log(address,string,address)", p0, p1, p2));
1339	 }
1340	 function log(address p0, bool p1, uint p2) internal view {
1341	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint)", p0, p1, p2));
1342	 }
1343	 function log(address p0, bool p1, string memory p2) internal view {
1344	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,string)", p0, p1, p2));
1345	 }
1346	 function log(address p0, bool p1, bool p2) internal view {
1347	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool)", p0, p1, p2));
1348	 }
1349	 function log(address p0, bool p1, address p2) internal view {
1350	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,address)", p0, p1, p2));
1351	 }
1352	 function log(address p0, address p1, uint p2) internal view {
1353	 _sendLogPayload(abi.encodeWithSignature("log(address,address,uint)", p0, p1, p2));
1354	 }
1355	 function log(address p0, address p1, string memory p2) internal view {
1356	 _sendLogPayload(abi.encodeWithSignature("log(address,address,string)", p0, p1, p2));
1357	 }
1358	 function log(address p0, address p1, bool p2) internal view {
1359	 _sendLogPayload(abi.encodeWithSignature("log(address,address,bool)", p0, p1, p2));
1360	 }
1361	 function log(address p0, address p1, address p2) internal view {
1362	 _sendLogPayload(abi.encodeWithSignature("log(address,address,address)", p0, p1, p2));
1363	 }
1364	 function log(uint p0, uint p1, uint p2, uint p3) internal view {
1365	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,uint)", p0, p1, p2, p3));
1366	 }
1367	 function log(uint p0, uint p1, uint p2, string memory p3) internal view {
1368	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,string)", p0, p1, p2, p3));
1369	 }
1370	 function log(uint p0, uint p1, uint p2, bool p3) internal view {
1371	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,bool)", p0, p1, p2, p3));
1372	 }
1373	 function log(uint p0, uint p1, uint p2, address p3) internal view {
1374	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,address)", p0, p1, p2, p3));
1375	 }
1376	 function log(uint p0, uint p1, string memory p2, uint p3) internal view {
1377	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,uint)", p0, p1, p2, p3));
1378	 }
1379	 function log(uint p0, uint p1, string memory p2, string memory p3) internal view {
1380	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,string)", p0, p1, p2, p3));
1381	 }
1382	 function log(uint p0, uint p1, string memory p2, bool p3) internal view {
1383	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,bool)", p0, p1, p2, p3));
1384	 }
1385	 function log(uint p0, uint p1, string memory p2, address p3) internal view {
1386	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,address)", p0, p1, p2, p3));
1387	 }
1388	 function log(uint p0, uint p1, bool p2, uint p3) internal view {
1389	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,uint)", p0, p1, p2, p3));
1390	 }
1391	 function log(uint p0, uint p1, bool p2, string memory p3) internal view {
1392	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,string)", p0, p1, p2, p3));
1393	 }
1394	 function log(uint p0, uint p1, bool p2, bool p3) internal view {
1395	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,bool)", p0, p1, p2, p3));
1396	 }
1397	 function log(uint p0, uint p1, bool p2, address p3) internal view {
1398	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,address)", p0, p1, p2, p3));
1399	 }
1400	 function log(uint p0, uint p1, address p2, uint p3) internal view {
1401	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,uint)", p0, p1, p2, p3));
1402	 }
1403	 function log(uint p0, uint p1, address p2, string memory p3) internal view {
1404	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,string)", p0, p1, p2, p3));
1405	 }
1406	 function log(uint p0, uint p1, address p2, bool p3) internal view {
1407	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,bool)", p0, p1, p2, p3));
1408	 }
1409	 function log(uint p0, uint p1, address p2, address p3) internal view {
1410	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,address)", p0, p1, p2, p3));
1411	 }
1412	 function log(uint p0, string memory p1, uint p2, uint p3) internal view {
1413	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,uint)", p0, p1, p2, p3));
1414	 }
1415	 function log(uint p0, string memory p1, uint p2, string memory p3) internal view {
1416	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,string)", p0, p1, p2, p3));
1417	 }
1418	 function log(uint p0, string memory p1, uint p2, bool p3) internal view {
1419	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,bool)", p0, p1, p2, p3));
1420	 }
1421	 function log(uint p0, string memory p1, uint p2, address p3) internal view {
1422	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,address)", p0, p1, p2, p3));
1423	 }
1424	 function log(uint p0, string memory p1, string memory p2, uint p3) internal view {
1425	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,uint)", p0, p1, p2, p3));
1426	 }
1427	 function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {
1428	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,string)", p0, p1, p2, p3));
1429	 }
1430	 function log(uint p0, string memory p1, string memory p2, bool p3) internal view {
1431	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,bool)", p0, p1, p2, p3));
1432	 }
1433	 function log(uint p0, string memory p1, string memory p2, address p3) internal view {
1434	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,address)", p0, p1, p2, p3));
1435	 }
1436	 function log(uint p0, string memory p1, bool p2, uint p3) internal view {
1437	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,uint)", p0, p1, p2, p3));
1438	 }
1439	 function log(uint p0, string memory p1, bool p2, string memory p3) internal view {
1440	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,string)", p0, p1, p2, p3));
1441	 }
1442	 function log(uint p0, string memory p1, bool p2, bool p3) internal view {
1443	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,bool)", p0, p1, p2, p3));
1444	 }
1445	 function log(uint p0, string memory p1, bool p2, address p3) internal view {
1446	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,address)", p0, p1, p2, p3));
1447	 }
1448	 function log(uint p0, string memory p1, address p2, uint p3) internal view {
1449	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,uint)", p0, p1, p2, p3));
1450	 }
1451	 function log(uint p0, string memory p1, address p2, string memory p3) internal view {
1452	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,string)", p0, p1, p2, p3));
1453	 }
1454	 function log(uint p0, string memory p1, address p2, bool p3) internal view {
1455	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,bool)", p0, p1, p2, p3));
1456	 }
1457	 function log(uint p0, string memory p1, address p2, address p3) internal view {
1458	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,address)", p0, p1, p2, p3));
1459	 }
1460	 function log(uint p0, bool p1, uint p2, uint p3) internal view {
1461	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,uint)", p0, p1, p2, p3));
1462	 }
1463	 function log(uint p0, bool p1, uint p2, string memory p3) internal view {
1464	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,string)", p0, p1, p2, p3));
1465	 }
1466	 function log(uint p0, bool p1, uint p2, bool p3) internal view {
1467	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,bool)", p0, p1, p2, p3));
1468	 }
1469	 function log(uint p0, bool p1, uint p2, address p3) internal view {
1470	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,address)", p0, p1, p2, p3));
1471	 }
1472	 function log(uint p0, bool p1, string memory p2, uint p3) internal view {
1473	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,uint)", p0, p1, p2, p3));
1474	 }
1475	 function log(uint p0, bool p1, string memory p2, string memory p3) internal view {
1476	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,string)", p0, p1, p2, p3));
1477	 }
1478	 function log(uint p0, bool p1, string memory p2, bool p3) internal view {
1479	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,bool)", p0, p1, p2, p3));
1480	 }
1481	 function log(uint p0, bool p1, string memory p2, address p3) internal view {
1482	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,address)", p0, p1, p2, p3));
1483	 }
1484	 function log(uint p0, bool p1, bool p2, uint p3) internal view {
1485	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,uint)", p0, p1, p2, p3));
1486	 }
1487	 function log(uint p0, bool p1, bool p2, string memory p3) internal view {
1488	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,string)", p0, p1, p2, p3));
1489	 }
1490	 function log(uint p0, bool p1, bool p2, bool p3) internal view {
1491	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,bool)", p0, p1, p2, p3));
1492	 }
1493	 function log(uint p0, bool p1, bool p2, address p3) internal view {
1494	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,address)", p0, p1, p2, p3));
1495	 }
1496	 function log(uint p0, bool p1, address p2, uint p3) internal view {
1497	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,uint)", p0, p1, p2, p3));
1498	 }
1499	 function log(uint p0, bool p1, address p2, string memory p3) internal view {
1500	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,string)", p0, p1, p2, p3));
1501	 }
1502	 function log(uint p0, bool p1, address p2, bool p3) internal view {
1503	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,bool)", p0, p1, p2, p3));
1504	 }
1505	 function log(uint p0, bool p1, address p2, address p3) internal view {
1506	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,address)", p0, p1, p2, p3));
1507	 }
1508	 function log(uint p0, address p1, uint p2, uint p3) internal view {
1509	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,uint)", p0, p1, p2, p3));
1510	 }
1511	 function log(uint p0, address p1, uint p2, string memory p3) internal view {
1512	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,string)", p0, p1, p2, p3));
1513	 }
1514	 function log(uint p0, address p1, uint p2, bool p3) internal view {
1515	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,bool)", p0, p1, p2, p3));
1516	 }
1517	 function log(uint p0, address p1, uint p2, address p3) internal view {
1518	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,address)", p0, p1, p2, p3));
1519	 }
1520	 function log(uint p0, address p1, string memory p2, uint p3) internal view {
1521	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,uint)", p0, p1, p2, p3));
1522	 }
1523	 function log(uint p0, address p1, string memory p2, string memory p3) internal view {
1524	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,string)", p0, p1, p2, p3));
1525	 }
1526	 function log(uint p0, address p1, string memory p2, bool p3) internal view {
1527	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,bool)", p0, p1, p2, p3));
1528	 }
1529	 function log(uint p0, address p1, string memory p2, address p3) internal view {
1530	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,address)", p0, p1, p2, p3));
1531	 }
1532	 function log(uint p0, address p1, bool p2, uint p3) internal view {
1533	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,uint)", p0, p1, p2, p3));
1534	 }
1535	 function log(uint p0, address p1, bool p2, string memory p3) internal view {
1536	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,string)", p0, p1, p2, p3));
1537	 }
1538	 function log(uint p0, address p1, bool p2, bool p3) internal view {
1539	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,bool)", p0, p1, p2, p3));
1540	 }
1541	 function log(uint p0, address p1, bool p2, address p3) internal view {
1542	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,address)", p0, p1, p2, p3));
1543	 }
1544	 function log(uint p0, address p1, address p2, uint p3) internal view {
1545	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,uint)", p0, p1, p2, p3));
1546	 }
1547	 function log(uint p0, address p1, address p2, string memory p3) internal view {
1548	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,string)", p0, p1, p2, p3));
1549	 }
1550	 function log(uint p0, address p1, address p2, bool p3) internal view {
1551	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,bool)", p0, p1, p2, p3));
1552	 }
1553	 function log(uint p0, address p1, address p2, address p3) internal view {
1554	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,address)", p0, p1, p2, p3));
1555	 }
1556	 function log(string memory p0, uint p1, uint p2, uint p3) internal view {
1557	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,uint)", p0, p1, p2, p3));
1558	 }
1559	 function log(string memory p0, uint p1, uint p2, string memory p3) internal view {
1560	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,string)", p0, p1, p2, p3));
1561	 }
1562	 function log(string memory p0, uint p1, uint p2, bool p3) internal view {
1563	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,bool)", p0, p1, p2, p3));
1564	 }
1565	 function log(string memory p0, uint p1, uint p2, address p3) internal view {
1566	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,address)", p0, p1, p2, p3));
1567	 }
1568	 function log(string memory p0, uint p1, string memory p2, uint p3) internal view {
1569	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,uint)", p0, p1, p2, p3));
1570	 }
1571	 function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {
1572	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,string)", p0, p1, p2, p3));
1573	 }
1574	 function log(string memory p0, uint p1, string memory p2, bool p3) internal view {
1575	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,bool)", p0, p1, p2, p3));
1576	 }
1577	 function log(string memory p0, uint p1, string memory p2, address p3) internal view {
1578	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,address)", p0, p1, p2, p3));
1579	 }
1580	 function log(string memory p0, uint p1, bool p2, uint p3) internal view {
1581	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,uint)", p0, p1, p2, p3));
1582	 }
1583	 function log(string memory p0, uint p1, bool p2, string memory p3) internal view {
1584	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,string)", p0, p1, p2, p3));
1585	 }
1586	 function log(string memory p0, uint p1, bool p2, bool p3) internal view {
1587	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,bool)", p0, p1, p2, p3));
1588	 }
1589	 function log(string memory p0, uint p1, bool p2, address p3) internal view {
1590	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,address)", p0, p1, p2, p3));
1591	 }
1592	 function log(string memory p0, uint p1, address p2, uint p3) internal view {
1593	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,uint)", p0, p1, p2, p3));
1594	 }
1595	 function log(string memory p0, uint p1, address p2, string memory p3) internal view {
1596	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,string)", p0, p1, p2, p3));
1597	 }
1598	 function log(string memory p0, uint p1, address p2, bool p3) internal view {
1599	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,bool)", p0, p1, p2, p3));
1600	 }
1601	 function log(string memory p0, uint p1, address p2, address p3) internal view {
1602	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,address)", p0, p1, p2, p3));
1603	 }
1604	 function log(string memory p0, string memory p1, uint p2, uint p3) internal view {
1605	 _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,uint)", p0, p1, p2, p3));
1606	 }
1607	 function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {
1608	 _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,string)", p0, p1, p2, p3));
1609	 }
1610	 function log(string memory p0, string memory p1, uint p2, bool p3) internal view {
1611	 _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,bool)", p0, p1, p2, p3));
1612	 }
1613	 function log(string memory p0, string memory p1, uint p2, address p3) internal view {
1614	 _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,address)", p0, p1, p2, p3));
1615	 }
1616	 function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {
1617	 _sendLogPayload(abi.encodeWithSignature("log(string,string,string,uint)", p0, p1, p2, p3));
1618	 }
1619	 function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {
1620	 _sendLogPayload(abi.encodeWithSignature("log(string,string,string,string)", p0, p1, p2, p3));
1621	 }
1622	 function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {
1623	 _sendLogPayload(abi.encodeWithSignature("log(string,string,string,bool)", p0, p1, p2, p3));
1624	 }
1625	 function log(string memory p0, string memory p1, string memory p2, address p3) internal view {
1626	 _sendLogPayload(abi.encodeWithSignature("log(string,string,string,address)", p0, p1, p2, p3));
1627	 }
1628	 function log(string memory p0, string memory p1, bool p2, uint p3) internal view {
1629	 _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,uint)", p0, p1, p2, p3));
1630	 }
1631	 function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {
1632	 _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,string)", p0, p1, p2, p3));
1633	 }
1634	 function log(string memory p0, string memory p1, bool p2, bool p3) internal view {
1635	 _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,bool)", p0, p1, p2, p3));
1636	 }
1637	 function log(string memory p0, string memory p1, bool p2, address p3) internal view {
1638	 _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,address)", p0, p1, p2, p3));
1639	 }
1640	 function log(string memory p0, string memory p1, address p2, uint p3) internal view {
1641	 _sendLogPayload(abi.encodeWithSignature("log(string,string,address,uint)", p0, p1, p2, p3));
1642	 }
1643	 function log(string memory p0, string memory p1, address p2, string memory p3) internal view {
1644	 _sendLogPayload(abi.encodeWithSignature("log(string,string,address,string)", p0, p1, p2, p3));
1645	 }
1646	 function log(string memory p0, string memory p1, address p2, bool p3) internal view {
1647	 _sendLogPayload(abi.encodeWithSignature("log(string,string,address,bool)", p0, p1, p2, p3));
1648	 }
1649	 function log(string memory p0, string memory p1, address p2, address p3) internal view {
1650	 _sendLogPayload(abi.encodeWithSignature("log(string,string,address,address)", p0, p1, p2, p3));
1651	 }
1652	 function log(string memory p0, bool p1, uint p2, uint p3) internal view {
1653	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,uint)", p0, p1, p2, p3));
1654	 }
1655	 function log(string memory p0, bool p1, uint p2, string memory p3) internal view {
1656	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,string)", p0, p1, p2, p3));
1657	 }
1658	 function log(string memory p0, bool p1, uint p2, bool p3) internal view {
1659	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,bool)", p0, p1, p2, p3));
1660	 }
1661	 function log(string memory p0, bool p1, uint p2, address p3) internal view {
1662	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,address)", p0, p1, p2, p3));
1663	 }
1664	 function log(string memory p0, bool p1, string memory p2, uint p3) internal view {
1665	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,uint)", p0, p1, p2, p3));
1666	 }
1667	 function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {
1668	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,string)", p0, p1, p2, p3));
1669	 }
1670	 function log(string memory p0, bool p1, string memory p2, bool p3) internal view {
1671	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,bool)", p0, p1, p2, p3));
1672	 }
1673	 function log(string memory p0, bool p1, string memory p2, address p3) internal view {
1674	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,address)", p0, p1, p2, p3));
1675	 }
1676	 function log(string memory p0, bool p1, bool p2, uint p3) internal view {
1677	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,uint)", p0, p1, p2, p3));
1678	 }
1679	 function log(string memory p0, bool p1, bool p2, string memory p3) internal view {
1680	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,string)", p0, p1, p2, p3));
1681	 }
1682	 function log(string memory p0, bool p1, bool p2, bool p3) internal view {
1683	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,bool)", p0, p1, p2, p3));
1684	 }
1685	 function log(string memory p0, bool p1, bool p2, address p3) internal view {
1686	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,address)", p0, p1, p2, p3));
1687	 }
1688	 function log(string memory p0, bool p1, address p2, uint p3) internal view {
1689	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,uint)", p0, p1, p2, p3));
1690	 }
1691	 function log(string memory p0, bool p1, address p2, string memory p3) internal view {
1692	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,string)", p0, p1, p2, p3));
1693	 }
1694	 function log(string memory p0, bool p1, address p2, bool p3) internal view {
1695	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,bool)", p0, p1, p2, p3));
1696	 }
1697	 function log(string memory p0, bool p1, address p2, address p3) internal view {
1698	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,address)", p0, p1, p2, p3));
1699	 }
1700	 function log(string memory p0, address p1, uint p2, uint p3) internal view {
1701	 _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,uint)", p0, p1, p2, p3));
1702	 }
1703	 function log(string memory p0, address p1, uint p2, string memory p3) internal view {
1704	 _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,string)", p0, p1, p2, p3));
1705	 }
1706	 function log(string memory p0, address p1, uint p2, bool p3) internal view {
1707	 _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,bool)", p0, p1, p2, p3));
1708	 }
1709	 function log(string memory p0, address p1, uint p2, address p3) internal view {
1710	 _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,address)", p0, p1, p2, p3));
1711	 }
1712	 function log(string memory p0, address p1, string memory p2, uint p3) internal view {
1713	 _sendLogPayload(abi.encodeWithSignature("log(string,address,string,uint)", p0, p1, p2, p3));
1714	 }
1715	 function log(string memory p0, address p1, string memory p2, string memory p3) internal view {
1716	 _sendLogPayload(abi.encodeWithSignature("log(string,address,string,string)", p0, p1, p2, p3));
1717	 }
1718	 function log(string memory p0, address p1, string memory p2, bool p3) internal view {
1719	 _sendLogPayload(abi.encodeWithSignature("log(string,address,string,bool)", p0, p1, p2, p3));
1720	 }
1721	 function log(string memory p0, address p1, string memory p2, address p3) internal view {
1722	 _sendLogPayload(abi.encodeWithSignature("log(string,address,string,address)", p0, p1, p2, p3));
1723	 }
1724	 function log(string memory p0, address p1, bool p2, uint p3) internal view {
1725	 _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,uint)", p0, p1, p2, p3));
1726	 }
1727	 function log(string memory p0, address p1, bool p2, string memory p3) internal view {
1728	 _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,string)", p0, p1, p2, p3));
1729	 }
1730	 function log(string memory p0, address p1, bool p2, bool p3) internal view {
1731	 _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,bool)", p0, p1, p2, p3));
1732	 }
1733	 function log(string memory p0, address p1, bool p2, address p3) internal view {
1734	 _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,address)", p0, p1, p2, p3));
1735	 }
1736	 function log(string memory p0, address p1, address p2, uint p3) internal view {
1737	 _sendLogPayload(abi.encodeWithSignature("log(string,address,address,uint)", p0, p1, p2, p3));
1738	 }
1739	 function log(string memory p0, address p1, address p2, string memory p3) internal view {
1740	 _sendLogPayload(abi.encodeWithSignature("log(string,address,address,string)", p0, p1, p2, p3));
1741	 }
1742	 function log(string memory p0, address p1, address p2, bool p3) internal view {
1743	 _sendLogPayload(abi.encodeWithSignature("log(string,address,address,bool)", p0, p1, p2, p3));
1744	 }
1745	 function log(string memory p0, address p1, address p2, address p3) internal view {
1746	 _sendLogPayload(abi.encodeWithSignature("log(string,address,address,address)", p0, p1, p2, p3));
1747	 }
1748	 function log(bool p0, uint p1, uint p2, uint p3) internal view {
1749	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,uint)", p0, p1, p2, p3));
1750	 }
1751	 function log(bool p0, uint p1, uint p2, string memory p3) internal view {
1752	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,string)", p0, p1, p2, p3));
1753	 }
1754	 function log(bool p0, uint p1, uint p2, bool p3) internal view {
1755	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,bool)", p0, p1, p2, p3));
1756	 }
1757	 function log(bool p0, uint p1, uint p2, address p3) internal view {
1758	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,address)", p0, p1, p2, p3));
1759	 }
1760	 function log(bool p0, uint p1, string memory p2, uint p3) internal view {
1761	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,uint)", p0, p1, p2, p3));
1762	 }
1763	 function log(bool p0, uint p1, string memory p2, string memory p3) internal view {
1764	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,string)", p0, p1, p2, p3));
1765	 }
1766	 function log(bool p0, uint p1, string memory p2, bool p3) internal view {
1767	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,bool)", p0, p1, p2, p3));
1768	 }
1769	 function log(bool p0, uint p1, string memory p2, address p3) internal view {
1770	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,address)", p0, p1, p2, p3));
1771	 }
1772	 function log(bool p0, uint p1, bool p2, uint p3) internal view {
1773	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,uint)", p0, p1, p2, p3));
1774	 }
1775	 function log(bool p0, uint p1, bool p2, string memory p3) internal view {
1776	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,string)", p0, p1, p2, p3));
1777	 }
1778	 function log(bool p0, uint p1, bool p2, bool p3) internal view {
1779	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,bool)", p0, p1, p2, p3));
1780	 }
1781	 function log(bool p0, uint p1, bool p2, address p3) internal view {
1782	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,address)", p0, p1, p2, p3));
1783	 }
1784	 function log(bool p0, uint p1, address p2, uint p3) internal view {
1785	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,uint)", p0, p1, p2, p3));
1786	 }
1787	 function log(bool p0, uint p1, address p2, string memory p3) internal view {
1788	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,string)", p0, p1, p2, p3));
1789	 }
1790	 function log(bool p0, uint p1, address p2, bool p3) internal view {
1791	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,bool)", p0, p1, p2, p3));
1792	 }
1793	 function log(bool p0, uint p1, address p2, address p3) internal view {
1794	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,address)", p0, p1, p2, p3));
1795	 }
1796	 function log(bool p0, string memory p1, uint p2, uint p3) internal view {
1797	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,uint)", p0, p1, p2, p3));
1798	 }
1799	 function log(bool p0, string memory p1, uint p2, string memory p3) internal view {
1800	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,string)", p0, p1, p2, p3));
1801	 }
1802	 function log(bool p0, string memory p1, uint p2, bool p3) internal view {
1803	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,bool)", p0, p1, p2, p3));
1804	 }
1805	 function log(bool p0, string memory p1, uint p2, address p3) internal view {
1806	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,address)", p0, p1, p2, p3));
1807	 }
1808	 function log(bool p0, string memory p1, string memory p2, uint p3) internal view {
1809	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,uint)", p0, p1, p2, p3));
1810	 }
1811	 function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {
1812	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,string)", p0, p1, p2, p3));
1813	 }
1814	 function log(bool p0, string memory p1, string memory p2, bool p3) internal view {
1815	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,bool)", p0, p1, p2, p3));
1816	 }
1817	 function log(bool p0, string memory p1, string memory p2, address p3) internal view {
1818	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,address)", p0, p1, p2, p3));
1819	 }
1820	 function log(bool p0, string memory p1, bool p2, uint p3) internal view {
1821	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,uint)", p0, p1, p2, p3));
1822	 }
1823	 function log(bool p0, string memory p1, bool p2, string memory p3) internal view {
1824	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,string)", p0, p1, p2, p3));
1825	 }
1826	 function log(bool p0, string memory p1, bool p2, bool p3) internal view {
1827	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,bool)", p0, p1, p2, p3));
1828	 }
1829	 function log(bool p0, string memory p1, bool p2, address p3) internal view {
1830	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,address)", p0, p1, p2, p3));
1831	 }
1832	 function log(bool p0, string memory p1, address p2, uint p3) internal view {
1833	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,uint)", p0, p1, p2, p3));
1834	 }
1835	 function log(bool p0, string memory p1, address p2, string memory p3) internal view {
1836	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,string)", p0, p1, p2, p3));
1837	 }
1838	 function log(bool p0, string memory p1, address p2, bool p3) internal view {
1839	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,bool)", p0, p1, p2, p3));
1840	 }
1841	 function log(bool p0, string memory p1, address p2, address p3) internal view {
1842	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,address)", p0, p1, p2, p3));
1843	 }
1844	 function log(bool p0, bool p1, uint p2, uint p3) internal view {
1845	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,uint)", p0, p1, p2, p3));
1846	 }
1847	 function log(bool p0, bool p1, uint p2, string memory p3) internal view {
1848	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,string)", p0, p1, p2, p3));
1849	 }
1850	 function log(bool p0, bool p1, uint p2, bool p3) internal view {
1851	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,bool)", p0, p1, p2, p3));
1852	 }
1853	 function log(bool p0, bool p1, uint p2, address p3) internal view {
1854	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,address)", p0, p1, p2, p3));
1855	 }
1856	 function log(bool p0, bool p1, string memory p2, uint p3) internal view {
1857	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,uint)", p0, p1, p2, p3));
1858	 }
1859	 function log(bool p0, bool p1, string memory p2, string memory p3) internal view {
1860	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,string)", p0, p1, p2, p3));
1861	 }
1862	 function log(bool p0, bool p1, string memory p2, bool p3) internal view {
1863	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,bool)", p0, p1, p2, p3));
1864	 }
1865	 function log(bool p0, bool p1, string memory p2, address p3) internal view {
1866	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,address)", p0, p1, p2, p3));
1867	 }
1868	 function log(bool p0, bool p1, bool p2, uint p3) internal view {
1869	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,uint)", p0, p1, p2, p3));
1870	 }
1871	 function log(bool p0, bool p1, bool p2, string memory p3) internal view {
1872	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,string)", p0, p1, p2, p3));
1873	 }
1874	 function log(bool p0, bool p1, bool p2, bool p3) internal view {
1875	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,bool)", p0, p1, p2, p3));
1876	 }
1877	 function log(bool p0, bool p1, bool p2, address p3) internal view {
1878	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,address)", p0, p1, p2, p3));
1879	 }
1880	 function log(bool p0, bool p1, address p2, uint p3) internal view {
1881	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,uint)", p0, p1, p2, p3));
1882	 }
1883	 function log(bool p0, bool p1, address p2, string memory p3) internal view {
1884	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,string)", p0, p1, p2, p3));
1885	 }
1886	 function log(bool p0, bool p1, address p2, bool p3) internal view {
1887	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,bool)", p0, p1, p2, p3));
1888	 }
1889	 function log(bool p0, bool p1, address p2, address p3) internal view {
1890	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,address)", p0, p1, p2, p3));
1891	 }
1892	 function log(bool p0, address p1, uint p2, uint p3) internal view {
1893	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,uint)", p0, p1, p2, p3));
1894	 }
1895	 function log(bool p0, address p1, uint p2, string memory p3) internal view {
1896	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,string)", p0, p1, p2, p3));
1897	 }
1898	 function log(bool p0, address p1, uint p2, bool p3) internal view {
1899	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,bool)", p0, p1, p2, p3));
1900	 }
1901	 function log(bool p0, address p1, uint p2, address p3) internal view {
1902	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,address)", p0, p1, p2, p3));
1903	 }
1904	 function log(bool p0, address p1, string memory p2, uint p3) internal view {
1905	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,uint)", p0, p1, p2, p3));
1906	 }
1907	 function log(bool p0, address p1, string memory p2, string memory p3) internal view {
1908	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,string)", p0, p1, p2, p3));
1909	 }
1910	 function log(bool p0, address p1, string memory p2, bool p3) internal view {
1911	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,bool)", p0, p1, p2, p3));
1912	 }
1913	 function log(bool p0, address p1, string memory p2, address p3) internal view {
1914	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,address)", p0, p1, p2, p3));
1915	 }
1916	 function log(bool p0, address p1, bool p2, uint p3) internal view {
1917	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,uint)", p0, p1, p2, p3));
1918	 }
1919	 function log(bool p0, address p1, bool p2, string memory p3) internal view {
1920	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,string)", p0, p1, p2, p3));
1921	 }
1922	 function log(bool p0, address p1, bool p2, bool p3) internal view {
1923	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,bool)", p0, p1, p2, p3));
1924	 }
1925	 function log(bool p0, address p1, bool p2, address p3) internal view {
1926	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,address)", p0, p1, p2, p3));
1927	 }
1928	 function log(bool p0, address p1, address p2, uint p3) internal view {
1929	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,uint)", p0, p1, p2, p3));
1930	 }
1931	 function log(bool p0, address p1, address p2, string memory p3) internal view {
1932	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,string)", p0, p1, p2, p3));
1933	 }
1934	 function log(bool p0, address p1, address p2, bool p3) internal view {
1935	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,bool)", p0, p1, p2, p3));
1936	 }
1937	 function log(bool p0, address p1, address p2, address p3) internal view {
1938	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,address)", p0, p1, p2, p3));
1939	 }
1940	 function log(address p0, uint p1, uint p2, uint p3) internal view {
1941	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,uint)", p0, p1, p2, p3));
1942	 }
1943	 function log(address p0, uint p1, uint p2, string memory p3) internal view {
1944	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,string)", p0, p1, p2, p3));
1945	 }
1946	 function log(address p0, uint p1, uint p2, bool p3) internal view {
1947	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,bool)", p0, p1, p2, p3));
1948	 }
1949	 function log(address p0, uint p1, uint p2, address p3) internal view {
1950	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,address)", p0, p1, p2, p3));
1951	 }
1952	 function log(address p0, uint p1, string memory p2, uint p3) internal view {
1953	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,uint)", p0, p1, p2, p3));
1954	 }
1955	 function log(address p0, uint p1, string memory p2, string memory p3) internal view {
1956	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,string)", p0, p1, p2, p3));
1957	 }
1958	 function log(address p0, uint p1, string memory p2, bool p3) internal view {
1959	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,bool)", p0, p1, p2, p3));
1960	 }
1961	 function log(address p0, uint p1, string memory p2, address p3) internal view {
1962	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,address)", p0, p1, p2, p3));
1963	 }
1964	 function log(address p0, uint p1, bool p2, uint p3) internal view {
1965	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,uint)", p0, p1, p2, p3));
1966	 }
1967	 function log(address p0, uint p1, bool p2, string memory p3) internal view {
1968	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,string)", p0, p1, p2, p3));
1969	 }
1970	 function log(address p0, uint p1, bool p2, bool p3) internal view {
1971	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,bool)", p0, p1, p2, p3));
1972	 }
1973	 function log(address p0, uint p1, bool p2, address p3) internal view {
1974	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,address)", p0, p1, p2, p3));
1975	 }
1976	 function log(address p0, uint p1, address p2, uint p3) internal view {
1977	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,uint)", p0, p1, p2, p3));
1978	 }
1979	 function log(address p0, uint p1, address p2, string memory p3) internal view {
1980	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,string)", p0, p1, p2, p3));
1981	 }
1982	 function log(address p0, uint p1, address p2, bool p3) internal view {
1983	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,bool)", p0, p1, p2, p3));
1984	 }
1985	 function log(address p0, uint p1, address p2, address p3) internal view {
1986	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,address)", p0, p1, p2, p3));
1987	 }
1988	 function log(address p0, string memory p1, uint p2, uint p3) internal view {
1989	 _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,uint)", p0, p1, p2, p3));
1990	 }
1991	 function log(address p0, string memory p1, uint p2, string memory p3) internal view {
1992	 _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,string)", p0, p1, p2, p3));
1993	 }
1994	 function log(address p0, string memory p1, uint p2, bool p3) internal view {
1995	 _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,bool)", p0, p1, p2, p3));
1996	 }
1997	 function log(address p0, string memory p1, uint p2, address p3) internal view {
1998	 _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,address)", p0, p1, p2, p3));
1999	 }
2000	 function log(address p0, string memory p1, string memory p2, uint p3) internal view {
2001	 _sendLogPayload(abi.encodeWithSignature("log(address,string,string,uint)", p0, p1, p2, p3));
2002	 }
2003	 function log(address p0, string memory p1, string memory p2, string memory p3) internal view {
2004	 _sendLogPayload(abi.encodeWithSignature("log(address,string,string,string)", p0, p1, p2, p3));
2005	 }
2006	 function log(address p0, string memory p1, string memory p2, bool p3) internal view {
2007	 _sendLogPayload(abi.encodeWithSignature("log(address,string,string,bool)", p0, p1, p2, p3));
2008	 }
2009	 function log(address p0, string memory p1, string memory p2, address p3) internal view {
2010	 _sendLogPayload(abi.encodeWithSignature("log(address,string,string,address)", p0, p1, p2, p3));
2011	 }
2012	 function log(address p0, string memory p1, bool p2, uint p3) internal view {
2013	 _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,uint)", p0, p1, p2, p3));
2014	 }
2015	 function log(address p0, string memory p1, bool p2, string memory p3) internal view {
2016	 _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,string)", p0, p1, p2, p3));
2017	 }
2018	 function log(address p0, string memory p1, bool p2, bool p3) internal view {
2019	 _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,bool)", p0, p1, p2, p3));
2020	 }
2021	 function log(address p0, string memory p1, bool p2, address p3) internal view {
2022	 _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,address)", p0, p1, p2, p3));
2023	 }
2024	 function log(address p0, string memory p1, address p2, uint p3) internal view {
2025	 _sendLogPayload(abi.encodeWithSignature("log(address,string,address,uint)", p0, p1, p2, p3));
2026	 }
2027	 function log(address p0, string memory p1, address p2, string memory p3) internal view {
2028	 _sendLogPayload(abi.encodeWithSignature("log(address,string,address,string)", p0, p1, p2, p3));
2029	 }
2030	 function log(address p0, string memory p1, address p2, bool p3) internal view {
2031	 _sendLogPayload(abi.encodeWithSignature("log(address,string,address,bool)", p0, p1, p2, p3));
2032	 }
2033	 function log(address p0, string memory p1, address p2, address p3) internal view {
2034	 _sendLogPayload(abi.encodeWithSignature("log(address,string,address,address)", p0, p1, p2, p3));
2035	 }
2036	 function log(address p0, bool p1, uint p2, uint p3) internal view {
2037	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,uint)", p0, p1, p2, p3));
2038	 }
2039	 function log(address p0, bool p1, uint p2, string memory p3) internal view {
2040	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,string)", p0, p1, p2, p3));
2041	 }
2042	 function log(address p0, bool p1, uint p2, bool p3) internal view {
2043	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,bool)", p0, p1, p2, p3));
2044	 }
2045	 function log(address p0, bool p1, uint p2, address p3) internal view {
2046	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,address)", p0, p1, p2, p3));
2047	 }
2048	 function log(address p0, bool p1, string memory p2, uint p3) internal view {
2049	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,uint)", p0, p1, p2, p3));
2050	 }
2051	 function log(address p0, bool p1, string memory p2, string memory p3) internal view {
2052	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,string)", p0, p1, p2, p3));
2053	 }
2054	 function log(address p0, bool p1, string memory p2, bool p3) internal view {
2055	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,bool)", p0, p1, p2, p3));
2056	 }
2057	 function log(address p0, bool p1, string memory p2, address p3) internal view {
2058	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,address)", p0, p1, p2, p3));
2059	 }
2060	 function log(address p0, bool p1, bool p2, uint p3) internal view {
2061	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,uint)", p0, p1, p2, p3));
2062	 }
2063	 function log(address p0, bool p1, bool p2, string memory p3) internal view {
2064	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,string)", p0, p1, p2, p3));
2065	 }
2066	 function log(address p0, bool p1, bool p2, bool p3) internal view {
2067	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,bool)", p0, p1, p2, p3));
2068	 }
2069	 function log(address p0, bool p1, bool p2, address p3) internal view {
2070	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,address)", p0, p1, p2, p3));
2071	 }
2072	 function log(address p0, bool p1, address p2, uint p3) internal view {
2073	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,uint)", p0, p1, p2, p3));
2074	 }
2075	 function log(address p0, bool p1, address p2, string memory p3) internal view {
2076	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,string)", p0, p1, p2, p3));
2077	 }
2078	 function log(address p0, bool p1, address p2, bool p3) internal view {
2079	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,bool)", p0, p1, p2, p3));
2080	 }
2081	 function log(address p0, bool p1, address p2, address p3) internal view {
2082	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,address)", p0, p1, p2, p3));
2083	 }
2084	 function log(address p0, address p1, uint p2, uint p3) internal view {
2085	 _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,uint)", p0, p1, p2, p3));
2086	 }
2087	 function log(address p0, address p1, uint p2, string memory p3) internal view {
2088	 _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,string)", p0, p1, p2, p3));
2089	 }
2090	 function log(address p0, address p1, uint p2, bool p3) internal view {
2091	 _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,bool)", p0, p1, p2, p3));
2092	 }
2093	 function log(address p0, address p1, uint p2, address p3) internal view {
2094	 _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,address)", p0, p1, p2, p3));
2095	 }
2096	 function log(address p0, address p1, string memory p2, uint p3) internal view {
2097	 _sendLogPayload(abi.encodeWithSignature("log(address,address,string,uint)", p0, p1, p2, p3));
2098	 }
2099	 function log(address p0, address p1, string memory p2, string memory p3) internal view {
2100	 _sendLogPayload(abi.encodeWithSignature("log(address,address,string,string)", p0, p1, p2, p3));
2101	 }
2102	 function log(address p0, address p1, string memory p2, bool p3) internal view {
2103	 _sendLogPayload(abi.encodeWithSignature("log(address,address,string,bool)", p0, p1, p2, p3));
2104	 }
2105	 function log(address p0, address p1, string memory p2, address p3) internal view {
2106	 _sendLogPayload(abi.encodeWithSignature("log(address,address,string,address)", p0, p1, p2, p3));
2107	 }
2108	 function log(address p0, address p1, bool p2, uint p3) internal view {
2109	 _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,uint)", p0, p1, p2, p3));
2110	 }
2111	 function log(address p0, address p1, bool p2, string memory p3) internal view {
2112	 _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,string)", p0, p1, p2, p3));
2113	 }
2114	 function log(address p0, address p1, bool p2, bool p3) internal view {
2115	 _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,bool)", p0, p1, p2, p3));
2116	 }
2117	 function log(address p0, address p1, bool p2, address p3) internal view {
2118	 _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,address)", p0, p1, p2, p3));
2119	 }
2120	 function log(address p0, address p1, address p2, uint p3) internal view {
2121	 _sendLogPayload(abi.encodeWithSignature("log(address,address,address,uint)", p0, p1, p2, p3));
2122	 }
2123	 function log(address p0, address p1, address p2, string memory p3) internal view {
2124	 _sendLogPayload(abi.encodeWithSignature("log(address,address,address,string)", p0, p1, p2, p3));
2125	 }
2126	 function log(address p0, address p1, address p2, bool p3) internal view {
2127	 _sendLogPayload(abi.encodeWithSignature("log(address,address,address,bool)", p0, p1, p2, p3));
2128	 }
2129	 function log(address p0, address p1, address p2, address p3) internal view {
2130	 _sendLogPayload(abi.encodeWithSignature("log(address,address,address,address)", p0, p1, p2, p3));
2131	 }
2132	 }
2133	 pragma solidity ^0.8.4;
2134	 library Decimal {
2135	 using SafeMath for uint256;
2136	 uint256 constant BASE_POW = 18;
2137	 uint256 constant BASE = 10**BASE_POW;
2138	 struct D256 {
2139	 uint256 value;
2140	 }
2141	 function one() internal pure returns (D256 memory) {
2142	 return D256({
2143	 value: BASE}
2144	 );
2145	 }
2146	 function onePlus(D256 memory d) internal pure returns (D256 memory) {
2147	 return D256({
2148	 value: d.value.add(BASE)}
2149	 );
2150	 }
2151	 function mul(uint256 target, D256 memory d) internal pure returns (uint256) {
2152	 return Math.getPartial(target, d.value, BASE);
2153	 }
2154	 function div(uint256 target, D256 memory d) internal pure returns (uint256) {
2155	 return Math.getPartial(target, BASE, d.value);
2156	 }
2157	 }
2158	 pragma solidity ^0.8.4;
2159	 library Math {
2160	 using SafeMath for uint256;
2161	 function getPartial( uint256 target, uint256 numerator, uint256 denominator ) internal pure returns (uint256) {
2162	 return target.mul(numerator).div(denominator);
2163	 }
2164	 function getPartialRoundUp( uint256 target, uint256 numerator, uint256 denominator ) internal pure returns (uint256) {
2165	 if (target == 0 || numerator == 0) {
2166	 return SafeMath.div(0, denominator);
2167	 }
2168	 return target.mul(numerator).sub(1).div(denominator).add(1);
2169	 }
2170	 function to128(uint256 number) internal pure returns (uint128) {
2171	 uint128 result = uint128(number);
2172	 require(result == number, "Math: Unsafe cast to uint128");
2173	 return result;
2174	 }
2175	 function to96(uint256 number) internal pure returns (uint96) {
2176	 uint96 result = uint96(number);
2177	 require(result == number, "Math: Unsafe cast to uint96");
2178	 return result;
2179	 }
2180	 function to32(uint256 number) internal pure returns (uint32) {
2181	 uint32 result = uint32(number);
2182	 require(result == number, "Math: Unsafe cast to uint32");
2183	 return result;
2184	 }
2185	 function min(uint256 a, uint256 b) internal pure returns (uint256) {
2186	 return a < b ? a : b;
2187	 }
2188	 function max(uint256 a, uint256 b) internal pure returns (uint256) {
2189	 return a > b ? a : b;
2190	 }
2191	 }
2192	 pragma solidity ^0.8.0;
2193	 interface IERC721Receiver {
2194	 function onERC721Received( address operator, address from, uint256 tokenId, bytes calldata data ) external returns (bytes4);
2195	 }
2196	 pragma solidity ^0.8.1;
2197	 library Address {
2198	 function isContract(address account) internal view returns (bool) {
2199	 return account.code.length > 0;
2200	 }
2201	 function sendValue(address payable recipient, uint256 amount) internal {
2202	 require(address(this).balance >= amount, "Address: insufficient balance");
2203	 (bool success, ) = recipient.call{
2204	 value: amount}
2205	 ("");
2206	 require(success, "Address: unable to send value, recipient may have reverted");
2207	 }
2208	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
2209	 return functionCall(target, data, "Address: low-level call failed");
2210	 }
2211	 function functionCall( address target, bytes memory data, string memory errorMessage ) internal returns (bytes memory) {
2212	 return functionCallWithValue(target, data, 0, errorMessage);
2213	 }
2214	 function functionCallWithValue( address target, bytes memory data, uint256 value ) internal returns (bytes memory) {
2215	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
2216	 }
2217	 function functionCallWithValue( address target, bytes memory data, uint256 value, string memory errorMessage ) internal returns (bytes memory) {
2218	 require(address(this).balance >= value, "Address: insufficient balance for call");
2219	 require(isContract(target), "Address: call to non-contract");
2220	 (bool success, bytes memory returndata) = target.call{
2221	 value: value}
2222	 (data);
2223	 return verifyCallResult(success, returndata, errorMessage);
2224	 }
2225	 function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
2226	 return functionStaticCall(target, data, "Address: low-level static call failed");
2227	 }
2228	 function functionStaticCall( address target, bytes memory data, string memory errorMessage ) internal view returns (bytes memory) {
2229	 require(isContract(target), "Address: static call to non-contract");
2230	 (bool success, bytes memory returndata) = target.staticcall(data);
2231	 return verifyCallResult(success, returndata, errorMessage);
2232	 }
2233	 function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
2234	 return functionDelegateCall(target, data, "Address: low-level delegate call failed");
2235	 }
2236	 function functionDelegateCall( address target, bytes memory data, string memory errorMessage ) internal returns (bytes memory) {
2237	 require(isContract(target), "Address: delegate call to non-contract");
2238	 (bool success, bytes memory returndata) = target.delegatecall(data);
2239	 return verifyCallResult(success, returndata, errorMessage);
2240	 }
2241	 function verifyCallResult( bool success, bytes memory returndata, string memory errorMessage ) internal pure returns (bytes memory) {
2242	 if (success) {
2243	 return returndata;
2244	 }
2245	 else {
2246	 if (returndata.length > 0) {
2247	 assembly {
2248	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
2249	 }
2250	 else {
2251	 revert(errorMessage);
2252	 }
2253	 }
2254	 }
2255	 }
2256	 pragma solidity ^0.8.0;
2257	 library Strings {
2258	 bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";
2259	 function toString(uint256 value) internal pure returns (string memory) {
2260	 if (value == 0) {
2261	 return "0";
2262	 }
2263	 uint256 temp = value;
2264	 uint256 digits;
2265	 while (temp != 0) {
2266	 digits++;
2267	 temp /= 10;
2268	 }
2269	 bytes memory buffer = new bytes(digits);
2270	 while (value != 0) {
2271	 digits -= 1;
2272	 buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
2273	 value /= 10;
2274	 }
2275	 return string(buffer);
2276	 }
2277	 function toHexString(uint256 value) internal pure returns (string memory) {
2278	 if (value == 0) {
2279	 return "0x00";
2280	 }
2281	 uint256 temp = value;
2282	 uint256 length = 0;
2283	 while (temp != 0) {
2284	 length++;
2285	 temp >>= 8;
2286	 }
2287	 return toHexString(value, length);
2288	 }
2289	 function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
2290	 bytes memory buffer = new bytes(2 * length + 2);
2291	 buffer[0] = "0";
2292	 buffer[1] = "x";
2293	 for (uint256 i = 2 * length + 1; i > 1; --i) {
2294	 buffer[i] = _HEX_SYMBOLS[value & 0xf];
2295	 value >>= 4;
2296	 }
2297	 require(value == 0, "Strings: hex length insufficient");
2298	 return string(buffer);
2299	 }
2300	 }
