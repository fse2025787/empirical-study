row number 
1	  pragma abicoder v2;
2	 pragma solidity 0.7.6;
3	 interface IERC20 {
4	 event Approval(address indexed owner, address indexed spender, uint256 value);
5	 event Transfer(address indexed from, address indexed to, uint256 value);
6	 function name() external view returns (string memory);
7	 function symbol() external view returns (string memory);
8	 function decimals() external view returns (uint8);
9	 function totalSupply() external view returns (uint256);
10	 function balanceOf(address owner) external view returns (uint256);
11	 function allowance(address owner, address spender) external view returns (uint256);
12	 function approve(address spender, uint256 value) external returns (bool);
13	 function transfer(address to, uint256 value) external returns (bool);
14	 function transferFrom( address from, address to, uint256 value ) external returns (bool);
15	 }
16	 pragma solidity 0.7.6;
17	 interface ITwapRelayer {
18	 event OwnerSet(address owner);
19	 event DelaySet(address delay);
20	 event PairEnabledSet(address pair, bool enabled);
21	 event SwapFeeSet(address pair, uint256 fee);
22	 event TwapIntervalSet(address pair, uint32 interval);
23	 event EthTransferGasCostSet(uint256 gasCost);
24	 event ExecutionGasLimitSet(uint256 limit);
25	 event GasPriceMultiplierSet(uint256 multiplier);
26	 event TokenLimitMinSet(address token, uint256 limit);
27	 event TokenLimitMaxMultiplierSet(address token, uint256 limit);
28	 event ToleranceSet(address pair, uint16 tolerance);
29	 event Approve(address token, address to, uint256 amount);
30	 event Withdraw(address token, address to, uint256 amount);
31	 event Swap( address indexed sender, address tokenIn, address tokenOut, uint256 amountIn, uint256 amountOut, bool wrapUnwrap, uint256 fee, address indexed to, uint256 indexed orderId );
32	 function factory() external view returns (address);
33	 function delay() external view returns (address);
34	 function setDelay(address _delay) external;
35	 function weth() external view returns (address);
36	 function owner() external view returns (address);
37	 function setOwner(address _owner) external;
38	 function swapFee(address pair) external view returns (uint256);
39	 function setSwapFee(address pair, uint256 fee) external;
40	 function twapInterval(address pair) external view returns (uint32);
41	 function setTwapInterval(address pair, uint32 _interval) external;
42	 function isPairEnabled(address pair) external view returns (bool);
43	 function setPairEnabled(address pair, bool enabled) external;
44	 function ethTransferGasCost() external view returns (uint256);
45	 function setEthTransferGasCost(uint256 gasCost) external;
46	 function executionGasLimit() external view returns (uint256);
47	 function setExecutionGasLimit(uint256 limit) external;
48	 function gasPriceMultiplier() external view returns (uint256);
49	 function setGasPriceMultiplier(uint256 multiplier) external;
50	 function tokenLimitMin(address token) external view returns (uint256);
51	 function setTokenLimitMin(address token, uint256 limit) external;
52	 function tokenLimitMaxMultiplier(address token) external view returns (uint256);
53	 function setTokenLimitMaxMultiplier(address token, uint256 multiplier) external;
54	 function tolerance(address pair) external view returns (uint16);
55	 function setTolerance(address pair, uint16 _tolerance) external;
56	 struct SellParams {
57	 address tokenIn;
58	 address tokenOut;
59	 uint256 amountIn;
60	 uint256 amountOutMin;
61	 bool wrapUnwrap;
62	 address to;
63	 uint32 submitDeadline;
64	 }
65	 function sell(SellParams memory sellParams) external payable returns (uint256 orderId);
66	 struct BuyParams {
67	 address tokenIn;
68	 address tokenOut;
69	 uint256 amountInMax;
70	 uint256 amountOut;
71	 bool wrapUnwrap;
72	 address to;
73	 uint32 submitDeadline;
74	 }
75	 function buy(BuyParams memory buyParams) external payable returns (uint256 orderId);
76	 function getPriceByPairAddress(address pair, bool inverted) external view returns ( uint8 xDecimals, uint8 yDecimals, uint256 price );
77	 function getPriceByTokenAddresses(address tokenIn, address tokenOut) external view returns (uint256 price);
78	 function getPoolState(address token0, address token1) external view returns ( uint256 price, uint256 fee, uint256 limitMin0, uint256 limitMax0, uint256 limitMin1, uint256 limitMax1 );
79	 function quoteSell( address tokenIn, address tokenOut, uint256 amountIn ) external view returns (uint256 amountOut);
80	 function quoteBuy( address tokenIn, address tokenOut, uint256 amountOut ) external view returns (uint256 amountIn);
81	 function approve( address token, uint256 amount, address to ) external;
82	 function withdraw( address token, uint256 amount, address to ) external;
83	 }
84	 pragma solidity 0.7.6;
85	 interface ITwapOracle {
86	 event OwnerSet(address owner);
87	 event UniswapPairSet(address uniswapPair);
88	 function decimalsConverter() external view returns (int256);
89	 function xDecimals() external view returns (uint8);
90	 function yDecimals() external view returns (uint8);
91	 function owner() external view returns (address);
92	 function uniswapPair() external view returns (address);
93	 function getPriceInfo() external view returns (uint256 priceAccumulator, uint32 priceTimestamp);
94	 function getSpotPrice() external view returns (uint256);
95	 function getAveragePrice(uint256 priceAccumulator, uint32 priceTimestamp) external view returns (uint256);
96	 function setOwner(address _owner) external;
97	 function setUniswapPair(address _uniswapPair) external;
98	 function tradeX( uint256 xAfter, uint256 xBefore, uint256 yBefore, bytes calldata data ) external view returns (uint256 yAfter);
99	 function tradeY( uint256 yAfter, uint256 yBefore, uint256 xBefore, bytes calldata data ) external view returns (uint256 xAfter);
100	 function depositTradeXIn( uint256 xLeft, uint256 xBefore, uint256 yBefore, bytes calldata data ) external view returns (uint256 xIn);
101	 function depositTradeYIn( uint256 yLeft, uint256 yBefore, uint256 xBefore, bytes calldata data ) external view returns (uint256 yIn);
102	 function getSwapAmount0Out( uint256 swapFee, uint256 amount1In, bytes calldata data ) external view returns (uint256 amount0Out);
103	 function getSwapAmount1Out( uint256 swapFee, uint256 amount0In, bytes calldata data ) external view returns (uint256 amount1Out);
104	 function getSwapAmountInMaxOut( bool inverse, uint256 swapFee, uint256 _amountOut, bytes calldata data ) external view returns (uint256 amountIn, uint256 amountOut);
105	 function getSwapAmountInMinOut( bool inverse, uint256 swapFee, uint256 _amountOut, bytes calldata data ) external view returns (uint256 amountIn, uint256 amountOut);
106	 }
107	 pragma solidity 0.7.6;
108	 interface ITwapERC20 is IERC20 {
109	 function PERMIT_TYPEHASH() external pure returns (bytes32);
110	 function nonces(address owner) external view returns (uint256);
111	 function permit( address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s ) external;
112	 function increaseAllowance(address spender, uint256 addedValue) external returns (bool);
113	 function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);
114	 }
115	 pragma solidity 0.7.6;
116	 interface IReserves {
117	 function getReserves() external view returns (uint112 reserve0, uint112 reserve1);
118	 function getFees() external view returns (uint256 fee0, uint256 fee1);
119	 }
120	 pragma solidity >=0.5.0;
121	 interface IUniswapV3PoolImmutables {
122	 function factory() external view returns (address);
123	 function token0() external view returns (address);
124	 function token1() external view returns (address);
125	 function fee() external view returns (uint24);
126	 function tickSpacing() external view returns (int24);
127	 function maxLiquidityPerTick() external view returns (uint128);
128	 }
129	 pragma solidity >=0.5.0;
130	 interface IUniswapV3PoolState {
131	 function slot0() external view returns ( uint160 sqrtPriceX96, int24 tick, uint16 observationIndex, uint16 observationCardinality, uint16 observationCardinalityNext, uint8 feeProtocol, bool unlocked );
132	 function feeGrowthGlobal0X128() external view returns (uint256);
133	 function feeGrowthGlobal1X128() external view returns (uint256);
134	 function protocolFees() external view returns (uint128 token0, uint128 token1);
135	 function liquidity() external view returns (uint128);
136	 function ticks(int24 tick) external view returns ( uint128 liquidityGross, int128 liquidityNet, uint256 feeGrowthOutside0X128, uint256 feeGrowthOutside1X128, int56 tickCumulativeOutside, uint160 secondsPerLiquidityOutsideX128, uint32 secondsOutside, bool initialized );
137	 function tickBitmap(int16 wordPosition) external view returns (uint256);
138	 function positions(bytes32 key) external view returns ( uint128 _liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, uint128 tokensOwed0, uint128 tokensOwed1 );
139	 function observations(uint256 index) external view returns ( uint32 blockTimestamp, int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128, bool initialized );
140	 }
141	 pragma solidity >=0.5.0;
142	 interface IUniswapV3PoolDerivedState {
143	 function observe(uint32[] calldata secondsAgos) external view returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);
144	 function snapshotCumulativesInside(int24 tickLower, int24 tickUpper) external view returns ( int56 tickCumulativeInside, uint160 secondsPerLiquidityInsideX128, uint32 secondsInside );
145	 }
146	 pragma solidity >=0.5.0;
147	 interface IUniswapV3PoolActions {
148	 function initialize(uint160 sqrtPriceX96) external;
149	 function mint( address recipient, int24 tickLower, int24 tickUpper, uint128 amount, bytes calldata data ) external returns (uint256 amount0, uint256 amount1);
150	 function collect( address recipient, int24 tickLower, int24 tickUpper, uint128 amount0Requested, uint128 amount1Requested ) external returns (uint128 amount0, uint128 amount1);
151	 function burn( int24 tickLower, int24 tickUpper, uint128 amount ) external returns (uint256 amount0, uint256 amount1);
152	 function swap( address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes calldata data ) external returns (int256 amount0, int256 amount1);
153	 function flash( address recipient, uint256 amount0, uint256 amount1, bytes calldata data ) external;
154	 function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;
155	 }
156	 pragma solidity >=0.5.0;
157	 interface IUniswapV3PoolEvents {
158	 event Initialize(uint160 sqrtPriceX96, int24 tick);
159	 event Mint( address sender, address indexed owner, int24 indexed tickLower, int24 indexed tickUpper, uint128 amount, uint256 amount0, uint256 amount1 );
160	 event Collect( address indexed owner, address recipient, int24 indexed tickLower, int24 indexed tickUpper, uint128 amount0, uint128 amount1 );
161	 event Burn( address indexed owner, int24 indexed tickLower, int24 indexed tickUpper, uint128 amount, uint256 amount0, uint256 amount1 );
162	 event Swap( address indexed sender, address indexed recipient, int256 amount0, int256 amount1, uint160 sqrtPriceX96, uint128 liquidity, int24 tick );
163	 event Flash( address indexed sender, address indexed recipient, uint256 amount0, uint256 amount1, uint256 paid0, uint256 paid1 );
164	 event IncreaseObservationCardinalityNext( uint16 observationCardinalityNextOld, uint16 observationCardinalityNextNew );
165	 event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);
166	 event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);
167	 }
168	 pragma solidity >=0.5.0;
169	 interface IUniswapV3PoolOwnerActions {
170	 function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;
171	 function collectProtocol( address recipient, uint128 amount0Requested, uint128 amount1Requested ) external returns (uint128 amount0, uint128 amount1);
172	 }
173	 pragma solidity 0.7.6;
174	 contract TwapRelayer is ITwapRelayer {
175	 using SafeMath for uint256;
176	 uint256 private constant PRECISION = 10**18;
177	 uint16 private constant MAX_TOLERANCE = 10;
178	 address public immutable override factory;
179	 address public immutable override weth;
180	 address public override delay;
181	 address public override owner;
182	 mapping(address => uint256) public override swapFee;
183	 mapping(address => uint32) public override twapInterval;
184	 mapping(address => bool) public override isPairEnabled;
185	 mapping(address => uint256) public override tokenLimitMin;
186	 mapping(address => uint256) public override tokenLimitMaxMultiplier;
187	 mapping(address => uint16) public override tolerance;
188	 uint256 public override ethTransferGasCost;
189	 uint256 public override executionGasLimit;
190	 uint256 public override gasPriceMultiplier;
191	 constructor( address _factory, address _delay, address _weth ) {
192	 factory = _factory;
193	 delay = _delay;
194	 weth = _weth;
195	 owner = msg.sender;
196	 ethTransferGasCost = 2600 + 1504;
197	 emit DelaySet(_delay);
198	 emit OwnerSet(msg.sender);
199	 emit EthTransferGasCostSet(ethTransferGasCost);
200	 }
201	 uint256 private locked;
202	 modifier lock() {
203	 require(locked == 0, 'TR06');
204	 locked = 1;
205	 _;
206	 locked = 0;
207	 }
208	 function setDelay(address _delay) external override {
209	 require(msg.sender == owner, 'TR00');
210	 require(_delay != delay, 'TR01');
211	 require(_delay != address(0), 'TR02');
212	 delay = _delay;
213	 emit DelaySet(_delay);
214	 }
215	 function setOwner(address _owner) external override {
216	 require(msg.sender == owner, 'TR00');
217	 require(_owner != owner, 'TR01');
218	 require(_owner != address(0), 'TR02');
219	 owner = _owner;
220	 emit OwnerSet(_owner);
221	 }
222	 function setSwapFee(address pair, uint256 fee) external override {
223	 require(msg.sender == owner, 'TR00');
224	 require(fee != swapFee[pair], 'TR01');
225	 swapFee[pair] = fee;
226	 emit SwapFeeSet(pair, fee);
227	 }
228	 function setTwapInterval(address pair, uint32 interval) external override {
229	 require(msg.sender == owner, 'TR00');
230	 require(interval != twapInterval[pair], 'TR01');
231	 require(interval > 0, 'TR56');
232	 twapInterval[pair] = interval;
233	 emit TwapIntervalSet(pair, interval);
234	 }
235	 function setPairEnabled(address pair, bool enabled) external override {
236	 require(msg.sender == owner, 'TR00');
237	 require(enabled != isPairEnabled[pair], 'TR01');
238	 isPairEnabled[pair] = enabled;
239	 emit PairEnabledSet(pair, enabled);
240	 }
241	 function setEthTransferGasCost(uint256 gasCost) external override {
242	 require(msg.sender == owner, 'TR00');
243	 require(gasCost != ethTransferGasCost, 'TR01');
244	 ethTransferGasCost = gasCost;
245	 emit EthTransferGasCostSet(gasCost);
246	 }
247	 function setExecutionGasLimit(uint256 limit) external override {
248	 require(msg.sender == owner, 'TR00');
249	 require(limit != executionGasLimit, 'TR01');
250	 executionGasLimit = limit;
251	 emit ExecutionGasLimitSet(limit);
252	 }
253	 function setGasPriceMultiplier(uint256 multiplier) external override {
254	 require(msg.sender == owner, 'TR00');
255	 require(multiplier != gasPriceMultiplier, 'TR01');
256	 gasPriceMultiplier = multiplier;
257	 emit GasPriceMultiplierSet(multiplier);
258	 }
259	 function setTokenLimitMin(address token, uint256 limit) external override {
260	 require(msg.sender == owner, 'TR00');
261	 require(limit != tokenLimitMin[token], 'TR01');
262	 tokenLimitMin[token] = limit;
263	 emit TokenLimitMinSet(token, limit);
264	 }
265	 function setTokenLimitMaxMultiplier(address token, uint256 multiplier) external override {
266	 require(msg.sender == owner, 'TR00');
267	 require(multiplier != tokenLimitMaxMultiplier[token], 'TR01');
268	 require(multiplier <= PRECISION, 'TR3A');
269	 tokenLimitMaxMultiplier[token] = multiplier;
270	 emit TokenLimitMaxMultiplierSet(token, multiplier);
271	 }
272	 function setTolerance(address pair, uint16 _tolerance) external override {
273	 require(msg.sender == owner, 'TR00');
274	 require(_tolerance != tolerance[pair], 'TR01');
275	 require(_tolerance <= MAX_TOLERANCE, 'TR54');
276	 tolerance[pair] = _tolerance;
277	 emit ToleranceSet(pair, _tolerance);
278	 }
279	 function sell(SellParams calldata sellParams) external payable override lock returns (uint256 orderId) {
280	 require( sellParams.to != sellParams.tokenIn && sellParams.to != sellParams.tokenOut && sellParams.to != address(0), 'TR26' );
281	 if (sellParams.wrapUnwrap && sellParams.tokenIn == weth) {
282	 require(msg.value == sellParams.amountIn, 'TR59');
283	 }
284	 else {
285	 require(msg.value == 0, 'TR58');
286	 }
287	 (address pair, bool inverted) = getPair(sellParams.tokenIn, sellParams.tokenOut);
288	 require(isPairEnabled[pair], 'TR5A');
289	 (uint256 amountIn, uint256 amountOut, uint256 fee) = swapExactIn( pair, inverted, sellParams.tokenIn, sellParams.tokenOut, sellParams.amountIn, sellParams.wrapUnwrap, sellParams.to );
290	 require(amountOut >= sellParams.amountOutMin, 'TR37');
291	 orderId = ITwapDelay(delay).sell{
292	 value: calculatePrepay() }
293	 ( Orders.SellParams( sellParams.tokenIn, sellParams.tokenOut, amountIn, 0, false, address(this), executionGasLimit, sellParams.submitDeadline ) );
294	 emit Swap( msg.sender, sellParams.tokenIn, sellParams.tokenOut, amountIn, amountOut, sellParams.wrapUnwrap, fee, sellParams.to, orderId );
295	 }
296	 function buy(BuyParams calldata buyParams) external payable override lock returns (uint256 orderId) {
297	 require( buyParams.to != buyParams.tokenIn && buyParams.to != buyParams.tokenOut && buyParams.to != address(0), 'TR26' );
298	 if (!buyParams.wrapUnwrap || buyParams.tokenIn != weth) {
299	 require(msg.value == 0, 'TR58');
300	 }
301	 (address pair, bool inverted) = getPair(buyParams.tokenIn, buyParams.tokenOut);
302	 require(isPairEnabled[pair], 'TR5A');
303	 uint256 balanceBefore = address(this).balance.sub(msg.value);
304	 (uint256 amountIn, uint256 amountOut, uint256 fee) = swapExactOut( pair, inverted, buyParams.tokenIn, buyParams.tokenOut, buyParams.amountOut, buyParams.wrapUnwrap, buyParams.to );
305	 require(amountIn <= buyParams.amountInMax, 'TR08');
306	 orderId = ITwapDelay(delay).sell{
307	 value: calculatePrepay() }
308	 ( Orders.SellParams( buyParams.tokenIn, buyParams.tokenOut, amountIn, 0, false, address(this), executionGasLimit, buyParams.submitDeadline ) );
309	 emit Swap( msg.sender, buyParams.tokenIn, buyParams.tokenOut, amountIn, amountOut, buyParams.wrapUnwrap, fee, buyParams.to, orderId );
310	 if (buyParams.wrapUnwrap && buyParams.tokenIn == weth) {
311	 uint256 balanceAfter = address(this).balance;
312	 if (balanceAfter > balanceBefore) {
313	 TransferHelper.safeTransferETH(msg.sender, balanceAfter.sub(balanceBefore), ethTransferGasCost);
314	 }
315	 }
316	 }
317	 function getPair(address tokenA, address tokenB) internal view returns (address pair, bool inverted) {
318	 inverted = tokenA > tokenB;
319	 pair = ITwapFactory(factory).getPair(tokenA, tokenB);
320	 require(pair != address(0), 'TR17');
321	 }
322	 function calculatePrepay() internal returns (uint256) {
323	 require(executionGasLimit > 0, 'TR3D');
324	 require(gasPriceMultiplier > 0, 'TR3C');
325	 return ITwapDelay(delay).gasPrice().mul(gasPriceMultiplier).mul(executionGasLimit).div(PRECISION);
326	 }
327	 function swapExactIn( address pair, bool inverted, address tokenIn, address tokenOut, uint256 amountIn, bool wrapUnwrap, address to ) internal returns ( uint256 _amountIn, uint256 _amountOut, uint256 fee ) {
328	 _amountIn = transferIn(tokenIn, amountIn, wrapUnwrap);
329	 fee = _amountIn.mul(swapFee[pair]).div(PRECISION);
330	 uint256 amountInMinusFee = _amountIn.sub(fee);
331	 uint256 calculatedAmountOut = calculateAmountOut(pair, inverted, amountInMinusFee);
332	 _amountOut = transferOut(to, tokenOut, calculatedAmountOut, wrapUnwrap);
333	 require(_amountOut <= calculatedAmountOut.add(tolerance[pair]), 'TR2E');
334	 }
335	 function swapExactOut( address pair, bool inverted, address tokenIn, address tokenOut, uint256 amountOut, bool wrapUnwrap, address to ) internal returns ( uint256 _amountIn, uint256 _amountOut, uint256 fee ) {
336	 _amountOut = transferOut(to, tokenOut, amountOut, wrapUnwrap);
337	 uint256 calculatedAmountIn = calculateAmountIn(pair, inverted, _amountOut);
338	 uint256 amountInPlusFee = calculatedAmountIn.mul(PRECISION).ceil_div(PRECISION.sub(swapFee[pair]));
339	 fee = amountInPlusFee.sub(calculatedAmountIn);
340	 _amountIn = transferIn(tokenIn, amountInPlusFee, wrapUnwrap);
341	 require(_amountIn >= amountInPlusFee.sub(tolerance[pair]), 'TR2E');
342	 }
343	 function calculateAmountIn( address pair, bool inverted, uint256 amountOut ) internal view returns (uint256 amountIn) {
344	 (uint8 xDecimals, uint8 yDecimals, uint256 price) = getPriceByPairAddress(pair, inverted);
345	 uint256 decimalsConverter = getDecimalsConverter(xDecimals, yDecimals, inverted);
346	 amountIn = amountOut.mul(decimalsConverter).ceil_div(price);
347	 }
348	 function calculateAmountOut( address pair, bool inverted, uint256 amountIn ) internal view returns (uint256 amountOut) {
349	 (uint8 xDecimals, uint8 yDecimals, uint256 price) = getPriceByPairAddress(pair, inverted);
350	 uint256 decimalsConverter = getDecimalsConverter(xDecimals, yDecimals, inverted);
351	 amountOut = amountIn.mul(price).div(decimalsConverter);
352	 }
353	 function getDecimalsConverter( uint8 xDecimals, uint8 yDecimals, bool inverted ) internal pure returns (uint256 decimalsConverter) {
354	 decimalsConverter = 10**(18 + (inverted ? yDecimals - xDecimals : xDecimals - yDecimals));
355	 }
356	 function getPriceByPairAddress(address pair, bool inverted) public view override returns ( uint8 xDecimals, uint8 yDecimals, uint256 price ) {
357	 uint256 spotPrice;
358	 uint256 averagePrice;
359	 (spotPrice, averagePrice, xDecimals, yDecimals) = getPricesFromOracle(pair);
360	 if (inverted) {
361	 price = uint256(10**36).div(spotPrice > averagePrice ? spotPrice : averagePrice);
362	 }
363	 else {
364	 price = spotPrice < averagePrice ? spotPrice : averagePrice;
365	 }
366	 }
367	 function getPriceByTokenAddresses(address tokenIn, address tokenOut) public view override returns (uint256 price) {
368	 (address pair, bool inverted) = getPair(tokenIn, tokenOut);
369	 (, , price) = getPriceByPairAddress(pair, inverted);
370	 }
371	 function getPoolState(address token0, address token1) external view override returns ( uint256 price, uint256 fee, uint256 limitMin0, uint256 limitMax0, uint256 limitMin1, uint256 limitMax1 ) {
372	 (address pair, ) = getPair(token0, token1);
373	 require(isPairEnabled[pair], 'TR5A');
374	 fee = swapFee[pair];
375	 price = getPriceByTokenAddresses(token0, token1);
376	 limitMin0 = tokenLimitMin[token0];
377	 limitMax0 = IERC20(token0).balanceOf(address(this)).mul(tokenLimitMaxMultiplier[token0]).div(PRECISION);
378	 limitMin1 = tokenLimitMin[token1];
379	 limitMax1 = IERC20(token1).balanceOf(address(this)).mul(tokenLimitMaxMultiplier[token1]).div(PRECISION);
380	 }
381	 function quoteSell( address tokenIn, address tokenOut, uint256 amountIn ) external view override returns (uint256 amountOut) {
382	 require(amountIn > 0, 'TR24');
383	 (address pair, bool inverted) = getPair(tokenIn, tokenOut);
384	 uint256 fee = amountIn.mul(swapFee[pair]).div(PRECISION);
385	 uint256 amountInMinusFee = amountIn.sub(fee);
386	 amountOut = calculateAmountOut(pair, inverted, amountInMinusFee);
387	 checkLimits(tokenOut, amountOut);
388	 }
389	 function quoteBuy( address tokenIn, address tokenOut, uint256 amountOut ) external view override returns (uint256 amountIn) {
390	 require(amountOut > 0, 'TR23');
391	 (address pair, bool inverted) = getPair(tokenIn, tokenOut);
392	 checkLimits(tokenOut, amountOut);
393	 uint256 calculatedAmountIn = calculateAmountIn(pair, inverted, amountOut);
394	 amountIn = calculatedAmountIn.mul(PRECISION).ceil_div(PRECISION.sub(swapFee[pair]));
395	 }
396	 function getPricesFromOracle(address pair) internal view returns ( uint256 spotPrice, uint256 averagePrice, uint8 xDecimals, uint8 yDecimals ) {
397	 ITwapOracleV3 oracle = ITwapOracleV3(ITwapPair(pair).oracle());
398	 xDecimals = oracle.xDecimals();
399	 yDecimals = oracle.yDecimals();
400	 spotPrice = oracle.getSpotPrice();
401	 address uniswapPair = oracle.uniswapPair();
402	 averagePrice = getAveragePrice(pair, uniswapPair, getDecimalsConverter(xDecimals, yDecimals, false));
403	 }
404	 function getAveragePrice( address pair, address uniswapPair, uint256 decimalsConverter ) internal view returns (uint256) {
405	 uint32 secondsAgo = twapInterval[pair];
406	 require(secondsAgo > 0, 'TR55');
407	 uint32[] memory secondsAgos = new uint32[](2);
408	 secondsAgos[0] = secondsAgo;
409	 secondsAgos[1] = 0;
410	 (int56[] memory tickCumulatives, ) = IUniswapV3Pool(uniswapPair).observe(secondsAgos);
411	 int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];
412	 int24 arithmeticMeanTick = int24(tickCumulativesDelta / secondsAgo);
413	 if (tickCumulativesDelta < 0 && (tickCumulativesDelta % secondsAgo != 0)) arithmeticMeanTick--;
414	 uint160 sqrtRatioX96 = TickMath.getSqrtRatioAtTick(arithmeticMeanTick);
415	 if (sqrtRatioX96 <= type(uint128).max) {
416	 uint256 ratioX192 = uint256(sqrtRatioX96) * sqrtRatioX96;
417	 return FullMath.mulDiv(ratioX192, decimalsConverter, 1 << 192);
418	 }
419	 else {
420	 uint256 ratioX128 = FullMath.mulDiv(sqrtRatioX96, sqrtRatioX96, 1 << 64);
421	 return FullMath.mulDiv(ratioX128, decimalsConverter, 1 << 128);
422	 }
423	 }
424	 function transferIn( address token, uint256 amount, bool wrap ) internal returns (uint256) {
425	 if (amount == 0) {
426	 return 0;
427	 }
428	 if (token == weth) {
429	 if (wrap) {
430	 require(msg.value >= amount, 'TR03');
431	 IWETH(token).deposit{
432	 value: amount }
433	 ();
434	 }
435	 else {
436	 TransferHelper.safeTransferFrom(token, msg.sender, address(this), amount);
437	 }
438	 return amount;
439	 }
440	 else {
441	 uint256 balanceBefore = IERC20(token).balanceOf(address(this));
442	 TransferHelper.safeTransferFrom(token, msg.sender, address(this), amount);
443	 uint256 balanceAfter = IERC20(token).balanceOf(address(this));
444	 require(balanceAfter > balanceBefore, 'TR2C');
445	 return balanceAfter.sub(balanceBefore);
446	 }
447	 }
448	 function transferOut( address to, address token, uint256 amount, bool unwrap ) internal returns (uint256) {
449	 if (amount == 0) {
450	 return 0;
451	 }
452	 checkLimits(token, amount);
453	 if (token == weth) {
454	 if (unwrap) {
455	 IWETH(token).withdraw(amount);
456	 TransferHelper.safeTransferETH(to, amount, ethTransferGasCost);
457	 }
458	 else {
459	 TransferHelper.safeTransfer(token, to, amount);
460	 }
461	 return amount;
462	 }
463	 else {
464	 uint256 balanceBefore = IERC20(token).balanceOf(address(this));
465	 TransferHelper.safeTransfer(token, to, amount);
466	 uint256 balanceAfter = IERC20(token).balanceOf(address(this));
467	 require(balanceBefore > balanceAfter, 'TR2C');
468	 return balanceBefore.sub(balanceAfter);
469	 }
470	 }
471	 function checkLimits(address token, uint256 amount) internal view {
472	 require(amount >= tokenLimitMin[token], 'TR03');
473	 require( amount <= IERC20(token).balanceOf(address(this)).mul(tokenLimitMaxMultiplier[token]).div(PRECISION), 'TR3A' );
474	 }
475	 function approve( address token, uint256 amount, address to ) external override lock {
476	 require(msg.sender == owner, 'TR00');
477	 require(to != address(0), 'TR02');
478	 require(IERC20(token).approve(to, amount), 'TR2F');
479	 emit Approve(token, to, amount);
480	 }
481	 function withdraw( address token, uint256 amount, address to ) external override lock {
482	 require(msg.sender == owner, 'TR00');
483	 require(to != address(0), 'TR02');
484	 if (token == address(0)) {
485	 TransferHelper.safeTransferETH(to, amount, ethTransferGasCost);
486	 }
487	 else {
488	 TransferHelper.safeTransfer(token, to, amount);
489	 }
490	 emit Withdraw(token, to, amount);
491	 }
492	 receive() external payable {
493	 }
494	 }
495	 pragma solidity 0.7.6;
496	 interface ITwapDelay {
497	 event OrderExecuted(uint256 indexed id, bool indexed success, bytes data, uint256 gasSpent, uint256 ethRefunded);
498	 event RefundFailed(address indexed to, address indexed token, uint256 amount, bytes data);
499	 event EthRefund(address indexed to, bool indexed success, uint256 value);
500	 event OwnerSet(address owner);
501	 event BotSet(address bot, bool isBot);
502	 event DelaySet(uint256 delay);
503	 event MaxGasLimitSet(uint256 maxGasLimit);
504	 event GasPriceInertiaSet(uint256 gasPriceInertia);
505	 event MaxGasPriceImpactSet(uint256 maxGasPriceImpact);
506	 event TransferGasCostSet(address token, uint256 gasCost);
507	 event ToleranceSet(address pair, uint16 amount);
508	 event OrderDisabled(address pair, Orders.OrderType orderType, bool disabled);
509	 event UnwrapFailed(address to, uint256 amount);
510	 event Execute(address sender, uint256 n);
511	 function factory() external returns (address);
512	 function owner() external returns (address);
513	 function isBot(address bot) external returns (bool);
514	 function tolerance(address pair) external returns (uint16);
515	 function gasPriceInertia() external returns (uint256);
516	 function gasPrice() external returns (uint256);
517	 function maxGasPriceImpact() external returns (uint256);
518	 function maxGasLimit() external returns (uint256);
519	 function delay() external returns (uint32);
520	 function totalShares(address token) external returns (uint256);
521	 function weth() external returns (address);
522	 function getTransferGasCost(address token) external returns (uint256);
523	 function getDepositOrder(uint256 orderId) external returns (Orders.DepositOrder memory order);
524	 function getWithdrawOrder(uint256 orderId) external returns (Orders.WithdrawOrder memory order);
525	 function getSellOrder(uint256 orderId) external returns (Orders.SellOrder memory order);
526	 function getBuyOrder(uint256 orderId) external returns (Orders.BuyOrder memory order);
527	 function getDepositDisabled(address pair) external returns (bool);
528	 function getWithdrawDisabled(address pair) external returns (bool);
529	 function getBuyDisabled(address pair) external returns (bool);
530	 function getSellDisabled(address pair) external returns (bool);
531	 function getOrderStatus(uint256 orderId) external view returns (Orders.OrderStatus);
532	 function setOrderDisabled( address pair, Orders.OrderType orderType, bool disabled ) external payable;
533	 function setOwner(address _owner) external payable;
534	 function setBot(address _bot, bool _isBot) external payable;
535	 function setMaxGasLimit(uint256 _maxGasLimit) external payable;
536	 function setDelay(uint32 _delay) external payable;
537	 function setGasPriceInertia(uint256 _gasPriceInertia) external payable;
538	 function setMaxGasPriceImpact(uint256 _maxGasPriceImpact) external payable;
539	 function setTransferGasCost(address token, uint256 gasCost) external payable;
540	 function setTolerance(address pair, uint16 amount) external payable;
541	 function deposit(Orders.DepositParams memory depositParams) external payable returns (uint256 orderId);
542	 function withdraw(Orders.WithdrawParams memory withdrawParams) external payable returns (uint256 orderId);
543	 function sell(Orders.SellParams memory sellParams) external payable returns (uint256 orderId);
544	 function buy(Orders.BuyParams memory buyParams) external payable returns (uint256 orderId);
545	 function execute(uint256 n) external payable;
546	 function retryRefund(uint256 orderId) external;
547	 function cancelOrder(uint256 orderId) external;
548	 }
549	 pragma solidity 0.7.6;
550	 interface ITwapOracleV3 is ITwapOracle {
551	 event TwapIntervalSet(uint32 interval);
552	 function setTwapInterval(uint32 _interval) external;
553	 }
554	 pragma solidity 0.7.6;
555	 interface ITwapPair is ITwapERC20, IReserves {
556	 event Mint(address indexed sender, uint256 amount0In, uint256 amount1In, uint256 liquidityOut, address indexed to);
557	 event Burn(address indexed sender, uint256 amount0Out, uint256 amount1Out, uint256 liquidityIn, address indexed to);
558	 event Swap( address indexed sender, uint256 amount0In, uint256 amount1In, uint256 amount0Out, uint256 amount1Out, address indexed to );
559	 event SetMintFee(uint256 fee);
560	 event SetBurnFee(uint256 fee);
561	 event SetSwapFee(uint256 fee);
562	 event SetOracle(address account);
563	 event SetTrader(address trader);
564	 function MINIMUM_LIQUIDITY() external pure returns (uint256);
565	 function factory() external view returns (address);
566	 function token0() external view returns (address);
567	 function token1() external view returns (address);
568	 function oracle() external view returns (address);
569	 function trader() external view returns (address);
570	 function mintFee() external view returns (uint256);
571	 function setMintFee(uint256 fee) external;
572	 function mint(address to) external returns (uint256 liquidity);
573	 function burnFee() external view returns (uint256);
574	 function setBurnFee(uint256 fee) external;
575	 function burn(address to) external returns (uint256 amount0, uint256 amount1);
576	 function swapFee() external view returns (uint256);
577	 function setSwapFee(uint256 fee) external;
578	 function setOracle(address account) external;
579	 function setTrader(address account) external;
580	 function collect(address to) external;
581	 function swap( uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data ) external;
582	 function sync() external;
583	 function initialize( address _token0, address _token1, address _oracle, address _trader ) external;
584	 function getSwapAmount0In(uint256 amount1Out, bytes calldata data) external view returns (uint256 swapAmount0In);
585	 function getSwapAmount1In(uint256 amount0Out, bytes calldata data) external view returns (uint256 swapAmount1In);
586	 function getSwapAmount0Out(uint256 amount1In, bytes calldata data) external view returns (uint256 swapAmount0Out);
587	 function getSwapAmount1Out(uint256 amount0In, bytes calldata data) external view returns (uint256 swapAmount1Out);
588	 function getDepositAmount0In(uint256 amount0, bytes calldata data) external view returns (uint256 depositAmount0In);
589	 function getDepositAmount1In(uint256 amount1, bytes calldata data) external view returns (uint256 depositAmount1In);
590	 }
591	 pragma solidity 0.7.6;
592	 interface ITwapFactory {
593	 event PairCreated(address indexed token0, address indexed token1, address pair, uint256);
594	 event OwnerSet(address owner);
595	 function owner() external view returns (address);
596	 function getPair(address tokenA, address tokenB) external view returns (address pair);
597	 function allPairs(uint256) external view returns (address pair);
598	 function allPairsLength() external view returns (uint256);
599	 function createPair( address tokenA, address tokenB, address oracle, address trader ) external returns (address pair);
600	 function setOwner(address) external;
601	 function setMintFee( address tokenA, address tokenB, uint256 fee ) external;
602	 function setBurnFee( address tokenA, address tokenB, uint256 fee ) external;
603	 function setSwapFee( address tokenA, address tokenB, uint256 fee ) external;
604	 function setOracle( address tokenA, address tokenB, address oracle ) external;
605	 function setTrader( address tokenA, address tokenB, address trader ) external;
606	 function collect( address tokenA, address tokenB, address to ) external;
607	 function withdraw( address tokenA, address tokenB, uint256 amount, address to ) external;
608	 }
609	 pragma solidity 0.7.6;
610	 library SafeMath {
611	 int256 private constant _INT256_MIN = -2**255;
612	 function add(uint256 x, uint256 y) internal pure returns (uint256 z) {
613	 require((z = x + y) >= x, 'SM4E');
614	 }
615	 function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {
616	 z = sub(x, y, 'SM12');
617	 }
618	 function sub( uint256 x, uint256 y, string memory message ) internal pure returns (uint256 z) {
619	 require((z = x - y) <= x, message);
620	 }
621	 function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {
622	 require(y == 0 || (z = x * y) / y == x, 'SM2A');
623	 }
624	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
625	 require(b > 0, 'SM43');
626	 return a / b;
627	 }
628	 function ceil_div(uint256 a, uint256 b) internal pure returns (uint256 c) {
629	 c = div(a, b);
630	 if (a != mul(b, c)) {
631	 return add(c, 1);
632	 }
633	 }
634	 function toUint32(uint256 n) internal pure returns (uint32) {
635	 require(n <= type(uint32).max, 'SM50');
636	 return uint32(n);
637	 }
638	 function toUint112(uint256 n) internal pure returns (uint112) {
639	 require(n <= type(uint112).max, 'SM51');
640	 return uint112(n);
641	 }
642	 function toInt256(uint256 unsigned) internal pure returns (int256 signed) {
643	 require(unsigned <= uint256(type(int256).max), 'SM34');
644	 signed = int256(unsigned);
645	 }
646	 function add(int256 a, int256 b) internal pure returns (int256 c) {
647	 c = a + b;
648	 require((b >= 0 && c >= a) || (b < 0 && c < a), 'SM4D');
649	 }
650	 function sub(int256 a, int256 b) internal pure returns (int256 c) {
651	 c = a - b;
652	 require((b >= 0 && c <= a) || (b < 0 && c > a), 'SM11');
653	 }
654	 function mul(int256 a, int256 b) internal pure returns (int256 c) {
655	 if (a == 0) {
656	 return 0;
657	 }
658	 require(!(a == -1 && b == _INT256_MIN), 'SM29');
659	 c = a * b;
660	 require(c / a == b, 'SM29');
661	 }
662	 function div(int256 a, int256 b) internal pure returns (int256) {
663	 require(b != 0, 'SM43');
664	 require(!(b == -1 && a == _INT256_MIN), 'SM42');
665	 return a / b;
666	 }
667	 function neg_floor_div(int256 a, int256 b) internal pure returns (int256 c) {
668	 c = div(a, b);
669	 if ((a < 0 && b > 0) || (a >= 0 && b < 0)) {
670	 if (a != mul(b, c)) {
671	 c = sub(c, 1);
672	 }
673	 }
674	 }
675	 }
676	 pragma solidity 0.7.6;
677	 library Orders {
678	 using SafeMath for uint256;
679	 using TokenShares for TokenShares.Data;
680	 using TransferHelper for address;
681	 enum OrderType {
682	 Empty, Deposit, Withdraw, Sell, Buy }
683	 enum OrderStatus {
684	 NonExistent, EnqueuedWaiting, EnqueuedReady, ExecutedSucceeded, ExecutedFailed, Canceled }
685	 event MaxGasLimitSet(uint256 maxGasLimit);
686	 event GasPriceInertiaSet(uint256 gasPriceInertia);
687	 event MaxGasPriceImpactSet(uint256 maxGasPriceImpact);
688	 event TransferGasCostSet(address token, uint256 gasCost);
689	 event DepositEnqueued(uint256 indexed orderId, uint32 validAfterTimestamp, uint256 gasPrice);
690	 event WithdrawEnqueued(uint256 indexed orderId, uint32 validAfterTimestamp, uint256 gasPrice);
691	 event SellEnqueued(uint256 indexed orderId, uint32 validAfterTimestamp, uint256 gasPrice);
692	 event BuyEnqueued(uint256 indexed orderId, uint32 validAfterTimestamp, uint256 gasPrice);
693	 event OrderDisabled(address pair, Orders.OrderType orderType, bool disabled);
694	 event RefundFailed(address indexed to, address indexed token, uint256 amount, bytes data);
695	 uint8 private constant DEPOSIT_TYPE = 1;
696	 uint8 private constant WITHDRAW_TYPE = 2;
697	 uint8 private constant BUY_TYPE = 3;
698	 uint8 private constant BUY_INVERTED_TYPE = 4;
699	 uint8 private constant SELL_TYPE = 5;
700	 uint8 private constant SELL_INVERTED_TYPE = 6;
701	 uint8 private constant UNWRAP_NOT_FAILED = 0;
702	 uint8 private constant KEEP_NOT_FAILED = 1;
703	 uint8 private constant UNWRAP_FAILED = 2;
704	 uint8 private constant KEEP_FAILED = 3;
705	 uint256 private constant ETHER_TRANSFER_COST = 2600 + 1504;
706	 uint256 private constant BUFFER_COST = 10000;
707	 uint256 private constant ORDER_EXECUTED_EVENT_COST = 3700;
708	 uint256 private constant EXECUTE_PREPARATION_COST = 55000;
709	 uint256 public constant ETHER_TRANSFER_CALL_COST = 10000;
710	 uint256 public constant PAIR_TRANSFER_COST = 55000;
711	 uint256 public constant REFUND_BASE_COST = 2 * ETHER_TRANSFER_COST + BUFFER_COST + ORDER_EXECUTED_EVENT_COST;
712	 uint256 public constant ORDER_BASE_COST = EXECUTE_PREPARATION_COST + REFUND_BASE_COST;
713	 uint8 private constant DEPOSIT_MASK = uint8(1 << uint8(OrderType.Deposit));
714	 uint8 private constant WITHDRAW_MASK = uint8(1 << uint8(OrderType.Withdraw));
715	 uint8 private constant SELL_MASK = uint8(1 << uint8(OrderType.Sell));
716	 uint8 private constant BUY_MASK = uint8(1 << uint8(OrderType.Buy));
717	 struct PairInfo {
718	 address pair;
719	 address token0;
720	 address token1;
721	 }
722	 struct Data {
723	 uint32 delay;
724	 uint256 newestOrderId;
725	 uint256 lastProcessedOrderId;
726	 mapping(uint256 => StoredOrder) orderQueue;
727	 address factory;
728	 uint256 maxGasLimit;
729	 uint256 gasPrice;
730	 uint256 gasPriceInertia;
731	 uint256 maxGasPriceImpact;
732	 mapping(uint32 => PairInfo) pairs;
733	 mapping(address => uint256) transferGasCosts;
734	 mapping(uint256 => bool) canceled;
735	 mapping(address => uint8) orderDisabled;
736	 }
737	 struct StoredOrder {
738	 uint8 orderType;
739	 uint32 validAfterTimestamp;
740	 uint8 unwrapAndFailure;
741	 uint32 timestamp;
742	 uint32 gasLimit;
743	 uint32 gasPrice;
744	 uint112 liquidity;
745	 uint112 value0;
746	 uint112 value1;
747	 uint32 pairId;
748	 address to;
749	 uint32 minSwapPrice;
750	 uint32 maxSwapPrice;
751	 bool swap;
752	 uint256 priceAccumulator;
753	 uint112 amountLimit0;
754	 uint112 amountLimit1;
755	 }
756	 struct DepositOrder {
757	 uint32 pairId;
758	 uint256 share0;
759	 uint256 share1;
760	 uint256 minSwapPrice;
761	 uint256 maxSwapPrice;
762	 bool unwrap;
763	 bool swap;
764	 address to;
765	 uint256 gasPrice;
766	 uint256 gasLimit;
767	 uint32 validAfterTimestamp;
768	 uint256 priceAccumulator;
769	 uint32 timestamp;
770	 }
771	 struct WithdrawOrder {
772	 uint32 pairId;
773	 uint256 liquidity;
774	 uint256 amount0Min;
775	 uint256 amount1Min;
776	 bool unwrap;
777	 address to;
778	 uint256 gasPrice;
779	 uint256 gasLimit;
780	 uint32 validAfterTimestamp;
781	 }
782	 struct SellOrder {
783	 uint32 pairId;
784	 bool inverse;
785	 uint256 shareIn;
786	 uint256 amountOutMin;
787	 bool unwrap;
788	 address to;
789	 uint256 gasPrice;
790	 uint256 gasLimit;
791	 uint32 validAfterTimestamp;
792	 uint256 priceAccumulator;
793	 uint32 timestamp;
794	 }
795	 struct BuyOrder {
796	 uint32 pairId;
797	 bool inverse;
798	 uint256 shareInMax;
799	 uint256 amountOut;
800	 bool unwrap;
801	 address to;
802	 uint256 gasPrice;
803	 uint256 gasLimit;
804	 uint32 validAfterTimestamp;
805	 uint256 priceAccumulator;
806	 uint32 timestamp;
807	 }
808	 function decodeType(uint256 internalType) internal pure returns (OrderType orderType) {
809	 if (internalType == DEPOSIT_TYPE) {
810	 orderType = OrderType.Deposit;
811	 }
812	 else if (internalType == WITHDRAW_TYPE) {
813	 orderType = OrderType.Withdraw;
814	 }
815	 else if (internalType == BUY_TYPE) {
816	 orderType = OrderType.Buy;
817	 }
818	 else if (internalType == BUY_INVERTED_TYPE) {
819	 orderType = OrderType.Buy;
820	 }
821	 else if (internalType == SELL_TYPE) {
822	 orderType = OrderType.Sell;
823	 }
824	 else if (internalType == SELL_INVERTED_TYPE) {
825	 orderType = OrderType.Sell;
826	 }
827	 else {
828	 orderType = OrderType.Empty;
829	 }
830	 }
831	 function getOrder(Data storage data, uint256 orderId) internal view returns (OrderType orderType, uint32 validAfterTimestamp) {
832	 StoredOrder storage order = data.orderQueue[orderId];
833	 validAfterTimestamp = order.validAfterTimestamp;
834	 orderType = decodeType(order.orderType);
835	 }
836	 function getOrderStatus(Data storage data, uint256 orderId) internal view returns (OrderStatus orderStatus) {
837	 if (orderId > data.newestOrderId) {
838	 return OrderStatus.NonExistent;
839	 }
840	 if (data.canceled[orderId]) {
841	 return OrderStatus.Canceled;
842	 }
843	 if (isRefundFailed(data, orderId)) {
844	 return OrderStatus.ExecutedFailed;
845	 }
846	 (OrderType orderType, uint32 validAfterTimestamp) = getOrder(data, orderId);
847	 if (orderType == OrderType.Empty) {
848	 return OrderStatus.ExecutedSucceeded;
849	 }
850	 if (validAfterTimestamp >= block.timestamp) {
851	 return OrderStatus.EnqueuedWaiting;
852	 }
853	 return OrderStatus.EnqueuedReady;
854	 }
855	 function getPair( Data storage data, address tokenA, address tokenB ) internal returns ( address pair, uint32 pairId, bool inverted ) {
856	 inverted = tokenA > tokenB;
857	 (address token0, address token1) = inverted ? (tokenB, tokenA) : (tokenA, tokenB);
858	 pair = ITwapFactory(data.factory).getPair(token0, token1);
859	 require(pair != address(0), 'OS17');
860	 pairId = uint32(bytes4(keccak256(abi.encodePacked(pair))));
861	 if (data.pairs[pairId].pair == address(0)) {
862	 data.pairs[pairId] = PairInfo(pair, token0, token1);
863	 }
864	 }
865	 function getPairInfo(Data storage data, uint32 pairId) internal view returns ( address pair, address token0, address token1 ) {
866	 PairInfo storage info = data.pairs[pairId];
867	 pair = info.pair;
868	 token0 = info.token0;
869	 token1 = info.token1;
870	 }
871	 function getDepositDisabled(Data storage data, address pair) internal view returns (bool) {
872	 return data.orderDisabled[pair] & DEPOSIT_MASK != 0;
873	 }
874	 function getWithdrawDisabled(Data storage data, address pair) internal view returns (bool) {
875	 return data.orderDisabled[pair] & WITHDRAW_MASK != 0;
876	 }
877	 function getSellDisabled(Data storage data, address pair) internal view returns (bool) {
878	 return data.orderDisabled[pair] & SELL_MASK != 0;
879	 }
880	 function getBuyDisabled(Data storage data, address pair) internal view returns (bool) {
881	 return data.orderDisabled[pair] & BUY_MASK != 0;
882	 }
883	 function getDepositOrder(Data storage data, uint256 index) public view returns ( DepositOrder memory order, uint256 amountLimit0, uint256 amountLimit1 ) {
884	 StoredOrder memory stored = data.orderQueue[index];
885	 require(stored.orderType == DEPOSIT_TYPE, 'OS32');
886	 order.pairId = stored.pairId;
887	 order.share0 = stored.value0;
888	 order.share1 = stored.value1;
889	 order.minSwapPrice = float32ToUint(stored.minSwapPrice);
890	 order.maxSwapPrice = float32ToUint(stored.maxSwapPrice);
891	 order.unwrap = getUnwrap(stored.unwrapAndFailure);
892	 order.swap = stored.swap;
893	 order.to = stored.to;
894	 order.gasPrice = uint32ToGasPrice(stored.gasPrice);
895	 order.gasLimit = stored.gasLimit;
896	 order.validAfterTimestamp = stored.validAfterTimestamp;
897	 order.priceAccumulator = stored.priceAccumulator;
898	 order.timestamp = stored.timestamp;
899	 amountLimit0 = stored.amountLimit0;
900	 amountLimit1 = stored.amountLimit1;
901	 }
902	 function getWithdrawOrder(Data storage data, uint256 index) public view returns (WithdrawOrder memory order) {
903	 StoredOrder memory stored = data.orderQueue[index];
904	 require(stored.orderType == WITHDRAW_TYPE, 'OS32');
905	 order.pairId = stored.pairId;
906	 order.liquidity = stored.liquidity;
907	 order.amount0Min = stored.value0;
908	 order.amount1Min = stored.value1;
909	 order.unwrap = getUnwrap(stored.unwrapAndFailure);
910	 order.to = stored.to;
911	 order.gasPrice = uint32ToGasPrice(stored.gasPrice);
912	 order.gasLimit = stored.gasLimit;
913	 order.validAfterTimestamp = stored.validAfterTimestamp;
914	 }
915	 function getSellOrder(Data storage data, uint256 index) public view returns (SellOrder memory order, uint256 amountLimit) {
916	 StoredOrder memory stored = data.orderQueue[index];
917	 require(stored.orderType == SELL_TYPE || stored.orderType == SELL_INVERTED_TYPE, 'OS32');
918	 order.pairId = stored.pairId;
919	 order.inverse = stored.orderType == SELL_INVERTED_TYPE;
920	 order.shareIn = stored.value0;
921	 order.amountOutMin = stored.value1;
922	 order.unwrap = getUnwrap(stored.unwrapAndFailure);
923	 order.to = stored.to;
924	 order.gasPrice = uint32ToGasPrice(stored.gasPrice);
925	 order.gasLimit = stored.gasLimit;
926	 order.validAfterTimestamp = stored.validAfterTimestamp;
927	 order.priceAccumulator = stored.priceAccumulator;
928	 order.timestamp = stored.timestamp;
929	 amountLimit = stored.amountLimit0;
930	 }
931	 function getBuyOrder(Data storage data, uint256 index) public view returns (BuyOrder memory order, uint256 amountLimit) {
932	 StoredOrder memory stored = data.orderQueue[index];
933	 require(stored.orderType == BUY_TYPE || stored.orderType == BUY_INVERTED_TYPE, 'OS32');
934	 order.pairId = stored.pairId;
935	 order.inverse = stored.orderType == BUY_INVERTED_TYPE;
936	 order.shareInMax = stored.value0;
937	 order.amountOut = stored.value1;
938	 order.unwrap = getUnwrap(stored.unwrapAndFailure);
939	 order.to = stored.to;
940	 order.gasPrice = uint32ToGasPrice(stored.gasPrice);
941	 order.gasLimit = stored.gasLimit;
942	 order.validAfterTimestamp = stored.validAfterTimestamp;
943	 order.timestamp = stored.timestamp;
944	 order.priceAccumulator = stored.priceAccumulator;
945	 amountLimit = stored.amountLimit0;
946	 }
947	 function getFailedOrderType(Data storage data, uint256 orderId) internal view returns (OrderType orderType, uint32 validAfterTimestamp) {
948	 require(isRefundFailed(data, orderId), 'OS21');
949	 (orderType, validAfterTimestamp) = getOrder(data, orderId);
950	 }
951	 function getUnwrap(uint8 unwrapAndFailure) private pure returns (bool) {
952	 return unwrapAndFailure == UNWRAP_FAILED || unwrapAndFailure == UNWRAP_NOT_FAILED;
953	 }
954	 function getUnwrapAndFailure(bool unwrap) private pure returns (uint8) {
955	 return unwrap ? UNWRAP_NOT_FAILED : KEEP_NOT_FAILED;
956	 }
957	 function timestampToUint32(uint256 timestamp) private pure returns (uint32 timestamp32) {
958	 if (timestamp == type(uint256).max) {
959	 return type(uint32).max;
960	 }
961	 timestamp32 = timestamp.toUint32();
962	 }
963	 function gasPriceToUint32(uint256 gasPrice) private pure returns (uint32 gasPrice32) {
964	 require((gasPrice / 1e6) * 1e6 == gasPrice, 'OS3C');
965	 gasPrice32 = (gasPrice / 1e6).toUint32();
966	 }
967	 function uint32ToGasPrice(uint32 gasPrice32) public pure returns (uint256 gasPrice) {
968	 gasPrice = uint256(gasPrice32) * 1e6;
969	 }
970	 function uintToFloat32(uint256 number) internal pure returns (uint32 float32) {
971	 if (number < 1 << 24) {
972	 return uint32(number << 8);
973	 }
974	 uint32 exponent;
975	 for (; exponent < 256 - 24; ++exponent) {
976	 if (number & 1 == 1) {
977	 break;
978	 }
979	 number = number >> 1;
980	 }
981	 require(number < 1 << 24, 'OS1A');
982	 float32 = uint32(number << 8) | exponent;
983	 }
984	 function float32ToUint(uint32 float32) internal pure returns (uint256 number) {
985	 uint256 exponent = float32 & 0xFF;
986	 require(exponent <= 256 - 24, 'OS1B');
987	 uint256 mantissa = (float32 & 0xFFFFFF00) >> 8;
988	 number = mantissa << exponent;
989	 }
990	 function setOrderDisabled( Data storage data, address pair, Orders.OrderType orderType, bool disabled ) external {
991	 require(orderType != Orders.OrderType.Empty, 'OS32');
992	 uint8 currentSettings = data.orderDisabled[pair];
993	 uint8 mask = uint8(1 << uint8(orderType));
994	 if (disabled) {
995	 currentSettings = currentSettings | mask;
996	 }
997	 else {
998	 currentSettings = currentSettings & (mask ^ 0xff);
999	 }
1000	 require(currentSettings != data.orderDisabled[pair], 'OS01');
1001	 data.orderDisabled[pair] = currentSettings;
1002	 emit OrderDisabled(pair, orderType, disabled);
1003	 }
1004	 function enqueueDepositOrder( Data storage data, DepositOrder memory depositOrder, uint256 amountIn0, uint256 amountIn1 ) internal {
1005	 ++data.newestOrderId;
1006	 emit DepositEnqueued(data.newestOrderId, depositOrder.validAfterTimestamp, depositOrder.gasPrice);
1007	 data.orderQueue[data.newestOrderId] = StoredOrder( DEPOSIT_TYPE, depositOrder.validAfterTimestamp, getUnwrapAndFailure(depositOrder.unwrap), depositOrder.timestamp, depositOrder.gasLimit.toUint32(), gasPriceToUint32(depositOrder.gasPrice), 0, depositOrder.share0.toUint112(), depositOrder.share1.toUint112(), depositOrder.pairId, depositOrder.to, uintToFloat32(depositOrder.minSwapPrice), uintToFloat32(depositOrder.maxSwapPrice), depositOrder.swap, depositOrder.priceAccumulator, amountIn0.toUint112(), amountIn1.toUint112() );
1008	 }
1009	 function enqueueWithdrawOrder(Data storage data, WithdrawOrder memory withdrawOrder) internal {
1010	 ++data.newestOrderId;
1011	 emit WithdrawEnqueued(data.newestOrderId, withdrawOrder.validAfterTimestamp, withdrawOrder.gasPrice);
1012	 data.orderQueue[data.newestOrderId] = StoredOrder( WITHDRAW_TYPE, withdrawOrder.validAfterTimestamp, getUnwrapAndFailure(withdrawOrder.unwrap), 0, withdrawOrder.gasLimit.toUint32(), gasPriceToUint32(withdrawOrder.gasPrice), withdrawOrder.liquidity.toUint112(), withdrawOrder.amount0Min.toUint112(), withdrawOrder.amount1Min.toUint112(), withdrawOrder.pairId, withdrawOrder.to, 0, 0, false, 0, 0, 0 );
1013	 }
1014	 function enqueueSellOrder( Data storage data, SellOrder memory sellOrder, uint256 amountIn ) internal {
1015	 ++data.newestOrderId;
1016	 emit SellEnqueued(data.newestOrderId, sellOrder.validAfterTimestamp, sellOrder.gasPrice);
1017	 data.orderQueue[data.newestOrderId] = StoredOrder( sellOrder.inverse ? SELL_INVERTED_TYPE : SELL_TYPE, sellOrder.validAfterTimestamp, getUnwrapAndFailure(sellOrder.unwrap), sellOrder.timestamp, sellOrder.gasLimit.toUint32(), gasPriceToUint32(sellOrder.gasPrice), 0, sellOrder.shareIn.toUint112(), sellOrder.amountOutMin.toUint112(), sellOrder.pairId, sellOrder.to, 0, 0, false, sellOrder.priceAccumulator, amountIn.toUint112(), 0 );
1018	 }
1019	 function enqueueBuyOrder( Data storage data, BuyOrder memory buyOrder, uint256 amountInMax ) internal {
1020	 ++data.newestOrderId;
1021	 emit BuyEnqueued(data.newestOrderId, buyOrder.validAfterTimestamp, buyOrder.gasPrice);
1022	 data.orderQueue[data.newestOrderId] = StoredOrder( buyOrder.inverse ? BUY_INVERTED_TYPE : BUY_TYPE, buyOrder.validAfterTimestamp, getUnwrapAndFailure(buyOrder.unwrap), buyOrder.timestamp, buyOrder.gasLimit.toUint32(), gasPriceToUint32(buyOrder.gasPrice), 0, buyOrder.shareInMax.toUint112(), buyOrder.amountOut.toUint112(), buyOrder.pairId, buyOrder.to, 0, 0, false, buyOrder.priceAccumulator, amountInMax.toUint112(), 0 );
1023	 }
1024	 function isRefundFailed(Data storage data, uint256 index) internal view returns (bool) {
1025	 uint8 unwrapAndFailure = data.orderQueue[index].unwrapAndFailure;
1026	 return unwrapAndFailure == UNWRAP_FAILED || unwrapAndFailure == KEEP_FAILED;
1027	 }
1028	 function markRefundFailed(Data storage data) internal {
1029	 StoredOrder storage stored = data.orderQueue[data.lastProcessedOrderId];
1030	 stored.unwrapAndFailure = stored.unwrapAndFailure == UNWRAP_NOT_FAILED ? UNWRAP_FAILED : KEEP_FAILED;
1031	 }
1032	 struct DepositParams {
1033	 address token0;
1034	 address token1;
1035	 uint256 amount0;
1036	 uint256 amount1;
1037	 uint256 minSwapPrice;
1038	 uint256 maxSwapPrice;
1039	 bool wrap;
1040	 bool swap;
1041	 address to;
1042	 uint256 gasLimit;
1043	 uint32 submitDeadline;
1044	 }
1045	 function deposit( Data storage data, DepositParams calldata depositParams, TokenShares.Data storage tokenShares ) external {
1046	 {
1047	 uint256 token0TransferCost = data.transferGasCosts[depositParams.token0];
1048	 uint256 token1TransferCost = data.transferGasCosts[depositParams.token1];
1049	 require(token0TransferCost != 0 && token1TransferCost != 0, 'OS0F');
1050	 checkOrderParams( data, depositParams.to, depositParams.gasLimit, depositParams.submitDeadline, ORDER_BASE_COST.add(token0TransferCost).add(token1TransferCost) );
1051	 }
1052	 require(depositParams.amount0 != 0 || depositParams.amount1 != 0, 'OS25');
1053	 (address pairAddress, uint32 pairId, bool inverted) = getPair(data, depositParams.token0, depositParams.token1);
1054	 require(!getDepositDisabled(data, pairAddress), 'OS46');
1055	 {
1056	 uint256 value = msg.value;
1057	 if (depositParams.wrap) {
1058	 if (depositParams.token0 == tokenShares.weth) {
1059	 value = msg.value.sub(depositParams.amount0, 'OS1E');
1060	 }
1061	 else if (depositParams.token1 == tokenShares.weth) {
1062	 value = msg.value.sub(depositParams.amount1, 'OS1E');
1063	 }
1064	 }
1065	 allocateGasRefund(data, value, depositParams.gasLimit);
1066	 }
1067	 uint256 shares0 = tokenShares.amountToShares( inverted ? depositParams.token1 : depositParams.token0, inverted ? depositParams.amount1 : depositParams.amount0, depositParams.wrap );
1068	 uint256 shares1 = tokenShares.amountToShares( inverted ? depositParams.token0 : depositParams.token1, inverted ? depositParams.amount0 : depositParams.amount1, depositParams.wrap );
1069	 (uint256 priceAccumulator, uint32 timestamp) = ITwapOracle(ITwapPair(pairAddress).oracle()).getPriceInfo();
1070	 enqueueDepositOrder( data, DepositOrder( pairId, shares0, shares1, depositParams.minSwapPrice, depositParams.maxSwapPrice, depositParams.wrap, depositParams.swap, depositParams.to, data.gasPrice, depositParams.gasLimit, timestamp + data.delay, priceAccumulator, timestamp ), inverted ? depositParams.amount1 : depositParams.amount0, inverted ? depositParams.amount0 : depositParams.amount1 );
1071	 }
1072	 struct WithdrawParams {
1073	 address token0;
1074	 address token1;
1075	 uint256 liquidity;
1076	 uint256 amount0Min;
1077	 uint256 amount1Min;
1078	 bool unwrap;
1079	 address to;
1080	 uint256 gasLimit;
1081	 uint32 submitDeadline;
1082	 }
1083	 function withdraw(Data storage data, WithdrawParams calldata withdrawParams) external {
1084	 (address pair, uint32 pairId, bool inverted) = getPair(data, withdrawParams.token0, withdrawParams.token1);
1085	 require(!getWithdrawDisabled(data, pair), 'OS0A');
1086	 checkOrderParams( data, withdrawParams.to, withdrawParams.gasLimit, withdrawParams.submitDeadline, ORDER_BASE_COST.add(PAIR_TRANSFER_COST) );
1087	 require(withdrawParams.liquidity != 0, 'OS22');
1088	 allocateGasRefund(data, msg.value, withdrawParams.gasLimit);
1089	 pair.safeTransferFrom(msg.sender, address(this), withdrawParams.liquidity);
1090	 enqueueWithdrawOrder( data, WithdrawOrder( pairId, withdrawParams.liquidity, inverted ? withdrawParams.amount1Min : withdrawParams.amount0Min, inverted ? withdrawParams.amount0Min : withdrawParams.amount1Min, withdrawParams.unwrap, withdrawParams.to, data.gasPrice, withdrawParams.gasLimit, timestampToUint32(block.timestamp) + data.delay ) );
1091	 }
1092	 struct SellParams {
1093	 address tokenIn;
1094	 address tokenOut;
1095	 uint256 amountIn;
1096	 uint256 amountOutMin;
1097	 bool wrapUnwrap;
1098	 address to;
1099	 uint256 gasLimit;
1100	 uint32 submitDeadline;
1101	 }
1102	 function sell( Data storage data, SellParams calldata sellParams, TokenShares.Data storage tokenShares ) external {
1103	 uint256 tokenTransferCost = data.transferGasCosts[sellParams.tokenIn];
1104	 require(tokenTransferCost != 0, 'OS0F');
1105	 checkOrderParams( data, sellParams.to, sellParams.gasLimit, sellParams.submitDeadline, ORDER_BASE_COST.add(tokenTransferCost) );
1106	 require(sellParams.amountIn != 0, 'OS24');
1107	 (address pairAddress, uint32 pairId, bool inverted) = getPair(data, sellParams.tokenIn, sellParams.tokenOut);
1108	 require(!getSellDisabled(data, pairAddress), 'OS13');
1109	 uint256 value = msg.value;
1110	 if (sellParams.tokenIn == tokenShares.weth && sellParams.wrapUnwrap) {
1111	 value = msg.value.sub(sellParams.amountIn, 'OS1E');
1112	 }
1113	 allocateGasRefund(data, value, sellParams.gasLimit);
1114	 uint256 shares = tokenShares.amountToShares(sellParams.tokenIn, sellParams.amountIn, sellParams.wrapUnwrap);
1115	 (uint256 priceAccumulator, uint32 timestamp) = ITwapOracle(ITwapPair(pairAddress).oracle()).getPriceInfo();
1116	 enqueueSellOrder( data, SellOrder( pairId, inverted, shares, sellParams.amountOutMin, sellParams.wrapUnwrap, sellParams.to, data.gasPrice, sellParams.gasLimit, timestamp + data.delay, priceAccumulator, timestamp ), sellParams.amountIn );
1117	 }
1118	 struct BuyParams {
1119	 address tokenIn;
1120	 address tokenOut;
1121	 uint256 amountInMax;
1122	 uint256 amountOut;
1123	 bool wrapUnwrap;
1124	 address to;
1125	 uint256 gasLimit;
1126	 uint32 submitDeadline;
1127	 }
1128	 function buy( Data storage data, BuyParams calldata buyParams, TokenShares.Data storage tokenShares ) external {
1129	 uint256 tokenTransferCost = data.transferGasCosts[buyParams.tokenIn];
1130	 require(tokenTransferCost != 0, 'OS0F');
1131	 checkOrderParams( data, buyParams.to, buyParams.gasLimit, buyParams.submitDeadline, ORDER_BASE_COST.add(tokenTransferCost) );
1132	 require(buyParams.amountOut != 0, 'OS23');
1133	 (address pairAddress, uint32 pairId, bool inverted) = getPair(data, buyParams.tokenIn, buyParams.tokenOut);
1134	 require(!getBuyDisabled(data, pairAddress), 'OS49');
1135	 uint256 value = msg.value;
1136	 if (buyParams.tokenIn == tokenShares.weth && buyParams.wrapUnwrap) {
1137	 value = msg.value.sub(buyParams.amountInMax, 'OS1E');
1138	 }
1139	 allocateGasRefund(data, value, buyParams.gasLimit);
1140	 uint256 shares = tokenShares.amountToShares(buyParams.tokenIn, buyParams.amountInMax, buyParams.wrapUnwrap);
1141	 (uint256 priceAccumulator, uint32 timestamp) = ITwapOracle(ITwapPair(pairAddress).oracle()).getPriceInfo();
1142	 enqueueBuyOrder( data, BuyOrder( pairId, inverted, shares, buyParams.amountOut, buyParams.wrapUnwrap, buyParams.to, data.gasPrice, buyParams.gasLimit, timestamp + data.delay, priceAccumulator, timestamp ), buyParams.amountInMax );
1143	 }
1144	 function checkOrderParams( Data storage data, address to, uint256 gasLimit, uint32 submitDeadline, uint256 minGasLimit ) private view {
1145	 require(submitDeadline >= block.timestamp, 'OS04');
1146	 require(gasLimit <= data.maxGasLimit, 'OS3E');
1147	 require(gasLimit >= minGasLimit, 'OS3D');
1148	 require(to != address(0), 'OS26');
1149	 }
1150	 function allocateGasRefund( Data storage data, uint256 value, uint256 gasLimit ) private returns (uint256 futureFee) {
1151	 futureFee = data.gasPrice.mul(gasLimit);
1152	 require(value >= futureFee, 'OS1E');
1153	 if (value > futureFee) {
1154	 TransferHelper.safeTransferETH(msg.sender, value.sub(futureFee), data.transferGasCosts[address(0)]);
1155	 }
1156	 }
1157	 function updateGasPrice(Data storage data, uint256 gasUsed) external {
1158	 uint256 scale = Math.min(gasUsed, data.maxGasPriceImpact);
1159	 uint256 updated = data.gasPrice.mul(data.gasPriceInertia.sub(scale)).add(tx.gasprice.mul(scale)).div( data.gasPriceInertia );
1160	 data.gasPrice = updated - (updated % 1e6);
1161	 }
1162	 function setMaxGasLimit(Data storage data, uint256 _maxGasLimit) external {
1163	 require(_maxGasLimit != data.maxGasLimit, 'OS01');
1164	 require(_maxGasLimit <= 10000000, 'OS2B');
1165	 data.maxGasLimit = _maxGasLimit;
1166	 emit MaxGasLimitSet(_maxGasLimit);
1167	 }
1168	 function setGasPriceInertia(Data storage data, uint256 _gasPriceInertia) external {
1169	 require(_gasPriceInertia != data.gasPriceInertia, 'OS01');
1170	 require(_gasPriceInertia >= 1, 'OS35');
1171	 data.gasPriceInertia = _gasPriceInertia;
1172	 emit GasPriceInertiaSet(_gasPriceInertia);
1173	 }
1174	 function setMaxGasPriceImpact(Data storage data, uint256 _maxGasPriceImpact) external {
1175	 require(_maxGasPriceImpact != data.maxGasPriceImpact, 'OS01');
1176	 require(_maxGasPriceImpact <= data.gasPriceInertia, 'OS33');
1177	 data.maxGasPriceImpact = _maxGasPriceImpact;
1178	 emit MaxGasPriceImpactSet(_maxGasPriceImpact);
1179	 }
1180	 function setTransferGasCost( Data storage data, address token, uint256 gasCost ) external {
1181	 require(gasCost != data.transferGasCosts[token], 'OS01');
1182	 data.transferGasCosts[token] = gasCost;
1183	 emit TransferGasCostSet(token, gasCost);
1184	 }
1185	 function refundLiquidity( address pair, address to, uint256 liquidity, bytes4 selector ) internal returns (bool) {
1186	 if (liquidity == 0) {
1187	 return true;
1188	 }
1189	 (bool success, bytes memory data) = address(this).call{
1190	 gas: PAIR_TRANSFER_COST }
1191	 ( abi.encodeWithSelector(selector, pair, to, liquidity, false) );
1192	 if (!success) {
1193	 emit RefundFailed(to, pair, liquidity, data);
1194	 }
1195	 return success;
1196	 }
1197	 function getNextOrder(Data storage data) internal view returns (OrderType orderType, uint256 validAfterTimestamp) {
1198	 return getOrder(data, data.lastProcessedOrderId + 1);
1199	 }
1200	 function dequeueCanceledOrder(Data storage data) internal {
1201	 ++data.lastProcessedOrderId;
1202	 }
1203	 function dequeueDepositOrder(Data storage data) external returns ( DepositOrder memory order, uint256 amountLimit0, uint256 amountLimit1 ) {
1204	 ++data.lastProcessedOrderId;
1205	 (order, amountLimit0, amountLimit1) = getDepositOrder(data, data.lastProcessedOrderId);
1206	 }
1207	 function dequeueWithdrawOrder(Data storage data) external returns (WithdrawOrder memory order) {
1208	 ++data.lastProcessedOrderId;
1209	 order = getWithdrawOrder(data, data.lastProcessedOrderId);
1210	 }
1211	 function dequeueSellOrder(Data storage data) external returns (SellOrder memory order, uint256 amountLimit) {
1212	 ++data.lastProcessedOrderId;
1213	 (order, amountLimit) = getSellOrder(data, data.lastProcessedOrderId);
1214	 }
1215	 function dequeueBuyOrder(Data storage data) external returns (BuyOrder memory order, uint256 amountLimit) {
1216	 ++data.lastProcessedOrderId;
1217	 (order, amountLimit) = getBuyOrder(data, data.lastProcessedOrderId);
1218	 }
1219	 function forgetOrder(Data storage data, uint256 orderId) internal {
1220	 delete data.orderQueue[orderId];
1221	 }
1222	 function forgetLastProcessedOrder(Data storage data) internal {
1223	 delete data.orderQueue[data.lastProcessedOrderId];
1224	 }
1225	 }
1226	 pragma solidity 0.7.6;
1227	 interface IWETH {
1228	 function deposit() external payable;
1229	 function transfer(address to, uint256 value) external returns (bool);
1230	 function withdraw(uint256) external;
1231	 }
1232	 pragma solidity 0.7.6;
1233	 library TransferHelper {
1234	 function safeApprove( address token, address to, uint256 value ) internal {
1235	 (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));
1236	 require(success && (data.length == 0 || abi.decode(data, (bool))), 'TH4B');
1237	 }
1238	 function safeTransfer( address token, address to, uint256 value ) internal {
1239	 (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));
1240	 require(success && (data.length == 0 || abi.decode(data, (bool))), 'TH05');
1241	 }
1242	 function safeTransferFrom( address token, address from, address to, uint256 value ) internal {
1243	 (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));
1244	 require(success && (data.length == 0 || abi.decode(data, (bool))), 'TH0E');
1245	 }
1246	 function safeTransferETH( address to, uint256 value, uint256 gasLimit ) internal {
1247	 (bool success, ) = to.call{
1248	 value: value, gas: gasLimit }
1249	 ('');
1250	 require(success, 'TH3F');
1251	 }
1252	 function transferETH( address to, uint256 value, uint256 gasLimit ) internal returns (bool success) {
1253	 (success, ) = to.call{
1254	 value: value, gas: gasLimit }
1255	 ('');
1256	 }
1257	 }
1258	 pragma solidity >=0.4.0 <0.8.0;
1259	 library FullMath {
1260	 function mulDiv( uint256 a, uint256 b, uint256 denominator ) internal pure returns (uint256 result) {
1261	 uint256 prod0;
1262	 uint256 prod1;
1263	 assembly {
1264	 let mm := mulmod(a, b, not(0)) prod0 := mul(a, b) prod1 := sub(sub(mm, prod0), lt(mm, prod0)) }
1265	 if (prod1 == 0) {
1266	 require(denominator > 0);
1267	 assembly {
1268	 result := div(prod0, denominator) }
1269	 return result;
1270	 }
1271	 require(denominator > prod1);
1272	 uint256 remainder;
1273	 assembly {
1274	 remainder := mulmod(a, b, denominator) }
1275	 assembly {
1276	 prod1 := sub(prod1, gt(remainder, prod0)) prod0 := sub(prod0, remainder) }
1277	 uint256 twos = -denominator & denominator;
1278	 assembly {
1279	 denominator := div(denominator, twos) }
1280	 assembly {
1281	 prod0 := div(prod0, twos) }
1282	 assembly {
1283	 twos := add(div(sub(0, twos), twos), 1) }
1284	 prod0 |= prod1 * twos;
1285	 uint256 inv = (3 * denominator) ^ 2;
1286	 inv *= 2 - denominator * inv;
1287	 inv *= 2 - denominator * inv;
1288	 inv *= 2 - denominator * inv;
1289	 inv *= 2 - denominator * inv;
1290	 inv *= 2 - denominator * inv;
1291	 inv *= 2 - denominator * inv;
1292	 result = prod0 * inv;
1293	 return result;
1294	 }
1295	 function mulDivRoundingUp( uint256 a, uint256 b, uint256 denominator ) internal pure returns (uint256 result) {
1296	 result = mulDiv(a, b, denominator);
1297	 if (mulmod(a, b, denominator) > 0) {
1298	 require(result < type(uint256).max);
1299	 result++;
1300	 }
1301	 }
1302	 }
1303	 pragma solidity >=0.5.0 <0.8.0;
1304	 library OracleLibrary {
1305	 function consult(address pool, uint32 secondsAgo) internal view returns (int24 arithmeticMeanTick, uint128 harmonicMeanLiquidity) {
1306	 require(secondsAgo != 0, 'BP');
1307	 uint32[] memory secondsAgos = new uint32[](2);
1308	 secondsAgos[0] = secondsAgo;
1309	 secondsAgos[1] = 0;
1310	 (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s) = IUniswapV3Pool(pool).observe(secondsAgos);
1311	 int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];
1312	 uint160 secondsPerLiquidityCumulativesDelta = secondsPerLiquidityCumulativeX128s[1] - secondsPerLiquidityCumulativeX128s[0];
1313	 arithmeticMeanTick = int24(tickCumulativesDelta / secondsAgo);
1314	 if (tickCumulativesDelta < 0 && (tickCumulativesDelta % secondsAgo != 0)) arithmeticMeanTick--;
1315	 uint192 secondsAgoX160 = uint192(secondsAgo) * type(uint160).max;
1316	 harmonicMeanLiquidity = uint128(secondsAgoX160 / (uint192(secondsPerLiquidityCumulativesDelta) << 32));
1317	 }
1318	 function getQuoteAtTick( int24 tick, uint128 baseAmount, address baseToken, address quoteToken ) internal pure returns (uint256 quoteAmount) {
1319	 uint160 sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);
1320	 if (sqrtRatioX96 <= type(uint128).max) {
1321	 uint256 ratioX192 = uint256(sqrtRatioX96) * sqrtRatioX96;
1322	 quoteAmount = baseToken < quoteToken ? FullMath.mulDiv(ratioX192, baseAmount, 1 << 192) : FullMath.mulDiv(1 << 192, baseAmount, ratioX192);
1323	 }
1324	 else {
1325	 uint256 ratioX128 = FullMath.mulDiv(sqrtRatioX96, sqrtRatioX96, 1 << 64);
1326	 quoteAmount = baseToken < quoteToken ? FullMath.mulDiv(ratioX128, baseAmount, 1 << 128) : FullMath.mulDiv(1 << 128, baseAmount, ratioX128);
1327	 }
1328	 }
1329	 function getOldestObservationSecondsAgo(address pool) internal view returns (uint32 secondsAgo) {
1330	 (, , uint16 observationIndex, uint16 observationCardinality, , , ) = IUniswapV3Pool(pool).slot0();
1331	 require(observationCardinality > 0, 'NI');
1332	 (uint32 observationTimestamp, , , bool initialized) = IUniswapV3Pool(pool).observations((observationIndex + 1) % observationCardinality);
1333	 if (!initialized) {
1334	 (observationTimestamp, , , ) = IUniswapV3Pool(pool).observations(0);
1335	 }
1336	 secondsAgo = uint32(block.timestamp) - observationTimestamp;
1337	 }
1338	 function getBlockStartingTickAndLiquidity(address pool) internal view returns (int24, uint128) {
1339	 (, int24 tick, uint16 observationIndex, uint16 observationCardinality, , , ) = IUniswapV3Pool(pool).slot0();
1340	 require(observationCardinality > 1, 'NEO');
1341	 (uint32 observationTimestamp, int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128, ) = IUniswapV3Pool(pool).observations(observationIndex);
1342	 if (observationTimestamp != uint32(block.timestamp)) {
1343	 return (tick, IUniswapV3Pool(pool).liquidity());
1344	 }
1345	 uint256 prevIndex = (uint256(observationIndex) + observationCardinality - 1) % observationCardinality;
1346	 ( uint32 prevObservationTimestamp, int56 prevTickCumulative, uint160 prevSecondsPerLiquidityCumulativeX128, bool prevInitialized ) = IUniswapV3Pool(pool).observations(prevIndex);
1347	 require(prevInitialized, 'ONI');
1348	 uint32 delta = observationTimestamp - prevObservationTimestamp;
1349	 tick = int24((tickCumulative - prevTickCumulative) / delta);
1350	 uint128 liquidity = uint128( (uint192(delta) * type(uint160).max) / (uint192(secondsPerLiquidityCumulativeX128 - prevSecondsPerLiquidityCumulativeX128) << 32) );
1351	 return (tick, liquidity);
1352	 }
1353	 struct WeightedTickData {
1354	 int24 tick;
1355	 uint128 weight;
1356	 }
1357	 function getWeightedArithmeticMeanTick(WeightedTickData[] memory weightedTickData) internal pure returns (int24 weightedArithmeticMeanTick) {
1358	 int256 numerator;
1359	 uint256 denominator;
1360	 for (uint256 i; i < weightedTickData.length; i++) {
1361	 numerator += weightedTickData[i].tick * int256(weightedTickData[i].weight);
1362	 denominator += weightedTickData[i].weight;
1363	 }
1364	 weightedArithmeticMeanTick = int24(numerator / int256(denominator));
1365	 if (numerator < 0 && (numerator % int256(denominator) != 0)) weightedArithmeticMeanTick--;
1366	 }
1367	 function getChainedPrice(address[] memory tokens, int24[] memory ticks) internal pure returns (int256 syntheticTick) {
1368	 require(tokens.length - 1 == ticks.length, 'DL');
1369	 for (uint256 i = 1; i <= ticks.length; i++) {
1370	 tokens[i - 1] < tokens[i] ? syntheticTick += ticks[i - 1] : syntheticTick -= ticks[i - 1];
1371	 }
1372	 }
1373	 }
1374	 pragma solidity 0.7.6;
1375	 library Math {
1376	 function min(uint256 x, uint256 y) internal pure returns (uint256 z) {
1377	 z = x < y ? x : y;
1378	 }
1379	 function max(uint256 x, uint256 y) internal pure returns (uint256 z) {
1380	 z = x > y ? x : y;
1381	 }
1382	 function sqrt(uint256 y) internal pure returns (uint256 z) {
1383	 if (y > 3) {
1384	 z = y;
1385	 uint256 x = y / 2 + 1;
1386	 while (x < z) {
1387	 z = x;
1388	 x = (y / x + x) / 2;
1389	 }
1390	 }
1391	 else if (y != 0) {
1392	 z = 1;
1393	 }
1394	 }
1395	 }
1396	 pragma solidity 0.7.6;
1397	 library TokenShares {
1398	 using SafeMath for uint256;
1399	 using TransferHelper for address;
1400	 uint256 private constant PRECISION = 10**18;
1401	 uint256 private constant TOLERANCE = 10**18 + 10**16;
1402	 event UnwrapFailed(address to, uint256 amount);
1403	 struct Data {
1404	 mapping(address => uint256) totalShares;
1405	 address weth;
1406	 }
1407	 function sharesToAmount( Data storage data, address token, uint256 share, uint256 amountLimit, address refundTo ) external returns (uint256) {
1408	 if (share == 0) {
1409	 return 0;
1410	 }
1411	 if (token == data.weth) {
1412	 return share;
1413	 }
1414	 uint256 totalTokenShares = data.totalShares[token];
1415	 require(totalTokenShares >= share, 'TS3A');
1416	 uint256 balance = IERC20(token).balanceOf(address(this));
1417	 uint256 value = balance.mul(share).div(totalTokenShares);
1418	 data.totalShares[token] = totalTokenShares.sub(share);
1419	 if (amountLimit > 0) {
1420	 uint256 amountLimitWithTolerance = amountLimit.mul(TOLERANCE).div(PRECISION);
1421	 if (value > amountLimitWithTolerance) {
1422	 TransferHelper.safeTransfer(token, refundTo, value.sub(amountLimitWithTolerance));
1423	 return amountLimitWithTolerance;
1424	 }
1425	 }
1426	 return value;
1427	 }
1428	 function amountToShares( Data storage data, address token, uint256 amount, bool wrap ) external returns (uint256) {
1429	 if (amount == 0) {
1430	 return 0;
1431	 }
1432	 if (token == data.weth) {
1433	 if (wrap) {
1434	 require(msg.value >= amount, 'TS03');
1435	 IWETH(token).deposit{
1436	 value: amount }
1437	 ();
1438	 }
1439	 else {
1440	 token.safeTransferFrom(msg.sender, address(this), amount);
1441	 }
1442	 return amount;
1443	 }
1444	 else {
1445	 uint256 balanceBefore = IERC20(token).balanceOf(address(this));
1446	 uint256 totalTokenShares = data.totalShares[token];
1447	 require(balanceBefore > 0 || totalTokenShares == 0, 'TS30');
1448	 if (totalTokenShares == 0) {
1449	 totalTokenShares = balanceBefore;
1450	 }
1451	 token.safeTransferFrom(msg.sender, address(this), amount);
1452	 uint256 balanceAfter = IERC20(token).balanceOf(address(this));
1453	 require(balanceAfter > balanceBefore, 'TS2C');
1454	 if (balanceBefore > 0) {
1455	 uint256 newShares = totalTokenShares.mul(balanceAfter).div(balanceBefore);
1456	 data.totalShares[token] = newShares;
1457	 return newShares - totalTokenShares;
1458	 }
1459	 else {
1460	 data.totalShares[token] = balanceAfter;
1461	 return balanceAfter;
1462	 }
1463	 }
1464	 }
1465	 function onUnwrapFailed( Data storage data, address to, uint256 amount ) external {
1466	 emit UnwrapFailed(to, amount);
1467	 IWETH(data.weth).deposit{
1468	 value: amount }
1469	 ();
1470	 TransferHelper.safeTransfer(data.weth, to, amount);
1471	 }
1472	 }
1473	 pragma solidity >=0.5.0 <0.8.0;
1474	 library TickMath {
1475	 int24 internal constant MIN_TICK = -887272;
1476	 int24 internal constant MAX_TICK = -MIN_TICK;
1477	 uint160 internal constant MIN_SQRT_RATIO = 4295128739;
1478	 uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;
1479	 function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {
1480	 uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));
1481	 require(absTick <= uint256(MAX_TICK), 'T');
1482	 uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;
1483	 if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;
1484	 if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;
1485	 if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;
1486	 if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;
1487	 if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;
1488	 if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;
1489	 if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;
1490	 if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;
1491	 if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;
1492	 if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;
1493	 if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;
1494	 if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;
1495	 if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;
1496	 if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;
1497	 if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;
1498	 if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;
1499	 if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;
1500	 if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;
1501	 if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;
1502	 if (tick > 0) ratio = type(uint256).max / ratio;
1503	 sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));
1504	 }
1505	 function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {
1506	 require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');
1507	 uint256 ratio = uint256(sqrtPriceX96) << 32;
1508	 uint256 r = ratio;
1509	 uint256 msb = 0;
1510	 assembly {
1511	 let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) msb := or(msb, f) r := shr(f, r) }
1512	 assembly {
1513	 let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF)) msb := or(msb, f) r := shr(f, r) }
1514	 assembly {
1515	 let f := shl(5, gt(r, 0xFFFFFFFF)) msb := or(msb, f) r := shr(f, r) }
1516	 assembly {
1517	 let f := shl(4, gt(r, 0xFFFF)) msb := or(msb, f) r := shr(f, r) }
1518	 assembly {
1519	 let f := shl(3, gt(r, 0xFF)) msb := or(msb, f) r := shr(f, r) }
1520	 assembly {
1521	 let f := shl(2, gt(r, 0xF)) msb := or(msb, f) r := shr(f, r) }
1522	 assembly {
1523	 let f := shl(1, gt(r, 0x3)) msb := or(msb, f) r := shr(f, r) }
1524	 assembly {
1525	 let f := gt(r, 0x1) msb := or(msb, f) }
1526	 if (msb >= 128) r = ratio >> (msb - 127);
1527	 else r = ratio << (127 - msb);
1528	 int256 log_2 = (int256(msb) - 128) << 64;
1529	 assembly {
1530	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(63, f)) r := shr(f, r) }
1531	 assembly {
1532	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(62, f)) r := shr(f, r) }
1533	 assembly {
1534	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(61, f)) r := shr(f, r) }
1535	 assembly {
1536	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(60, f)) r := shr(f, r) }
1537	 assembly {
1538	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(59, f)) r := shr(f, r) }
1539	 assembly {
1540	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(58, f)) r := shr(f, r) }
1541	 assembly {
1542	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(57, f)) r := shr(f, r) }
1543	 assembly {
1544	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(56, f)) r := shr(f, r) }
1545	 assembly {
1546	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(55, f)) r := shr(f, r) }
1547	 assembly {
1548	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(54, f)) r := shr(f, r) }
1549	 assembly {
1550	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(53, f)) r := shr(f, r) }
1551	 assembly {
1552	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(52, f)) r := shr(f, r) }
1553	 assembly {
1554	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(51, f)) r := shr(f, r) }
1555	 assembly {
1556	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(50, f)) }
1557	 int256 log_sqrt10001 = log_2 * 255738958999603826347141;
1558	 int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);
1559	 int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);
1560	 tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;
1561	 }
1562	 }
1563	 pragma solidity >=0.5.0;
1564	 interface IUniswapV3Pool is IUniswapV3PoolImmutables, IUniswapV3PoolState, IUniswapV3PoolDerivedState, IUniswapV3PoolActions, IUniswapV3PoolOwnerActions, IUniswapV3PoolEvents {
1565	 }
