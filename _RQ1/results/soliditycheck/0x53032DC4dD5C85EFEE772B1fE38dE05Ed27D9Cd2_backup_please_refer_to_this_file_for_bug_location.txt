row number 
1	  pragma experimental ABIEncoderV2;
2	 pragma solidity >=0.6.0 <0.8.0;
3	 abstract contract Context {
4	 function _msgSender() internal view virtual returns (address payable) {
5	 return msg.sender;
6	 }
7	 function _msgData() internal view virtual returns (bytes memory) {
8	 this;
9	 return msg.data;
10	 }
11	 }
12	 pragma solidity >=0.6.12;
13	 interface IVault {
14	 event Deposit(address indexed userAddrs, address indexed asset, uint256 amount);
15	 event Withdraw(address indexed userAddrs, address indexed asset, uint256 amount);
16	 event Borrow(address indexed userAddrs, address indexed asset, uint256 amount);
17	 event Payback(address indexed userAddrs, address indexed asset, uint256 amount);
18	 event SetActiveProvider(address providerAddr);
19	 event Switch( address vault, address fromProviderAddrs, address toProviderAddr, uint256 debtamount, uint256 collattamount );
20	 function deposit(uint256 _collateralAmount) external payable;
21	 function withdraw(int256 _withdrawAmount) external;
22	 function borrow(uint256 _borrowAmount) external;
23	 function payback(int256 _repayAmount) external payable;
24	 function executeSwitch( address _newProvider, uint256 _flashLoanDebt, uint256 _fee ) external;
25	 function activeProvider() external view returns (address);
26	 function borrowBalance(address _provider) external view returns (uint256);
27	 function depositBalance(address _provider) external view returns (uint256);
28	 function getNeededCollateralFor(uint256 _amount, bool _withFactors) external view returns (uint256);
29	 function getLiquidationBonusFor(uint256 _amount, bool _flash) external view returns (uint256);
30	 function getProviders() external view returns (address[] memory);
31	 function fujiERC1155() external view returns (address);
32	 function setActiveProvider(address _provider) external;
33	 function updateF1155Balances() external;
34	 }
35	 pragma solidity >=0.6.12;
36	 interface IFujiERC1155 {
37	 enum AssetType {
38	 collateralToken, debtToken }
39	 function getAssetID(AssetType _type, address _assetAddr) external view returns (uint256);
40	 function qtyOfManagedAssets() external view returns (uint64);
41	 function balanceOf(address _account, uint256 _id) external view returns (uint256);
42	 function mint( address _account, uint256 _id, uint256 _amount, bytes memory _data ) external;
43	 function burn( address _account, uint256 _id, uint256 _amount ) external;
44	 function updateState(uint256 _assetID, uint256 _newBalance) external;
45	 function addInitializeAsset(AssetType _type, address _addr) external returns (uint64);
46	 }
47	 pragma solidity >=0.6.0 <0.8.0;
48	 abstract contract Ownable is Context {
49	 address private _owner;
50	 event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
51	 constructor () internal {
52	 address msgSender = _msgSender();
53	 _owner = msgSender;
54	 emit OwnershipTransferred(address(0), msgSender);
55	 }
56	 function owner() public view virtual returns (address) {
57	 return _owner;
58	 }
59	 modifier onlyOwner() {
60	 require(owner() == _msgSender(), "Ownable: caller is not the owner");
61	 _;
62	 }
63	 function renounceOwnership() public virtual onlyOwner {
64	 emit OwnershipTransferred(_owner, address(0));
65	 _owner = address(0);
66	 }
67	 function transferOwnership(address newOwner) public virtual onlyOwner {
68	 require(newOwner != address(0), "Ownable: new owner is the zero address");
69	 emit OwnershipTransferred(_owner, newOwner);
70	 _owner = newOwner;
71	 }
72	 }
73	 pragma solidity >=0.6.0 <0.8.0;
74	 abstract contract ReentrancyGuard {
75	 uint256 private constant _NOT_ENTERED = 1;
76	 uint256 private constant _ENTERED = 2;
77	 uint256 private _status;
78	 constructor () internal {
79	 _status = _NOT_ENTERED;
80	 }
81	 modifier nonReentrant() {
82	 require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
83	 _status = _ENTERED;
84	 _;
85	 _status = _NOT_ENTERED;
86	 }
87	 }
88	 pragma solidity >=0.4.25 <0.7.5;
89	 interface IFlashLoanReceiver {
90	 function executeOperation( address[] calldata assets, uint256[] calldata amounts, uint256[] calldata premiums, address initiator, bytes calldata params ) external returns (bool);
91	 }
92	 interface ICallee {
93	 function callFunction( address sender, Account.Info memory accountInfo, bytes memory data ) external;
94	 }
95	 contract DyDxFlashloanBase {
96	 function _getMarketIdFromTokenAddress(ISoloMargin solo, address token) internal view returns (uint256) {
97	 uint256 numMarkets = solo.getNumMarkets();
98	 address curToken;
99	 for (uint256 i = 0; i < numMarkets; i++) {
100	 curToken = solo.getMarketTokenAddress(i);
101	 if (curToken == token) {
102	 return i;
103	 }
104	 }
105	 revert("No marketId found");
106	 }
107	 function _getAccountInfo(address receiver) internal pure returns (Account.Info memory) {
108	 return Account.Info({
109	 owner: receiver, number: 1 }
110	 );
111	 }
112	 function _getWithdrawAction(uint256 marketId, uint256 amount) internal view returns (Actions.ActionArgs memory) {
113	 return Actions.ActionArgs({
114	 actionType: Actions.ActionType.Withdraw, accountId: 0, amount: Types.AssetAmount({
115	 sign: false, denomination: Types.AssetDenomination.Wei, ref: Types.AssetReference.Delta, value: amount }
116	 ), primaryMarketId: marketId, secondaryMarketId: 0, otherAddress: address(this), otherAccountId: 0, data: "" }
117	 );
118	 }
119	 function _getCallAction(bytes memory data) internal view returns (Actions.ActionArgs memory) {
120	 return Actions.ActionArgs({
121	 actionType: Actions.ActionType.Call, accountId: 0, amount: Types.AssetAmount({
122	 sign: false, denomination: Types.AssetDenomination.Wei, ref: Types.AssetReference.Delta, value: 0 }
123	 ), primaryMarketId: 0, secondaryMarketId: 0, otherAddress: address(this), otherAccountId: 0, data: data }
124	 );
125	 }
126	 function _getDepositAction(uint256 marketId, uint256 amount) internal view returns (Actions.ActionArgs memory) {
127	 return Actions.ActionArgs({
128	 actionType: Actions.ActionType.Deposit, accountId: 0, amount: Types.AssetAmount({
129	 sign: true, denomination: Types.AssetDenomination.Wei, ref: Types.AssetReference.Delta, value: amount }
130	 ), primaryMarketId: marketId, secondaryMarketId: 0, otherAddress: address(this), otherAccountId: 0, data: "" }
131	 );
132	 }
133	 }
134	 pragma solidity >=0.4.25 <0.7.5;
135	 interface ICFlashloanReceiver {
136	 function executeOperation( address sender, address underlying, uint256 amount, uint256 fee, bytes calldata params ) external;
137	 }
138	 pragma solidity >=0.6.2;
139	 interface IUniswapV2Router01 {
140	 function factory() external pure returns (address);
141	 function WETH() external pure returns (address);
142	 function addLiquidity( address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline ) external returns (uint amountA, uint amountB, uint liquidity);
143	 function addLiquidityETH( address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
144	 function removeLiquidity( address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline ) external returns (uint amountA, uint amountB);
145	 function removeLiquidityETH( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) external returns (uint amountToken, uint amountETH);
146	 function removeLiquidityWithPermit( address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s ) external returns (uint amountA, uint amountB);
147	 function removeLiquidityETHWithPermit( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s ) external returns (uint amountToken, uint amountETH);
148	 function swapExactTokensForTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external returns (uint[] memory amounts);
149	 function swapTokensForExactTokens( uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline ) external returns (uint[] memory amounts);
150	 function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);
151	 function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);
152	 function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);
153	 function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);
154	 function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);
155	 function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);
156	 function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);
157	 function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);
158	 function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);
159	 }
160	 pragma solidity >=0.6.12;
161	 interface IVaultExt is IVault {
162	 struct VaultAssets {
163	 address collateralAsset;
164	 address borrowAsset;
165	 uint64 collateralID;
166	 uint64 borrowID;
167	 }
168	 function vAssets() external view returns (VaultAssets memory);
169	 }
170	 interface IFujiERC1155Ext is IFujiERC1155 {
171	 function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);
172	 }
173	 contract Fliquidator is Ownable, ReentrancyGuard {
174	 using SafeMath for uint256;
175	 using LibUniversalERC20 for IERC20;
176	 struct Factor {
177	 uint64 a;
178	 uint64 b;
179	 }
180	 Factor public flashCloseF;
181	 IFujiAdmin private _fujiAdmin;
182	 IUniswapV2Router02 public swapper;
183	 event Liquidate( address indexed userAddr, address liquidator, address indexed asset, uint256 amount );
184	 event FlashClose(address indexed userAddr, address indexed asset, uint256 amount);
185	 event FlashLiquidate(address userAddr, address liquidator, address indexed asset, uint256 amount);
186	 modifier isAuthorized() {
187	 require(msg.sender == owner(), Errors.VL_NOT_AUTHORIZED);
188	 _;
189	 }
190	 modifier onlyFlash() {
191	 require(msg.sender == _fujiAdmin.getFlasher(), Errors.VL_NOT_AUTHORIZED);
192	 _;
193	 }
194	 modifier isValidVault(address _vaultAddr) {
195	 require(_fujiAdmin.validVault(_vaultAddr), "Invalid vault!");
196	 _;
197	 }
198	 constructor() public {
199	 flashCloseF.a = 1013;
200	 flashCloseF.b = 1000;
201	 }
202	 receive() external payable {
203	 }
204	 function batchLiquidate(address[] calldata _userAddrs, address _vault) external nonReentrant isValidVault(_vault) {
205	 IVault(_vault).updateF1155Balances();
206	 IFujiERC1155Ext f1155 = IFujiERC1155Ext(IVault(_vault).fujiERC1155());
207	 IVaultExt.VaultAssets memory vAssets = IVaultExt(_vault).vAssets();
208	 address[] memory formattedUserAddrs = new address[](2 * _userAddrs.length);
209	 uint256[] memory formattedIds = new uint256[](2 * _userAddrs.length);
210	 for (uint256 i = 0; i < _userAddrs.length; i++) {
211	 formattedUserAddrs[2 * i] = _userAddrs[i];
212	 formattedUserAddrs[2 * i + 1] = _userAddrs[i];
213	 formattedIds[2 * i] = vAssets.collateralID;
214	 formattedIds[2 * i + 1] = vAssets.borrowID;
215	 }
216	 uint256[] memory usrsBals = f1155.balanceOfBatch(formattedUserAddrs, formattedIds);
217	 uint256 neededCollateral;
218	 uint256 debtBalanceTotal;
219	 for (uint256 i = 0; i < formattedUserAddrs.length; i += 2) {
220	 neededCollateral = IVault(_vault).getNeededCollateralFor(usrsBals[i + 1], true);
221	 if (usrsBals[i] < neededCollateral) {
222	 debtBalanceTotal = debtBalanceTotal.add(usrsBals[i + 1]);
223	 }
224	 else {
225	 formattedUserAddrs[i] = address(0);
226	 formattedUserAddrs[i + 1] = address(0);
227	 }
228	 }
229	 require(debtBalanceTotal > 0, Errors.VL_USER_NOT_LIQUIDATABLE);
230	 require( IERC20(vAssets.borrowAsset).allowance(msg.sender, address(this)) >= debtBalanceTotal, Errors.VL_MISSING_ERC20_ALLOWANCE );
231	 IERC20(vAssets.borrowAsset).transferFrom(msg.sender, address(this), debtBalanceTotal);
232	 IERC20(vAssets.borrowAsset).univTransfer(payable(_vault), debtBalanceTotal);
233	 IVault(_vault).payback(int256(debtBalanceTotal));
234	 uint256 globalBonus = IVault(_vault).getLiquidationBonusFor(debtBalanceTotal, false);
235	 uint256 globalCollateralInPlay = _getCollateralInPlay(vAssets.borrowAsset, debtBalanceTotal.add(globalBonus));
236	 _burnMultiLoop(formattedUserAddrs, usrsBals, IVault(_vault), f1155, vAssets);
237	 IVault(_vault).withdraw(int256(globalCollateralInPlay));
238	 _swap(vAssets.borrowAsset, debtBalanceTotal.add(globalBonus), globalCollateralInPlay);
239	 IERC20(vAssets.borrowAsset).univTransfer(msg.sender, debtBalanceTotal.add(globalBonus));
240	 for (uint256 i = 0; i < formattedUserAddrs.length; i += 2) {
241	 if (formattedUserAddrs[i] != address(0)) {
242	 f1155.burn(formattedUserAddrs[i], vAssets.borrowID, usrsBals[i + 1]);
243	 emit Liquidate(formattedUserAddrs[i], msg.sender, vAssets.borrowAsset, usrsBals[i + 1]);
244	 }
245	 }
246	 }
247	 function flashClose( int256 _amount, address _vault, uint8 _flashnum ) external nonReentrant isValidVault(_vault) {
248	 Flasher flasher = Flasher(payable(_fujiAdmin.getFlasher()));
249	 IVault(_vault).updateF1155Balances();
250	 IFujiERC1155Ext f1155 = IFujiERC1155Ext(IVault(_vault).fujiERC1155());
251	 IVaultExt.VaultAssets memory vAssets = IVaultExt(_vault).vAssets();
252	 uint256 userCollateral = f1155.balanceOf(msg.sender, vAssets.collateralID);
253	 uint256 userDebtBalance = f1155.balanceOf(msg.sender, vAssets.borrowID);
254	 require(userDebtBalance > 0, Errors.VL_NO_DEBT_TO_PAYBACK);
255	 uint256 amount = _amount < 0 ? userDebtBalance : uint256(_amount);
256	 uint256 neededCollateral = IVault(_vault).getNeededCollateralFor(amount, false);
257	 require(userCollateral >= neededCollateral, Errors.VL_UNDERCOLLATERIZED_ERROR);
258	 address[] memory userAddressArray = new address[](1);
259	 userAddressArray[0] = msg.sender;
260	 FlashLoan.Info memory info = FlashLoan.Info({
261	 callType: FlashLoan.CallType.Close, asset: vAssets.borrowAsset, amount: amount, vault: _vault, newProvider: address(0), userAddrs: userAddressArray, userBalances: new uint256[](0), userliquidator: address(0), fliquidator: address(this) }
262	 );
263	 flasher.initiateFlashloan(info, _flashnum);
264	 }
265	 function executeFlashClose( address payable _userAddr, address _vault, uint256 _amount, uint256 _flashloanFee ) external onlyFlash {
266	 IFujiERC1155 f1155 = IFujiERC1155(IVault(_vault).fujiERC1155());
267	 IVaultExt.VaultAssets memory vAssets = IVaultExt(_vault).vAssets();
268	 uint256 userCollateral = f1155.balanceOf(_userAddr, vAssets.collateralID);
269	 uint256 userDebtBalance = f1155.balanceOf(_userAddr, vAssets.borrowID);
270	 uint256 userCollateralInPlay = IVault(_vault) .getNeededCollateralFor(_amount.add(_flashloanFee), false) .mul(flashCloseF.a) .div(flashCloseF.b);
271	 IVault(_vault).payback(int256(_amount));
272	 if (_amount == userDebtBalance) {
273	 f1155.burn(_userAddr, vAssets.collateralID, userCollateral);
274	 IVault(_vault).withdraw(int256(userCollateral));
275	 IERC20(vAssets.collateralAsset).univTransfer( _userAddr, userCollateral.sub(userCollateralInPlay) );
276	 }
277	 else {
278	 f1155.burn(_userAddr, vAssets.collateralID, userCollateralInPlay);
279	 IVault(_vault).withdraw(int256(userCollateralInPlay));
280	 }
281	 uint256 remaining = _swap(vAssets.borrowAsset, _amount.add(_flashloanFee), userCollateralInPlay);
282	 IERC20(vAssets.collateralAsset).univTransfer(_fujiAdmin.getTreasury(), remaining);
283	 IERC20(vAssets.borrowAsset).univTransfer( payable(_fujiAdmin.getFlasher()), _amount.add(_flashloanFee) );
284	 f1155.burn(_userAddr, vAssets.borrowID, _amount);
285	 emit FlashClose(_userAddr, vAssets.borrowAsset, userDebtBalance);
286	 }
287	 function flashBatchLiquidate( address[] calldata _userAddrs, address _vault, uint8 _flashnum ) external isValidVault(_vault) nonReentrant {
288	 IVault(_vault).updateF1155Balances();
289	 IFujiERC1155Ext f1155 = IFujiERC1155Ext(IVault(_vault).fujiERC1155());
290	 IVaultExt.VaultAssets memory vAssets = IVaultExt(_vault).vAssets();
291	 address[] memory formattedUserAddrs = new address[](2 * _userAddrs.length);
292	 uint256[] memory formattedIds = new uint256[](2 * _userAddrs.length);
293	 for (uint256 i = 0; i < _userAddrs.length; i++) {
294	 formattedUserAddrs[2 * i] = _userAddrs[i];
295	 formattedUserAddrs[2 * i + 1] = _userAddrs[i];
296	 formattedIds[2 * i] = vAssets.collateralID;
297	 formattedIds[2 * i + 1] = vAssets.borrowID;
298	 }
299	 uint256[] memory usrsBals = f1155.balanceOfBatch(formattedUserAddrs, formattedIds);
300	 uint256 neededCollateral;
301	 uint256 debtBalanceTotal;
302	 for (uint256 i = 0; i < formattedUserAddrs.length; i += 2) {
303	 neededCollateral = IVault(_vault).getNeededCollateralFor(usrsBals[i + 1], true);
304	 if (usrsBals[i] < neededCollateral) {
305	 debtBalanceTotal = debtBalanceTotal.add(usrsBals[i + 1]);
306	 }
307	 else {
308	 formattedUserAddrs[i] = address(0);
309	 formattedUserAddrs[i + 1] = address(0);
310	 }
311	 }
312	 require(debtBalanceTotal > 0, Errors.VL_USER_NOT_LIQUIDATABLE);
313	 Flasher flasher = Flasher(payable(_fujiAdmin.getFlasher()));
314	 FlashLoan.Info memory info = FlashLoan.Info({
315	 callType: FlashLoan.CallType.BatchLiquidate, asset: vAssets.borrowAsset, amount: debtBalanceTotal, vault: _vault, newProvider: address(0), userAddrs: formattedUserAddrs, userBalances: usrsBals, userliquidator: msg.sender, fliquidator: address(this) }
316	 );
317	 flasher.initiateFlashloan(info, _flashnum);
318	 }
319	 function executeFlashBatchLiquidation( address[] calldata _userAddrs, uint256[] calldata _usrsBals, address _liquidatorAddr, address _vault, uint256 _amount, uint256 _flashloanFee ) external onlyFlash {
320	 IFujiERC1155 f1155 = IFujiERC1155(IVault(_vault).fujiERC1155());
321	 IVaultExt.VaultAssets memory vAssets = IVaultExt(_vault).vAssets();
322	 IVault(_vault).payback(int256(_amount));
323	 uint256 globalBonus = IVault(_vault).getLiquidationBonusFor(_amount, true);
324	 uint256 globalCollateralInPlay = _getCollateralInPlay(vAssets.borrowAsset, _amount.add(_flashloanFee).add(globalBonus));
325	 _burnMultiLoop(_userAddrs, _usrsBals, IVault(_vault), f1155, vAssets);
326	 IVault(_vault).withdraw(int256(globalCollateralInPlay));
327	 _swap(vAssets.borrowAsset, _amount.add(_flashloanFee).add(globalBonus), globalCollateralInPlay);
328	 IERC20(vAssets.borrowAsset).univTransfer( payable(_fujiAdmin.getFlasher()), _amount.add(_flashloanFee) );
329	 IERC20(vAssets.borrowAsset).univTransfer( payable(_liquidatorAddr), globalBonus.sub(_flashloanFee) );
330	 for (uint256 i = 0; i < _userAddrs.length; i += 2) {
331	 if (_userAddrs[i] != address(0)) {
332	 f1155.burn(_userAddrs[i], vAssets.borrowID, _usrsBals[i + 1]);
333	 emit FlashLiquidate(_userAddrs[i], _liquidatorAddr, vAssets.borrowAsset, _usrsBals[i + 1]);
334	 }
335	 }
336	 }
337	 function _swap( address _borrowAsset, uint256 _amountToReceive, uint256 _collateralAmount ) internal returns (uint256) {
338	 address[] memory path = new address[](2);
339	 path[0] = swapper.WETH();
340	 path[1] = _borrowAsset;
341	 uint256[] memory swapperAmounts = swapper.swapETHForExactTokens{
342	 value: _collateralAmount }
343	 ( _amountToReceive, path, address(this), block.timestamp );
344	 return _collateralAmount.sub(swapperAmounts[0]);
345	 }
346	 function _getCollateralInPlay(address _borrowAsset, uint256 _amountToReceive) internal view returns (uint256) {
347	 address[] memory path = new address[](2);
348	 path[0] = swapper.WETH();
349	 path[1] = _borrowAsset;
350	 uint256[] memory amounts = swapper.getAmountsIn(_amountToReceive, path);
351	 return amounts[0];
352	 }
353	 function _burnMultiLoop( address[] memory _userAddrs, uint256[] memory _usrsBals, IVault _vault, IFujiERC1155 _f1155, IVaultExt.VaultAssets memory _vAssets ) internal {
354	 uint256 bonusPerUser;
355	 uint256 collateralInPlayPerUser;
356	 for (uint256 i = 0; i < _userAddrs.length; i += 2) {
357	 if (_userAddrs[i] != address(0)) {
358	 bonusPerUser = _vault.getLiquidationBonusFor(_usrsBals[i + 1], true);
359	 collateralInPlayPerUser = _getCollateralInPlay( _vAssets.borrowAsset, _usrsBals[i + 1].add(bonusPerUser) );
360	 _f1155.burn(_userAddrs[i], _vAssets.collateralID, collateralInPlayPerUser);
361	 }
362	 }
363	 }
364	 function setFlashCloseFee(uint64 _newFactorA, uint64 _newFactorB) external isAuthorized {
365	 flashCloseF.a = _newFactorA;
366	 flashCloseF.b = _newFactorB;
367	 }
368	 function setFujiAdmin(address _newFujiAdmin) external isAuthorized {
369	 _fujiAdmin = IFujiAdmin(_newFujiAdmin);
370	 }
371	 function setSwapper(address _newSwapper) external isAuthorized {
372	 swapper = IUniswapV2Router02(_newSwapper);
373	 }
374	 }
375	 pragma solidity >=0.6.12 <0.8.0;
376	 interface IFujiAdmin {
377	 function validVault(address _vaultAddr) external view returns (bool);
378	 function getFlasher() external view returns (address);
379	 function getFliquidator() external view returns (address);
380	 function getController() external view returns (address);
381	 function getTreasury() external view returns (address payable);
382	 function getaWhiteList() external view returns (address);
383	 function getVaultHarvester() external view returns (address);
384	 function getBonusFlashL() external view returns (uint64, uint64);
385	 function getBonusLiq() external view returns (uint64, uint64);
386	 }
387	 pragma solidity >=0.6.0 <0.8.0;
388	 interface IERC20 {
389	 function totalSupply() external view returns (uint256);
390	 function balanceOf(address account) external view returns (uint256);
391	 function transfer(address recipient, uint256 amount) external returns (bool);
392	 function allowance(address owner, address spender) external view returns (uint256);
393	 function approve(address spender, uint256 amount) external returns (bool);
394	 function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
395	 event Transfer(address indexed from, address indexed to, uint256 value);
396	 event Approval(address indexed owner, address indexed spender, uint256 value);
397	 }
398	 pragma solidity >=0.6.12 <0.8.0;
399	 interface IFliquidator {
400	 function executeFlashClose( address _userAddr, address _vault, uint256 _amount, uint256 _flashloanfee ) external;
401	 function executeFlashBatchLiquidation( address[] calldata _userAddrs, uint256[] calldata _usrsBals, address _liquidatorAddr, address _vault, uint256 _amount, uint256 _flashloanFee ) external;
402	 }
403	 interface IFujiMappings {
404	 function addressMapping(address) external view returns (address);
405	 }
406	 contract Flasher is DyDxFlashloanBase, IFlashLoanReceiver, ICFlashloanReceiver, ICallee, Ownable {
407	 using SafeMath for uint256;
408	 using UniERC20 for IERC20;
409	 IFujiAdmin private _fujiAdmin;
410	 address private immutable _aaveLendingPool = 0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9;
411	 address private immutable _dydxSoloMargin = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;
412	 IFujiMappings private immutable _crMappings = IFujiMappings(0x03BD587Fe413D59A20F32Fc75f31bDE1dD1CD6c9);
413	 receive() external payable {
414	 }
415	 modifier isAuthorized() {
416	 require( msg.sender == _fujiAdmin.getController() || msg.sender == _fujiAdmin.getFliquidator() || msg.sender == owner(), Errors.VL_NOT_AUTHORIZED );
417	 _;
418	 }
419	 function setFujiAdmin(address _newFujiAdmin) public onlyOwner {
420	 _fujiAdmin = IFujiAdmin(_newFujiAdmin);
421	 }
422	 function initiateFlashloan(FlashLoan.Info calldata info, uint8 _flashnum) external isAuthorized {
423	 if (_flashnum == 0) {
424	 _initiateAaveFlashLoan(info);
425	 }
426	 else if (_flashnum == 1) {
427	 _initiateDyDxFlashLoan(info);
428	 }
429	 else if (_flashnum == 2) {
430	 _initiateCreamFlashLoan(info);
431	 }
432	 }
433	 function _initiateDyDxFlashLoan(FlashLoan.Info calldata info) internal {
434	 ISoloMargin solo = ISoloMargin(_dydxSoloMargin);
435	 uint256 marketId = _getMarketIdFromTokenAddress(solo, info.asset);
436	 Actions.ActionArgs[] memory operations = new Actions.ActionArgs[](3);
437	 operations[0] = _getWithdrawAction(marketId, info.amount);
438	 operations[1] = _getCallAction(abi.encode(info));
439	 operations[2] = _getDepositAction(marketId, info.amount.add(2));
440	 Account.Info[] memory accountInfos = new Account.Info[](1);
441	 accountInfos[0] = _getAccountInfo(address(this));
442	 solo.operate(accountInfos, operations);
443	 }
444	 function callFunction( address sender, Account.Info calldata account, bytes calldata data ) external override {
445	 require(msg.sender == _dydxSoloMargin && sender == address(this), Errors.VL_NOT_AUTHORIZED);
446	 account;
447	 FlashLoan.Info memory info = abi.decode(data, (FlashLoan.Info));
448	 uint256 amountOwing = info.amount.add(2);
449	 IERC20(info.asset).uniTransfer(payable(info.vault), info.amount);
450	 if (info.callType == FlashLoan.CallType.Switch) {
451	 IVault(info.vault).executeSwitch(info.newProvider, info.amount, 2);
452	 }
453	 else if (info.callType == FlashLoan.CallType.Close) {
454	 IFliquidator(info.fliquidator).executeFlashClose( info.userAddrs[0], info.vault, info.amount, 2 );
455	 }
456	 else {
457	 IFliquidator(info.fliquidator).executeFlashBatchLiquidation( info.userAddrs, info.userBalances, info.userliquidator, info.vault, info.amount, 2 );
458	 }
459	 IERC20(info.asset).approve(_dydxSoloMargin, amountOwing);
460	 }
461	 function _initiateAaveFlashLoan(FlashLoan.Info calldata info) internal {
462	 ILendingPool aaveLp = ILendingPool(_aaveLendingPool);
463	 address receiverAddress = address(this);
464	 address[] memory assets = new address[](1);
465	 assets[0] = address(info.asset);
466	 uint256[] memory amounts = new uint256[](1);
467	 amounts[0] = info.amount;
468	 uint256[] memory modes = new uint256[](1);
469	 aaveLp.flashLoan(receiverAddress, assets, amounts, modes, address(this), abi.encode(info), 0);
470	 }
471	 function executeOperation( address[] calldata assets, uint256[] calldata amounts, uint256[] calldata premiums, address initiator, bytes calldata params ) external override returns (bool) {
472	 require(msg.sender == _aaveLendingPool && initiator == address(this), Errors.VL_NOT_AUTHORIZED);
473	 FlashLoan.Info memory info = abi.decode(params, (FlashLoan.Info));
474	 uint256 amountOwing = amounts[0].add(premiums[0]);
475	 IERC20(assets[0]).uniTransfer(payable(info.vault), amounts[0]);
476	 if (info.callType == FlashLoan.CallType.Switch) {
477	 IVault(info.vault).executeSwitch(info.newProvider, amounts[0], premiums[0]);
478	 }
479	 else if (info.callType == FlashLoan.CallType.Close) {
480	 IFliquidator(info.fliquidator).executeFlashClose( info.userAddrs[0], info.vault, amounts[0], premiums[0] );
481	 }
482	 else {
483	 IFliquidator(info.fliquidator).executeFlashBatchLiquidation( info.userAddrs, info.userBalances, info.userliquidator, info.vault, amounts[0], premiums[0] );
484	 }
485	 IERC20(assets[0]).uniApprove(payable(_aaveLendingPool), amountOwing);
486	 return true;
487	 }
488	 function _initiateCreamFlashLoan(FlashLoan.Info calldata info) internal {
489	 address crToken = _crMappings.addressMapping(info.asset);
490	 bytes memory params = abi.encode(info);
491	 ICTokenFlashloan(crToken).flashLoan(address(this), info.amount, params);
492	 }
493	 function executeOperation( address sender, address underlying, uint256 amount, uint256 fee, bytes calldata params ) external override {
494	 address crToken = _crMappings.addressMapping(underlying);
495	 require(msg.sender == crToken && address(this) == sender, Errors.VL_NOT_AUTHORIZED);
496	 require(IERC20(underlying).balanceOf(address(this)) >= amount, Errors.VL_FLASHLOAN_FAILED);
497	 FlashLoan.Info memory info = abi.decode(params, (FlashLoan.Info));
498	 uint256 amountOwing = amount.add(fee);
499	 IERC20(underlying).uniTransfer(payable(info.vault), amount);
500	 if (info.callType == FlashLoan.CallType.Switch) {
501	 IVault(info.vault).executeSwitch(info.newProvider, amount, fee);
502	 }
503	 else if (info.callType == FlashLoan.CallType.Close) {
504	 IFliquidator(info.fliquidator).executeFlashClose(info.userAddrs[0], info.vault, amount, fee);
505	 }
506	 else {
507	 IFliquidator(info.fliquidator).executeFlashBatchLiquidation( info.userAddrs, info.userBalances, info.userliquidator, info.vault, amount, fee );
508	 }
509	 IERC20(underlying).uniTransfer(payable(crToken), amountOwing);
510	 }
511	 }
512	 pragma solidity >=0.4.25 <0.7.5;
513	 library FlashLoan {
514	 enum CallType {
515	 Switch, Close, BatchLiquidate }
516	 struct Info {
517	 CallType callType;
518	 address asset;
519	 uint256 amount;
520	 address vault;
521	 address newProvider;
522	 address[] userAddrs;
523	 uint256[] userBalances;
524	 address userliquidator;
525	 address fliquidator;
526	 }
527	 }
528	 pragma solidity <0.8.0;
529	 library Errors {
530	 string public constant VL_INDEX_OVERFLOW = "100";
531	 string public constant VL_INVALID_MINT_AMOUNT = "101";
532	 string public constant VL_INVALID_BURN_AMOUNT = "102";
533	 string public constant VL_AMOUNT_ERROR = "103";
534	 string public constant VL_INVALID_WITHDRAW_AMOUNT = "104";
535	 string public constant VL_INVALID_BORROW_AMOUNT = "105";
536	 string public constant VL_NO_DEBT_TO_PAYBACK = "106";
537	 string public constant VL_MISSING_ERC20_ALLOWANCE = "107";
538	 string public constant VL_USER_NOT_LIQUIDATABLE = "108";
539	 string public constant VL_DEBT_LESS_THAN_AMOUNT = "109";
540	 string public constant VL_PROVIDER_ALREADY_ADDED = "110";
541	 string public constant VL_NOT_AUTHORIZED = "111";
542	 string public constant VL_INVALID_COLLATERAL = "112";
543	 string public constant VL_NO_ERC20_BALANCE = "113";
544	 string public constant VL_INPUT_ERROR = "114";
545	 string public constant VL_ASSET_EXISTS = "115";
546	 string public constant VL_ZERO_ADDR_1155 = "116";
547	 string public constant VL_NOT_A_CONTRACT = "117";
548	 string public constant VL_INVALID_ASSETID_1155 = "118";
549	 string public constant VL_NO_ERC1155_BALANCE = "119";
550	 string public constant VL_MISSING_ERC1155_APPROVAL = "120";
551	 string public constant VL_RECEIVER_REJECT_1155 = "121";
552	 string public constant VL_RECEIVER_CONTRACT_NON_1155 = "122";
553	 string public constant VL_OPTIMIZER_FEE_SMALL = "123";
554	 string public constant VL_UNDERCOLLATERIZED_ERROR = "124";
555	 string public constant VL_MINIMUM_PAYBACK_ERROR = "125";
556	 string public constant VL_HARVESTING_FAILED = "126";
557	 string public constant VL_FLASHLOAN_FAILED = "127";
558	 string public constant MATH_DIVISION_BY_ZERO = "201";
559	 string public constant MATH_ADDITION_OVERFLOW = "202";
560	 string public constant MATH_MULTIPLICATION_OVERFLOW = "203";
561	 string public constant RF_NO_GREENLIGHT = "300";
562	 string public constant RF_INVALID_RATIO_VALUES = "301";
563	 string public constant RF_CHECK_RATES_FALSE = "302";
564	 string public constant VLT_CALLER_MUST_BE_VAULT = "401";
565	 string public constant SP_ALPHA_WHITELIST = "901";
566	 }
567	 pragma solidity >=0.6.0 <0.8.0;
568	 library SafeMath {
569	 function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
570	 uint256 c = a + b;
571	 if (c < a) return (false, 0);
572	 return (true, c);
573	 }
574	 function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
575	 if (b > a) return (false, 0);
576	 return (true, a - b);
577	 }
578	 function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
579	 if (a == 0) return (true, 0);
580	 uint256 c = a * b;
581	 if (c / a != b) return (false, 0);
582	 return (true, c);
583	 }
584	 function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
585	 if (b == 0) return (false, 0);
586	 return (true, a / b);
587	 }
588	 function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
589	 if (b == 0) return (false, 0);
590	 return (true, a % b);
591	 }
592	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
593	 uint256 c = a + b;
594	 require(c >= a, "SafeMath: addition overflow");
595	 return c;
596	 }
597	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
598	 require(b <= a, "SafeMath: subtraction overflow");
599	 return a - b;
600	 }
601	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
602	 if (a == 0) return 0;
603	 uint256 c = a * b;
604	 require(c / a == b, "SafeMath: multiplication overflow");
605	 return c;
606	 }
607	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
608	 require(b > 0, "SafeMath: division by zero");
609	 return a / b;
610	 }
611	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
612	 require(b > 0, "SafeMath: modulo by zero");
613	 return a % b;
614	 }
615	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
616	 require(b <= a, errorMessage);
617	 return a - b;
618	 }
619	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
620	 require(b > 0, errorMessage);
621	 return a / b;
622	 }
623	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
624	 require(b > 0, errorMessage);
625	 return a % b;
626	 }
627	 }
628	 pragma solidity ^0.6.12;
629	 library LibUniversalERC20 {
630	 using SafeERC20 for IERC20;
631	 IERC20 private constant _ETH_ADDRESS = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);
632	 IERC20 private constant _ZERO_ADDRESS = IERC20(0);
633	 function isETH(IERC20 token) internal pure returns (bool) {
634	 return (token == _ZERO_ADDRESS || token == _ETH_ADDRESS);
635	 }
636	 function univBalanceOf(IERC20 token, address account) internal view returns (uint256) {
637	 if (isETH(token)) {
638	 return account.balance;
639	 }
640	 else {
641	 return token.balanceOf(account);
642	 }
643	 }
644	 function univTransfer( IERC20 token, address payable to, uint256 amount ) internal {
645	 if (amount > 0) {
646	 if (isETH(token)) {
647	 (bool sent, ) = to.call{
648	 value: amount }
649	 ("");
650	 require(sent, "Failed to send Ether");
651	 }
652	 else {
653	 token.safeTransfer(to, amount);
654	 }
655	 }
656	 }
657	 function univApprove( IERC20 token, address to, uint256 amount ) internal {
658	 require(!isETH(token), "Approve called on ETH");
659	 if (amount == 0) {
660	 token.safeApprove(to, 0);
661	 }
662	 else {
663	 uint256 allowance = token.allowance(address(this), to);
664	 if (allowance < amount) {
665	 if (allowance > 0) {
666	 token.safeApprove(to, 0);
667	 }
668	 token.safeApprove(to, amount);
669	 }
670	 }
671	 }
672	 }
673	 pragma solidity >=0.6.2;
674	 interface IUniswapV2Router02 is IUniswapV2Router01 {
675	 function removeLiquidityETHSupportingFeeOnTransferTokens( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) external returns (uint amountETH);
676	 function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s ) external returns (uint amountETH);
677	 function swapExactTokensForTokensSupportingFeeOnTransferTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external;
678	 function swapExactETHForTokensSupportingFeeOnTransferTokens( uint amountOutMin, address[] calldata path, address to, uint deadline ) external payable;
679	 function swapExactTokensForETHSupportingFeeOnTransferTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external;
680	 }
681	 pragma solidity ^0.6.12;
682	 library UniERC20 {
683	 using SafeERC20 for IERC20;
684	 IERC20 private constant _ETH_ADDRESS = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);
685	 IERC20 private constant _ZERO_ADDRESS = IERC20(0);
686	 function isETH(IERC20 token) internal pure returns (bool) {
687	 return (token == _ZERO_ADDRESS || token == _ETH_ADDRESS);
688	 }
689	 function uniBalanceOf(IERC20 token, address account) internal view returns (uint256) {
690	 if (isETH(token)) {
691	 return account.balance;
692	 }
693	 else {
694	 return token.balanceOf(account);
695	 }
696	 }
697	 function uniTransfer( IERC20 token, address payable to, uint256 amount ) internal {
698	 if (amount > 0) {
699	 if (isETH(token)) {
700	 to.transfer(amount);
701	 }
702	 else {
703	 token.safeTransfer(to, amount);
704	 }
705	 }
706	 }
707	 function uniApprove( IERC20 token, address to, uint256 amount ) internal {
708	 require(!isETH(token), "Approve called on ETH");
709	 if (amount == 0) {
710	 token.safeApprove(to, 0);
711	 }
712	 else {
713	 uint256 allowance = token.allowance(address(this), to);
714	 if (allowance < amount) {
715	 if (allowance > 0) {
716	 token.safeApprove(to, 0);
717	 }
718	 token.safeApprove(to, amount);
719	 }
720	 }
721	 }
722	 }
723	 interface ILendingPool {
724	 function flashLoan( address receiverAddress, address[] calldata assets, uint256[] calldata amounts, uint256[] calldata modes, address onBehalfOf, bytes calldata params, uint16 referralCode ) external;
725	 }
726	 pragma solidity >=0.4.25 <0.7.5;
727	 library Account {
728	 enum Status {
729	 Normal, Liquid, Vapor }
730	 struct Info {
731	 address owner;
732	 uint256 number;
733	 }
734	 }
735	 library Actions {
736	 enum ActionType {
737	 Deposit, Withdraw, Transfer, Buy, Sell, Trade, Liquidate, Vaporize, Call }
738	 struct ActionArgs {
739	 ActionType actionType;
740	 uint256 accountId;
741	 Types.AssetAmount amount;
742	 uint256 primaryMarketId;
743	 uint256 secondaryMarketId;
744	 address otherAddress;
745	 uint256 otherAccountId;
746	 bytes data;
747	 }
748	 }
749	 library Types {
750	 enum AssetDenomination {
751	 Wei, Par }
752	 enum AssetReference {
753	 Delta, Target }
754	 struct AssetAmount {
755	 bool sign;
756	 AssetDenomination denomination;
757	 AssetReference ref;
758	 uint256 value;
759	 }
760	 }
761	 interface ISoloMargin {
762	 function getNumMarkets() external view returns (uint256);
763	 function getMarketTokenAddress(uint256 marketId) external view returns (address);
764	 function operate(Account.Info[] memory accounts, Actions.ActionArgs[] memory actions) external;
765	 }
766	 interface ICTokenFlashloan {
767	 function flashLoan( address receiver, uint256 amount, bytes calldata params ) external;
768	 }
769	 pragma solidity >=0.6.0 <0.8.0;
770	 library SafeERC20 {
771	 using SafeMath for uint256;
772	 using Address for address;
773	 function safeTransfer(IERC20 token, address to, uint256 value) internal {
774	 _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
775	 }
776	 function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
777	 _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
778	 }
779	 function safeApprove(IERC20 token, address spender, uint256 value) internal {
780	 require((value == 0) || (token.allowance(address(this), spender) == 0), "SafeERC20: approve from non-zero to non-zero allowance" );
781	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
782	 }
783	 function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
784	 uint256 newAllowance = token.allowance(address(this), spender).add(value);
785	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
786	 }
787	 function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
788	 uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
789	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
790	 }
791	 function _callOptionalReturn(IERC20 token, bytes memory data) private {
792	 bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
793	 if (returndata.length > 0) {
794	 require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
795	 }
796	 }
797	 }
798	 pragma solidity >=0.6.2 <0.8.0;
799	 library Address {
800	 function isContract(address account) internal view returns (bool) {
801	 uint256 size;
802	 assembly {
803	 size := extcodesize(account) }
804	 return size > 0;
805	 }
806	 function sendValue(address payable recipient, uint256 amount) internal {
807	 require(address(this).balance >= amount, "Address: insufficient balance");
808	 (bool success, ) = recipient.call{
809	 value: amount }
810	 ("");
811	 require(success, "Address: unable to send value, recipient may have reverted");
812	 }
813	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
814	 return functionCall(target, data, "Address: low-level call failed");
815	 }
816	 function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
817	 return functionCallWithValue(target, data, 0, errorMessage);
818	 }
819	 function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
820	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
821	 }
822	 function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
823	 require(address(this).balance >= value, "Address: insufficient balance for call");
824	 require(isContract(target), "Address: call to non-contract");
825	 (bool success, bytes memory returndata) = target.call{
826	 value: value }
827	 (data);
828	 return _verifyCallResult(success, returndata, errorMessage);
829	 }
830	 function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
831	 return functionStaticCall(target, data, "Address: low-level static call failed");
832	 }
833	 function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
834	 require(isContract(target), "Address: static call to non-contract");
835	 (bool success, bytes memory returndata) = target.staticcall(data);
836	 return _verifyCallResult(success, returndata, errorMessage);
837	 }
838	 function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
839	 return functionDelegateCall(target, data, "Address: low-level delegate call failed");
840	 }
841	 function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
842	 require(isContract(target), "Address: delegate call to non-contract");
843	 (bool success, bytes memory returndata) = target.delegatecall(data);
844	 return _verifyCallResult(success, returndata, errorMessage);
845	 }
846	 function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
847	 if (success) {
848	 return returndata;
849	 }
850	 else {
851	 if (returndata.length > 0) {
852	 assembly {
853	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
854	 }
855	 else {
856	 revert(errorMessage);
857	 }
858	 }
859	 }
860	 }
