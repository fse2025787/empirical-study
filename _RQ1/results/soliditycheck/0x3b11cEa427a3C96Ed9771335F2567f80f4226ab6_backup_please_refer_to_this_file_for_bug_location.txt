row number 
1	  pragma abicoder v2;
2	 pragma solidity >=0.4.24 <0.8.0;
3	 abstract contract Initializable {
4	 bool private _initialized;
5	 bool private _initializing;
6	 modifier initializer() {
7	 require(_initializing || _isConstructor() || !_initialized, "Initializable: contract is already initialized");
8	 bool isTopLevelCall = !_initializing;
9	 if (isTopLevelCall) {
10	 _initializing = true;
11	 _initialized = true;
12	 }
13	 _;
14	 if (isTopLevelCall) {
15	 _initializing = false;
16	 }
17	 }
18	 function _isConstructor() private view returns (bool) {
19	 return !AddressUpgradeable.isContract(address(this));
20	 }
21	 }
22	 pragma solidity ^0.7.0;
23	 interface IERC165 {
24	 function supportsInterface(bytes4 interfaceId) external view returns (bool);
25	 }
26	 pragma solidity ^0.7.0;
27	 abstract contract Proxy {
28	 function _delegate(address implementation) internal virtual {
29	 assembly {
30	 calldatacopy(0, 0, calldatasize()) let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0) returndatacopy(0, 0, returndatasize()) switch result case 0 {
31	 revert(0, returndatasize()) }
32	 default {
33	 return(0, returndatasize()) }
34	 }
35	 }
36	 function _implementation() internal view virtual returns (address);
37	 function _fallback() internal virtual {
38	 _beforeFallback();
39	 _delegate(_implementation());
40	 }
41	 fallback () external payable virtual {
42	 _fallback();
43	 }
44	 receive () external payable virtual {
45	 _fallback();
46	 }
47	 function _beforeFallback() internal virtual {
48	 }
49	 }
50	 pragma solidity >=0.6.0 <0.8.0;
51	 abstract contract ContextUpgradeable is Initializable {
52	 function __Context_init() internal initializer {
53	 __Context_init_unchained();
54	 }
55	 function __Context_init_unchained() internal initializer {
56	 }
57	 function _msgSender() internal view virtual returns (address payable) {
58	 return msg.sender;
59	 }
60	 function _msgData() internal view virtual returns (bytes memory) {
61	 this;
62	 return msg.data;
63	 }
64	 uint256[50] private __gap;
65	 }
66	 pragma solidity ^0.7.0;
67	 interface IERC721 is IERC165 {
68	 event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
69	 event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
70	 event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
71	 function balanceOf(address owner) external view returns (uint256 balance);
72	 function ownerOf(uint256 tokenId) external view returns (address owner);
73	 function safeTransferFrom(address from, address to, uint256 tokenId) external;
74	 function transferFrom(address from, address to, uint256 tokenId) external;
75	 function approve(address to, uint256 tokenId) external;
76	 function getApproved(uint256 tokenId) external view returns (address operator);
77	 function setApprovalForAll(address operator, bool _approved) external;
78	 function isApprovedForAll(address owner, address operator) external view returns (bool);
79	 function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;
80	 }
81	 pragma solidity ^0.7.0;
82	 contract UpgradeableProxy is Proxy {
83	 constructor(address _logic, bytes memory _data) payable {
84	 assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1));
85	 _setImplementation(_logic);
86	 if(_data.length > 0) {
87	 Address.functionDelegateCall(_logic, _data);
88	 }
89	 }
90	 event Upgraded(address indexed implementation);
91	 bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
92	 function _implementation() internal view virtual override returns (address impl) {
93	 bytes32 slot = _IMPLEMENTATION_SLOT;
94	 assembly {
95	 impl := sload(slot) }
96	 }
97	 function _upgradeTo(address newImplementation) internal virtual {
98	 _setImplementation(newImplementation);
99	 emit Upgraded(newImplementation);
100	 }
101	 function _setImplementation(address newImplementation) private {
102	 require(Address.isContract(newImplementation), "UpgradeableProxy: new implementation is not a contract");
103	 bytes32 slot = _IMPLEMENTATION_SLOT;
104	 assembly {
105	 sstore(slot, newImplementation) }
106	 }
107	 }
108	 pragma solidity >=0.6.0 <0.8.0;
109	 abstract contract Context {
110	 function _msgSender() internal view virtual returns (address payable) {
111	 return msg.sender;
112	 }
113	 function _msgData() internal view virtual returns (bytes memory) {
114	 this;
115	 return msg.data;
116	 }
117	 }
118	 pragma solidity ^0.7.0;
119	 abstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {
120	 address private _owner;
121	 event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
122	 function __Ownable_init() internal initializer {
123	 __Context_init_unchained();
124	 __Ownable_init_unchained();
125	 }
126	 function __Ownable_init_unchained() internal initializer {
127	 address msgSender = _msgSender();
128	 _owner = msgSender;
129	 emit OwnershipTransferred(address(0), msgSender);
130	 }
131	 function owner() public view virtual returns (address) {
132	 return _owner;
133	 }
134	 modifier onlyOwner() {
135	 require(owner() == _msgSender(), "Ownable: caller is not the owner");
136	 _;
137	 }
138	 function renounceOwnership() public virtual onlyOwner {
139	 emit OwnershipTransferred(_owner, address(0));
140	 _owner = address(0);
141	 }
142	 function transferOwnership(address newOwner) public virtual onlyOwner {
143	 require(newOwner != address(0), "Ownable: new owner is the zero address");
144	 emit OwnershipTransferred(_owner, newOwner);
145	 _owner = newOwner;
146	 }
147	 uint256[49] private __gap;
148	 }
149	 pragma solidity ^0.7.0;
150	 interface IERC20 {
151	 function totalSupply() external view returns (uint256);
152	 function balanceOf(address account) external view returns (uint256);
153	 function transfer(address recipient, uint256 amount) external returns (bool);
154	 function allowance(address owner, address spender) external view returns (uint256);
155	 function approve(address spender, uint256 amount) external returns (bool);
156	 function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
157	 event Transfer(address indexed from, address indexed to, uint256 value);
158	 event Approval(address indexed owner, address indexed spender, uint256 value);
159	 }
160	 pragma solidity ^0.7.0;
161	 interface IERC721Metadata is IERC721 {
162	 function name() external view returns (string memory);
163	 function symbol() external view returns (string memory);
164	 function tokenURI(uint256 tokenId) external view returns (string memory);
165	 }
166	 pragma solidity ^0.7.0;
167	 interface IERC721Enumerable is IERC721 {
168	 function totalSupply() external view returns (uint256);
169	 function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);
170	 function tokenByIndex(uint256 index) external view returns (uint256);
171	 }
172	 pragma solidity >=0.7.5;
173	 interface IPoolInitializer {
174	 function createAndInitializePoolIfNecessary( address token0, address token1, uint24 fee, uint160 sqrtPriceX96 ) external payable returns (address pool);
175	 }
176	 pragma solidity >=0.7.5;
177	 interface IERC721Permit is IERC721 {
178	 function PERMIT_TYPEHASH() external pure returns (bytes32);
179	 function DOMAIN_SEPARATOR() external view returns (bytes32);
180	 function permit( address spender, uint256 tokenId, uint256 deadline, uint8 v, bytes32 r, bytes32 s ) external payable;
181	 }
182	 pragma solidity >=0.5.0;
183	 interface IPeripheryImmutableState {
184	 function factory() external view returns (address);
185	 function WETH9() external view returns (address);
186	 }
187	 pragma solidity 0.7.6;
188	 interface IStakingRewards {
189	 function earned(address account, address token) external view returns (uint256);
190	 function getRewardForDuration(address token) external view returns (uint256);
191	 function getRewardTokens() external view returns (address[] memory tokens);
192	 function getRewardTokensCount() external view returns (uint256);
193	 function lastTimeRewardApplicable() external view returns (uint256);
194	 function lastUpdateTime(address) external view returns (uint256);
195	 function periodFinish() external view returns (uint256);
196	 function rewardEscrow() external view returns (IRewardEscrow);
197	 function rewardInfo(address) external view returns ( uint256 rewardRate, uint256 rewardPerTokenStored, uint256 totalRewardAmount, uint256 remainingRewardAmount );
198	 function rewardPerToken(address token) external view returns (uint256);
199	 function rewardTokens(uint256) external view returns (address);
200	 function rewardsAreEscrowed() external view returns (bool);
201	 function rewardsDuration() external view returns (uint256);
202	 function stakedBalanceOf(address account) external view returns (uint256);
203	 function stakedTotalSupply() external view returns (uint256);
204	 function claimReward() external;
205	 function initializeReward(uint256 rewardAmount, address token) external;
206	 function setRewardsDuration(uint256 _rewardsDuration) external;
207	 }
208	 pragma solidity ^0.7.0;
209	 abstract contract Ownable is Context {
210	 address private _owner;
211	 event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
212	 constructor () {
213	 address msgSender = _msgSender();
214	 _owner = msgSender;
215	 emit OwnershipTransferred(address(0), msgSender);
216	 }
217	 function owner() public view virtual returns (address) {
218	 return _owner;
219	 }
220	 modifier onlyOwner() {
221	 require(owner() == _msgSender(), "Ownable: caller is not the owner");
222	 _;
223	 }
224	 function renounceOwnership() public virtual onlyOwner {
225	 emit OwnershipTransferred(_owner, address(0));
226	 _owner = address(0);
227	 }
228	 function transferOwnership(address newOwner) public virtual onlyOwner {
229	 require(newOwner != address(0), "Ownable: new owner is the zero address");
230	 emit OwnershipTransferred(_owner, newOwner);
231	 _owner = newOwner;
232	 }
233	 }
234	 pragma solidity ^0.7.0;
235	 contract TransparentUpgradeableProxy is UpgradeableProxy {
236	 constructor(address _logic, address admin_, bytes memory _data) payable UpgradeableProxy(_logic, _data) {
237	 assert(_ADMIN_SLOT == bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1));
238	 _setAdmin(admin_);
239	 }
240	 event AdminChanged(address previousAdmin, address newAdmin);
241	 bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;
242	 modifier ifAdmin() {
243	 if (msg.sender == _admin()) {
244	 _;
245	 }
246	 else {
247	 _fallback();
248	 }
249	 }
250	 function admin() external ifAdmin returns (address admin_) {
251	 admin_ = _admin();
252	 }
253	 function implementation() external ifAdmin returns (address implementation_) {
254	 implementation_ = _implementation();
255	 }
256	 function changeAdmin(address newAdmin) external virtual ifAdmin {
257	 require(newAdmin != address(0), "TransparentUpgradeableProxy: new admin is the zero address");
258	 emit AdminChanged(_admin(), newAdmin);
259	 _setAdmin(newAdmin);
260	 }
261	 function upgradeTo(address newImplementation) external virtual ifAdmin {
262	 _upgradeTo(newImplementation);
263	 }
264	 function upgradeToAndCall(address newImplementation, bytes calldata data) external payable virtual ifAdmin {
265	 _upgradeTo(newImplementation);
266	 Address.functionDelegateCall(newImplementation, data);
267	 }
268	 function _admin() internal view virtual returns (address adm) {
269	 bytes32 slot = _ADMIN_SLOT;
270	 assembly {
271	 adm := sload(slot) }
272	 }
273	 function _setAdmin(address newAdmin) private {
274	 bytes32 slot = _ADMIN_SLOT;
275	 assembly {
276	 sstore(slot, newAdmin) }
277	 }
278	 function _beforeFallback() internal virtual override {
279	 require(msg.sender != _admin(), "TransparentUpgradeableProxy: admin cannot fallback to proxy target");
280	 super._beforeFallback();
281	 }
282	 }
283	 pragma solidity 0.7.6;
284	 contract LMTerminal is Initializable, OwnableUpgradeable {
285	 using SafeMath for uint256;
286	 using SafeERC20 for IERC20;
287	 IRewardEscrow public rewardEscrow;
288	 ICLR[] public deployedCLRPools;
289	 uint256 public deploymentFee;
290	 uint256 public rewardFee;
291	 uint256 public tradeFee;
292	 mapping(address => uint256) public customDeploymentFee;
293	 mapping(address => bool) public customDeploymentFeeEnabled;
294	 CLRDeployer public clrDeployer;
295	 IxTokenManager public xTokenManager;
296	 address public proxyAdmin;
297	 IUniswapV3Factory public uniswapFactory;
298	 INonfungiblePositionManager public positionManager;
299	 ICLR.UniswapContracts public uniContracts;
300	 mapping(address => bool) private isCLRPool;
301	 NonRewardPoolDeployer public nonRewardPoolDeployer;
302	 struct PositionTicks {
303	 int24 lowerTick;
304	 int24 upperTick;
305	 }
306	 struct RewardsProgram {
307	 address[] rewardTokens;
308	 uint256 vestingPeriod;
309	 }
310	 struct PoolDetails {
311	 uint24 fee;
312	 address token0;
313	 address token1;
314	 uint256 amount0;
315	 uint256 amount1;
316	 }
317	 event DeployedUniV3Pool( address indexed pool, address indexed token0, address indexed token1, uint24 fee );
318	 event DeployedIncentivizedPool( address indexed clrInstance, address indexed token0, address indexed token1, uint24 fee, int24 lowerTick, int24 upperTick );
319	 event DeployedNonIncentivizedPool( address indexed poolInstance, address indexed token0, address indexed token1, uint24 fee, int24 lowerTick, int24 upperTick );
320	 event InitiatedRewardsProgram( address indexed clrInstance, address[] rewardTokens, uint256[] totalRewardAmounts, uint256 rewardsDuration );
321	 event TokenFeeWithdraw(address indexed token, uint256 amount);
322	 event EthFeeWithdraw(uint256 amount);
323	 constructor() initializer {
324	 }
325	 function initialize( address _xTokenManager, address _rewardEscrow, address _proxyAdmin, address _clrDeployer, address _nonRewardPoolDeployer, address _uniswapFactory, ICLR.UniswapContracts memory _uniContracts, uint256 _deploymentFee, uint256 _rewardFee, uint256 _tradeFee ) external initializer {
326	 __Ownable_init();
327	 xTokenManager = IxTokenManager(_xTokenManager);
328	 rewardEscrow = IRewardEscrow(_rewardEscrow);
329	 proxyAdmin = _proxyAdmin;
330	 clrDeployer = CLRDeployer(_clrDeployer);
331	 nonRewardPoolDeployer = NonRewardPoolDeployer(_nonRewardPoolDeployer);
332	 positionManager = INonfungiblePositionManager( _uniContracts.positionManager );
333	 uniswapFactory = IUniswapV3Factory(_uniswapFactory);
334	 uniContracts = _uniContracts;
335	 deploymentFee = _deploymentFee;
336	 rewardFee = _rewardFee;
337	 tradeFee = _tradeFee;
338	 }
339	 function deployUniswapPool( address token0, address token1, uint24 fee, uint160 initPrice ) external returns (address pool) {
340	 if (token0 > token1) {
341	 (token0, token1) = (token1, token0);
342	 }
343	 pool = positionManager.createAndInitializePoolIfNecessary( token0, token1, fee, initPrice );
344	 emit DeployedUniV3Pool(pool, token0, token1, fee);
345	 }
346	 function deployNonIncentivizedPool( string memory symbol, PositionTicks memory ticks, PoolDetails memory pool ) external payable returns (address nonRewardPoolAddress) {
347	 uint256 feeOwed = customDeploymentFeeEnabled[msg.sender] ? customDeploymentFee[msg.sender] : deploymentFee;
348	 require( msg.value == feeOwed, "Need to send ETH for non reward pool deployment" );
349	 INonRewardPool nonRewardPool = INonRewardPool( nonRewardPoolDeployer.deployNonRewardPool(proxyAdmin) );
350	 if (pool.token0 > pool.token1) {
351	 (pool.token0, pool.token1) = (pool.token1, pool.token0);
352	 (pool.amount0, pool.amount1) = (pool.amount1, pool.amount0);
353	 }
354	 address poolAddress = getPool(pool.token0, pool.token1, pool.fee);
355	 nonRewardPool.initialize( symbol, ticks.lowerTick, ticks.upperTick, pool.fee, tradeFee, pool.token0, pool.token1, address(this), poolAddress, INonRewardPool.UniswapContracts({
356	 router: uniContracts.router, quoter: uniContracts.quoter, positionManager: uniContracts.positionManager }
357	 ) );
358	 (uint256 actualAmount0, uint256 actualAmount1) = nonRewardPool .calculatePoolMintedAmounts(pool.amount0, pool.amount1);
359	 IERC20(pool.token0).safeApprove(address(nonRewardPool), actualAmount0);
360	 IERC20(pool.token1).safeApprove(address(nonRewardPool), actualAmount1);
361	 IERC20(pool.token0).safeTransferFrom( msg.sender, address(this), actualAmount0 );
362	 IERC20(pool.token1).safeTransferFrom( msg.sender, address(this), actualAmount1 );
363	 nonRewardPool.mintInitial(actualAmount0, actualAmount1, msg.sender);
364	 nonRewardPool.transferOwnership(msg.sender);
365	 IProxyAdmin(proxyAdmin).addProxyAdmin( address(nonRewardPool), msg.sender );
366	 emit DeployedNonIncentivizedPool( address(nonRewardPool), pool.token0, pool.token1, pool.fee, ticks.lowerTick, ticks.upperTick );
367	 return address(nonRewardPool);
368	 }
369	 function deployIncentivizedPool( string memory symbol, PositionTicks memory ticks, RewardsProgram memory rewardsProgram, PoolDetails memory pool ) external payable returns (address clrPoolAddress) {
370	 uint256 feeOwed = customDeploymentFeeEnabled[msg.sender] ? customDeploymentFee[msg.sender] : deploymentFee;
371	 require( msg.value == feeOwed, "Need to send ETH for CLR pool deployment" );
372	 ICLR clrPool = ICLR(clrDeployer.deployCLRPool(proxyAdmin));
373	 IStakedCLRToken stakedToken = IStakedCLRToken( clrDeployer.deploySCLRToken(proxyAdmin) );
374	 stakedToken.initialize( "StakedCLRToken", symbol, address(clrPool), false );
375	 if (pool.token0 > pool.token1) {
376	 (pool.token0, pool.token1) = (pool.token1, pool.token0);
377	 (pool.amount0, pool.amount1) = (pool.amount1, pool.amount0);
378	 }
379	 bool rewardsAreEscrowed = rewardsProgram.vestingPeriod > 0 ? true : false;
380	 address poolAddress = getPool(pool.token0, pool.token1, pool.fee);
381	 ICLR.StakingDetails memory stakingParams = ICLR.StakingDetails({
382	 rewardTokens: rewardsProgram.rewardTokens, rewardEscrow: address(rewardEscrow), rewardsAreEscrowed: rewardsAreEscrowed }
383	 );
384	 clrPool.initialize( symbol, ticks.lowerTick, ticks.upperTick, pool.fee, tradeFee, pool.token0, pool.token1, address(stakedToken), address(this), poolAddress, uniContracts, stakingParams );
385	 {
386	 (uint256 actualAmount0, uint256 actualAmount1) = clrPool .calculatePoolMintedAmounts(pool.amount0, pool.amount1);
387	 IERC20(pool.token0).safeApprove(address(clrPool), actualAmount0);
388	 IERC20(pool.token1).safeApprove(address(clrPool), actualAmount1);
389	 IERC20(pool.token0).safeTransferFrom( msg.sender, address(this), actualAmount0 );
390	 IERC20(pool.token1).safeTransferFrom( msg.sender, address(this), actualAmount1 );
391	 clrPool.mintInitial(actualAmount0, actualAmount1, msg.sender);
392	 }
393	 if (rewardsAreEscrowed) {
394	 rewardEscrow.setCLRPoolVestingPeriod( address(clrPool), rewardsProgram.vestingPeriod );
395	 }
396	 clrPool.transferOwnership(msg.sender);
397	 IProxyAdmin(proxyAdmin).addProxyAdmin(address(clrPool), msg.sender);
398	 IProxyAdmin(proxyAdmin).addProxyAdmin(address(stakedToken), msg.sender);
399	 deployedCLRPools.push(clrPool);
400	 isCLRPool[address(clrPool)] = true;
401	 emit DeployedIncentivizedPool( address(clrPool), pool.token0, pool.token1, pool.fee, ticks.lowerTick, ticks.upperTick );
402	 return address(clrPool);
403	 }
404	 function initiateRewardsProgram( ICLR clrPool, uint256[] memory totalRewardAmounts, uint256 rewardsDuration ) external {
405	 require(isCLRPool[address(clrPool)], "Not CLR pool");
406	 require( clrPool.periodFinish() == 0, "Reward program has been initiated" );
407	 if (clrPool.rewardsAreEscrowed()) {
408	 rewardEscrow.addRewardsContract(address(clrPool));
409	 }
410	 clrPool.setRewardsDuration(rewardsDuration);
411	 _initiateRewardsProgram(clrPool, totalRewardAmounts);
412	 }
413	 function initiateNewRewardsProgram( ICLR clrPool, uint256[] memory totalRewardAmounts, uint256 rewardsDuration ) external {
414	 require( clrPool.periodFinish() != 0, "First program must be initialized using initiateRewardsProgram" );
415	 require( block.timestamp > clrPool.periodFinish(), "Previous program must finish before initializing a new one" );
416	 clrPool.setRewardsDuration(rewardsDuration);
417	 _initiateRewardsProgram(clrPool, totalRewardAmounts);
418	 }
419	 function _initiateRewardsProgram( ICLR clrPool, uint256[] memory totalRewardAmounts ) private {
420	 address[] memory rewardTokens = clrPool.getRewardTokens();
421	 require( totalRewardAmounts.length == rewardTokens.length, "Total reward amounts count should be the same as reward tokens count" );
422	 address owner = clrPool.owner();
423	 address manager = clrPool.manager();
424	 require( msg.sender == owner || msg.sender == manager, "Only owner or manager can initiate the rewards program" );
425	 for (uint256 i = 0; i < rewardTokens.length; ++i) {
426	 address rewardToken = rewardTokens[i];
427	 uint256 rewardAmountFee = totalRewardAmounts[i].div(rewardFee);
428	 uint256 rewardAmount = totalRewardAmounts[i];
429	 IERC20(rewardToken).safeTransferFrom( msg.sender, address(this), rewardAmountFee );
430	 IERC20(rewardToken).safeTransferFrom( msg.sender, address(clrPool), rewardAmount );
431	 clrPool.initializeReward(rewardAmount, rewardToken);
432	 }
433	 emit InitiatedRewardsProgram( address(clrPool), rewardTokens, totalRewardAmounts, clrPool.rewardsDuration() );
434	 }
435	 function getPool( address token0, address token1, uint24 fee ) public view returns (address pool) {
436	 return uniswapFactory.getPool(token0, token1, fee);
437	 }
438	 function enableCustomDeploymentFee(address deployer, uint256 feeAmount) public onlyOwner {
439	 require( feeAmount < deploymentFee, "Custom fee should be less than flat deployment fee" );
440	 customDeploymentFeeEnabled[deployer] = true;
441	 customDeploymentFee[deployer] = feeAmount;
442	 }
443	 function disableCustomDeploymentFee(address deployer) public onlyOwner {
444	 customDeploymentFeeEnabled[deployer] = false;
445	 }
446	 function setCLRDeployer(address newDeployer) public onlyOwner {
447	 clrDeployer = CLRDeployer(newDeployer);
448	 }
449	 function setNonRewardPoolDeployer(address newDeployer) public onlyOwner {
450	 nonRewardPoolDeployer = NonRewardPoolDeployer(newDeployer);
451	 }
452	 function withdrawFees(IERC20 token) external onlyRevenueController {
453	 uint256 fees = token.balanceOf(address(this));
454	 if (fees > 0) {
455	 token.safeTransfer(msg.sender, fees);
456	 emit TokenFeeWithdraw(address(token), fees);
457	 }
458	 if (address(this).balance > 0) {
459	 bool sent = transferETH(address(this).balance, msg.sender);
460	 if (sent) {
461	 emit EthFeeWithdraw(address(this).balance);
462	 }
463	 }
464	 }
465	 function transferETH(uint256 amount, address payable to) private returns (bool sent) {
466	 (sent, ) = to.call{
467	 value: amount}
468	 ("");
469	 }
470	 receive() external payable {
471	 }
472	 modifier onlyRevenueController() {
473	 require( xTokenManager.isRevenueController(msg.sender), "Callable only by Revenue Controller" );
474	 _;
475	 }
476	 }
477	 pragma solidity ^0.7.0;
478	 library SafeMath {
479	 function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
480	 uint256 c = a + b;
481	 if (c < a) return (false, 0);
482	 return (true, c);
483	 }
484	 function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
485	 if (b > a) return (false, 0);
486	 return (true, a - b);
487	 }
488	 function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
489	 if (a == 0) return (true, 0);
490	 uint256 c = a * b;
491	 if (c / a != b) return (false, 0);
492	 return (true, c);
493	 }
494	 function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
495	 if (b == 0) return (false, 0);
496	 return (true, a / b);
497	 }
498	 function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
499	 if (b == 0) return (false, 0);
500	 return (true, a % b);
501	 }
502	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
503	 uint256 c = a + b;
504	 require(c >= a, "SafeMath: addition overflow");
505	 return c;
506	 }
507	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
508	 require(b <= a, "SafeMath: subtraction overflow");
509	 return a - b;
510	 }
511	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
512	 if (a == 0) return 0;
513	 uint256 c = a * b;
514	 require(c / a == b, "SafeMath: multiplication overflow");
515	 return c;
516	 }
517	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
518	 require(b > 0, "SafeMath: division by zero");
519	 return a / b;
520	 }
521	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
522	 require(b > 0, "SafeMath: modulo by zero");
523	 return a % b;
524	 }
525	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
526	 require(b <= a, errorMessage);
527	 return a - b;
528	 }
529	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
530	 require(b > 0, errorMessage);
531	 return a / b;
532	 }
533	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
534	 require(b > 0, errorMessage);
535	 return a % b;
536	 }
537	 }
538	 pragma solidity ^0.7.0;
539	 library SafeERC20 {
540	 using SafeMath for uint256;
541	 using Address for address;
542	 function safeTransfer(IERC20 token, address to, uint256 value) internal {
543	 _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
544	 }
545	 function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
546	 _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
547	 }
548	 function safeApprove(IERC20 token, address spender, uint256 value) internal {
549	 require((value == 0) || (token.allowance(address(this), spender) == 0), "SafeERC20: approve from non-zero to non-zero allowance" );
550	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
551	 }
552	 function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
553	 uint256 newAllowance = token.allowance(address(this), spender).add(value);
554	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
555	 }
556	 function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
557	 uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
558	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
559	 }
560	 function _callOptionalReturn(IERC20 token, bytes memory data) private {
561	 bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
562	 if (returndata.length > 0) {
563	 require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
564	 }
565	 }
566	 }
567	 pragma solidity >=0.7.5;
568	 interface INonfungiblePositionManager is IPoolInitializer, IPeripheryImmutableState, IERC721Metadata, IERC721Enumerable, IERC721Permit {
569	 event IncreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);
570	 event DecreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);
571	 event Collect(uint256 indexed tokenId, address recipient, uint256 amount0, uint256 amount1);
572	 function positions(uint256 tokenId) external view returns ( uint96 nonce, address operator, address token0, address token1, uint24 fee, int24 tickLower, int24 tickUpper, uint128 liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, uint128 tokensOwed0, uint128 tokensOwed1 );
573	 struct MintParams {
574	 address token0;
575	 address token1;
576	 uint24 fee;
577	 int24 tickLower;
578	 int24 tickUpper;
579	 uint256 amount0Desired;
580	 uint256 amount1Desired;
581	 uint256 amount0Min;
582	 uint256 amount1Min;
583	 address recipient;
584	 uint256 deadline;
585	 }
586	 function mint(MintParams calldata params) external payable returns ( uint256 tokenId, uint128 liquidity, uint256 amount0, uint256 amount1 );
587	 struct IncreaseLiquidityParams {
588	 uint256 tokenId;
589	 uint256 amount0Desired;
590	 uint256 amount1Desired;
591	 uint256 amount0Min;
592	 uint256 amount1Min;
593	 uint256 deadline;
594	 }
595	 function increaseLiquidity(IncreaseLiquidityParams calldata params) external payable returns ( uint128 liquidity, uint256 amount0, uint256 amount1 );
596	 struct DecreaseLiquidityParams {
597	 uint256 tokenId;
598	 uint128 liquidity;
599	 uint256 amount0Min;
600	 uint256 amount1Min;
601	 uint256 deadline;
602	 }
603	 function decreaseLiquidity(DecreaseLiquidityParams calldata params) external payable returns (uint256 amount0, uint256 amount1);
604	 struct CollectParams {
605	 uint256 tokenId;
606	 address recipient;
607	 uint128 amount0Max;
608	 uint128 amount1Max;
609	 }
610	 function collect(CollectParams calldata params) external payable returns (uint256 amount0, uint256 amount1);
611	 function burn(uint256 tokenId) external payable;
612	 }
613	 pragma solidity >=0.5.0;
614	 interface IUniswapV3Factory {
615	 event OwnerChanged(address indexed oldOwner, address indexed newOwner);
616	 event PoolCreated( address indexed token0, address indexed token1, uint24 indexed fee, int24 tickSpacing, address pool );
617	 event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);
618	 function owner() external view returns (address);
619	 function feeAmountTickSpacing(uint24 fee) external view returns (int24);
620	 function getPool( address tokenA, address tokenB, uint24 fee ) external view returns (address pool);
621	 function createPool( address tokenA, address tokenB, uint24 fee ) external returns (address pool);
622	 function setOwner(address _owner) external;
623	 function enableFeeAmount(uint24 fee, int24 tickSpacing) external;
624	 }
625	 pragma solidity 0.7.6;
626	 interface IERC20Extended is IERC20 {
627	 function name() external view returns (string memory);
628	 function symbol() external view returns (string memory);
629	 function decimals() external view returns (uint8);
630	 }
631	 pragma solidity 0.7.6;
632	 interface ICLR is IERC20, IStakingRewards {
633	 function addManager(address _manager) external;
634	 function adminStake(uint256 amount0, uint256 amount1) external;
635	 function adminSwap(uint256 amount, bool _0for1) external;
636	 function calculateAmountsMintedSingleToken(uint8 inputAsset, uint256 amount) external view returns (uint256 amount0Minted, uint256 amount1Minted);
637	 function calculateMintAmount(uint256 amount0, uint256 amount1) external view returns (uint256 mintAmount);
638	 function calculatePoolMintedAmounts(uint256 amount0, uint256 amount1) external view returns (uint256 amount0Minted, uint256 amount1Minted);
639	 function collect() external returns (uint256 collected0, uint256 collected1);
640	 function decimals() external view returns (uint8);
641	 function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);
642	 function deposit(uint8 inputAsset, uint256 amount) external;
643	 function getAmountsForLiquidity(uint128 liquidity) external view returns (uint256 amount0, uint256 amount1);
644	 function getBufferToken0Balance() external view returns (uint256 amount0);
645	 function getBufferToken1Balance() external view returns (uint256 amount1);
646	 function getBufferTokenBalance() external view returns (uint256 amount0, uint256 amount1);
647	 function getLiquidityForAmounts(uint256 amount0, uint256 amount1) external view returns (uint128 liquidity);
648	 function getPositionLiquidity() external view returns (uint128 liquidity);
649	 function getStakedTokenBalance() external view returns (uint256 amount0, uint256 amount1);
650	 function getTicks() external view returns (int24 tick0, int24 tick1);
651	 function increaseAllowance(address spender, uint256 addedValue) external returns (bool);
652	 function initialize( string memory _symbol, int24 _tickLower, int24 _tickUpper, uint24 _poolFee, uint256 _tradeFee, address _token0, address _token1, address _stakedToken, address _terminal, address _uniswapPool, UniswapContracts memory contracts, StakingDetails memory stakingParams ) external;
653	 function manager() external view returns (address);
654	 function mintInitial( uint256 amount0, uint256 amount1, address sender ) external;
655	 function name() external view returns (string memory);
656	 function owner() external view returns (address);
657	 function pauseContract() external returns (bool);
658	 function paused() external view returns (bool);
659	 function poolFee() external view returns (uint24);
660	 function reinvest() external;
661	 function renounceOwnership() external;
662	 function stakedToken() external view returns (address);
663	 function symbol() external view returns (string memory);
664	 function token0() external view returns (address);
665	 function token0DecimalMultiplier() external view returns (uint256);
666	 function token0Decimals() external view returns (uint8);
667	 function token1() external view returns (address);
668	 function token1DecimalMultiplier() external view returns (uint256);
669	 function token1Decimals() external view returns (uint8);
670	 function tokenId() external view returns (uint256);
671	 function tradeFee() external view returns (uint256);
672	 function transferOwnership(address newOwner) external;
673	 function uniContracts() external view returns ( address router, address quoter, address positionManager );
674	 function uniswapPool() external view returns (address);
675	 function unpauseContract() external returns (bool);
676	 function withdraw(uint256 amount) external;
677	 function withdrawAndClaimReward(uint256 amount) external;
678	 struct UniswapContracts {
679	 address router;
680	 address quoter;
681	 address positionManager;
682	 }
683	 struct StakingDetails {
684	 address[] rewardTokens;
685	 address rewardEscrow;
686	 bool rewardsAreEscrowed;
687	 }
688	 }
689	 pragma solidity 0.7.6;
690	 interface IStakedCLRToken is IERC20 {
691	 function mint(address _recipient, uint256 _amount) external returns (bool);
692	 function burnFrom(address _sender, uint256 _amount) external returns (bool);
693	 function initialize( string memory _name, string memory _symbol, address _clrPool, bool _transferable ) external;
694	 }
695	 pragma solidity 0.7.6;
696	 interface INonRewardPool is IERC20 {
697	 function addManager(address _manager) external;
698	 function adminStake(uint256 amount0, uint256 amount1) external;
699	 function adminSwap(uint256 amount, bool _0for1) external;
700	 function calculateAmountsMintedSingleToken(uint8 inputAsset, uint256 amount) external view returns (uint256 amount0Minted, uint256 amount1Minted);
701	 function calculateMintAmount(uint256 amount0, uint256 amount1) external view returns (uint256 mintAmount);
702	 function calculatePoolMintedAmounts(uint256 amount0, uint256 amount1) external view returns (uint256 amount0Minted, uint256 amount1Minted);
703	 function collect() external returns (uint256 collected0, uint256 collected1);
704	 function decimals() external view returns (uint8);
705	 function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);
706	 function deposit(uint8 inputAsset, uint256 amount) external;
707	 function getAmountsForLiquidity(uint128 liquidity) external view returns (uint256 amount0, uint256 amount1);
708	 function getBufferToken0Balance() external view returns (uint256 amount0);
709	 function getBufferToken1Balance() external view returns (uint256 amount1);
710	 function getBufferTokenBalance() external view returns (uint256 amount0, uint256 amount1);
711	 function getLiquidityForAmounts(uint256 amount0, uint256 amount1) external view returns (uint128 liquidity);
712	 function getPositionLiquidity() external view returns (uint128 liquidity);
713	 function getStakedTokenBalance() external view returns (uint256 amount0, uint256 amount1);
714	 function getTicks() external view returns (int24 tick0, int24 tick1);
715	 function increaseAllowance(address spender, uint256 addedValue) external returns (bool);
716	 function initialize( string memory _symbol, int24 _tickLower, int24 _tickUpper, uint24 _poolFee, uint256 _tradeFee, address _token0, address _token1, address _terminal, address _uniswapPool, UniswapContracts memory contracts ) external;
717	 function manager() external view returns (address);
718	 function mintInitial( uint256 amount0, uint256 amount1, address sender ) external;
719	 function name() external view returns (string memory);
720	 function owner() external view returns (address);
721	 function pauseContract() external returns (bool);
722	 function paused() external view returns (bool);
723	 function poolFee() external view returns (uint24);
724	 function reinvest() external;
725	 function renounceOwnership() external;
726	 function symbol() external view returns (string memory);
727	 function token0() external view returns (address);
728	 function token0DecimalMultiplier() external view returns (uint256);
729	 function token0Decimals() external view returns (uint8);
730	 function token1() external view returns (address);
731	 function token1DecimalMultiplier() external view returns (uint256);
732	 function token1Decimals() external view returns (uint8);
733	 function tokenId() external view returns (uint256);
734	 function tradeFee() external view returns (uint256);
735	 function transferOwnership(address newOwner) external;
736	 function uniContracts() external view returns ( address router, address quoter, address positionManager );
737	 function uniswapPool() external view returns (address);
738	 function unpauseContract() external returns (bool);
739	 function withdraw(uint256 amount) external;
740	 struct UniswapContracts {
741	 address router;
742	 address quoter;
743	 address positionManager;
744	 }
745	 }
746	 pragma solidity 0.7.6;
747	 interface IRewardEscrow {
748	 function MAX_VESTING_ENTRIES() external view returns (uint256);
749	 function addRewardsContract(address _rewardContract) external;
750	 function appendVestingEntry( address token, address account, address pool, uint256 quantity ) external;
751	 function balanceOf(address token, address account) external view returns (uint256);
752	 function checkAccountSchedule( address pool, address token, address account ) external view returns (uint256[] memory);
753	 function clrPoolVestingPeriod(address) external view returns (uint256);
754	 function getNextVestingEntry( address pool, address token, address account ) external view returns (uint256[2] memory);
755	 function getNextVestingIndex( address pool, address token, address account ) external view returns (uint256);
756	 function getNextVestingQuantity( address pool, address token, address account ) external view returns (uint256);
757	 function getNextVestingTime( address pool, address token, address account ) external view returns (uint256);
758	 function getVestingQuantity( address pool, address token, address account, uint256 index ) external view returns (uint256);
759	 function getVestingScheduleEntry( address pool, address token, address account, uint256 index ) external view returns (uint256[2] memory);
760	 function getVestingTime( address pool, address token, address account, uint256 index ) external view returns (uint256);
761	 function initialize() external;
762	 function isRewardContract(address) external view returns (bool);
763	 function numVestingEntries( address pool, address token, address account ) external view returns (uint256);
764	 function owner() external view returns (address);
765	 function removeRewardsContract(address _rewardContract) external;
766	 function renounceOwnership() external;
767	 function setCLRPoolVestingPeriod(address pool, uint256 vestingPeriod) external;
768	 function totalEscrowedAccountBalance(address, address) external view returns (uint256);
769	 function totalEscrowedBalance(address) external view returns (uint256);
770	 function totalSupply(address token) external view returns (uint256);
771	 function totalVestedAccountBalance(address, address) external view returns (uint256);
772	 function transferOwnership(address newOwner) external;
773	 function vest(address pool, address token) external;
774	 function vestAll(address pool, address[] memory tokens) external;
775	 function vestingSchedules( address, address, address, uint256, uint256 ) external view returns (uint256);
776	 }
777	 pragma solidity 0.7.6;
778	 interface IxTokenManager {
779	 function addManager(address manager, address fund) external;
780	 function removeManager(address manager, address fund) external;
781	 function isManager(address manager, address fund) external view returns (bool);
782	 function setRevenueController(address controller) external;
783	 function isRevenueController(address caller) external view returns (bool);
784	 }
785	 pragma solidity 0.7.6;
786	 interface IProxyAdmin {
787	 function addProxyAdmin(address proxy, address admin) external;
788	 function changeProxyAdmin(address proxy, address newAdmin) external;
789	 function getProxyAdmin(address proxy) external view returns (address);
790	 function getProxyImplementation(address proxy) external view returns (address);
791	 function owner() external view returns (address);
792	 function renounceOwnership() external;
793	 function transferOwnership(address newOwner) external;
794	 function upgrade(address proxy, address implementation) external;
795	 }
796	 pragma solidity 0.7.6;
797	 contract CLRDeployer is Ownable {
798	 address public clrImplementation;
799	 address public sCLRTokenImplementation;
800	 constructor(address _clrImplementation, address _sclrTokenImplementation) {
801	 clrImplementation = _clrImplementation;
802	 sCLRTokenImplementation = _sclrTokenImplementation;
803	 emit CLRImplementationSet(_clrImplementation);
804	 emit CLRTokenImplementationSet(_sclrTokenImplementation);
805	 }
806	 function deployCLRPool(address _proxyAdmin) external returns (address pool) {
807	 CLRProxy clrInstance = new CLRProxy( clrImplementation, _proxyAdmin, address(this) );
808	 return address(clrInstance);
809	 }
810	 function deploySCLRToken(address _proxyAdmin) external returns (address token) {
811	 StakedCLRTokenProxy clrTokenInstance = new StakedCLRTokenProxy( sCLRTokenImplementation, _proxyAdmin, address(this) );
812	 return address(clrTokenInstance);
813	 }
814	 function setCLRImplementation(address _clrImplementation) external onlyOwner {
815	 clrImplementation = _clrImplementation;
816	 emit CLRImplementationSet(_clrImplementation);
817	 }
818	 function setsCLRTokenImplementation(address _sCLRTokenImplementation) external onlyOwner {
819	 sCLRTokenImplementation = _sCLRTokenImplementation;
820	 emit CLRTokenImplementationSet(_sCLRTokenImplementation);
821	 }
822	 event CLRImplementationSet(address indexed clrImplementation);
823	 event CLRTokenImplementationSet(address indexed sCLRTokenImplementation);
824	 }
825	 pragma solidity 0.7.6;
826	 contract NonRewardPoolDeployer is Ownable {
827	 address public nonRewardPoolImplementation;
828	 constructor(address _nonRewardPoolImplementation) {
829	 nonRewardPoolImplementation = _nonRewardPoolImplementation;
830	 emit NonRewardPoolImplementationSet(_nonRewardPoolImplementation);
831	 }
832	 function deployNonRewardPool(address _proxyAdmin) external returns (address pool) {
833	 NonRewardPoolProxy poolInstance = new NonRewardPoolProxy( nonRewardPoolImplementation, _proxyAdmin, address(this) );
834	 return address(poolInstance);
835	 }
836	 function setNonRewardPoolImplementation(address _poolImplementation) external onlyOwner {
837	 nonRewardPoolImplementation = _poolImplementation;
838	 emit NonRewardPoolImplementationSet(_poolImplementation);
839	 }
840	 event NonRewardPoolImplementationSet(address indexed poolImplementation);
841	 }
842	 pragma solidity ^0.7.0;
843	 library AddressUpgradeable {
844	 function isContract(address account) internal view returns (bool) {
845	 uint256 size;
846	 assembly {
847	 size := extcodesize(account) }
848	 return size > 0;
849	 }
850	 function sendValue(address payable recipient, uint256 amount) internal {
851	 require(address(this).balance >= amount, "Address: insufficient balance");
852	 (bool success, ) = recipient.call{
853	 value: amount }
854	 ("");
855	 require(success, "Address: unable to send value, recipient may have reverted");
856	 }
857	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
858	 return functionCall(target, data, "Address: low-level call failed");
859	 }
860	 function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
861	 return functionCallWithValue(target, data, 0, errorMessage);
862	 }
863	 function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
864	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
865	 }
866	 function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
867	 require(address(this).balance >= value, "Address: insufficient balance for call");
868	 require(isContract(target), "Address: call to non-contract");
869	 (bool success, bytes memory returndata) = target.call{
870	 value: value }
871	 (data);
872	 return _verifyCallResult(success, returndata, errorMessage);
873	 }
874	 function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
875	 return functionStaticCall(target, data, "Address: low-level static call failed");
876	 }
877	 function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
878	 require(isContract(target), "Address: static call to non-contract");
879	 (bool success, bytes memory returndata) = target.staticcall(data);
880	 return _verifyCallResult(success, returndata, errorMessage);
881	 }
882	 function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
883	 if (success) {
884	 return returndata;
885	 }
886	 else {
887	 if (returndata.length > 0) {
888	 assembly {
889	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
890	 }
891	 else {
892	 revert(errorMessage);
893	 }
894	 }
895	 }
896	 }
897	 pragma solidity ^0.7.0;
898	 library Address {
899	 function isContract(address account) internal view returns (bool) {
900	 uint256 size;
901	 assembly {
902	 size := extcodesize(account) }
903	 return size > 0;
904	 }
905	 function sendValue(address payable recipient, uint256 amount) internal {
906	 require(address(this).balance >= amount, "Address: insufficient balance");
907	 (bool success, ) = recipient.call{
908	 value: amount }
909	 ("");
910	 require(success, "Address: unable to send value, recipient may have reverted");
911	 }
912	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
913	 return functionCall(target, data, "Address: low-level call failed");
914	 }
915	 function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
916	 return functionCallWithValue(target, data, 0, errorMessage);
917	 }
918	 function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
919	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
920	 }
921	 function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
922	 require(address(this).balance >= value, "Address: insufficient balance for call");
923	 require(isContract(target), "Address: call to non-contract");
924	 (bool success, bytes memory returndata) = target.call{
925	 value: value }
926	 (data);
927	 return _verifyCallResult(success, returndata, errorMessage);
928	 }
929	 function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
930	 return functionStaticCall(target, data, "Address: low-level static call failed");
931	 }
932	 function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
933	 require(isContract(target), "Address: static call to non-contract");
934	 (bool success, bytes memory returndata) = target.staticcall(data);
935	 return _verifyCallResult(success, returndata, errorMessage);
936	 }
937	 function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
938	 return functionDelegateCall(target, data, "Address: low-level delegate call failed");
939	 }
940	 function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
941	 require(isContract(target), "Address: delegate call to non-contract");
942	 (bool success, bytes memory returndata) = target.delegatecall(data);
943	 return _verifyCallResult(success, returndata, errorMessage);
944	 }
945	 function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
946	 if (success) {
947	 return returndata;
948	 }
949	 else {
950	 if (returndata.length > 0) {
951	 assembly {
952	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
953	 }
954	 else {
955	 revert(errorMessage);
956	 }
957	 }
958	 }
959	 }
960	 pragma solidity >=0.5.0;
961	 library PoolAddress {
962	 bytes32 internal constant POOL_INIT_CODE_HASH = 0xc02f72e8ae5e68802e6d893d58ddfb0df89a2f4c9c2f04927db1186a29373660;
963	 struct PoolKey {
964	 address token0;
965	 address token1;
966	 uint24 fee;
967	 }
968	 function getPoolKey( address tokenA, address tokenB, uint24 fee ) internal pure returns (PoolKey memory) {
969	 if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);
970	 return PoolKey({
971	 token0: tokenA, token1: tokenB, fee: fee}
972	 );
973	 }
974	 function computeAddress(address factory, PoolKey memory key) internal pure returns (address pool) {
975	 require(key.token0 < key.token1);
976	 pool = address( uint256( keccak256( abi.encodePacked( hex'ff', factory, keccak256(abi.encode(key.token0, key.token1, key.fee)), POOL_INIT_CODE_HASH ) ) ) );
977	 }
978	 }
979	 pragma solidity 0.7.6;
980	 contract CLRProxy is TransparentUpgradeableProxy {
981	 bytes32 private constant _DEPLOYER_SLOT = 0x3d08d612cd86aed0e9677508733085e4cbe15d53bdc770ec5b581bb4e0a721ca;
982	 constructor( address _logic, address _proxyAdmin, address __clrDeployer ) TransparentUpgradeableProxy(_logic, _proxyAdmin, "") {
983	 assert( _DEPLOYER_SLOT == bytes32(uint256(keccak256("eip1967.proxy.clrDeployer")) - 1) );
984	 _setCLRDeployer(__clrDeployer);
985	 }
986	 function _clrDeployer() internal view virtual returns (address clrDeployer) {
987	 bytes32 slot = _DEPLOYER_SLOT;
988	 assembly {
989	 clrDeployer := sload(slot) }
990	 }
991	 function _setCLRDeployer(address clrDeployer) private {
992	 bytes32 slot = _DEPLOYER_SLOT;
993	 assembly {
994	 sstore(slot, clrDeployer) }
995	 }
996	 function upgradeTo(address _implementation) external override ifAdmin {
997	 require( ICLRDeployer(_clrDeployer()).clrImplementation() == _implementation, "Can only upgrade to latest CLR implementation" );
998	 _upgradeTo(_implementation);
999	 }
1000	 function upgradeToAndCall(address _implementation, bytes calldata data) external payable override ifAdmin {
1001	 require( ICLRDeployer(_clrDeployer()).clrImplementation() == _implementation, "Can only upgrade to latest CLR implementation" );
1002	 _upgradeTo(_implementation);
1003	 Address.functionDelegateCall(_implementation, data);
1004	 }
1005	 }
1006	 pragma solidity 0.7.6;
1007	 contract StakedCLRTokenProxy is TransparentUpgradeableProxy {
1008	 bytes32 private constant _DEPLOYER_SLOT = 0x3d08d612cd86aed0e9677508733085e4cbe15d53bdc770ec5b581bb4e0a721ca;
1009	 constructor( address _logic, address _proxyAdmin, address __clrDeployer ) TransparentUpgradeableProxy(_logic, _proxyAdmin, "") {
1010	 assert( _DEPLOYER_SLOT == bytes32(uint256(keccak256("eip1967.proxy.clrDeployer")) - 1) );
1011	 _setCLRDeployer(__clrDeployer);
1012	 }
1013	 function _clrDeployer() internal view virtual returns (address clrDeployer) {
1014	 bytes32 slot = _DEPLOYER_SLOT;
1015	 assembly {
1016	 clrDeployer := sload(slot) }
1017	 }
1018	 function _setCLRDeployer(address clrDeployer) private {
1019	 bytes32 slot = _DEPLOYER_SLOT;
1020	 assembly {
1021	 sstore(slot, clrDeployer) }
1022	 }
1023	 function upgradeTo(address _implementation) external override ifAdmin {
1024	 require( ICLRDeployer(_clrDeployer()).sCLRTokenImplementation() == _implementation, "Can only upgrade to latest Staked CLR token implementation" );
1025	 _upgradeTo(_implementation);
1026	 }
1027	 function upgradeToAndCall(address _implementation, bytes calldata data) external payable override ifAdmin {
1028	 require( ICLRDeployer(_clrDeployer()).sCLRTokenImplementation() == _implementation, "Can only upgrade to latest Staked CLR token implementation" );
1029	 _upgradeTo(_implementation);
1030	 Address.functionDelegateCall(_implementation, data);
1031	 }
1032	 }
1033	 pragma solidity 0.7.6;
1034	 interface ICLRDeployer {
1035	 function clrImplementation() external view returns (address);
1036	 function deployCLRPool(address _proxyAdmin) external returns (address pool);
1037	 function deploySCLRToken(address _proxyAdmin) external returns (address token);
1038	 function owner() external view returns (address);
1039	 function renounceOwnership() external;
1040	 function sCLRTokenImplementation() external view returns (address);
1041	 function setCLRImplementation(address _clrImplementation) external;
1042	 function setsCLRTokenImplementation(address _sCLRTokenImplementation) external;
1043	 function transferOwnership(address newOwner) external;
1044	 }
1045	 pragma solidity 0.7.6;
1046	 contract NonRewardPoolProxy is TransparentUpgradeableProxy {
1047	 bytes32 private constant _DEPLOYER_SLOT = 0xa31c8a9c15ab83630b8333276b3d2f13132daf1ee481355dbdc6ab0253791319;
1048	 constructor( address _logic, address _proxyAdmin, address __poolDeployer ) TransparentUpgradeableProxy(_logic, _proxyAdmin, "") {
1049	 assert( _DEPLOYER_SLOT == bytes32( uint256(keccak256("eip1967.proxy.nonRewardPoolDeployer")) - 1 ) );
1050	 _setNonRewardPoolDeployer(__poolDeployer);
1051	 }
1052	 function _poolDeployer() internal view virtual returns (address poolDeployer) {
1053	 bytes32 slot = _DEPLOYER_SLOT;
1054	 assembly {
1055	 poolDeployer := sload(slot) }
1056	 }
1057	 function _setNonRewardPoolDeployer(address poolDeployer) private {
1058	 bytes32 slot = _DEPLOYER_SLOT;
1059	 assembly {
1060	 sstore(slot, poolDeployer) }
1061	 }
1062	 function upgradeTo(address _implementation) external override ifAdmin {
1063	 require( INonRewardPoolDeployer(_poolDeployer()) .nonRewardPoolImplementation() == _implementation, "Can only upgrade to latest NonRewardPool implementation" );
1064	 _upgradeTo(_implementation);
1065	 }
1066	 function upgradeToAndCall(address _implementation, bytes calldata data) external payable override ifAdmin {
1067	 require( INonRewardPoolDeployer(_poolDeployer()) .nonRewardPoolImplementation() == _implementation, "Can only upgrade to latest NonRewardPool implementation" );
1068	 _upgradeTo(_implementation);
1069	 Address.functionDelegateCall(_implementation, data);
1070	 }
1071	 }
1072	 pragma solidity 0.7.6;
1073	 interface INonRewardPoolDeployer {
1074	 function nonRewardPoolImplementation() external view returns (address);
1075	 function deployNonRewardPool(address _proxyAdmin) external returns (address pool);
1076	 function owner() external view returns (address);
1077	 function renounceOwnership() external;
1078	 function setNonRewardPoolImplementation(address _poolImplementation) external;
1079	 function transferOwnership(address newOwner) external;
1080	 }
