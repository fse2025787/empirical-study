row number 
1	  pragma experimental ABIEncoderV2;
2	 pragma solidity 0.6.12;
3	 struct StrategyParams {
4	 uint256 performanceFee;
5	 uint256 activation;
6	 uint256 debtRatio;
7	 uint256 minDebtPerHarvest;
8	 uint256 maxDebtPerHarvest;
9	 uint256 lastReport;
10	 uint256 totalDebt;
11	 uint256 totalGain;
12	 uint256 totalLoss;
13	 }
14	 library DataTypes {
15	 struct ReserveData {
16	 ReserveConfigurationMap configuration;
17	 uint128 liquidityIndex;
18	 uint128 variableBorrowIndex;
19	 uint128 currentLiquidityRate;
20	 uint128 currentVariableBorrowRate;
21	 uint128 currentStableBorrowRate;
22	 uint40 lastUpdateTimestamp;
23	 address aTokenAddress;
24	 address stableDebtTokenAddress;
25	 address variableDebtTokenAddress;
26	 address interestRateStrategyAddress;
27	 uint8 id;
28	 }
29	 struct ReserveConfigurationMap {
30	 uint256 data;
31	 }
32	 struct UserConfigurationMap {
33	 uint256 data;
34	 }
35	 enum InterestRateMode {
36	 NONE, STABLE, VARIABLE}
37	 }
38	 interface IAaveIncentivesController {
39	 function getRewardsBalance(address[] calldata assets, address user) external view returns (uint256);
40	 function claimRewards( address[] calldata assets, uint256 amount, address to ) external returns (uint256);
41	 function claimRewardsOnBehalf( address[] calldata assets, uint256 amount, address user, address to ) external returns (uint256);
42	 function getUserUnclaimedRewards(address user) external view returns (uint256);
43	 function REWARD_TOKEN() external view returns (address);
44	 function getDistributionEnd() external view returns (uint256);
45	 function getAssetData(address asset) external view returns ( uint256, uint256, uint256 );
46	 }
47	 interface IERC3156FlashBorrower {
48	 function onFlashLoan( address initiator, address token, uint256 amount, uint256 fee, bytes calldata data ) external returns (bytes32);
49	 }
50	 interface ILendingPoolAddressesProvider {
51	 event MarketIdSet(string newMarketId);
52	 event LendingPoolUpdated(address indexed newAddress);
53	 event ConfigurationAdminUpdated(address indexed newAddress);
54	 event EmergencyAdminUpdated(address indexed newAddress);
55	 event LendingPoolConfiguratorUpdated(address indexed newAddress);
56	 event LendingPoolCollateralManagerUpdated(address indexed newAddress);
57	 event PriceOracleUpdated(address indexed newAddress);
58	 event LendingRateOracleUpdated(address indexed newAddress);
59	 event ProxyCreated(bytes32 id, address indexed newAddress);
60	 event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);
61	 function getMarketId() external view returns (string memory);
62	 function setMarketId(string calldata marketId) external;
63	 function setAddress(bytes32 id, address newAddress) external;
64	 function setAddressAsProxy(bytes32 id, address impl) external;
65	 function getAddress(bytes32 id) external view returns (address);
66	 function getLendingPool() external view returns (address);
67	 function setLendingPoolImpl(address pool) external;
68	 function getLendingPoolConfigurator() external view returns (address);
69	 function setLendingPoolConfiguratorImpl(address configurator) external;
70	 function getLendingPoolCollateralManager() external view returns (address);
71	 function setLendingPoolCollateralManager(address manager) external;
72	 function getPoolAdmin() external view returns (address);
73	 function setPoolAdmin(address admin) external;
74	 function getEmergencyAdmin() external view returns (address);
75	 function setEmergencyAdmin(address admin) external;
76	 function getPriceOracle() external view returns (address);
77	 function setPriceOracle(address priceOracle) external;
78	 function getLendingRateOracle() external view returns (address);
79	 function setLendingRateOracle(address lendingRateOracle) external;
80	 }
81	 interface IOptionalERC20 {
82	 function decimals() external view returns (uint8);
83	 }
84	 interface IPriceOracle {
85	 function getAssetPrice(address _asset) external view returns (uint256);
86	 function getAssetsPrices(address[] calldata _assets) external view returns (uint256[] memory);
87	 function getSourceOfAsset(address _asset) external view returns (address);
88	 function getFallbackOracle() external view returns (address);
89	 }
90	 interface IScaledBalanceToken {
91	 function scaledBalanceOf(address user) external view returns (uint256);
92	 function getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256);
93	 function scaledTotalSupply() external view returns (uint256);
94	 }
95	 interface IStakedAave {
96	 function stake(address to, uint256 amount) external;
97	 function redeem(address to, uint256 amount) external;
98	 function cooldown() external;
99	 function claimRewards(address to, uint256 amount) external;
100	 function getTotalRewardsBalance(address) external view returns (uint256);
101	 function COOLDOWN_SECONDS() external view returns (uint256);
102	 function stakersCooldowns(address) external view returns (uint256);
103	 function UNSTAKE_WINDOW() external view returns (uint256);
104	 }
105	 interface IUni{
106	 function getAmountsOut( uint256 amountIn, address[] calldata path ) external view returns (uint256[] memory amounts);
107	 function swapExactTokensForTokens( uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline ) external returns (uint256[] memory amounts);
108	 }
109	 interface IUniswapV3SwapCallback {
110	 function uniswapV3SwapCallback( int256 amount0Delta, int256 amount1Delta, bytes calldata data ) external;
111	 }
112	 library Address {
113	 function isContract(address account) internal view returns (bool) {
114	 bytes32 codehash;
115	 bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
116	 assembly {
117	 codehash := extcodehash(account) }
118	 return (codehash != accountHash && codehash != 0x0);
119	 }
120	 function sendValue(address payable recipient, uint256 amount) internal {
121	 require(address(this).balance >= amount, "Address: insufficient balance");
122	 (bool success, ) = recipient.call{
123	 value: amount }
124	 ("");
125	 require(success, "Address: unable to send value, recipient may have reverted");
126	 }
127	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
128	 return functionCall(target, data, "Address: low-level call failed");
129	 }
130	 function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
131	 return _functionCallWithValue(target, data, 0, errorMessage);
132	 }
133	 function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
134	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
135	 }
136	 function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
137	 require(address(this).balance >= value, "Address: insufficient balance for call");
138	 return _functionCallWithValue(target, data, value, errorMessage);
139	 }
140	 function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {
141	 require(isContract(target), "Address: call to non-contract");
142	 (bool success, bytes memory returndata) = target.call{
143	 value: weiValue }
144	 (data);
145	 if (success) {
146	 return returndata;
147	 }
148	 else {
149	 if (returndata.length > 0) {
150	 assembly {
151	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
152	 }
153	 else {
154	 revert(errorMessage);
155	 }
156	 }
157	 }
158	 }
159	 interface IERC20 {
160	 function totalSupply() external view returns (uint256);
161	 function balanceOf(address account) external view returns (uint256);
162	 function transfer(address recipient, uint256 amount) external returns (bool);
163	 function allowance(address owner, address spender) external view returns (uint256);
164	 function approve(address spender, uint256 amount) external returns (bool);
165	 function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
166	 event Transfer(address indexed from, address indexed to, uint256 value);
167	 event Approval(address indexed owner, address indexed spender, uint256 value);
168	 }
169	 library Math {
170	 function max(uint256 a, uint256 b) internal pure returns (uint256) {
171	 return a >= b ? a : b;
172	 }
173	 function min(uint256 a, uint256 b) internal pure returns (uint256) {
174	 return a < b ? a : b;
175	 }
176	 function average(uint256 a, uint256 b) internal pure returns (uint256) {
177	 return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);
178	 }
179	 }
180	 library SafeMath {
181	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
182	 uint256 c = a + b;
183	 require(c >= a, "SafeMath: addition overflow");
184	 return c;
185	 }
186	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
187	 return sub(a, b, "SafeMath: subtraction overflow");
188	 }
189	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
190	 require(b <= a, errorMessage);
191	 uint256 c = a - b;
192	 return c;
193	 }
194	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
195	 if (a == 0) {
196	 return 0;
197	 }
198	 uint256 c = a * b;
199	 require(c / a == b, "SafeMath: multiplication overflow");
200	 return c;
201	 }
202	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
203	 return div(a, b, "SafeMath: division by zero");
204	 }
205	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
206	 require(b > 0, errorMessage);
207	 uint256 c = a / b;
208	 return c;
209	 }
210	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
211	 return mod(a, b, "SafeMath: modulo by zero");
212	 }
213	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
214	 require(b != 0, errorMessage);
215	 return a % b;
216	 }
217	 }
218	 interface HealthCheck {
219	 function check( uint256 profit, uint256 loss, uint256 debtPayment, uint256 debtOutstanding, uint256 totalDebt ) external view returns (bool);
220	 }
221	 interface IERC3156FlashLender {
222	 function maxFlashLoan(address token) external view returns (uint256);
223	 function flashFee(address token, uint256 amount) external view returns (uint256);
224	 function flashLoan( IERC3156FlashBorrower receiver, address token, uint256 amount, bytes calldata data ) external returns (bool);
225	 }
226	 interface ILendingPool {
227	 event Deposit( address indexed reserve, address user, address indexed onBehalfOf, uint256 amount, uint16 indexed referral );
228	 event Withdraw( address indexed reserve, address indexed user, address indexed to, uint256 amount );
229	 event Borrow( address indexed reserve, address user, address indexed onBehalfOf, uint256 amount, uint256 borrowRateMode, uint256 borrowRate, uint16 indexed referral );
230	 event Repay( address indexed reserve, address indexed user, address indexed repayer, uint256 amount );
231	 event Swap(address indexed reserve, address indexed user, uint256 rateMode);
232	 event ReserveUsedAsCollateralEnabled( address indexed reserve, address indexed user );
233	 event ReserveUsedAsCollateralDisabled( address indexed reserve, address indexed user );
234	 event RebalanceStableBorrowRate( address indexed reserve, address indexed user );
235	 event FlashLoan( address indexed target, address indexed initiator, address indexed asset, uint256 amount, uint256 premium, uint16 referralCode );
236	 event Paused();
237	 event Unpaused();
238	 event LiquidationCall( address indexed collateralAsset, address indexed debtAsset, address indexed user, uint256 debtToCover, uint256 liquidatedCollateralAmount, address liquidator, bool receiveAToken );
239	 event ReserveDataUpdated( address indexed reserve, uint256 liquidityRate, uint256 stableBorrowRate, uint256 variableBorrowRate, uint256 liquidityIndex, uint256 variableBorrowIndex );
240	 function deposit( address asset, uint256 amount, address onBehalfOf, uint16 referralCode ) external;
241	 function withdraw( address asset, uint256 amount, address to ) external returns (uint256);
242	 function borrow( address asset, uint256 amount, uint256 interestRateMode, uint16 referralCode, address onBehalfOf ) external;
243	 function repay( address asset, uint256 amount, uint256 rateMode, address onBehalfOf ) external returns (uint256);
244	 function swapBorrowRateMode(address asset, uint256 rateMode) external;
245	 function rebalanceStableBorrowRate(address asset, address user) external;
246	 function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;
247	 function liquidationCall( address collateralAsset, address debtAsset, address user, uint256 debtToCover, bool receiveAToken ) external;
248	 function flashLoan( address receiverAddress, address[] calldata assets, uint256[] calldata amounts, uint256[] calldata modes, address onBehalfOf, bytes calldata params, uint16 referralCode ) external;
249	 function getUserAccountData(address user) external view returns ( uint256 totalCollateralETH, uint256 totalDebtETH, uint256 availableBorrowsETH, uint256 currentLiquidationThreshold, uint256 ltv, uint256 healthFactor );
250	 function initReserve( address reserve, address aTokenAddress, address stableDebtAddress, address variableDebtAddress, address interestRateStrategyAddress ) external;
251	 function setReserveInterestRateStrategyAddress( address reserve, address rateStrategyAddress ) external;
252	 function setConfiguration(address reserve, uint256 configuration) external;
253	 function getConfiguration(address asset) external view returns (DataTypes.ReserveConfigurationMap memory);
254	 function getUserConfiguration(address user) external view returns (DataTypes.UserConfigurationMap memory);
255	 function getReserveNormalizedIncome(address asset) external view returns (uint256);
256	 function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);
257	 function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);
258	 function finalizeTransfer( address asset, address from, address to, uint256 amount, uint256 balanceFromAfter, uint256 balanceToBefore ) external;
259	 function getReservesList() external view returns (address[] memory);
260	 function getAddressesProvider() external view returns (ILendingPoolAddressesProvider);
261	 function setPause(bool val) external;
262	 function paused() external view returns (bool);
263	 }
264	 interface IProtocolDataProvider {
265	 struct TokenData {
266	 string symbol;
267	 address tokenAddress;
268	 }
269	 function ADDRESSES_PROVIDER() external view returns (ILendingPoolAddressesProvider);
270	 function getAllReservesTokens() external view returns (TokenData[] memory);
271	 function getAllATokens() external view returns (TokenData[] memory);
272	 function getReserveConfigurationData(address asset) external view returns ( uint256 decimals, uint256 ltv, uint256 liquidationThreshold, uint256 liquidationBonus, uint256 reserveFactor, bool usageAsCollateralEnabled, bool borrowingEnabled, bool stableBorrowRateEnabled, bool isActive, bool isFrozen );
273	 function getReserveData(address asset) external view returns ( uint256 availableLiquidity, uint256 totalStableDebt, uint256 totalVariableDebt, uint256 liquidityRate, uint256 variableBorrowRate, uint256 stableBorrowRate, uint256 averageStableBorrowRate, uint256 liquidityIndex, uint256 variableBorrowIndex, uint40 lastUpdateTimestamp );
274	 function getUserReserveData(address asset, address user) external view returns ( uint256 currentATokenBalance, uint256 currentStableDebt, uint256 currentVariableDebt, uint256 principalStableDebt, uint256 scaledVariableDebt, uint256 stableBorrowRate, uint256 liquidityRate, uint40 stableRateLastUpdated, bool usageAsCollateralEnabled );
275	 function getReserveTokensAddresses(address asset) external view returns ( address aTokenAddress, address stableDebtTokenAddress, address variableDebtTokenAddress );
276	 }
277	 interface ISwapRouter is IUniswapV3SwapCallback {
278	 struct ExactInputSingleParams {
279	 address tokenIn;
280	 address tokenOut;
281	 uint24 fee;
282	 address recipient;
283	 uint256 deadline;
284	 uint256 amountIn;
285	 uint256 amountOutMinimum;
286	 uint160 sqrtPriceLimitX96;
287	 }
288	 function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);
289	 struct ExactInputParams {
290	 bytes path;
291	 address recipient;
292	 uint256 deadline;
293	 uint256 amountIn;
294	 uint256 amountOutMinimum;
295	 }
296	 function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);
297	 struct ExactOutputSingleParams {
298	 address tokenIn;
299	 address tokenOut;
300	 uint24 fee;
301	 address recipient;
302	 uint256 deadline;
303	 uint256 amountOut;
304	 uint256 amountInMaximum;
305	 uint160 sqrtPriceLimitX96;
306	 }
307	 function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);
308	 struct ExactOutputParams {
309	 bytes path;
310	 address recipient;
311	 uint256 deadline;
312	 uint256 amountOut;
313	 uint256 amountInMaximum;
314	 }
315	 function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);
316	 }
317	 interface IVariableDebtToken is IERC20, IScaledBalanceToken {
318	 event Mint( address indexed from, address indexed onBehalfOf, uint256 value, uint256 index );
319	 function mint( address user, address onBehalfOf, uint256 amount, uint256 index ) external returns (bool);
320	 event Burn(address indexed user, uint256 amount, uint256 index);
321	 function burn( address user, uint256 amount, uint256 index ) external;
322	 function getIncentivesController() external view returns (IAaveIncentivesController);
323	 }
324	 library SafeERC20 {
325	 using SafeMath for uint256;
326	 using Address for address;
327	 function safeTransfer(IERC20 token, address to, uint256 value) internal {
328	 _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
329	 }
330	 function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
331	 _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
332	 }
333	 function safeApprove(IERC20 token, address spender, uint256 value) internal {
334	 require((value == 0) || (token.allowance(address(this), spender) == 0), "SafeERC20: approve from non-zero to non-zero allowance" );
335	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
336	 }
337	 function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
338	 uint256 newAllowance = token.allowance(address(this), spender).add(value);
339	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
340	 }
341	 function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
342	 uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
343	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
344	 }
345	 function _callOptionalReturn(IERC20 token, bytes memory data) private {
346	 bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
347	 if (returndata.length > 0) {
348	 require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
349	 }
350	 }
351	 }
352	 interface VaultAPI is IERC20 {
353	 function name() external view returns (string calldata);
354	 function symbol() external view returns (string calldata);
355	 function decimals() external view returns (uint256);
356	 function apiVersion() external pure returns (string memory);
357	 function permit( address owner, address spender, uint256 amount, uint256 expiry, bytes calldata signature ) external returns (bool);
358	 function deposit() external returns (uint256);
359	 function deposit(uint256 amount) external returns (uint256);
360	 function deposit(uint256 amount, address recipient) external returns (uint256);
361	 function withdraw() external returns (uint256);
362	 function withdraw(uint256 maxShares) external returns (uint256);
363	 function withdraw(uint256 maxShares, address recipient) external returns (uint256);
364	 function token() external view returns (address);
365	 function strategies(address _strategy) external view returns (StrategyParams memory);
366	 function pricePerShare() external view returns (uint256);
367	 function totalAssets() external view returns (uint256);
368	 function depositLimit() external view returns (uint256);
369	 function maxAvailableShares() external view returns (uint256);
370	 function creditAvailable() external view returns (uint256);
371	 function debtOutstanding() external view returns (uint256);
372	 function expectedReturn() external view returns (uint256);
373	 function report( uint256 _gain, uint256 _loss, uint256 _debtPayment ) external returns (uint256);
374	 function revokeStrategy() external;
375	 function governance() external view returns (address);
376	 function management() external view returns (address);
377	 function guardian() external view returns (address);
378	 }
379	 interface IInitializableAToken {
380	 event Initialized( address indexed underlyingAsset, address indexed pool, address treasury, address incentivesController, uint8 aTokenDecimals, string aTokenName, string aTokenSymbol, bytes params );
381	 function initialize( ILendingPool pool, address treasury, address underlyingAsset, IAaveIncentivesController incentivesController, uint8 aTokenDecimals, string calldata aTokenName, string calldata aTokenSymbol, bytes calldata params ) external;
382	 }
383	 abstract contract BaseStrategy {
384	 using SafeMath for uint256;
385	 using SafeERC20 for IERC20;
386	 string public metadataURI;
387	 bool public doHealthCheck;
388	 address public healthCheck;
389	 function apiVersion() public pure returns (string memory) {
390	 return "0.4.3";
391	 }
392	 function name() external view virtual returns (string memory);
393	 function delegatedAssets() external view virtual returns (uint256) {
394	 return 0;
395	 }
396	 VaultAPI public vault;
397	 address public strategist;
398	 address public rewards;
399	 address public keeper;
400	 IERC20 public want;
401	 event Harvested(uint256 profit, uint256 loss, uint256 debtPayment, uint256 debtOutstanding);
402	 event UpdatedStrategist(address newStrategist);
403	 event UpdatedKeeper(address newKeeper);
404	 event UpdatedRewards(address rewards);
405	 event UpdatedMinReportDelay(uint256 delay);
406	 event UpdatedMaxReportDelay(uint256 delay);
407	 event UpdatedProfitFactor(uint256 profitFactor);
408	 event UpdatedDebtThreshold(uint256 debtThreshold);
409	 event EmergencyExitEnabled();
410	 event UpdatedMetadataURI(string metadataURI);
411	 uint256 public minReportDelay;
412	 uint256 public maxReportDelay;
413	 uint256 public profitFactor;
414	 uint256 public debtThreshold;
415	 bool public emergencyExit;
416	 modifier onlyAuthorized() {
417	 require(msg.sender == strategist || msg.sender == governance(), "!authorized");
418	 _;
419	 }
420	 modifier onlyEmergencyAuthorized() {
421	 require( msg.sender == strategist || msg.sender == governance() || msg.sender == vault.guardian() || msg.sender == vault.management(), "!authorized" );
422	 _;
423	 }
424	 modifier onlyStrategist() {
425	 require(msg.sender == strategist, "!strategist");
426	 _;
427	 }
428	 modifier onlyGovernance() {
429	 require(msg.sender == governance(), "!authorized");
430	 _;
431	 }
432	 modifier onlyKeepers() {
433	 require( msg.sender == keeper || msg.sender == strategist || msg.sender == governance() || msg.sender == vault.guardian() || msg.sender == vault.management(), "!authorized" );
434	 _;
435	 }
436	 modifier onlyVaultManagers() {
437	 require(msg.sender == vault.management() || msg.sender == governance(), "!authorized");
438	 _;
439	 }
440	 constructor(address _vault) public {
441	 _initialize(_vault, msg.sender, msg.sender, msg.sender);
442	 }
443	 function _initialize( address _vault, address _strategist, address _rewards, address _keeper ) internal {
444	 require(address(want) == address(0), "Strategy already initialized");
445	 vault = VaultAPI(_vault);
446	 want = IERC20(vault.token());
447	 want.safeApprove(_vault, uint256(-1));
448	 strategist = _strategist;
449	 rewards = _rewards;
450	 keeper = _keeper;
451	 minReportDelay = 0;
452	 maxReportDelay = 86400;
453	 profitFactor = 100;
454	 debtThreshold = 0;
455	 vault.approve(rewards, uint256(-1));
456	 }
457	 function setHealthCheck(address _healthCheck) external onlyVaultManagers {
458	 healthCheck = _healthCheck;
459	 }
460	 function setDoHealthCheck(bool _doHealthCheck) external onlyVaultManagers {
461	 doHealthCheck = _doHealthCheck;
462	 }
463	 function setStrategist(address _strategist) external onlyAuthorized {
464	 require(_strategist != address(0));
465	 strategist = _strategist;
466	 emit UpdatedStrategist(_strategist);
467	 }
468	 function setKeeper(address _keeper) external onlyAuthorized {
469	 require(_keeper != address(0));
470	 keeper = _keeper;
471	 emit UpdatedKeeper(_keeper);
472	 }
473	 function setRewards(address _rewards) external onlyStrategist {
474	 require(_rewards != address(0));
475	 vault.approve(rewards, 0);
476	 rewards = _rewards;
477	 vault.approve(rewards, uint256(-1));
478	 emit UpdatedRewards(_rewards);
479	 }
480	 function setMinReportDelay(uint256 _delay) external onlyAuthorized {
481	 minReportDelay = _delay;
482	 emit UpdatedMinReportDelay(_delay);
483	 }
484	 function setMaxReportDelay(uint256 _delay) external onlyAuthorized {
485	 maxReportDelay = _delay;
486	 emit UpdatedMaxReportDelay(_delay);
487	 }
488	 function setProfitFactor(uint256 _profitFactor) external onlyAuthorized {
489	 profitFactor = _profitFactor;
490	 emit UpdatedProfitFactor(_profitFactor);
491	 }
492	 function setDebtThreshold(uint256 _debtThreshold) external onlyAuthorized {
493	 debtThreshold = _debtThreshold;
494	 emit UpdatedDebtThreshold(_debtThreshold);
495	 }
496	 function setMetadataURI(string calldata _metadataURI) external onlyAuthorized {
497	 metadataURI = _metadataURI;
498	 emit UpdatedMetadataURI(_metadataURI);
499	 }
500	 function governance() internal view returns (address) {
501	 return vault.governance();
502	 }
503	 function ethToWant(uint256 _amtInWei) public view virtual returns (uint256);
504	 function estimatedTotalAssets() public view virtual returns (uint256);
505	 function isActive() public view returns (bool) {
506	 return vault.strategies(address(this)).debtRatio > 0 || estimatedTotalAssets() > 0;
507	 }
508	 function prepareReturn(uint256 _debtOutstanding) internal virtual returns ( uint256 _profit, uint256 _loss, uint256 _debtPayment );
509	 function adjustPosition(uint256 _debtOutstanding) internal virtual;
510	 function liquidatePosition(uint256 _amountNeeded) internal virtual returns (uint256 _liquidatedAmount, uint256 _loss);
511	 function liquidateAllPositions() internal virtual returns (uint256 _amountFreed);
512	 function tendTrigger(uint256 callCostInWei) public view virtual returns (bool) {
513	 return false;
514	 }
515	 function tend() external onlyKeepers {
516	 adjustPosition(vault.debtOutstanding());
517	 }
518	 function harvestTrigger(uint256 callCostInWei) public view virtual returns (bool) {
519	 uint256 callCost = ethToWant(callCostInWei);
520	 StrategyParams memory params = vault.strategies(address(this));
521	 if (params.activation == 0) return false;
522	 if (block.timestamp.sub(params.lastReport) < minReportDelay) return false;
523	 if (block.timestamp.sub(params.lastReport) >= maxReportDelay) return true;
524	 uint256 outstanding = vault.debtOutstanding();
525	 if (outstanding > debtThreshold) return true;
526	 uint256 total = estimatedTotalAssets();
527	 if (total.add(debtThreshold) < params.totalDebt) return true;
528	 uint256 profit = 0;
529	 if (total > params.totalDebt) profit = total.sub(params.totalDebt);
530	 uint256 credit = vault.creditAvailable();
531	 return (profitFactor.mul(callCost) < credit.add(profit));
532	 }
533	 function harvest() external onlyKeepers {
534	 uint256 profit = 0;
535	 uint256 loss = 0;
536	 uint256 debtOutstanding = vault.debtOutstanding();
537	 uint256 debtPayment = 0;
538	 if (emergencyExit) {
539	 uint256 amountFreed = liquidateAllPositions();
540	 if (amountFreed < debtOutstanding) {
541	 loss = debtOutstanding.sub(amountFreed);
542	 }
543	 else if (amountFreed > debtOutstanding) {
544	 profit = amountFreed.sub(debtOutstanding);
545	 }
546	 debtPayment = debtOutstanding.sub(loss);
547	 }
548	 else {
549	 (profit, loss, debtPayment) = prepareReturn(debtOutstanding);
550	 }
551	 uint256 totalDebt = vault.strategies(address(this)).totalDebt;
552	 debtOutstanding = vault.report(profit, loss, debtPayment);
553	 adjustPosition(debtOutstanding);
554	 if (doHealthCheck && healthCheck != address(0)) {
555	 require(HealthCheck(healthCheck).check(profit, loss, debtPayment, debtOutstanding, totalDebt), "!healthcheck");
556	 }
557	 else {
558	 doHealthCheck = true;
559	 }
560	 emit Harvested(profit, loss, debtPayment, debtOutstanding);
561	 }
562	 function withdraw(uint256 _amountNeeded) external returns (uint256 _loss) {
563	 require(msg.sender == address(vault), "!vault");
564	 uint256 amountFreed;
565	 (amountFreed, _loss) = liquidatePosition(_amountNeeded);
566	 want.safeTransfer(msg.sender, amountFreed);
567	 }
568	 function prepareMigration(address _newStrategy) internal virtual;
569	 function migrate(address _newStrategy) external {
570	 require(msg.sender == address(vault));
571	 require(BaseStrategy(_newStrategy).vault() == vault);
572	 prepareMigration(_newStrategy);
573	 want.safeTransfer(_newStrategy, want.balanceOf(address(this)));
574	 }
575	 function setEmergencyExit() external onlyEmergencyAuthorized {
576	 emergencyExit = true;
577	 vault.revokeStrategy();
578	 emit EmergencyExitEnabled();
579	 }
580	 function protectedTokens() internal view virtual returns (address[] memory);
581	 function sweep(address _token) external onlyGovernance {
582	 require(_token != address(want), "!want");
583	 require(_token != address(vault), "!shares");
584	 address[] memory _protectedTokens = protectedTokens();
585	 for (uint256 i; i < _protectedTokens.length; i++) require(_token != _protectedTokens[i], "!protected");
586	 IERC20(_token).safeTransfer(governance(), IERC20(_token).balanceOf(address(this)));
587	 }
588	 }
589	 interface IAToken is IERC20, IScaledBalanceToken, IInitializableAToken {
590	 event Mint(address indexed from, uint256 value, uint256 index);
591	 function mint( address user, uint256 amount, uint256 index ) external returns (bool);
592	 event Burn( address indexed from, address indexed target, uint256 value, uint256 index );
593	 event BalanceTransfer( address indexed from, address indexed to, uint256 value, uint256 index );
594	 function burn( address user, address receiverOfUnderlying, uint256 amount, uint256 index ) external;
595	 function mintToTreasury(uint256 amount, uint256 index) external;
596	 function transferOnLiquidation( address from, address to, uint256 value ) external;
597	 function transferUnderlyingTo(address user, uint256 amount) external returns (uint256);
598	 function handleRepayment(address user, uint256 amount) external;
599	 function getIncentivesController() external view returns (IAaveIncentivesController);
600	 function UNDERLYING_ASSET_ADDRESS() external view returns (address);
601	 }
602	 library FlashMintLib {
603	 using SafeMath for uint256;
604	 event Leverage( uint256 amountRequested, uint256 amountUsed, uint256 requiredDAI, uint256 amountToCloseLTVGap, bool deficit, address flashLoan );
605	 address public constant LENDER = 0x1EB4CF3A948E7D72A198fe073cCb8C7a948cD853;
606	 uint256 private constant DAI_DECIMALS = 1e18;
607	 uint256 private constant COLLAT_RATIO_PRECISION = 1 ether;
608	 address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
609	 address private constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
610	 IAToken public constant ADAI = IAToken(0x028171bCA77440897B824Ca71D1c56caC55b68A3);
611	 IProtocolDataProvider private constant protocolDataProvider = IProtocolDataProvider(0x057835Ad21a177dbdd3090bB1CAE03EaCF78Fc6d);
612	 ILendingPool private constant lendingPool = ILendingPool(0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9);
613	 bytes32 public constant CALLBACK_SUCCESS = keccak256("ERC3156FlashBorrower.onFlashLoan");
614	 uint16 private constant referral = 7;
615	 function doFlashMint( bool deficit, uint256 amountDesired, address token, uint256 collatRatioDAI, uint256 depositToCloseLTVGap ) public returns (uint256 amount) {
616	 if (amountDesired == 0) {
617	 return 0;
618	 }
619	 amount = amountDesired;
620	 address dai = DAI;
621	 uint256 requiredDAI;
622	 {
623	 requiredDAI = _toDAI(amount, token).mul(COLLAT_RATIO_PRECISION).div( collatRatioDAI );
624	 uint256 requiredDAIToCloseLTVGap = 0;
625	 if (depositToCloseLTVGap > 0) {
626	 requiredDAIToCloseLTVGap = _toDAI(depositToCloseLTVGap, token);
627	 requiredDAI = requiredDAI.add(requiredDAIToCloseLTVGap);
628	 }
629	 uint256 _maxLiquidity = maxLiquidity();
630	 if (requiredDAI > _maxLiquidity) {
631	 requiredDAI = _maxLiquidity;
632	 amount = _fromDAI( requiredDAI.sub(requiredDAIToCloseLTVGap), token ) .mul(collatRatioDAI) .div(COLLAT_RATIO_PRECISION);
633	 }
634	 }
635	 bytes memory data = abi.encode(deficit, amount);
636	 uint256 _fee = IERC3156FlashLender(LENDER).flashFee(dai, requiredDAI);
637	 require(_fee == 0);
638	 uint256 _allowance = IERC20(dai).allowance(address(this), address(LENDER));
639	 if (_allowance < requiredDAI) {
640	 IERC20(dai).approve(address(LENDER), 0);
641	 IERC20(dai).approve(address(LENDER), type(uint256).max);
642	 }
643	 IERC3156FlashLender(LENDER).flashLoan( IERC3156FlashBorrower(address(this)), dai, requiredDAI, data );
644	 emit Leverage( amountDesired, amount, requiredDAI, depositToCloseLTVGap, deficit, LENDER );
645	 return amount;
646	 }
647	 function loanLogic( bool deficit, uint256 amount, uint256 amountFlashmint, address want ) public returns (bytes32) {
648	 address dai = DAI;
649	 bool isDai = (want == dai);
650	 ILendingPool lp = lendingPool;
651	 if (isDai) {
652	 if (deficit) {
653	 lp.deposit( dai, amountFlashmint.sub(amount), address(this), referral );
654	 lp.repay( dai, IERC20(dai).balanceOf(address(this)), 2, address(this) );
655	 lp.withdraw(dai, amountFlashmint, address(this));
656	 }
657	 else {
658	 lp.deposit( dai, IERC20(dai).balanceOf(address(this)), address(this), referral );
659	 lp.borrow(dai, amount, 2, referral, address(this));
660	 lp.withdraw(dai, amountFlashmint.sub(amount), address(this));
661	 }
662	 }
663	 else {
664	 lp.deposit(dai, amountFlashmint, address(this), referral);
665	 if (deficit) {
666	 lp.withdraw(want, amount, address(this));
667	 lp.repay( want, IERC20(want).balanceOf(address(this)), 2, address(this) );
668	 }
669	 else {
670	 lp.borrow(want, amount, 2, referral, address(this));
671	 lp.deposit( want, IERC20(want).balanceOf(address(this)), address(this), referral );
672	 }
673	 lp.withdraw(dai, amountFlashmint, address(this));
674	 }
675	 return CALLBACK_SUCCESS;
676	 }
677	 function _priceOracle() internal view returns (IPriceOracle) {
678	 return IPriceOracle( protocolDataProvider.ADDRESSES_PROVIDER().getPriceOracle() );
679	 }
680	 function _toDAI(uint256 _amount, address asset) internal view returns (uint256) {
681	 address dai = DAI;
682	 if ( _amount == 0 || _amount == type(uint256).max || asset == dai ) {
683	 return _amount;
684	 }
685	 if (asset == WETH) {
686	 return _amount .mul(uint256(10)**uint256(IOptionalERC20(dai).decimals())) .div(_priceOracle().getAssetPrice(dai));
687	 }
688	 address[] memory tokens = new address[](2);
689	 tokens[0] = asset;
690	 tokens[1] = dai;
691	 uint256[] memory prices = _priceOracle().getAssetsPrices(tokens);
692	 uint256 ethPrice = _amount.mul(prices[0]).div( uint256(10)**uint256(IOptionalERC20(asset).decimals()) );
693	 return ethPrice.mul(DAI_DECIMALS).div(prices[1]);
694	 }
695	 function _fromDAI(uint256 _amount, address asset) internal view returns (uint256) {
696	 address dai = DAI;
697	 if ( _amount == 0 || _amount == type(uint256).max || asset == dai ) {
698	 return _amount;
699	 }
700	 if (asset == WETH) {
701	 return _amount.mul(_priceOracle().getAssetPrice(dai)).div( uint256(10)**uint256(IOptionalERC20(dai).decimals()) );
702	 }
703	 address[] memory tokens = new address[](2);
704	 tokens[0] = asset;
705	 tokens[1] = dai;
706	 uint256[] memory prices = _priceOracle().getAssetsPrices(tokens);
707	 uint256 ethPrice = _amount.mul(prices[1]).div(DAI_DECIMALS);
708	 return ethPrice .mul(uint256(10)**uint256(IOptionalERC20(asset).decimals())) .div(prices[0]);
709	 }
710	 function maxLiquidity() public view returns (uint256) {
711	 return IERC3156FlashLender(LENDER).maxFlashLoan(DAI);
712	 }
713	 }
714	 contract Strategy is BaseStrategy, IERC3156FlashBorrower {
715	 using SafeERC20 for IERC20;
716	 using Address for address;
717	 using SafeMath for uint256;
718	 IProtocolDataProvider private constant protocolDataProvider = IProtocolDataProvider(0x057835Ad21a177dbdd3090bB1CAE03EaCF78Fc6d);
719	 IAaveIncentivesController private constant incentivesController = IAaveIncentivesController(0xd784927Ff2f95ba542BfC824c8a8a98F3495f6b5);
720	 ILendingPool private constant lendingPool = ILendingPool(0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9);
721	 address private constant aave = 0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9;
722	 IStakedAave private constant stkAave = IStakedAave(0x4da27a545c0c5B758a6BA100e3a049001de870f5);
723	 address private constant weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
724	 address private constant dai = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
725	 IAToken public aToken;
726	 IVariableDebtToken public debtToken;
727	 enum CooldownStatus {
728	 None, Claim, Initiated}
729	 IUni private constant UNI_V2_ROUTER = IUni(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
730	 IUni private constant SUSHI_V2_ROUTER = IUni(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);
731	 ISwapRouter private constant UNI_V3_ROUTER = ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564);
732	 uint256 private constant DEFAULT_COLLAT_TARGET_MARGIN = 0.02 ether;
733	 uint256 private constant DEFAULT_COLLAT_MAX_MARGIN = 0.005 ether;
734	 uint256 private constant LIQUIDATION_WARNING_THRESHOLD = 0.01 ether;
735	 uint256 public maxBorrowCollatRatio;
736	 uint256 public targetCollatRatio;
737	 uint256 public maxCollatRatio;
738	 uint256 public daiBorrowCollatRatio;
739	 uint8 public maxIterations;
740	 bool public isFlashMintActive;
741	 bool public withdrawCheck;
742	 uint256 public minWant;
743	 uint256 public minRatio;
744	 uint256 public minRewardToSell;
745	 enum SwapRouter {
746	 UniV2, SushiV2, UniV3}
747	 SwapRouter public swapRouter = SwapRouter.UniV2;
748	 bool public sellStkAave;
749	 bool public cooldownStkAave;
750	 uint256 public maxStkAavePriceImpactBps;
751	 uint24 public stkAaveToAaveSwapFee;
752	 uint24 public aaveToWethSwapFee;
753	 uint24 public wethToWantSwapFee;
754	 bool private alreadyAdjusted;
755	 uint16 private constant referral = 7;
756	 uint256 private constant MAX_BPS = 1e4;
757	 uint256 private constant BPS_WAD_RATIO = 1e14;
758	 uint256 private constant COLLATERAL_RATIO_PRECISION = 1 ether;
759	 uint256 private constant PESSIMISM_FACTOR = 1000;
760	 uint256 private DECIMALS;
761	 constructor(address _vault) public BaseStrategy(_vault) {
762	 _initializeThis();
763	 }
764	 function initialize( address _vault, address _strategist, address _rewards, address _keeper ) external {
765	 _initialize(_vault, _strategist, _rewards, _keeper);
766	 _initializeThis();
767	 }
768	 function _initializeThis() internal {
769	 require(address(aToken) == address(0));
770	 maxIterations = 6;
771	 isFlashMintActive = true;
772	 withdrawCheck = false;
773	 minWant = 100;
774	 minRatio = 0.005 ether;
775	 minRewardToSell = 1e15;
776	 swapRouter = SwapRouter.UniV2;
777	 sellStkAave = true;
778	 cooldownStkAave = false;
779	 maxStkAavePriceImpactBps = 500;
780	 stkAaveToAaveSwapFee = 3000;
781	 aaveToWethSwapFee = 3000;
782	 wethToWantSwapFee = 3000;
783	 alreadyAdjusted = false;
784	 (address _aToken, , address _debtToken) = protocolDataProvider.getReserveTokensAddresses(address(want));
785	 aToken = IAToken(_aToken);
786	 debtToken = IVariableDebtToken(_debtToken);
787	 (uint256 ltv, uint256 liquidationThreshold) = getProtocolCollatRatios(address(want));
788	 targetCollatRatio = liquidationThreshold.sub( DEFAULT_COLLAT_TARGET_MARGIN );
789	 maxCollatRatio = liquidationThreshold.sub(DEFAULT_COLLAT_MAX_MARGIN);
790	 maxBorrowCollatRatio = ltv.sub(DEFAULT_COLLAT_MAX_MARGIN);
791	 (uint256 daiLtv, ) = getProtocolCollatRatios(dai);
792	 daiBorrowCollatRatio = daiLtv.sub(DEFAULT_COLLAT_MAX_MARGIN);
793	 DECIMALS = 10**vault.decimals();
794	 approveMaxSpend(address(want), address(lendingPool));
795	 approveMaxSpend(address(aToken), address(lendingPool));
796	 address _dai = dai;
797	 if (address(want) != _dai) {
798	 approveMaxSpend(_dai, address(lendingPool));
799	 }
800	 approveMaxSpend(_dai, FlashMintLib.LENDER);
801	 approveMaxSpend(address(stkAave), address(UNI_V3_ROUTER));
802	 approveMaxSpend(aave, address(UNI_V2_ROUTER));
803	 approveMaxSpend(aave, address(SUSHI_V2_ROUTER));
804	 approveMaxSpend(aave, address(UNI_V3_ROUTER));
805	 }
806	 function setCollateralTargets( uint256 _targetCollatRatio, uint256 _maxCollatRatio, uint256 _maxBorrowCollatRatio, uint256 _daiBorrowCollatRatio ) external onlyVaultManagers {
807	 (uint256 ltv, uint256 liquidationThreshold) = getProtocolCollatRatios(address(want));
808	 (uint256 daiLtv, ) = getProtocolCollatRatios(dai);
809	 require(_targetCollatRatio < liquidationThreshold);
810	 require(_maxCollatRatio < liquidationThreshold);
811	 require(_targetCollatRatio < _maxCollatRatio);
812	 require(_maxBorrowCollatRatio < ltv);
813	 require(_daiBorrowCollatRatio < daiLtv);
814	 targetCollatRatio = _targetCollatRatio;
815	 maxCollatRatio = _maxCollatRatio;
816	 maxBorrowCollatRatio = _maxBorrowCollatRatio;
817	 daiBorrowCollatRatio = _daiBorrowCollatRatio;
818	 }
819	 function setIsFlashMintActive(bool _isFlashMintActive) external onlyVaultManagers {
820	 isFlashMintActive = _isFlashMintActive;
821	 }
822	 function setWithdrawCheck(bool _withdrawCheck) external onlyVaultManagers {
823	 withdrawCheck = _withdrawCheck;
824	 }
825	 function setMinsAndMaxs( uint256 _minWant, uint256 _minRatio, uint8 _maxIterations ) external onlyVaultManagers {
826	 require(_minRatio < maxBorrowCollatRatio);
827	 require(_maxIterations > 0 && _maxIterations < 16);
828	 minWant = _minWant;
829	 minRatio = _minRatio;
830	 maxIterations = _maxIterations;
831	 }
832	 function setRewardBehavior( SwapRouter _swapRouter, bool _sellStkAave, bool _cooldownStkAave, uint256 _minRewardToSell, uint256 _maxStkAavePriceImpactBps, uint24 _stkAaveToAaveSwapFee, uint24 _aaveToWethSwapFee, uint24 _wethToWantSwapFee ) external onlyVaultManagers {
833	 require( _swapRouter == SwapRouter.UniV2 || _swapRouter == SwapRouter.SushiV2 || _swapRouter == SwapRouter.UniV3 );
834	 require(_maxStkAavePriceImpactBps <= MAX_BPS);
835	 swapRouter = _swapRouter;
836	 sellStkAave = _sellStkAave;
837	 cooldownStkAave = _cooldownStkAave;
838	 minRewardToSell = _minRewardToSell;
839	 maxStkAavePriceImpactBps = _maxStkAavePriceImpactBps;
840	 stkAaveToAaveSwapFee = _stkAaveToAaveSwapFee;
841	 aaveToWethSwapFee = _aaveToWethSwapFee;
842	 wethToWantSwapFee = _wethToWantSwapFee;
843	 }
844	 function name() external view override returns (string memory) {
845	 return "StrategyGenLevAAVE-Flashmint";
846	 }
847	 function estimatedTotalAssets() public view override returns (uint256) {
848	 uint256 balanceExcludingRewards = balanceOfWant().add(getCurrentSupply());
849	 if (balanceExcludingRewards < minWant) {
850	 return balanceExcludingRewards;
851	 }
852	 uint256 rewards = estimatedRewardsInWant().mul(MAX_BPS.sub(PESSIMISM_FACTOR)).div( MAX_BPS );
853	 return balanceExcludingRewards.add(rewards);
854	 }
855	 function estimatedRewardsInWant() public view returns (uint256) {
856	 uint256 aaveBalance = balanceOfAave();
857	 uint256 stkAaveBalance = balanceOfStkAave();
858	 uint256 pendingRewards = incentivesController.getRewardsBalance( getAaveAssets(), address(this) );
859	 uint256 stkAaveDiscountFactor = MAX_BPS.sub(maxStkAavePriceImpactBps);
860	 uint256 combinedStkAave = pendingRewards.add(stkAaveBalance).mul(stkAaveDiscountFactor).div( MAX_BPS );
861	 return tokenToWant(aave, aaveBalance.add(combinedStkAave));
862	 }
863	 function prepareReturn(uint256 _debtOutstanding) internal override returns ( uint256 _profit, uint256 _loss, uint256 _debtPayment ) {
864	 _claimAndSellRewards();
865	 uint256 totalDebt = vault.strategies(address(this)).totalDebt;
866	 uint256 supply = getCurrentSupply();
867	 uint256 totalAssets = balanceOfWant().add(supply);
868	 if (totalDebt > totalAssets) {
869	 _loss = totalDebt.sub(totalAssets);
870	 }
871	 else {
872	 _profit = totalAssets.sub(totalDebt);
873	 }
874	 uint256 amountAvailable = balanceOfWant();
875	 uint256 amountRequired = _debtOutstanding.add(_profit);
876	 if (amountRequired > amountAvailable) {
877	 (amountAvailable, ) = liquidatePosition(amountRequired);
878	 alreadyAdjusted = true;
879	 if (amountAvailable >= amountRequired) {
880	 _debtPayment = _debtOutstanding;
881	 if (amountRequired.sub(_debtPayment) < _profit) {
882	 _profit = amountRequired.sub(_debtPayment);
883	 }
884	 }
885	 else {
886	 if (amountAvailable < _debtOutstanding) {
887	 _profit = 0;
888	 _debtPayment = amountAvailable;
889	 }
890	 else {
891	 _debtPayment = _debtOutstanding;
892	 _profit = amountAvailable.sub(_debtPayment);
893	 }
894	 }
895	 }
896	 else {
897	 _debtPayment = _debtOutstanding;
898	 if (amountRequired.sub(_debtPayment) < _profit) {
899	 _profit = amountRequired.sub(_debtPayment);
900	 }
901	 }
902	 }
903	 function adjustPosition(uint256 _debtOutstanding) internal override {
904	 if (alreadyAdjusted) {
905	 alreadyAdjusted = false;
906	 return;
907	 }
908	 uint256 wantBalance = balanceOfWant();
909	 if ( wantBalance > _debtOutstanding && wantBalance.sub(_debtOutstanding) > minWant ) {
910	 _depositCollateral(wantBalance.sub(_debtOutstanding));
911	 wantBalance = balanceOfWant();
912	 }
913	 uint256 currentCollatRatio = getCurrentCollatRatio();
914	 if (_debtOutstanding > wantBalance) {
915	 uint256 amountRequired = _debtOutstanding.sub(wantBalance);
916	 _freeFunds(amountRequired);
917	 }
918	 else if (currentCollatRatio < targetCollatRatio) {
919	 if (targetCollatRatio.sub(currentCollatRatio) > minRatio) {
920	 _leverMax();
921	 }
922	 }
923	 else if (currentCollatRatio > targetCollatRatio) {
924	 if (currentCollatRatio.sub(targetCollatRatio) > minRatio) {
925	 (uint256 deposits, uint256 borrows) = getCurrentPosition();
926	 uint256 newBorrow = getBorrowFromSupply( deposits.sub(borrows), targetCollatRatio );
927	 _leverDownTo(newBorrow, borrows);
928	 }
929	 }
930	 }
931	 function liquidatePosition(uint256 _amountNeeded) internal override returns (uint256 _liquidatedAmount, uint256 _loss) {
932	 uint256 wantBalance = balanceOfWant();
933	 if (wantBalance > _amountNeeded) {
934	 return (_amountNeeded, 0);
935	 }
936	 uint256 amountRequired = _amountNeeded.sub(wantBalance);
937	 _freeFunds(amountRequired);
938	 uint256 freeAssets = balanceOfWant();
939	 if (_amountNeeded > freeAssets) {
940	 _liquidatedAmount = freeAssets;
941	 uint256 diff = _amountNeeded.sub(_liquidatedAmount);
942	 if (diff <= minWant) {
943	 _loss = diff;
944	 }
945	 }
946	 else {
947	 _liquidatedAmount = _amountNeeded;
948	 }
949	 if (withdrawCheck) {
950	 require(_amountNeeded == _liquidatedAmount.add(_loss));
951	 }
952	 }
953	 function tendTrigger(uint256 gasCost) public view override returns (bool) {
954	 if (harvestTrigger(gasCost)) {
955	 return false;
956	 }
957	 (, uint256 liquidationThreshold) = getProtocolCollatRatios(address(want));
958	 uint256 currentCollatRatio = getCurrentCollatRatio();
959	 if (currentCollatRatio >= liquidationThreshold) {
960	 return true;
961	 }
962	 return (liquidationThreshold.sub(currentCollatRatio) <= LIQUIDATION_WARNING_THRESHOLD);
963	 }
964	 function liquidateAllPositions() internal override returns (uint256 _amountFreed) {
965	 (_amountFreed, ) = liquidatePosition(type(uint256).max);
966	 }
967	 function prepareMigration(address _newStrategy) internal override {
968	 require(getCurrentSupply() < minWant);
969	 }
970	 function protectedTokens() internal view override returns (address[] memory) {
971	 }
972	 function manualDeleverage(uint256 amount) external onlyVaultManagers {
973	 _withdrawCollateral(amount);
974	 _repayWant(amount);
975	 }
976	 function manualReleaseWant(uint256 amount) external onlyVaultManagers {
977	 _withdrawCollateral(amount);
978	 }
979	 function manualClaimAndSellRewards() external onlyVaultManagers {
980	 _claimAndSellRewards();
981	 }
982	 function _claimAndSellRewards() internal returns (uint256) {
983	 uint256 stkAaveBalance = balanceOfStkAave();
984	 CooldownStatus cooldownStatus;
985	 if (stkAaveBalance > 0) {
986	 cooldownStatus = _checkCooldown();
987	 }
988	 if (stkAaveBalance > 0 && cooldownStatus == CooldownStatus.Claim) {
989	 stkAave.claimRewards(address(this), type(uint256).max);
990	 stkAave.redeem(address(this), stkAaveBalance);
991	 }
992	 incentivesController.claimRewards( getAaveAssets(), type(uint256).max, address(this) );
993	 stkAaveBalance = balanceOfStkAave();
994	 if ( cooldownStkAave && stkAaveBalance > 0 && cooldownStatus == CooldownStatus.None ) {
995	 stkAave.cooldown();
996	 }
997	 if (sellStkAave && stkAaveBalance >= minRewardToSell.add(1)) {
998	 uint256 minAAVEOut = stkAaveBalance.mul(MAX_BPS.sub(maxStkAavePriceImpactBps)).div( MAX_BPS );
999	 _sellSTKAAVEToAAVE(stkAaveBalance.sub(1), minAAVEOut);
1000	 }
1001	 uint256 aaveBalance = balanceOfAave();
1002	 if (aaveBalance >= minRewardToSell) {
1003	 _sellAAVEForWant(aaveBalance, 0);
1004	 }
1005	 }
1006	 function _freeFunds(uint256 amountToFree) internal returns (uint256) {
1007	 if (amountToFree == 0) return 0;
1008	 (uint256 deposits, uint256 borrows) = getCurrentPosition();
1009	 uint256 realAssets = deposits.sub(borrows);
1010	 uint256 amountRequired = Math.min(amountToFree, realAssets);
1011	 uint256 newSupply = realAssets.sub(amountRequired);
1012	 uint256 newBorrow = getBorrowFromSupply(newSupply, targetCollatRatio);
1013	 _leverDownTo(newBorrow, borrows);
1014	 return balanceOfWant();
1015	 }
1016	 function _leverMax() internal {
1017	 (uint256 deposits, uint256 borrows) = getCurrentPosition();
1018	 uint256 realSupply = deposits.sub(borrows);
1019	 uint256 newBorrow = getBorrowFromSupply(realSupply, targetCollatRatio);
1020	 uint256 totalAmountToBorrow = newBorrow.sub(borrows);
1021	 if (isFlashMintActive) {
1022	 totalAmountToBorrow = totalAmountToBorrow.sub( _leverUpStep(totalAmountToBorrow) );
1023	 if (totalAmountToBorrow > minWant) {
1024	 totalAmountToBorrow = totalAmountToBorrow.sub( _leverUpFlashLoan(totalAmountToBorrow) );
1025	 }
1026	 }
1027	 else {
1028	 for ( uint8 i = 0; i < maxIterations && totalAmountToBorrow > minWant; i++ ) {
1029	 totalAmountToBorrow = totalAmountToBorrow.sub( _leverUpStep(totalAmountToBorrow) );
1030	 }
1031	 }
1032	 }
1033	 function _leverUpFlashLoan(uint256 amount) internal returns (uint256) {
1034	 (uint256 deposits, uint256 borrows) = getCurrentPosition();
1035	 uint256 depositsToMeetLtv = getDepositFromBorrow(borrows, maxBorrowCollatRatio);
1036	 uint256 depositsDeficitToMeetLtv = 0;
1037	 if (depositsToMeetLtv > deposits) {
1038	 depositsDeficitToMeetLtv = depositsToMeetLtv.sub(deposits);
1039	 }
1040	 return FlashMintLib.doFlashMint( false, amount, address(want), daiBorrowCollatRatio, depositsDeficitToMeetLtv );
1041	 }
1042	 function _leverUpStep(uint256 amount) internal returns (uint256) {
1043	 if (amount == 0) {
1044	 return 0;
1045	 }
1046	 uint256 wantBalance = balanceOfWant();
1047	 (uint256 deposits, uint256 borrows) = getCurrentPosition();
1048	 uint256 canBorrow = getBorrowFromDeposit( deposits.add(wantBalance), maxBorrowCollatRatio );
1049	 if (canBorrow <= borrows) {
1050	 return 0;
1051	 }
1052	 canBorrow = canBorrow.sub(borrows);
1053	 if (canBorrow < amount) {
1054	 amount = canBorrow;
1055	 }
1056	 _depositCollateral(wantBalance);
1057	 _borrowWant(amount);
1058	 return amount;
1059	 }
1060	 function _leverDownTo(uint256 newAmountBorrowed, uint256 currentBorrowed) internal {
1061	 if (currentBorrowed > newAmountBorrowed) {
1062	 uint256 totalRepayAmount = currentBorrowed.sub(newAmountBorrowed);
1063	 if (isFlashMintActive) {
1064	 totalRepayAmount = totalRepayAmount.sub( _leverDownFlashLoan(totalRepayAmount) );
1065	 }
1066	 uint256 _maxCollatRatio = maxCollatRatio;
1067	 for ( uint8 i = 0; i < maxIterations && totalRepayAmount > minWant; i++ ) {
1068	 _withdrawExcessCollateral(_maxCollatRatio);
1069	 uint256 toRepay = totalRepayAmount;
1070	 uint256 wantBalance = balanceOfWant();
1071	 if (toRepay > wantBalance) {
1072	 toRepay = wantBalance;
1073	 }
1074	 uint256 repaid = _repayWant(toRepay);
1075	 totalRepayAmount = totalRepayAmount.sub(repaid);
1076	 }
1077	 }
1078	 (uint256 deposits, uint256 borrows) = getCurrentPosition();
1079	 uint256 _targetCollatRatio = targetCollatRatio;
1080	 uint256 targetDeposit = getDepositFromBorrow(borrows, _targetCollatRatio);
1081	 if (targetDeposit > deposits) {
1082	 uint256 toDeposit = targetDeposit.sub(deposits);
1083	 if (toDeposit > minWant) {
1084	 _depositCollateral(Math.min(toDeposit, balanceOfWant()));
1085	 }
1086	 }
1087	 else {
1088	 _withdrawExcessCollateral(_targetCollatRatio);
1089	 }
1090	 }
1091	 function _leverDownFlashLoan(uint256 amount) internal returns (uint256) {
1092	 if (amount <= minWant) return 0;
1093	 (, uint256 borrows) = getCurrentPosition();
1094	 if (amount > borrows) {
1095	 amount = borrows;
1096	 }
1097	 return FlashMintLib.doFlashMint( true, amount, address(want), daiBorrowCollatRatio, 0 );
1098	 }
1099	 function _withdrawExcessCollateral(uint256 collatRatio) internal returns (uint256 amount) {
1100	 (uint256 deposits, uint256 borrows) = getCurrentPosition();
1101	 uint256 theoDeposits = getDepositFromBorrow(borrows, collatRatio);
1102	 if (deposits > theoDeposits) {
1103	 uint256 toWithdraw = deposits.sub(theoDeposits);
1104	 return _withdrawCollateral(toWithdraw);
1105	 }
1106	 }
1107	 function _depositCollateral(uint256 amount) internal returns (uint256) {
1108	 if (amount == 0) return 0;
1109	 lendingPool.deposit(address(want), amount, address(this), referral);
1110	 return amount;
1111	 }
1112	 function _withdrawCollateral(uint256 amount) internal returns (uint256) {
1113	 if (amount == 0) return 0;
1114	 lendingPool.withdraw(address(want), amount, address(this));
1115	 return amount;
1116	 }
1117	 function _repayWant(uint256 amount) internal returns (uint256) {
1118	 if (amount == 0) return 0;
1119	 return lendingPool.repay(address(want), amount, 2, address(this));
1120	 }
1121	 function _borrowWant(uint256 amount) internal returns (uint256) {
1122	 if (amount == 0) return 0;
1123	 lendingPool.borrow(address(want), amount, 2, referral, address(this));
1124	 return amount;
1125	 }
1126	 function balanceOfWant() internal view returns (uint256) {
1127	 return want.balanceOf(address(this));
1128	 }
1129	 function balanceOfAToken() internal view returns (uint256) {
1130	 return aToken.balanceOf(address(this));
1131	 }
1132	 function balanceOfDebtToken() internal view returns (uint256) {
1133	 return debtToken.balanceOf(address(this));
1134	 }
1135	 function balanceOfAave() internal view returns (uint256) {
1136	 return IERC20(aave).balanceOf(address(this));
1137	 }
1138	 function balanceOfStkAave() internal view returns (uint256) {
1139	 return IERC20(address(stkAave)).balanceOf(address(this));
1140	 }
1141	 function onFlashLoan( address initiator, address token, uint256 amount, uint256 fee, bytes calldata data ) external override returns (bytes32) {
1142	 require(msg.sender == FlashMintLib.LENDER);
1143	 require(initiator == address(this));
1144	 (bool deficit, uint256 amountWant) = abi.decode(data, (bool, uint256));
1145	 return FlashMintLib.loanLogic(deficit, amountWant, amount, address(want));
1146	 }
1147	 function getCurrentPosition() public view returns (uint256 deposits, uint256 borrows) {
1148	 deposits = balanceOfAToken();
1149	 borrows = balanceOfDebtToken();
1150	 }
1151	 function getCurrentCollatRatio() public view returns (uint256 currentCollatRatio) {
1152	 (uint256 deposits, uint256 borrows) = getCurrentPosition();
1153	 if (deposits > 0) {
1154	 currentCollatRatio = borrows.mul(COLLATERAL_RATIO_PRECISION).div( deposits );
1155	 }
1156	 }
1157	 function getCurrentSupply() public view returns (uint256) {
1158	 (uint256 deposits, uint256 borrows) = getCurrentPosition();
1159	 return deposits.sub(borrows);
1160	 }
1161	 function tokenToWant(address token, uint256 amount) internal view returns (uint256) {
1162	 if (amount == 0 || address(want) == token) {
1163	 return amount;
1164	 }
1165	 IUni router = swapRouter == SwapRouter.SushiV2 ? SUSHI_V2_ROUTER : UNI_V2_ROUTER;
1166	 uint256[] memory amounts = router.getAmountsOut( amount, getTokenOutPathV2(token, address(want)) );
1167	 return amounts[amounts.length - 1];
1168	 }
1169	 function ethToWant(uint256 _amtInWei) public view override returns (uint256) {
1170	 return tokenToWant(weth, _amtInWei);
1171	 }
1172	 function _checkCooldown() internal view returns (CooldownStatus) {
1173	 uint256 cooldownStartTimestamp = IStakedAave(stkAave).stakersCooldowns(address(this));
1174	 uint256 COOLDOWN_SECONDS = IStakedAave(stkAave).COOLDOWN_SECONDS();
1175	 uint256 UNSTAKE_WINDOW = IStakedAave(stkAave).UNSTAKE_WINDOW();
1176	 uint256 nextClaimStartTimestamp = cooldownStartTimestamp.add(COOLDOWN_SECONDS);
1177	 if (cooldownStartTimestamp == 0) {
1178	 return CooldownStatus.None;
1179	 }
1180	 if ( block.timestamp > nextClaimStartTimestamp && block.timestamp <= nextClaimStartTimestamp.add(UNSTAKE_WINDOW) ) {
1181	 return CooldownStatus.Claim;
1182	 }
1183	 if (block.timestamp < nextClaimStartTimestamp) {
1184	 return CooldownStatus.Initiated;
1185	 }
1186	 }
1187	 function getTokenOutPathV2(address _token_in, address _token_out) internal pure returns (address[] memory _path) {
1188	 bool is_weth = _token_in == address(weth) || _token_out == address(weth);
1189	 _path = new address[](is_weth ? 2 : 3);
1190	 _path[0] = _token_in;
1191	 if (is_weth) {
1192	 _path[1] = _token_out;
1193	 }
1194	 else {
1195	 _path[1] = address(weth);
1196	 _path[2] = _token_out;
1197	 }
1198	 }
1199	 function getTokenOutPathV3(address _token_in, address _token_out) internal view returns (bytes memory _path) {
1200	 if (address(want) == weth) {
1201	 _path = abi.encodePacked( address(aave), aaveToWethSwapFee, address(weth) );
1202	 }
1203	 else {
1204	 _path = abi.encodePacked( address(aave), aaveToWethSwapFee, address(weth), wethToWantSwapFee, address(want) );
1205	 }
1206	 }
1207	 function _sellAAVEForWant(uint256 amountIn, uint256 minOut) internal {
1208	 if (amountIn == 0) {
1209	 return;
1210	 }
1211	 if (swapRouter == SwapRouter.UniV3) {
1212	 UNI_V3_ROUTER.exactInput( ISwapRouter.ExactInputParams( getTokenOutPathV3(address(aave), address(want)), address(this), now, amountIn, minOut ) );
1213	 }
1214	 else {
1215	 IUni router = swapRouter == SwapRouter.UniV2 ? UNI_V2_ROUTER : SUSHI_V2_ROUTER;
1216	 router.swapExactTokensForTokens( amountIn, minOut, getTokenOutPathV2(address(aave), address(want)), address(this), now );
1217	 }
1218	 }
1219	 function _sellSTKAAVEToAAVE(uint256 amountIn, uint256 minOut) internal {
1220	 UNI_V3_ROUTER.exactInputSingle( ISwapRouter.ExactInputSingleParams( address(stkAave), address(aave), stkAaveToAaveSwapFee, address(this), now, amountIn, minOut, 0 ) );
1221	 }
1222	 function getAaveAssets() internal view returns (address[] memory assets) {
1223	 assets = new address[](2);
1224	 assets[0] = address(aToken);
1225	 assets[1] = address(debtToken);
1226	 }
1227	 function getProtocolCollatRatios(address token) internal view returns (uint256 ltv, uint256 liquidationThreshold) {
1228	 (, ltv, liquidationThreshold, , , , , , , ) = protocolDataProvider .getReserveConfigurationData(token);
1229	 ltv = ltv.mul(BPS_WAD_RATIO);
1230	 liquidationThreshold = liquidationThreshold.mul(BPS_WAD_RATIO);
1231	 }
1232	 function getBorrowFromDeposit(uint256 deposit, uint256 collatRatio) internal pure returns (uint256) {
1233	 return deposit.mul(collatRatio).div(COLLATERAL_RATIO_PRECISION);
1234	 }
1235	 function getDepositFromBorrow(uint256 borrow, uint256 collatRatio) internal pure returns (uint256) {
1236	 return borrow.mul(COLLATERAL_RATIO_PRECISION).div(collatRatio);
1237	 }
1238	 function getBorrowFromSupply(uint256 supply, uint256 collatRatio) internal pure returns (uint256) {
1239	 return supply.mul(collatRatio).div( COLLATERAL_RATIO_PRECISION.sub(collatRatio) );
1240	 }
1241	 function approveMaxSpend(address token, address spender) internal {
1242	 IERC20(token).safeApprove(spender, type(uint256).max);
1243	 }
1244	 }
1245	 contract LevAaveFactory {
1246	 address public immutable original;
1247	 event Cloned(address indexed clone);
1248	 event Deployed(address indexed original);
1249	 constructor(address _vault) public {
1250	 Strategy _original = new Strategy(_vault);
1251	 emit Deployed(address(_original));
1252	 original = address(_original);
1253	 _original.setRewards(msg.sender);
1254	 _original.setKeeper(msg.sender);
1255	 _original.setStrategist(msg.sender);
1256	 }
1257	 function name() external view returns (string memory) {
1258	 return string( abi.encodePacked( "Factory", Strategy(payable(original)).name(), "@", Strategy(payable(original)).apiVersion() ) );
1259	 }
1260	 function cloneLevAave(address _vault) external returns (address payable newStrategy) {
1261	 bytes20 addressBytes = bytes20(original);
1262	 assembly {
1263	 let clone_code := mload(0x40) mstore( clone_code, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000 ) mstore(add(clone_code, 0x14), addressBytes) mstore( add(clone_code, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000 ) newStrategy := create(0, clone_code, 0x37) }
1264	 Strategy(newStrategy).initialize( _vault, msg.sender, msg.sender, msg.sender );
1265	 emit Cloned(newStrategy);
1266	 }
1267	 }
