row number 
1	  pragma abicoder v2;
2	 pragma solidity >=0.6.0 <0.8.0;
3	 interface IERC165Upgradeable {
4	 function supportsInterface(bytes4 interfaceId) external view returns (bool);
5	 }
6	 pragma solidity >=0.4.24 <0.8.0;
7	 abstract contract Initializable {
8	 bool private _initialized;
9	 bool private _initializing;
10	 modifier initializer() {
11	 require(_initializing || _isConstructor() || !_initialized, "Initializable: contract is already initialized");
12	 bool isTopLevelCall = !_initializing;
13	 if (isTopLevelCall) {
14	 _initializing = true;
15	 _initialized = true;
16	 }
17	 _;
18	 if (isTopLevelCall) {
19	 _initializing = false;
20	 }
21	 }
22	 function _isConstructor() private view returns (bool) {
23	 return !AddressUpgradeable.isContract(address(this));
24	 }
25	 }
26	 pragma solidity >=0.6.2 <0.8.0;
27	 interface IERC1155Upgradeable is IERC165Upgradeable {
28	 event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);
29	 event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);
30	 event ApprovalForAll(address indexed account, address indexed operator, bool approved);
31	 event URI(string value, uint256 indexed id);
32	 function balanceOf(address account, uint256 id) external view returns (uint256);
33	 function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);
34	 function setApprovalForAll(address operator, bool approved) external;
35	 function isApprovedForAll(address account, address operator) external view returns (bool);
36	 function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;
37	 function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;
38	 }
39	 pragma solidity >=0.6.0 <0.8.0;
40	 abstract contract ContextUpgradeable is Initializable {
41	 function __Context_init() internal initializer {
42	 __Context_init_unchained();
43	 }
44	 function __Context_init_unchained() internal initializer {
45	 }
46	 function _msgSender() internal view virtual returns (address payable) {
47	 return msg.sender;
48	 }
49	 function _msgData() internal view virtual returns (bytes memory) {
50	 this;
51	 return msg.data;
52	 }
53	 uint256[50] private __gap;
54	 }
55	 pragma solidity >=0.6.0 <0.8.0;
56	 abstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {
57	 bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;
58	 mapping(bytes4 => bool) private _supportedInterfaces;
59	 function __ERC165_init() internal initializer {
60	 __ERC165_init_unchained();
61	 }
62	 function __ERC165_init_unchained() internal initializer {
63	 _registerInterface(_INTERFACE_ID_ERC165);
64	 }
65	 function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
66	 return _supportedInterfaces[interfaceId];
67	 }
68	 function _registerInterface(bytes4 interfaceId) internal virtual {
69	 require(interfaceId != 0xffffffff, "ERC165: invalid interface id");
70	 _supportedInterfaces[interfaceId] = true;
71	 }
72	 uint256[49] private __gap;
73	 }
74	 pragma solidity >=0.6.2 <0.8.0;
75	 interface IERC1155MetadataURIUpgradeable is IERC1155Upgradeable {
76	 function uri(uint256 id) external view returns (string memory);
77	 }
78	 pragma solidity >=0.6.0 <0.8.0;
79	 abstract contract EIP712Upgradeable is Initializable {
80	 bytes32 private _HASHED_NAME;
81	 bytes32 private _HASHED_VERSION;
82	 bytes32 private constant _TYPE_HASH = keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");
83	 function __EIP712_init(string memory name, string memory version) internal initializer {
84	 __EIP712_init_unchained(name, version);
85	 }
86	 function __EIP712_init_unchained(string memory name, string memory version) internal initializer {
87	 bytes32 hashedName = keccak256(bytes(name));
88	 bytes32 hashedVersion = keccak256(bytes(version));
89	 _HASHED_NAME = hashedName;
90	 _HASHED_VERSION = hashedVersion;
91	 }
92	 function _domainSeparatorV4() internal view returns (bytes32) {
93	 return _buildDomainSeparator(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash());
94	 }
95	 function _buildDomainSeparator(bytes32 typeHash, bytes32 name, bytes32 version) private view returns (bytes32) {
96	 return keccak256( abi.encode( typeHash, name, version, _getChainId(), address(this) ) );
97	 }
98	 function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {
99	 return keccak256(abi.encodePacked("\x19\x01", _domainSeparatorV4(), structHash));
100	 }
101	 function _getChainId() private view returns (uint256 chainId) {
102	 this;
103	 assembly {
104	 chainId := chainid() }
105	 }
106	 function _EIP712NameHash() internal virtual view returns (bytes32) {
107	 return _HASHED_NAME;
108	 }
109	 function _EIP712VersionHash() internal virtual view returns (bytes32) {
110	 return _HASHED_VERSION;
111	 }
112	 uint256[50] private __gap;
113	 }
114	 pragma solidity >=0.6.2 <0.8.0;
115	 interface RoyaltiesV2 {
116	 event RoyaltiesSet(uint256 tokenId, LibPart.Part[] royalties);
117	 function getRoyalties(uint256 id) external view returns (LibPart.Part[] memory);
118	 }
119	 pragma solidity >=0.6.2 <0.8.0;
120	 abstract contract AbstractRoyalties {
121	 mapping (uint256 => LibPart.Part[]) public royalties;
122	 function _saveRoyalties(uint256 _id, LibPart.Part[] memory _royalties) internal {
123	 for (uint i = 0; i < _royalties.length; i++) {
124	 require(_royalties[i].account != address(0x0), "Recipient should be present");
125	 require(_royalties[i].value != 0, "Royalty value should be positive");
126	 royalties[_id].push(_royalties[i]);
127	 }
128	 _onRoyaltiesSet(_id, _royalties);
129	 }
130	 function _updateAccount(uint256 _id, address _from, address _to) internal {
131	 uint length = royalties[_id].length;
132	 for(uint i = 0; i < length; i++) {
133	 if (royalties[_id][i].account == _from) {
134	 royalties[_id][i].account = address(uint160(_to));
135	 }
136	 }
137	 }
138	 function _onRoyaltiesSet(uint256 _id, LibPart.Part[] memory _royalties) virtual internal;
139	 }
140	 pragma solidity >=0.6.0 <0.8.0;
141	 contract ERC1155Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC1155Upgradeable, IERC1155MetadataURIUpgradeable {
142	 using SafeMathUpgradeable for uint256;
143	 using AddressUpgradeable for address;
144	 mapping (uint256 => mapping(address => uint256)) private _balances;
145	 mapping (address => mapping(address => bool)) private _operatorApprovals;
146	 string private _uri;
147	 bytes4 private constant _INTERFACE_ID_ERC1155 = 0xd9b67a26;
148	 bytes4 private constant _INTERFACE_ID_ERC1155_METADATA_URI = 0x0e89341c;
149	 function __ERC1155_init(string memory uri_) internal initializer {
150	 __Context_init_unchained();
151	 __ERC165_init_unchained();
152	 __ERC1155_init_unchained(uri_);
153	 }
154	 function __ERC1155_init_unchained(string memory uri_) internal initializer {
155	 _setURI(uri_);
156	 _registerInterface(_INTERFACE_ID_ERC1155);
157	 _registerInterface(_INTERFACE_ID_ERC1155_METADATA_URI);
158	 }
159	 function uri(uint256) external view virtual override returns (string memory) {
160	 return _uri;
161	 }
162	 function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
163	 require(account != address(0), "ERC1155: balance query for the zero address");
164	 return _balances[id][account];
165	 }
166	 function balanceOfBatch( address[] memory accounts, uint256[] memory ids ) public view virtual override returns (uint256[] memory) {
167	 require(accounts.length == ids.length, "ERC1155: accounts and ids length mismatch");
168	 uint256[] memory batchBalances = new uint256[](accounts.length);
169	 for (uint256 i = 0; i < accounts.length; ++i) {
170	 batchBalances[i] = balanceOf(accounts[i], ids[i]);
171	 }
172	 return batchBalances;
173	 }
174	 function setApprovalForAll(address operator, bool approved) public virtual override {
175	 require(_msgSender() != operator, "ERC1155: setting approval status for self");
176	 _operatorApprovals[_msgSender()][operator] = approved;
177	 emit ApprovalForAll(_msgSender(), operator, approved);
178	 }
179	 function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {
180	 return _operatorApprovals[account][operator];
181	 }
182	 function safeTransferFrom( address from, address to, uint256 id, uint256 amount, bytes memory data ) public virtual override {
183	 require(to != address(0), "ERC1155: transfer to the zero address");
184	 require( from == _msgSender() || isApprovedForAll(from, _msgSender()), "ERC1155: caller is not owner nor approved" );
185	 address operator = _msgSender();
186	 _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);
187	 _balances[id][from] = _balances[id][from].sub(amount, "ERC1155: insufficient balance for transfer");
188	 _balances[id][to] = _balances[id][to].add(amount);
189	 emit TransferSingle(operator, from, to, id, amount);
190	 _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);
191	 }
192	 function safeBatchTransferFrom( address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data ) public virtual override {
193	 require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch");
194	 require(to != address(0), "ERC1155: transfer to the zero address");
195	 require( from == _msgSender() || isApprovedForAll(from, _msgSender()), "ERC1155: transfer caller is not owner nor approved" );
196	 address operator = _msgSender();
197	 _beforeTokenTransfer(operator, from, to, ids, amounts, data);
198	 for (uint256 i = 0; i < ids.length; ++i) {
199	 uint256 id = ids[i];
200	 uint256 amount = amounts[i];
201	 _balances[id][from] = _balances[id][from].sub( amount, "ERC1155: insufficient balance for transfer" );
202	 _balances[id][to] = _balances[id][to].add(amount);
203	 }
204	 emit TransferBatch(operator, from, to, ids, amounts);
205	 _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);
206	 }
207	 function _setURI(string memory newuri) internal virtual {
208	 _uri = newuri;
209	 }
210	 function _mint(address account, uint256 id, uint256 amount, bytes memory data) internal virtual {
211	 require(account != address(0), "ERC1155: mint to the zero address");
212	 address operator = _msgSender();
213	 _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);
214	 _balances[id][account] = _balances[id][account].add(amount);
215	 emit TransferSingle(operator, address(0), account, id, amount);
216	 _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);
217	 }
218	 function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal virtual {
219	 require(to != address(0), "ERC1155: mint to the zero address");
220	 require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch");
221	 address operator = _msgSender();
222	 _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);
223	 for (uint i = 0; i < ids.length; i++) {
224	 _balances[ids[i]][to] = amounts[i].add(_balances[ids[i]][to]);
225	 }
226	 emit TransferBatch(operator, address(0), to, ids, amounts);
227	 _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);
228	 }
229	 function _burn(address account, uint256 id, uint256 amount) internal virtual {
230	 require(account != address(0), "ERC1155: burn from the zero address");
231	 address operator = _msgSender();
232	 _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), "");
233	 _balances[id][account] = _balances[id][account].sub( amount, "ERC1155: burn amount exceeds balance" );
234	 emit TransferSingle(operator, account, address(0), id, amount);
235	 }
236	 function _burnBatch(address account, uint256[] memory ids, uint256[] memory amounts) internal virtual {
237	 require(account != address(0), "ERC1155: burn from the zero address");
238	 require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch");
239	 address operator = _msgSender();
240	 _beforeTokenTransfer(operator, account, address(0), ids, amounts, "");
241	 for (uint i = 0; i < ids.length; i++) {
242	 _balances[ids[i]][account] = _balances[ids[i]][account].sub( amounts[i], "ERC1155: burn amount exceeds balance" );
243	 }
244	 emit TransferBatch(operator, account, address(0), ids, amounts);
245	 }
246	 function _beforeTokenTransfer( address operator, address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data ) internal virtual {
247	 }
248	 function _doSafeTransferAcceptanceCheck( address operator, address from, address to, uint256 id, uint256 amount, bytes memory data ) private {
249	 if (to.isContract()) {
250	 try IERC1155ReceiverUpgradeable(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {
251	 if (response != IERC1155ReceiverUpgradeable(to).onERC1155Received.selector) {
252	 revert("ERC1155: ERC1155Receiver rejected tokens");
253	 }
254	 }
255	 catch Error(string memory reason) {
256	 revert(reason);
257	 }
258	 catch {
259	 revert("ERC1155: transfer to non ERC1155Receiver implementer");
260	 }
261	 }
262	 }
263	 function _doSafeBatchTransferAcceptanceCheck( address operator, address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data ) private {
264	 if (to.isContract()) {
265	 try IERC1155ReceiverUpgradeable(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (bytes4 response) {
266	 if (response != IERC1155ReceiverUpgradeable(to).onERC1155BatchReceived.selector) {
267	 revert("ERC1155: ERC1155Receiver rejected tokens");
268	 }
269	 }
270	 catch Error(string memory reason) {
271	 revert(reason);
272	 }
273	 catch {
274	 revert("ERC1155: transfer to non ERC1155Receiver implementer");
275	 }
276	 }
277	 }
278	 function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {
279	 uint256[] memory array = new uint256[](1);
280	 array[0] = element;
281	 return array;
282	 }
283	 uint256[47] private __gap;
284	 }
285	 pragma solidity 0.7.6;
286	 abstract contract ERC1271Validator is EIP712Upgradeable {
287	 using AddressUpgradeable for address;
288	 using ECDSAUpgradeable for bytes32;
289	 string constant SIGNATURE_ERROR = "signature verification error";
290	 bytes4 constant internal MAGICVALUE = 0x1626ba7e;
291	 function validate1271(address signer, bytes32 structHash, bytes memory signature) internal view {
292	 bytes32 hash = _hashTypedDataV4(structHash);
293	 if (signer.isContract()) {
294	 require( ERC1271(signer).isValidSignature(hash, signature) == MAGICVALUE, SIGNATURE_ERROR );
295	 }
296	 else {
297	 require( hash.recover(signature) == signer, SIGNATURE_ERROR );
298	 }
299	 }
300	 uint256[50] private __gap;
301	 }
302	 pragma solidity >=0.6.2 <0.8.0;
303	 abstract contract RoyaltiesV2Upgradeable is ERC165Upgradeable, RoyaltiesV2 {
304	 function __RoyaltiesV2Upgradeable_init_unchained() internal initializer {
305	 _registerInterface(LibRoyaltiesV2._INTERFACE_ID_ROYALTIES);
306	 }
307	 }
308	 pragma solidity >=0.6.2 <0.8.0;
309	 contract RoyaltiesV2Impl is AbstractRoyalties, RoyaltiesV2 {
310	 function getRoyalties(uint256 id) override external view returns (LibPart.Part[] memory) {
311	 return royalties[id];
312	 }
313	 function _onRoyaltiesSet(uint256 _id, LibPart.Part[] memory _royalties) override internal {
314	 emit RoyaltiesSet(_id, _royalties);
315	 }
316	 }
317	 pragma solidity >=0.6.2 <0.8.0;
318	 interface IERC1155LazyMint is IERC1155Upgradeable {
319	 event Supply( uint256 indexed tokenId, uint256 value );
320	 event Creators( uint256 indexed tokenId, LibPart.Part[] creators );
321	 function mintAndTransfer( LibERC1155LazyMint.Mint1155Data memory data, address to, uint256 _amount ) external;
322	 function transferFromOrMint( LibERC1155LazyMint.Mint1155Data memory data, address from, address to, uint256 amount ) external;
323	 }
324	 pragma solidity 0.7.6;
325	 contract ERC1155BaseURI is ERC1155Upgradeable {
326	 using StringsUpgradeable for uint;
327	 mapping (uint256 => string) private _tokenURIs;
328	 string private _baseURI;
329	 function baseURI() public view virtual returns (string memory) {
330	 return _baseURI;
331	 }
332	 function uri(uint id) external view override virtual returns (string memory) {
333	 return _tokenURI(id);
334	 }
335	 function _tokenURI(uint256 tokenId) internal view virtual returns (string memory) {
336	 string memory tokenURI = _tokenURIs[tokenId];
337	 string memory base = baseURI();
338	 if (bytes(base).length == 0) {
339	 return tokenURI;
340	 }
341	 if (bytes(tokenURI).length > 0) {
342	 return string(abi.encodePacked(base, tokenURI));
343	 }
344	 return string(abi.encodePacked(base, tokenId.toString()));
345	 }
346	 function _setTokenURI(uint256 tokenId, string memory _uri) internal virtual {
347	 _tokenURIs[tokenId] = _uri;
348	 emit URI(_tokenURI(tokenId), tokenId);
349	 }
350	 function _setBaseURI(string memory baseURI_) internal virtual {
351	 _baseURI = baseURI_;
352	 }
353	 uint256[50] private __gap;
354	 }
355	 pragma solidity 0.7.6;
356	 contract Mint1155Validator is ERC1271Validator {
357	 function __Mint1155Validator_init_unchained() internal initializer {
358	 __EIP712_init_unchained("Mint1155", "1");
359	 }
360	 function validate(address account, bytes32 hash, bytes memory signature) internal view {
361	 validate1271(account, hash, signature);
362	 }
363	 uint256[50] private __gap;
364	 }
365	 pragma solidity >=0.6.0 <0.8.0;
366	 abstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {
367	 address private _owner;
368	 event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
369	 function __Ownable_init() internal initializer {
370	 __Context_init_unchained();
371	 __Ownable_init_unchained();
372	 }
373	 function __Ownable_init_unchained() internal initializer {
374	 address msgSender = _msgSender();
375	 _owner = msgSender;
376	 emit OwnershipTransferred(address(0), msgSender);
377	 }
378	 function owner() public view virtual returns (address) {
379	 return _owner;
380	 }
381	 modifier onlyOwner() {
382	 require(owner() == _msgSender(), "Ownable: caller is not the owner");
383	 _;
384	 }
385	 function renounceOwnership() public virtual onlyOwner {
386	 emit OwnershipTransferred(_owner, address(0));
387	 _owner = address(0);
388	 }
389	 function transferOwnership(address newOwner) public virtual onlyOwner {
390	 require(newOwner != address(0), "Ownable: new owner is the zero address");
391	 emit OwnershipTransferred(_owner, newOwner);
392	 _owner = newOwner;
393	 }
394	 uint256[49] private __gap;
395	 }
396	 pragma solidity >=0.6.0 <0.8.0;
397	 abstract contract ERC1155BurnableUpgradeable is Initializable, ERC1155Upgradeable {
398	 function __ERC1155Burnable_init() internal initializer {
399	 __Context_init_unchained();
400	 __ERC165_init_unchained();
401	 __ERC1155Burnable_init_unchained();
402	 }
403	 function __ERC1155Burnable_init_unchained() internal initializer {
404	 }
405	 function burn(address account, uint256 id, uint256 value) public virtual {
406	 require( account == _msgSender() || isApprovedForAll(account, _msgSender()), "ERC1155: caller is not owner nor approved" );
407	 _burn(account, id, value);
408	 }
409	 function burnBatch(address account, uint256[] memory ids, uint256[] memory values) public virtual {
410	 require( account == _msgSender() || isApprovedForAll(account, _msgSender()), "ERC1155: caller is not owner nor approved" );
411	 _burnBatch(account, ids, values);
412	 }
413	 uint256[50] private __gap;
414	 }
415	 pragma solidity 0.7.6;
416	 abstract contract HasContractURI is ERC165Upgradeable {
417	 string public contractURI;
418	 bytes4 private constant _INTERFACE_ID_CONTRACT_URI = 0xe8a3d485;
419	 function __HasContractURI_init_unchained(string memory _contractURI) internal initializer {
420	 contractURI = _contractURI;
421	 _registerInterface(_INTERFACE_ID_CONTRACT_URI);
422	 }
423	 function _setContractURI(string memory _contractURI) internal {
424	 contractURI = _contractURI;
425	 }
426	 uint256[49] private __gap;
427	 }
428	 pragma solidity 0.7.6;
429	 abstract contract ERC1155DefaultApproval is ERC1155Upgradeable {
430	 mapping(address => bool) private defaultApprovals;
431	 event DefaultApproval(address indexed operator, bool hasApproval);
432	 function _setDefaultApproval(address operator, bool hasApproval) internal {
433	 defaultApprovals[operator] = hasApproval;
434	 emit DefaultApproval(operator, hasApproval);
435	 }
436	 function isApprovedForAll(address _owner, address _operator) public virtual override view returns (bool) {
437	 return defaultApprovals[_operator] || super.isApprovedForAll(_owner, _operator);
438	 }
439	 uint256[50] private __gap;
440	 }
441	 pragma solidity 0.7.6;
442	 abstract contract ERC1155Lazy is IERC1155LazyMint, ERC1155BaseURI, Mint1155Validator, RoyaltiesV2Upgradeable, RoyaltiesV2Impl {
443	 using SafeMathUpgradeable for uint;
444	 mapping(uint256 => LibPart.Part[]) public creators;
445	 mapping(uint => uint) private supply;
446	 mapping(uint => uint) private minted;
447	 function __ERC1155Lazy_init_unchained() internal initializer {
448	 _registerInterface(0x6db15a0f);
449	 }
450	 function transferFromOrMint( LibERC1155LazyMint.Mint1155Data memory data, address from, address to, uint256 amount ) override external {
451	 uint balance = balanceOf(from, data.tokenId);
452	 uint left = amount;
453	 if (balance != 0) {
454	 uint transfer = amount;
455	 if (balance < amount) {
456	 transfer = balance;
457	 }
458	 safeTransferFrom(from, to, data.tokenId, transfer, "");
459	 left = amount - transfer;
460	 }
461	 if (left > 0) {
462	 mintAndTransfer(data, to, left);
463	 }
464	 }
465	 function mintAndTransfer(LibERC1155LazyMint.Mint1155Data memory data, address to, uint256 _amount) public override virtual {
466	 address minter = address(data.tokenId >> 96);
467	 address sender = _msgSender();
468	 require(minter == sender || isApprovedForAll(minter, sender), "ERC1155: transfer caller is not approved");
469	 require(_amount > 0, "amount incorrect");
470	 if (supply[data.tokenId] == 0) {
471	 require(minter == data.creators[0].account, "tokenId incorrect");
472	 require(data.supply > 0, "supply incorrect");
473	 require(data.creators.length == data.signatures.length);
474	 bytes32 hash = LibERC1155LazyMint.hash(data);
475	 for (uint i = 0; i < data.creators.length; i++) {
476	 address creator = data.creators[i].account;
477	 if (creator != sender) {
478	 validate(creator, hash, data.signatures[i]);
479	 }
480	 }
481	 _saveSupply(data.tokenId, data.supply);
482	 _saveRoyalties(data.tokenId, data.royalties);
483	 _saveCreators(data.tokenId, data.creators);
484	 _setTokenURI(data.tokenId, data.tokenURI);
485	 }
486	 _mint(to, data.tokenId, _amount, "");
487	 }
488	 function _mint(address account, uint256 id, uint256 amount, bytes memory data) internal virtual override {
489	 uint newMinted = amount.add(minted[id]);
490	 require(newMinted <= supply[id], "more than supply");
491	 minted[id] = newMinted;
492	 super._mint(account, id, amount, data);
493	 }
494	 function _saveSupply(uint tokenId, uint _supply) internal {
495	 require(supply[tokenId] == 0);
496	 supply[tokenId] = _supply;
497	 emit Supply(tokenId, _supply);
498	 }
499	 function _saveCreators(uint tokenId, LibPart.Part[] memory _creators) internal {
500	 LibPart.Part[] storage creatorsOfToken = creators[tokenId];
501	 uint total = 0;
502	 for (uint i = 0; i < _creators.length; i++) {
503	 require(_creators[i].account != address(0x0), "Account should be present");
504	 require(_creators[i].value != 0, "Creator share should be positive");
505	 creatorsOfToken.push(_creators[i]);
506	 total = total.add(_creators[i].value);
507	 }
508	 require(total == 10000, "total amount of creators share should be 10000");
509	 emit Creators(tokenId, _creators);
510	 }
511	 function updateAccount(uint256 _id, address _from, address _to) external {
512	 require(_msgSender() == _from, "not allowed");
513	 super._updateAccount(_id, _from, _to);
514	 }
515	 function getCreators(uint256 _id) external view returns (LibPart.Part[] memory) {
516	 return creators[_id];
517	 }
518	 function _getSupply(uint tokenId) internal view returns (uint) {
519	 return supply[tokenId];
520	 }
521	 uint256[50] private __gap;
522	 }
523	 pragma solidity >=0.6.2 <0.8.0;
524	 contract ERC1155Image {
525	 using StringsUpgradeable for uint;
526	 mapping (uint256 => string) private _tokenImages;
527	 event Image(string value, uint256 indexed id);
528	 function image(uint id) external view virtual returns (string memory) {
529	 return _tokenImage(id);
530	 }
531	 function _tokenImage(uint256 tokenId) internal view virtual returns (string memory) {
532	 string memory tokenImage = _tokenImages[tokenId];
533	 return tokenImage;
534	 }
535	 function _setTokenImage(uint256 tokenId, string memory _image) internal virtual {
536	 _tokenImages[tokenId] = _image;
537	 emit Image(_tokenImage(tokenId), tokenId);
538	 }
539	 function _clearTokenImages(uint256 tokenId) internal {
540	 if (bytes(_tokenImages[tokenId]).length != 0) {
541	 delete _tokenImages[tokenId];
542	 }
543	 }
544	 uint256[50] private __gap;
545	 }
546	 pragma solidity 0.7.6;
547	 abstract contract ERC1155Base is OwnableUpgradeable, ERC1155DefaultApproval, ERC1155BurnableUpgradeable, ERC1155Lazy, HasContractURI {
548	 string public name;
549	 string public symbol;
550	 function setDefaultApproval(address operator, bool hasApproval) external onlyOwner {
551	 _setDefaultApproval(operator, hasApproval);
552	 }
553	 function isApprovedForAll(address _owner, address _operator) public override(ERC1155Upgradeable, ERC1155DefaultApproval, IERC1155Upgradeable) view returns (bool) {
554	 return ERC1155DefaultApproval.isApprovedForAll(_owner, _operator);
555	 }
556	 function _mint(address account, uint256 id, uint256 amount, bytes memory data) internal virtual override(ERC1155Upgradeable, ERC1155Lazy) {
557	 ERC1155Lazy._mint(account, id, amount, data);
558	 }
559	 function __ERC1155Base_init_unchained(string memory _name, string memory _symbol) internal initializer {
560	 name = _name;
561	 symbol = _symbol;
562	 }
563	 function uri(uint id) external view override(ERC1155BaseURI, ERC1155Upgradeable) virtual returns (string memory) {
564	 return _tokenURI(id);
565	 }
566	 uint256[50] private __gap;
567	 }
568	 pragma solidity >=0.6.2 <0.8.0;
569	 contract EcoFiCommunityERC1155 is ERC1155Base, ERC1155Image {
570	 event CreateEcoFiERC1155(address owner, string name, string symbol);
571	 function __EcoFiCommunityERC1155_init(string memory _name, string memory _symbol, string memory baseURI, string memory contractURI, address _address) external initializer {
572	 __Ownable_init_unchained();
573	 __ERC1155Lazy_init_unchained();
574	 __ERC165_init_unchained();
575	 __Context_init_unchained();
576	 __Mint1155Validator_init_unchained();
577	 __ERC1155_init_unchained("");
578	 __HasContractURI_init_unchained(contractURI);
579	 __ERC1155Burnable_init_unchained();
580	 __RoyaltiesV2Upgradeable_init_unchained();
581	 __ERC1155Base_init_unchained(_name, _symbol);
582	 _setBaseURI(baseURI);
583	 _setDefaultApproval(_address, true);
584	 emit CreateEcoFiERC1155(_msgSender(), _name, _symbol);
585	 }
586	 function mintWithImage(LibERC1155LazyMint.Mint1155Data memory data, string memory image, address to, uint256 _amount) public virtual {
587	 address minter = address(data.tokenId >> 96);
588	 address sender = _msgSender();
589	 require(minter == sender || isApprovedForAll(minter, sender), "ERC1155: transfer caller is not approved");
590	 require(_amount > 0, "amount incorrect");
591	 if (_getSupply(data.tokenId) == 0) {
592	 require(minter == data.creators[0].account, "tokenId incorrect");
593	 require(data.supply > 0, "supply incorrect");
594	 require(data.creators.length == data.signatures.length);
595	 bytes32 hash = LibERC1155LazyMint.hash(data);
596	 for (uint i = 0; i < data.creators.length; i++) {
597	 address creator = data.creators[i].account;
598	 if (creator != sender) {
599	 validate(creator, hash, data.signatures[i]);
600	 }
601	 }
602	 _saveSupply(data.tokenId, data.supply);
603	 _saveRoyalties(data.tokenId, data.royalties);
604	 _saveCreators(data.tokenId, data.creators);
605	 _setTokenURI(data.tokenId, data.tokenURI);
606	 _setTokenImage(data.tokenId, image);
607	 }
608	 _mint(to, data.tokenId, _amount, "");
609	 }
610	 function batchMintAndTransfer(LibERC1155LazyMint.Mint1155Data memory data, address[] memory tos, uint256[] memory _amounts) public onlyOwner {
611	 require(tos.length == _amounts.length, "ERC1155: addresses and amounts length mismatch");
612	 for (uint256 i = 0; i < tos.length; ++i) {
613	 address to = tos[i];
614	 require(to != address(0), "ERC1155: transfer to the zero address");
615	 uint256 _amount = _amounts[i];
616	 mintAndTransfer(data, to, _amount);
617	 }
618	 }
619	 uint256[50] private __gap;
620	 }
621	 pragma solidity >=0.6.0 <0.8.0;
622	 library ECDSAUpgradeable {
623	 function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {
624	 if (signature.length != 65) {
625	 revert("ECDSA: invalid signature length");
626	 }
627	 bytes32 r;
628	 bytes32 s;
629	 uint8 v;
630	 assembly {
631	 r := mload(add(signature, 0x20)) s := mload(add(signature, 0x40)) v := byte(0, mload(add(signature, 0x60))) }
632	 return recover(hash, v, r, s);
633	 }
634	 function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {
635	 require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, "ECDSA: invalid signature 's' value");
636	 require(v == 27 || v == 28, "ECDSA: invalid signature 'v' value");
637	 address signer = ecrecover(hash, v, r, s);
638	 require(signer != address(0), "ECDSA: invalid signature");
639	 return signer;
640	 }
641	 function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {
642	 return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
643	 }
644	 }
645	 pragma solidity >=0.6.0 <0.8.0;
646	 library SafeMathUpgradeable {
647	 function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
648	 uint256 c = a + b;
649	 if (c < a) return (false, 0);
650	 return (true, c);
651	 }
652	 function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
653	 if (b > a) return (false, 0);
654	 return (true, a - b);
655	 }
656	 function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
657	 if (a == 0) return (true, 0);
658	 uint256 c = a * b;
659	 if (c / a != b) return (false, 0);
660	 return (true, c);
661	 }
662	 function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
663	 if (b == 0) return (false, 0);
664	 return (true, a / b);
665	 }
666	 function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
667	 if (b == 0) return (false, 0);
668	 return (true, a % b);
669	 }
670	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
671	 uint256 c = a + b;
672	 require(c >= a, "SafeMath: addition overflow");
673	 return c;
674	 }
675	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
676	 require(b <= a, "SafeMath: subtraction overflow");
677	 return a - b;
678	 }
679	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
680	 if (a == 0) return 0;
681	 uint256 c = a * b;
682	 require(c / a == b, "SafeMath: multiplication overflow");
683	 return c;
684	 }
685	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
686	 require(b > 0, "SafeMath: division by zero");
687	 return a / b;
688	 }
689	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
690	 require(b > 0, "SafeMath: modulo by zero");
691	 return a % b;
692	 }
693	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
694	 require(b <= a, errorMessage);
695	 return a - b;
696	 }
697	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
698	 require(b > 0, errorMessage);
699	 return a / b;
700	 }
701	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
702	 require(b > 0, errorMessage);
703	 return a % b;
704	 }
705	 }
706	 pragma solidity >=0.6.0 <0.8.0;
707	 interface IERC1155ReceiverUpgradeable is IERC165Upgradeable {
708	 function onERC1155Received( address operator, address from, uint256 id, uint256 value, bytes calldata data ) external returns(bytes4);
709	 function onERC1155BatchReceived( address operator, address from, uint256[] calldata ids, uint256[] calldata values, bytes calldata data ) external returns(bytes4);
710	 }
711	 pragma solidity >=0.6.2 <0.8.0;
712	 library AddressUpgradeable {
713	 function isContract(address account) internal view returns (bool) {
714	 uint256 size;
715	 assembly {
716	 size := extcodesize(account) }
717	 return size > 0;
718	 }
719	 function sendValue(address payable recipient, uint256 amount) internal {
720	 require(address(this).balance >= amount, "Address: insufficient balance");
721	 (bool success, ) = recipient.call{
722	 value: amount }
723	 ("");
724	 require(success, "Address: unable to send value, recipient may have reverted");
725	 }
726	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
727	 return functionCall(target, data, "Address: low-level call failed");
728	 }
729	 function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
730	 return functionCallWithValue(target, data, 0, errorMessage);
731	 }
732	 function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
733	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
734	 }
735	 function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
736	 require(address(this).balance >= value, "Address: insufficient balance for call");
737	 require(isContract(target), "Address: call to non-contract");
738	 (bool success, bytes memory returndata) = target.call{
739	 value: value }
740	 (data);
741	 return _verifyCallResult(success, returndata, errorMessage);
742	 }
743	 function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
744	 return functionStaticCall(target, data, "Address: low-level static call failed");
745	 }
746	 function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
747	 require(isContract(target), "Address: static call to non-contract");
748	 (bool success, bytes memory returndata) = target.staticcall(data);
749	 return _verifyCallResult(success, returndata, errorMessage);
750	 }
751	 function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
752	 if (success) {
753	 return returndata;
754	 }
755	 else {
756	 if (returndata.length > 0) {
757	 assembly {
758	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
759	 }
760	 else {
761	 revert(errorMessage);
762	 }
763	 }
764	 }
765	 }
766	 pragma solidity >=0.6.0 <0.8.0;
767	 library StringsUpgradeable {
768	 function toString(uint256 value) internal pure returns (string memory) {
769	 if (value == 0) {
770	 return "0";
771	 }
772	 uint256 temp = value;
773	 uint256 digits;
774	 while (temp != 0) {
775	 digits++;
776	 temp /= 10;
777	 }
778	 bytes memory buffer = new bytes(digits);
779	 uint256 index = digits - 1;
780	 temp = value;
781	 while (temp != 0) {
782	 buffer[index--] = bytes1(uint8(48 + temp % 10));
783	 temp /= 10;
784	 }
785	 return string(buffer);
786	 }
787	 }
788	 pragma solidity >=0.6.2 <0.8.0;
789	 library LibPart {
790	 bytes32 public constant TYPE_HASH = keccak256("Part(address account,uint96 value)");
791	 struct Part {
792	 address payable account;
793	 uint96 value;
794	 }
795	 function hash(Part memory part) internal pure returns (bytes32) {
796	 return keccak256(abi.encode(TYPE_HASH, part.account, part.value));
797	 }
798	 }
799	 pragma solidity >=0.6.2 <0.8.0;
800	 library LibRoyaltiesV2 {
801	 bytes4 constant _INTERFACE_ID_ROYALTIES = 0x44c74bcc;
802	 }
803	 pragma solidity >= 0.4.22 <0.9.0;
804	 library console {
805	 address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);
806	 function _sendLogPayload(bytes memory payload) private view {
807	 uint256 payloadLength = payload.length;
808	 address consoleAddress = CONSOLE_ADDRESS;
809	 assembly {
810	 let payloadStart := add(payload, 32) let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0) }
811	 }
812	 function log() internal view {
813	 _sendLogPayload(abi.encodeWithSignature("log()"));
814	 }
815	 function logInt(int p0) internal view {
816	 _sendLogPayload(abi.encodeWithSignature("log(int)", p0));
817	 }
818	 function logUint(uint p0) internal view {
819	 _sendLogPayload(abi.encodeWithSignature("log(uint)", p0));
820	 }
821	 function logString(string memory p0) internal view {
822	 _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
823	 }
824	 function logBool(bool p0) internal view {
825	 _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
826	 }
827	 function logAddress(address p0) internal view {
828	 _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
829	 }
830	 function logBytes(bytes memory p0) internal view {
831	 _sendLogPayload(abi.encodeWithSignature("log(bytes)", p0));
832	 }
833	 function logBytes1(bytes1 p0) internal view {
834	 _sendLogPayload(abi.encodeWithSignature("log(bytes1)", p0));
835	 }
836	 function logBytes2(bytes2 p0) internal view {
837	 _sendLogPayload(abi.encodeWithSignature("log(bytes2)", p0));
838	 }
839	 function logBytes3(bytes3 p0) internal view {
840	 _sendLogPayload(abi.encodeWithSignature("log(bytes3)", p0));
841	 }
842	 function logBytes4(bytes4 p0) internal view {
843	 _sendLogPayload(abi.encodeWithSignature("log(bytes4)", p0));
844	 }
845	 function logBytes5(bytes5 p0) internal view {
846	 _sendLogPayload(abi.encodeWithSignature("log(bytes5)", p0));
847	 }
848	 function logBytes6(bytes6 p0) internal view {
849	 _sendLogPayload(abi.encodeWithSignature("log(bytes6)", p0));
850	 }
851	 function logBytes7(bytes7 p0) internal view {
852	 _sendLogPayload(abi.encodeWithSignature("log(bytes7)", p0));
853	 }
854	 function logBytes8(bytes8 p0) internal view {
855	 _sendLogPayload(abi.encodeWithSignature("log(bytes8)", p0));
856	 }
857	 function logBytes9(bytes9 p0) internal view {
858	 _sendLogPayload(abi.encodeWithSignature("log(bytes9)", p0));
859	 }
860	 function logBytes10(bytes10 p0) internal view {
861	 _sendLogPayload(abi.encodeWithSignature("log(bytes10)", p0));
862	 }
863	 function logBytes11(bytes11 p0) internal view {
864	 _sendLogPayload(abi.encodeWithSignature("log(bytes11)", p0));
865	 }
866	 function logBytes12(bytes12 p0) internal view {
867	 _sendLogPayload(abi.encodeWithSignature("log(bytes12)", p0));
868	 }
869	 function logBytes13(bytes13 p0) internal view {
870	 _sendLogPayload(abi.encodeWithSignature("log(bytes13)", p0));
871	 }
872	 function logBytes14(bytes14 p0) internal view {
873	 _sendLogPayload(abi.encodeWithSignature("log(bytes14)", p0));
874	 }
875	 function logBytes15(bytes15 p0) internal view {
876	 _sendLogPayload(abi.encodeWithSignature("log(bytes15)", p0));
877	 }
878	 function logBytes16(bytes16 p0) internal view {
879	 _sendLogPayload(abi.encodeWithSignature("log(bytes16)", p0));
880	 }
881	 function logBytes17(bytes17 p0) internal view {
882	 _sendLogPayload(abi.encodeWithSignature("log(bytes17)", p0));
883	 }
884	 function logBytes18(bytes18 p0) internal view {
885	 _sendLogPayload(abi.encodeWithSignature("log(bytes18)", p0));
886	 }
887	 function logBytes19(bytes19 p0) internal view {
888	 _sendLogPayload(abi.encodeWithSignature("log(bytes19)", p0));
889	 }
890	 function logBytes20(bytes20 p0) internal view {
891	 _sendLogPayload(abi.encodeWithSignature("log(bytes20)", p0));
892	 }
893	 function logBytes21(bytes21 p0) internal view {
894	 _sendLogPayload(abi.encodeWithSignature("log(bytes21)", p0));
895	 }
896	 function logBytes22(bytes22 p0) internal view {
897	 _sendLogPayload(abi.encodeWithSignature("log(bytes22)", p0));
898	 }
899	 function logBytes23(bytes23 p0) internal view {
900	 _sendLogPayload(abi.encodeWithSignature("log(bytes23)", p0));
901	 }
902	 function logBytes24(bytes24 p0) internal view {
903	 _sendLogPayload(abi.encodeWithSignature("log(bytes24)", p0));
904	 }
905	 function logBytes25(bytes25 p0) internal view {
906	 _sendLogPayload(abi.encodeWithSignature("log(bytes25)", p0));
907	 }
908	 function logBytes26(bytes26 p0) internal view {
909	 _sendLogPayload(abi.encodeWithSignature("log(bytes26)", p0));
910	 }
911	 function logBytes27(bytes27 p0) internal view {
912	 _sendLogPayload(abi.encodeWithSignature("log(bytes27)", p0));
913	 }
914	 function logBytes28(bytes28 p0) internal view {
915	 _sendLogPayload(abi.encodeWithSignature("log(bytes28)", p0));
916	 }
917	 function logBytes29(bytes29 p0) internal view {
918	 _sendLogPayload(abi.encodeWithSignature("log(bytes29)", p0));
919	 }
920	 function logBytes30(bytes30 p0) internal view {
921	 _sendLogPayload(abi.encodeWithSignature("log(bytes30)", p0));
922	 }
923	 function logBytes31(bytes31 p0) internal view {
924	 _sendLogPayload(abi.encodeWithSignature("log(bytes31)", p0));
925	 }
926	 function logBytes32(bytes32 p0) internal view {
927	 _sendLogPayload(abi.encodeWithSignature("log(bytes32)", p0));
928	 }
929	 function log(uint p0) internal view {
930	 _sendLogPayload(abi.encodeWithSignature("log(uint)", p0));
931	 }
932	 function log(string memory p0) internal view {
933	 _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
934	 }
935	 function log(bool p0) internal view {
936	 _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
937	 }
938	 function log(address p0) internal view {
939	 _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
940	 }
941	 function log(uint p0, uint p1) internal view {
942	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint)", p0, p1));
943	 }
944	 function log(uint p0, string memory p1) internal view {
945	 _sendLogPayload(abi.encodeWithSignature("log(uint,string)", p0, p1));
946	 }
947	 function log(uint p0, bool p1) internal view {
948	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool)", p0, p1));
949	 }
950	 function log(uint p0, address p1) internal view {
951	 _sendLogPayload(abi.encodeWithSignature("log(uint,address)", p0, p1));
952	 }
953	 function log(string memory p0, uint p1) internal view {
954	 _sendLogPayload(abi.encodeWithSignature("log(string,uint)", p0, p1));
955	 }
956	 function log(string memory p0, string memory p1) internal view {
957	 _sendLogPayload(abi.encodeWithSignature("log(string,string)", p0, p1));
958	 }
959	 function log(string memory p0, bool p1) internal view {
960	 _sendLogPayload(abi.encodeWithSignature("log(string,bool)", p0, p1));
961	 }
962	 function log(string memory p0, address p1) internal view {
963	 _sendLogPayload(abi.encodeWithSignature("log(string,address)", p0, p1));
964	 }
965	 function log(bool p0, uint p1) internal view {
966	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint)", p0, p1));
967	 }
968	 function log(bool p0, string memory p1) internal view {
969	 _sendLogPayload(abi.encodeWithSignature("log(bool,string)", p0, p1));
970	 }
971	 function log(bool p0, bool p1) internal view {
972	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool)", p0, p1));
973	 }
974	 function log(bool p0, address p1) internal view {
975	 _sendLogPayload(abi.encodeWithSignature("log(bool,address)", p0, p1));
976	 }
977	 function log(address p0, uint p1) internal view {
978	 _sendLogPayload(abi.encodeWithSignature("log(address,uint)", p0, p1));
979	 }
980	 function log(address p0, string memory p1) internal view {
981	 _sendLogPayload(abi.encodeWithSignature("log(address,string)", p0, p1));
982	 }
983	 function log(address p0, bool p1) internal view {
984	 _sendLogPayload(abi.encodeWithSignature("log(address,bool)", p0, p1));
985	 }
986	 function log(address p0, address p1) internal view {
987	 _sendLogPayload(abi.encodeWithSignature("log(address,address)", p0, p1));
988	 }
989	 function log(uint p0, uint p1, uint p2) internal view {
990	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint)", p0, p1, p2));
991	 }
992	 function log(uint p0, uint p1, string memory p2) internal view {
993	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string)", p0, p1, p2));
994	 }
995	 function log(uint p0, uint p1, bool p2) internal view {
996	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool)", p0, p1, p2));
997	 }
998	 function log(uint p0, uint p1, address p2) internal view {
999	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address)", p0, p1, p2));
1000	 }
1001	 function log(uint p0, string memory p1, uint p2) internal view {
1002	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint)", p0, p1, p2));
1003	 }
1004	 function log(uint p0, string memory p1, string memory p2) internal view {
1005	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,string)", p0, p1, p2));
1006	 }
1007	 function log(uint p0, string memory p1, bool p2) internal view {
1008	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool)", p0, p1, p2));
1009	 }
1010	 function log(uint p0, string memory p1, address p2) internal view {
1011	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,address)", p0, p1, p2));
1012	 }
1013	 function log(uint p0, bool p1, uint p2) internal view {
1014	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint)", p0, p1, p2));
1015	 }
1016	 function log(uint p0, bool p1, string memory p2) internal view {
1017	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string)", p0, p1, p2));
1018	 }
1019	 function log(uint p0, bool p1, bool p2) internal view {
1020	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool)", p0, p1, p2));
1021	 }
1022	 function log(uint p0, bool p1, address p2) internal view {
1023	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address)", p0, p1, p2));
1024	 }
1025	 function log(uint p0, address p1, uint p2) internal view {
1026	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint)", p0, p1, p2));
1027	 }
1028	 function log(uint p0, address p1, string memory p2) internal view {
1029	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,string)", p0, p1, p2));
1030	 }
1031	 function log(uint p0, address p1, bool p2) internal view {
1032	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool)", p0, p1, p2));
1033	 }
1034	 function log(uint p0, address p1, address p2) internal view {
1035	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,address)", p0, p1, p2));
1036	 }
1037	 function log(string memory p0, uint p1, uint p2) internal view {
1038	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint)", p0, p1, p2));
1039	 }
1040	 function log(string memory p0, uint p1, string memory p2) internal view {
1041	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,string)", p0, p1, p2));
1042	 }
1043	 function log(string memory p0, uint p1, bool p2) internal view {
1044	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool)", p0, p1, p2));
1045	 }
1046	 function log(string memory p0, uint p1, address p2) internal view {
1047	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,address)", p0, p1, p2));
1048	 }
1049	 function log(string memory p0, string memory p1, uint p2) internal view {
1050	 _sendLogPayload(abi.encodeWithSignature("log(string,string,uint)", p0, p1, p2));
1051	 }
1052	 function log(string memory p0, string memory p1, string memory p2) internal view {
1053	 _sendLogPayload(abi.encodeWithSignature("log(string,string,string)", p0, p1, p2));
1054	 }
1055	 function log(string memory p0, string memory p1, bool p2) internal view {
1056	 _sendLogPayload(abi.encodeWithSignature("log(string,string,bool)", p0, p1, p2));
1057	 }
1058	 function log(string memory p0, string memory p1, address p2) internal view {
1059	 _sendLogPayload(abi.encodeWithSignature("log(string,string,address)", p0, p1, p2));
1060	 }
1061	 function log(string memory p0, bool p1, uint p2) internal view {
1062	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint)", p0, p1, p2));
1063	 }
1064	 function log(string memory p0, bool p1, string memory p2) internal view {
1065	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,string)", p0, p1, p2));
1066	 }
1067	 function log(string memory p0, bool p1, bool p2) internal view {
1068	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool)", p0, p1, p2));
1069	 }
1070	 function log(string memory p0, bool p1, address p2) internal view {
1071	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,address)", p0, p1, p2));
1072	 }
1073	 function log(string memory p0, address p1, uint p2) internal view {
1074	 _sendLogPayload(abi.encodeWithSignature("log(string,address,uint)", p0, p1, p2));
1075	 }
1076	 function log(string memory p0, address p1, string memory p2) internal view {
1077	 _sendLogPayload(abi.encodeWithSignature("log(string,address,string)", p0, p1, p2));
1078	 }
1079	 function log(string memory p0, address p1, bool p2) internal view {
1080	 _sendLogPayload(abi.encodeWithSignature("log(string,address,bool)", p0, p1, p2));
1081	 }
1082	 function log(string memory p0, address p1, address p2) internal view {
1083	 _sendLogPayload(abi.encodeWithSignature("log(string,address,address)", p0, p1, p2));
1084	 }
1085	 function log(bool p0, uint p1, uint p2) internal view {
1086	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint)", p0, p1, p2));
1087	 }
1088	 function log(bool p0, uint p1, string memory p2) internal view {
1089	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string)", p0, p1, p2));
1090	 }
1091	 function log(bool p0, uint p1, bool p2) internal view {
1092	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool)", p0, p1, p2));
1093	 }
1094	 function log(bool p0, uint p1, address p2) internal view {
1095	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address)", p0, p1, p2));
1096	 }
1097	 function log(bool p0, string memory p1, uint p2) internal view {
1098	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint)", p0, p1, p2));
1099	 }
1100	 function log(bool p0, string memory p1, string memory p2) internal view {
1101	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,string)", p0, p1, p2));
1102	 }
1103	 function log(bool p0, string memory p1, bool p2) internal view {
1104	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool)", p0, p1, p2));
1105	 }
1106	 function log(bool p0, string memory p1, address p2) internal view {
1107	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,address)", p0, p1, p2));
1108	 }
1109	 function log(bool p0, bool p1, uint p2) internal view {
1110	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint)", p0, p1, p2));
1111	 }
1112	 function log(bool p0, bool p1, string memory p2) internal view {
1113	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string)", p0, p1, p2));
1114	 }
1115	 function log(bool p0, bool p1, bool p2) internal view {
1116	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool)", p0, p1, p2));
1117	 }
1118	 function log(bool p0, bool p1, address p2) internal view {
1119	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address)", p0, p1, p2));
1120	 }
1121	 function log(bool p0, address p1, uint p2) internal view {
1122	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint)", p0, p1, p2));
1123	 }
1124	 function log(bool p0, address p1, string memory p2) internal view {
1125	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,string)", p0, p1, p2));
1126	 }
1127	 function log(bool p0, address p1, bool p2) internal view {
1128	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool)", p0, p1, p2));
1129	 }
1130	 function log(bool p0, address p1, address p2) internal view {
1131	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,address)", p0, p1, p2));
1132	 }
1133	 function log(address p0, uint p1, uint p2) internal view {
1134	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint)", p0, p1, p2));
1135	 }
1136	 function log(address p0, uint p1, string memory p2) internal view {
1137	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,string)", p0, p1, p2));
1138	 }
1139	 function log(address p0, uint p1, bool p2) internal view {
1140	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool)", p0, p1, p2));
1141	 }
1142	 function log(address p0, uint p1, address p2) internal view {
1143	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,address)", p0, p1, p2));
1144	 }
1145	 function log(address p0, string memory p1, uint p2) internal view {
1146	 _sendLogPayload(abi.encodeWithSignature("log(address,string,uint)", p0, p1, p2));
1147	 }
1148	 function log(address p0, string memory p1, string memory p2) internal view {
1149	 _sendLogPayload(abi.encodeWithSignature("log(address,string,string)", p0, p1, p2));
1150	 }
1151	 function log(address p0, string memory p1, bool p2) internal view {
1152	 _sendLogPayload(abi.encodeWithSignature("log(address,string,bool)", p0, p1, p2));
1153	 }
1154	 function log(address p0, string memory p1, address p2) internal view {
1155	 _sendLogPayload(abi.encodeWithSignature("log(address,string,address)", p0, p1, p2));
1156	 }
1157	 function log(address p0, bool p1, uint p2) internal view {
1158	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint)", p0, p1, p2));
1159	 }
1160	 function log(address p0, bool p1, string memory p2) internal view {
1161	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,string)", p0, p1, p2));
1162	 }
1163	 function log(address p0, bool p1, bool p2) internal view {
1164	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool)", p0, p1, p2));
1165	 }
1166	 function log(address p0, bool p1, address p2) internal view {
1167	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,address)", p0, p1, p2));
1168	 }
1169	 function log(address p0, address p1, uint p2) internal view {
1170	 _sendLogPayload(abi.encodeWithSignature("log(address,address,uint)", p0, p1, p2));
1171	 }
1172	 function log(address p0, address p1, string memory p2) internal view {
1173	 _sendLogPayload(abi.encodeWithSignature("log(address,address,string)", p0, p1, p2));
1174	 }
1175	 function log(address p0, address p1, bool p2) internal view {
1176	 _sendLogPayload(abi.encodeWithSignature("log(address,address,bool)", p0, p1, p2));
1177	 }
1178	 function log(address p0, address p1, address p2) internal view {
1179	 _sendLogPayload(abi.encodeWithSignature("log(address,address,address)", p0, p1, p2));
1180	 }
1181	 function log(uint p0, uint p1, uint p2, uint p3) internal view {
1182	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,uint)", p0, p1, p2, p3));
1183	 }
1184	 function log(uint p0, uint p1, uint p2, string memory p3) internal view {
1185	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,string)", p0, p1, p2, p3));
1186	 }
1187	 function log(uint p0, uint p1, uint p2, bool p3) internal view {
1188	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,bool)", p0, p1, p2, p3));
1189	 }
1190	 function log(uint p0, uint p1, uint p2, address p3) internal view {
1191	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,address)", p0, p1, p2, p3));
1192	 }
1193	 function log(uint p0, uint p1, string memory p2, uint p3) internal view {
1194	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,uint)", p0, p1, p2, p3));
1195	 }
1196	 function log(uint p0, uint p1, string memory p2, string memory p3) internal view {
1197	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,string)", p0, p1, p2, p3));
1198	 }
1199	 function log(uint p0, uint p1, string memory p2, bool p3) internal view {
1200	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,bool)", p0, p1, p2, p3));
1201	 }
1202	 function log(uint p0, uint p1, string memory p2, address p3) internal view {
1203	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,address)", p0, p1, p2, p3));
1204	 }
1205	 function log(uint p0, uint p1, bool p2, uint p3) internal view {
1206	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,uint)", p0, p1, p2, p3));
1207	 }
1208	 function log(uint p0, uint p1, bool p2, string memory p3) internal view {
1209	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,string)", p0, p1, p2, p3));
1210	 }
1211	 function log(uint p0, uint p1, bool p2, bool p3) internal view {
1212	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,bool)", p0, p1, p2, p3));
1213	 }
1214	 function log(uint p0, uint p1, bool p2, address p3) internal view {
1215	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,address)", p0, p1, p2, p3));
1216	 }
1217	 function log(uint p0, uint p1, address p2, uint p3) internal view {
1218	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,uint)", p0, p1, p2, p3));
1219	 }
1220	 function log(uint p0, uint p1, address p2, string memory p3) internal view {
1221	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,string)", p0, p1, p2, p3));
1222	 }
1223	 function log(uint p0, uint p1, address p2, bool p3) internal view {
1224	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,bool)", p0, p1, p2, p3));
1225	 }
1226	 function log(uint p0, uint p1, address p2, address p3) internal view {
1227	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,address)", p0, p1, p2, p3));
1228	 }
1229	 function log(uint p0, string memory p1, uint p2, uint p3) internal view {
1230	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,uint)", p0, p1, p2, p3));
1231	 }
1232	 function log(uint p0, string memory p1, uint p2, string memory p3) internal view {
1233	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,string)", p0, p1, p2, p3));
1234	 }
1235	 function log(uint p0, string memory p1, uint p2, bool p3) internal view {
1236	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,bool)", p0, p1, p2, p3));
1237	 }
1238	 function log(uint p0, string memory p1, uint p2, address p3) internal view {
1239	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,address)", p0, p1, p2, p3));
1240	 }
1241	 function log(uint p0, string memory p1, string memory p2, uint p3) internal view {
1242	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,uint)", p0, p1, p2, p3));
1243	 }
1244	 function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {
1245	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,string)", p0, p1, p2, p3));
1246	 }
1247	 function log(uint p0, string memory p1, string memory p2, bool p3) internal view {
1248	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,bool)", p0, p1, p2, p3));
1249	 }
1250	 function log(uint p0, string memory p1, string memory p2, address p3) internal view {
1251	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,address)", p0, p1, p2, p3));
1252	 }
1253	 function log(uint p0, string memory p1, bool p2, uint p3) internal view {
1254	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,uint)", p0, p1, p2, p3));
1255	 }
1256	 function log(uint p0, string memory p1, bool p2, string memory p3) internal view {
1257	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,string)", p0, p1, p2, p3));
1258	 }
1259	 function log(uint p0, string memory p1, bool p2, bool p3) internal view {
1260	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,bool)", p0, p1, p2, p3));
1261	 }
1262	 function log(uint p0, string memory p1, bool p2, address p3) internal view {
1263	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,address)", p0, p1, p2, p3));
1264	 }
1265	 function log(uint p0, string memory p1, address p2, uint p3) internal view {
1266	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,uint)", p0, p1, p2, p3));
1267	 }
1268	 function log(uint p0, string memory p1, address p2, string memory p3) internal view {
1269	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,string)", p0, p1, p2, p3));
1270	 }
1271	 function log(uint p0, string memory p1, address p2, bool p3) internal view {
1272	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,bool)", p0, p1, p2, p3));
1273	 }
1274	 function log(uint p0, string memory p1, address p2, address p3) internal view {
1275	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,address)", p0, p1, p2, p3));
1276	 }
1277	 function log(uint p0, bool p1, uint p2, uint p3) internal view {
1278	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,uint)", p0, p1, p2, p3));
1279	 }
1280	 function log(uint p0, bool p1, uint p2, string memory p3) internal view {
1281	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,string)", p0, p1, p2, p3));
1282	 }
1283	 function log(uint p0, bool p1, uint p2, bool p3) internal view {
1284	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,bool)", p0, p1, p2, p3));
1285	 }
1286	 function log(uint p0, bool p1, uint p2, address p3) internal view {
1287	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,address)", p0, p1, p2, p3));
1288	 }
1289	 function log(uint p0, bool p1, string memory p2, uint p3) internal view {
1290	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,uint)", p0, p1, p2, p3));
1291	 }
1292	 function log(uint p0, bool p1, string memory p2, string memory p3) internal view {
1293	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,string)", p0, p1, p2, p3));
1294	 }
1295	 function log(uint p0, bool p1, string memory p2, bool p3) internal view {
1296	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,bool)", p0, p1, p2, p3));
1297	 }
1298	 function log(uint p0, bool p1, string memory p2, address p3) internal view {
1299	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,address)", p0, p1, p2, p3));
1300	 }
1301	 function log(uint p0, bool p1, bool p2, uint p3) internal view {
1302	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,uint)", p0, p1, p2, p3));
1303	 }
1304	 function log(uint p0, bool p1, bool p2, string memory p3) internal view {
1305	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,string)", p0, p1, p2, p3));
1306	 }
1307	 function log(uint p0, bool p1, bool p2, bool p3) internal view {
1308	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,bool)", p0, p1, p2, p3));
1309	 }
1310	 function log(uint p0, bool p1, bool p2, address p3) internal view {
1311	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,address)", p0, p1, p2, p3));
1312	 }
1313	 function log(uint p0, bool p1, address p2, uint p3) internal view {
1314	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,uint)", p0, p1, p2, p3));
1315	 }
1316	 function log(uint p0, bool p1, address p2, string memory p3) internal view {
1317	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,string)", p0, p1, p2, p3));
1318	 }
1319	 function log(uint p0, bool p1, address p2, bool p3) internal view {
1320	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,bool)", p0, p1, p2, p3));
1321	 }
1322	 function log(uint p0, bool p1, address p2, address p3) internal view {
1323	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,address)", p0, p1, p2, p3));
1324	 }
1325	 function log(uint p0, address p1, uint p2, uint p3) internal view {
1326	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,uint)", p0, p1, p2, p3));
1327	 }
1328	 function log(uint p0, address p1, uint p2, string memory p3) internal view {
1329	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,string)", p0, p1, p2, p3));
1330	 }
1331	 function log(uint p0, address p1, uint p2, bool p3) internal view {
1332	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,bool)", p0, p1, p2, p3));
1333	 }
1334	 function log(uint p0, address p1, uint p2, address p3) internal view {
1335	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,address)", p0, p1, p2, p3));
1336	 }
1337	 function log(uint p0, address p1, string memory p2, uint p3) internal view {
1338	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,uint)", p0, p1, p2, p3));
1339	 }
1340	 function log(uint p0, address p1, string memory p2, string memory p3) internal view {
1341	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,string)", p0, p1, p2, p3));
1342	 }
1343	 function log(uint p0, address p1, string memory p2, bool p3) internal view {
1344	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,bool)", p0, p1, p2, p3));
1345	 }
1346	 function log(uint p0, address p1, string memory p2, address p3) internal view {
1347	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,address)", p0, p1, p2, p3));
1348	 }
1349	 function log(uint p0, address p1, bool p2, uint p3) internal view {
1350	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,uint)", p0, p1, p2, p3));
1351	 }
1352	 function log(uint p0, address p1, bool p2, string memory p3) internal view {
1353	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,string)", p0, p1, p2, p3));
1354	 }
1355	 function log(uint p0, address p1, bool p2, bool p3) internal view {
1356	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,bool)", p0, p1, p2, p3));
1357	 }
1358	 function log(uint p0, address p1, bool p2, address p3) internal view {
1359	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,address)", p0, p1, p2, p3));
1360	 }
1361	 function log(uint p0, address p1, address p2, uint p3) internal view {
1362	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,uint)", p0, p1, p2, p3));
1363	 }
1364	 function log(uint p0, address p1, address p2, string memory p3) internal view {
1365	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,string)", p0, p1, p2, p3));
1366	 }
1367	 function log(uint p0, address p1, address p2, bool p3) internal view {
1368	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,bool)", p0, p1, p2, p3));
1369	 }
1370	 function log(uint p0, address p1, address p2, address p3) internal view {
1371	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,address)", p0, p1, p2, p3));
1372	 }
1373	 function log(string memory p0, uint p1, uint p2, uint p3) internal view {
1374	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,uint)", p0, p1, p2, p3));
1375	 }
1376	 function log(string memory p0, uint p1, uint p2, string memory p3) internal view {
1377	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,string)", p0, p1, p2, p3));
1378	 }
1379	 function log(string memory p0, uint p1, uint p2, bool p3) internal view {
1380	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,bool)", p0, p1, p2, p3));
1381	 }
1382	 function log(string memory p0, uint p1, uint p2, address p3) internal view {
1383	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,address)", p0, p1, p2, p3));
1384	 }
1385	 function log(string memory p0, uint p1, string memory p2, uint p3) internal view {
1386	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,uint)", p0, p1, p2, p3));
1387	 }
1388	 function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {
1389	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,string)", p0, p1, p2, p3));
1390	 }
1391	 function log(string memory p0, uint p1, string memory p2, bool p3) internal view {
1392	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,bool)", p0, p1, p2, p3));
1393	 }
1394	 function log(string memory p0, uint p1, string memory p2, address p3) internal view {
1395	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,address)", p0, p1, p2, p3));
1396	 }
1397	 function log(string memory p0, uint p1, bool p2, uint p3) internal view {
1398	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,uint)", p0, p1, p2, p3));
1399	 }
1400	 function log(string memory p0, uint p1, bool p2, string memory p3) internal view {
1401	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,string)", p0, p1, p2, p3));
1402	 }
1403	 function log(string memory p0, uint p1, bool p2, bool p3) internal view {
1404	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,bool)", p0, p1, p2, p3));
1405	 }
1406	 function log(string memory p0, uint p1, bool p2, address p3) internal view {
1407	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,address)", p0, p1, p2, p3));
1408	 }
1409	 function log(string memory p0, uint p1, address p2, uint p3) internal view {
1410	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,uint)", p0, p1, p2, p3));
1411	 }
1412	 function log(string memory p0, uint p1, address p2, string memory p3) internal view {
1413	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,string)", p0, p1, p2, p3));
1414	 }
1415	 function log(string memory p0, uint p1, address p2, bool p3) internal view {
1416	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,bool)", p0, p1, p2, p3));
1417	 }
1418	 function log(string memory p0, uint p1, address p2, address p3) internal view {
1419	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,address)", p0, p1, p2, p3));
1420	 }
1421	 function log(string memory p0, string memory p1, uint p2, uint p3) internal view {
1422	 _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,uint)", p0, p1, p2, p3));
1423	 }
1424	 function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {
1425	 _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,string)", p0, p1, p2, p3));
1426	 }
1427	 function log(string memory p0, string memory p1, uint p2, bool p3) internal view {
1428	 _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,bool)", p0, p1, p2, p3));
1429	 }
1430	 function log(string memory p0, string memory p1, uint p2, address p3) internal view {
1431	 _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,address)", p0, p1, p2, p3));
1432	 }
1433	 function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {
1434	 _sendLogPayload(abi.encodeWithSignature("log(string,string,string,uint)", p0, p1, p2, p3));
1435	 }
1436	 function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {
1437	 _sendLogPayload(abi.encodeWithSignature("log(string,string,string,string)", p0, p1, p2, p3));
1438	 }
1439	 function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {
1440	 _sendLogPayload(abi.encodeWithSignature("log(string,string,string,bool)", p0, p1, p2, p3));
1441	 }
1442	 function log(string memory p0, string memory p1, string memory p2, address p3) internal view {
1443	 _sendLogPayload(abi.encodeWithSignature("log(string,string,string,address)", p0, p1, p2, p3));
1444	 }
1445	 function log(string memory p0, string memory p1, bool p2, uint p3) internal view {
1446	 _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,uint)", p0, p1, p2, p3));
1447	 }
1448	 function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {
1449	 _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,string)", p0, p1, p2, p3));
1450	 }
1451	 function log(string memory p0, string memory p1, bool p2, bool p3) internal view {
1452	 _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,bool)", p0, p1, p2, p3));
1453	 }
1454	 function log(string memory p0, string memory p1, bool p2, address p3) internal view {
1455	 _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,address)", p0, p1, p2, p3));
1456	 }
1457	 function log(string memory p0, string memory p1, address p2, uint p3) internal view {
1458	 _sendLogPayload(abi.encodeWithSignature("log(string,string,address,uint)", p0, p1, p2, p3));
1459	 }
1460	 function log(string memory p0, string memory p1, address p2, string memory p3) internal view {
1461	 _sendLogPayload(abi.encodeWithSignature("log(string,string,address,string)", p0, p1, p2, p3));
1462	 }
1463	 function log(string memory p0, string memory p1, address p2, bool p3) internal view {
1464	 _sendLogPayload(abi.encodeWithSignature("log(string,string,address,bool)", p0, p1, p2, p3));
1465	 }
1466	 function log(string memory p0, string memory p1, address p2, address p3) internal view {
1467	 _sendLogPayload(abi.encodeWithSignature("log(string,string,address,address)", p0, p1, p2, p3));
1468	 }
1469	 function log(string memory p0, bool p1, uint p2, uint p3) internal view {
1470	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,uint)", p0, p1, p2, p3));
1471	 }
1472	 function log(string memory p0, bool p1, uint p2, string memory p3) internal view {
1473	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,string)", p0, p1, p2, p3));
1474	 }
1475	 function log(string memory p0, bool p1, uint p2, bool p3) internal view {
1476	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,bool)", p0, p1, p2, p3));
1477	 }
1478	 function log(string memory p0, bool p1, uint p2, address p3) internal view {
1479	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,address)", p0, p1, p2, p3));
1480	 }
1481	 function log(string memory p0, bool p1, string memory p2, uint p3) internal view {
1482	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,uint)", p0, p1, p2, p3));
1483	 }
1484	 function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {
1485	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,string)", p0, p1, p2, p3));
1486	 }
1487	 function log(string memory p0, bool p1, string memory p2, bool p3) internal view {
1488	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,bool)", p0, p1, p2, p3));
1489	 }
1490	 function log(string memory p0, bool p1, string memory p2, address p3) internal view {
1491	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,address)", p0, p1, p2, p3));
1492	 }
1493	 function log(string memory p0, bool p1, bool p2, uint p3) internal view {
1494	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,uint)", p0, p1, p2, p3));
1495	 }
1496	 function log(string memory p0, bool p1, bool p2, string memory p3) internal view {
1497	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,string)", p0, p1, p2, p3));
1498	 }
1499	 function log(string memory p0, bool p1, bool p2, bool p3) internal view {
1500	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,bool)", p0, p1, p2, p3));
1501	 }
1502	 function log(string memory p0, bool p1, bool p2, address p3) internal view {
1503	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,address)", p0, p1, p2, p3));
1504	 }
1505	 function log(string memory p0, bool p1, address p2, uint p3) internal view {
1506	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,uint)", p0, p1, p2, p3));
1507	 }
1508	 function log(string memory p0, bool p1, address p2, string memory p3) internal view {
1509	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,string)", p0, p1, p2, p3));
1510	 }
1511	 function log(string memory p0, bool p1, address p2, bool p3) internal view {
1512	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,bool)", p0, p1, p2, p3));
1513	 }
1514	 function log(string memory p0, bool p1, address p2, address p3) internal view {
1515	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,address)", p0, p1, p2, p3));
1516	 }
1517	 function log(string memory p0, address p1, uint p2, uint p3) internal view {
1518	 _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,uint)", p0, p1, p2, p3));
1519	 }
1520	 function log(string memory p0, address p1, uint p2, string memory p3) internal view {
1521	 _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,string)", p0, p1, p2, p3));
1522	 }
1523	 function log(string memory p0, address p1, uint p2, bool p3) internal view {
1524	 _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,bool)", p0, p1, p2, p3));
1525	 }
1526	 function log(string memory p0, address p1, uint p2, address p3) internal view {
1527	 _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,address)", p0, p1, p2, p3));
1528	 }
1529	 function log(string memory p0, address p1, string memory p2, uint p3) internal view {
1530	 _sendLogPayload(abi.encodeWithSignature("log(string,address,string,uint)", p0, p1, p2, p3));
1531	 }
1532	 function log(string memory p0, address p1, string memory p2, string memory p3) internal view {
1533	 _sendLogPayload(abi.encodeWithSignature("log(string,address,string,string)", p0, p1, p2, p3));
1534	 }
1535	 function log(string memory p0, address p1, string memory p2, bool p3) internal view {
1536	 _sendLogPayload(abi.encodeWithSignature("log(string,address,string,bool)", p0, p1, p2, p3));
1537	 }
1538	 function log(string memory p0, address p1, string memory p2, address p3) internal view {
1539	 _sendLogPayload(abi.encodeWithSignature("log(string,address,string,address)", p0, p1, p2, p3));
1540	 }
1541	 function log(string memory p0, address p1, bool p2, uint p3) internal view {
1542	 _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,uint)", p0, p1, p2, p3));
1543	 }
1544	 function log(string memory p0, address p1, bool p2, string memory p3) internal view {
1545	 _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,string)", p0, p1, p2, p3));
1546	 }
1547	 function log(string memory p0, address p1, bool p2, bool p3) internal view {
1548	 _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,bool)", p0, p1, p2, p3));
1549	 }
1550	 function log(string memory p0, address p1, bool p2, address p3) internal view {
1551	 _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,address)", p0, p1, p2, p3));
1552	 }
1553	 function log(string memory p0, address p1, address p2, uint p3) internal view {
1554	 _sendLogPayload(abi.encodeWithSignature("log(string,address,address,uint)", p0, p1, p2, p3));
1555	 }
1556	 function log(string memory p0, address p1, address p2, string memory p3) internal view {
1557	 _sendLogPayload(abi.encodeWithSignature("log(string,address,address,string)", p0, p1, p2, p3));
1558	 }
1559	 function log(string memory p0, address p1, address p2, bool p3) internal view {
1560	 _sendLogPayload(abi.encodeWithSignature("log(string,address,address,bool)", p0, p1, p2, p3));
1561	 }
1562	 function log(string memory p0, address p1, address p2, address p3) internal view {
1563	 _sendLogPayload(abi.encodeWithSignature("log(string,address,address,address)", p0, p1, p2, p3));
1564	 }
1565	 function log(bool p0, uint p1, uint p2, uint p3) internal view {
1566	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,uint)", p0, p1, p2, p3));
1567	 }
1568	 function log(bool p0, uint p1, uint p2, string memory p3) internal view {
1569	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,string)", p0, p1, p2, p3));
1570	 }
1571	 function log(bool p0, uint p1, uint p2, bool p3) internal view {
1572	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,bool)", p0, p1, p2, p3));
1573	 }
1574	 function log(bool p0, uint p1, uint p2, address p3) internal view {
1575	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,address)", p0, p1, p2, p3));
1576	 }
1577	 function log(bool p0, uint p1, string memory p2, uint p3) internal view {
1578	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,uint)", p0, p1, p2, p3));
1579	 }
1580	 function log(bool p0, uint p1, string memory p2, string memory p3) internal view {
1581	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,string)", p0, p1, p2, p3));
1582	 }
1583	 function log(bool p0, uint p1, string memory p2, bool p3) internal view {
1584	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,bool)", p0, p1, p2, p3));
1585	 }
1586	 function log(bool p0, uint p1, string memory p2, address p3) internal view {
1587	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,address)", p0, p1, p2, p3));
1588	 }
1589	 function log(bool p0, uint p1, bool p2, uint p3) internal view {
1590	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,uint)", p0, p1, p2, p3));
1591	 }
1592	 function log(bool p0, uint p1, bool p2, string memory p3) internal view {
1593	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,string)", p0, p1, p2, p3));
1594	 }
1595	 function log(bool p0, uint p1, bool p2, bool p3) internal view {
1596	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,bool)", p0, p1, p2, p3));
1597	 }
1598	 function log(bool p0, uint p1, bool p2, address p3) internal view {
1599	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,address)", p0, p1, p2, p3));
1600	 }
1601	 function log(bool p0, uint p1, address p2, uint p3) internal view {
1602	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,uint)", p0, p1, p2, p3));
1603	 }
1604	 function log(bool p0, uint p1, address p2, string memory p3) internal view {
1605	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,string)", p0, p1, p2, p3));
1606	 }
1607	 function log(bool p0, uint p1, address p2, bool p3) internal view {
1608	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,bool)", p0, p1, p2, p3));
1609	 }
1610	 function log(bool p0, uint p1, address p2, address p3) internal view {
1611	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,address)", p0, p1, p2, p3));
1612	 }
1613	 function log(bool p0, string memory p1, uint p2, uint p3) internal view {
1614	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,uint)", p0, p1, p2, p3));
1615	 }
1616	 function log(bool p0, string memory p1, uint p2, string memory p3) internal view {
1617	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,string)", p0, p1, p2, p3));
1618	 }
1619	 function log(bool p0, string memory p1, uint p2, bool p3) internal view {
1620	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,bool)", p0, p1, p2, p3));
1621	 }
1622	 function log(bool p0, string memory p1, uint p2, address p3) internal view {
1623	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,address)", p0, p1, p2, p3));
1624	 }
1625	 function log(bool p0, string memory p1, string memory p2, uint p3) internal view {
1626	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,uint)", p0, p1, p2, p3));
1627	 }
1628	 function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {
1629	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,string)", p0, p1, p2, p3));
1630	 }
1631	 function log(bool p0, string memory p1, string memory p2, bool p3) internal view {
1632	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,bool)", p0, p1, p2, p3));
1633	 }
1634	 function log(bool p0, string memory p1, string memory p2, address p3) internal view {
1635	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,address)", p0, p1, p2, p3));
1636	 }
1637	 function log(bool p0, string memory p1, bool p2, uint p3) internal view {
1638	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,uint)", p0, p1, p2, p3));
1639	 }
1640	 function log(bool p0, string memory p1, bool p2, string memory p3) internal view {
1641	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,string)", p0, p1, p2, p3));
1642	 }
1643	 function log(bool p0, string memory p1, bool p2, bool p3) internal view {
1644	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,bool)", p0, p1, p2, p3));
1645	 }
1646	 function log(bool p0, string memory p1, bool p2, address p3) internal view {
1647	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,address)", p0, p1, p2, p3));
1648	 }
1649	 function log(bool p0, string memory p1, address p2, uint p3) internal view {
1650	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,uint)", p0, p1, p2, p3));
1651	 }
1652	 function log(bool p0, string memory p1, address p2, string memory p3) internal view {
1653	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,string)", p0, p1, p2, p3));
1654	 }
1655	 function log(bool p0, string memory p1, address p2, bool p3) internal view {
1656	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,bool)", p0, p1, p2, p3));
1657	 }
1658	 function log(bool p0, string memory p1, address p2, address p3) internal view {
1659	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,address)", p0, p1, p2, p3));
1660	 }
1661	 function log(bool p0, bool p1, uint p2, uint p3) internal view {
1662	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,uint)", p0, p1, p2, p3));
1663	 }
1664	 function log(bool p0, bool p1, uint p2, string memory p3) internal view {
1665	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,string)", p0, p1, p2, p3));
1666	 }
1667	 function log(bool p0, bool p1, uint p2, bool p3) internal view {
1668	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,bool)", p0, p1, p2, p3));
1669	 }
1670	 function log(bool p0, bool p1, uint p2, address p3) internal view {
1671	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,address)", p0, p1, p2, p3));
1672	 }
1673	 function log(bool p0, bool p1, string memory p2, uint p3) internal view {
1674	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,uint)", p0, p1, p2, p3));
1675	 }
1676	 function log(bool p0, bool p1, string memory p2, string memory p3) internal view {
1677	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,string)", p0, p1, p2, p3));
1678	 }
1679	 function log(bool p0, bool p1, string memory p2, bool p3) internal view {
1680	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,bool)", p0, p1, p2, p3));
1681	 }
1682	 function log(bool p0, bool p1, string memory p2, address p3) internal view {
1683	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,address)", p0, p1, p2, p3));
1684	 }
1685	 function log(bool p0, bool p1, bool p2, uint p3) internal view {
1686	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,uint)", p0, p1, p2, p3));
1687	 }
1688	 function log(bool p0, bool p1, bool p2, string memory p3) internal view {
1689	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,string)", p0, p1, p2, p3));
1690	 }
1691	 function log(bool p0, bool p1, bool p2, bool p3) internal view {
1692	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,bool)", p0, p1, p2, p3));
1693	 }
1694	 function log(bool p0, bool p1, bool p2, address p3) internal view {
1695	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,address)", p0, p1, p2, p3));
1696	 }
1697	 function log(bool p0, bool p1, address p2, uint p3) internal view {
1698	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,uint)", p0, p1, p2, p3));
1699	 }
1700	 function log(bool p0, bool p1, address p2, string memory p3) internal view {
1701	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,string)", p0, p1, p2, p3));
1702	 }
1703	 function log(bool p0, bool p1, address p2, bool p3) internal view {
1704	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,bool)", p0, p1, p2, p3));
1705	 }
1706	 function log(bool p0, bool p1, address p2, address p3) internal view {
1707	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,address)", p0, p1, p2, p3));
1708	 }
1709	 function log(bool p0, address p1, uint p2, uint p3) internal view {
1710	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,uint)", p0, p1, p2, p3));
1711	 }
1712	 function log(bool p0, address p1, uint p2, string memory p3) internal view {
1713	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,string)", p0, p1, p2, p3));
1714	 }
1715	 function log(bool p0, address p1, uint p2, bool p3) internal view {
1716	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,bool)", p0, p1, p2, p3));
1717	 }
1718	 function log(bool p0, address p1, uint p2, address p3) internal view {
1719	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,address)", p0, p1, p2, p3));
1720	 }
1721	 function log(bool p0, address p1, string memory p2, uint p3) internal view {
1722	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,uint)", p0, p1, p2, p3));
1723	 }
1724	 function log(bool p0, address p1, string memory p2, string memory p3) internal view {
1725	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,string)", p0, p1, p2, p3));
1726	 }
1727	 function log(bool p0, address p1, string memory p2, bool p3) internal view {
1728	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,bool)", p0, p1, p2, p3));
1729	 }
1730	 function log(bool p0, address p1, string memory p2, address p3) internal view {
1731	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,address)", p0, p1, p2, p3));
1732	 }
1733	 function log(bool p0, address p1, bool p2, uint p3) internal view {
1734	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,uint)", p0, p1, p2, p3));
1735	 }
1736	 function log(bool p0, address p1, bool p2, string memory p3) internal view {
1737	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,string)", p0, p1, p2, p3));
1738	 }
1739	 function log(bool p0, address p1, bool p2, bool p3) internal view {
1740	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,bool)", p0, p1, p2, p3));
1741	 }
1742	 function log(bool p0, address p1, bool p2, address p3) internal view {
1743	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,address)", p0, p1, p2, p3));
1744	 }
1745	 function log(bool p0, address p1, address p2, uint p3) internal view {
1746	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,uint)", p0, p1, p2, p3));
1747	 }
1748	 function log(bool p0, address p1, address p2, string memory p3) internal view {
1749	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,string)", p0, p1, p2, p3));
1750	 }
1751	 function log(bool p0, address p1, address p2, bool p3) internal view {
1752	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,bool)", p0, p1, p2, p3));
1753	 }
1754	 function log(bool p0, address p1, address p2, address p3) internal view {
1755	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,address)", p0, p1, p2, p3));
1756	 }
1757	 function log(address p0, uint p1, uint p2, uint p3) internal view {
1758	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,uint)", p0, p1, p2, p3));
1759	 }
1760	 function log(address p0, uint p1, uint p2, string memory p3) internal view {
1761	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,string)", p0, p1, p2, p3));
1762	 }
1763	 function log(address p0, uint p1, uint p2, bool p3) internal view {
1764	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,bool)", p0, p1, p2, p3));
1765	 }
1766	 function log(address p0, uint p1, uint p2, address p3) internal view {
1767	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,address)", p0, p1, p2, p3));
1768	 }
1769	 function log(address p0, uint p1, string memory p2, uint p3) internal view {
1770	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,uint)", p0, p1, p2, p3));
1771	 }
1772	 function log(address p0, uint p1, string memory p2, string memory p3) internal view {
1773	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,string)", p0, p1, p2, p3));
1774	 }
1775	 function log(address p0, uint p1, string memory p2, bool p3) internal view {
1776	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,bool)", p0, p1, p2, p3));
1777	 }
1778	 function log(address p0, uint p1, string memory p2, address p3) internal view {
1779	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,address)", p0, p1, p2, p3));
1780	 }
1781	 function log(address p0, uint p1, bool p2, uint p3) internal view {
1782	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,uint)", p0, p1, p2, p3));
1783	 }
1784	 function log(address p0, uint p1, bool p2, string memory p3) internal view {
1785	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,string)", p0, p1, p2, p3));
1786	 }
1787	 function log(address p0, uint p1, bool p2, bool p3) internal view {
1788	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,bool)", p0, p1, p2, p3));
1789	 }
1790	 function log(address p0, uint p1, bool p2, address p3) internal view {
1791	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,address)", p0, p1, p2, p3));
1792	 }
1793	 function log(address p0, uint p1, address p2, uint p3) internal view {
1794	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,uint)", p0, p1, p2, p3));
1795	 }
1796	 function log(address p0, uint p1, address p2, string memory p3) internal view {
1797	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,string)", p0, p1, p2, p3));
1798	 }
1799	 function log(address p0, uint p1, address p2, bool p3) internal view {
1800	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,bool)", p0, p1, p2, p3));
1801	 }
1802	 function log(address p0, uint p1, address p2, address p3) internal view {
1803	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,address)", p0, p1, p2, p3));
1804	 }
1805	 function log(address p0, string memory p1, uint p2, uint p3) internal view {
1806	 _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,uint)", p0, p1, p2, p3));
1807	 }
1808	 function log(address p0, string memory p1, uint p2, string memory p3) internal view {
1809	 _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,string)", p0, p1, p2, p3));
1810	 }
1811	 function log(address p0, string memory p1, uint p2, bool p3) internal view {
1812	 _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,bool)", p0, p1, p2, p3));
1813	 }
1814	 function log(address p0, string memory p1, uint p2, address p3) internal view {
1815	 _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,address)", p0, p1, p2, p3));
1816	 }
1817	 function log(address p0, string memory p1, string memory p2, uint p3) internal view {
1818	 _sendLogPayload(abi.encodeWithSignature("log(address,string,string,uint)", p0, p1, p2, p3));
1819	 }
1820	 function log(address p0, string memory p1, string memory p2, string memory p3) internal view {
1821	 _sendLogPayload(abi.encodeWithSignature("log(address,string,string,string)", p0, p1, p2, p3));
1822	 }
1823	 function log(address p0, string memory p1, string memory p2, bool p3) internal view {
1824	 _sendLogPayload(abi.encodeWithSignature("log(address,string,string,bool)", p0, p1, p2, p3));
1825	 }
1826	 function log(address p0, string memory p1, string memory p2, address p3) internal view {
1827	 _sendLogPayload(abi.encodeWithSignature("log(address,string,string,address)", p0, p1, p2, p3));
1828	 }
1829	 function log(address p0, string memory p1, bool p2, uint p3) internal view {
1830	 _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,uint)", p0, p1, p2, p3));
1831	 }
1832	 function log(address p0, string memory p1, bool p2, string memory p3) internal view {
1833	 _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,string)", p0, p1, p2, p3));
1834	 }
1835	 function log(address p0, string memory p1, bool p2, bool p3) internal view {
1836	 _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,bool)", p0, p1, p2, p3));
1837	 }
1838	 function log(address p0, string memory p1, bool p2, address p3) internal view {
1839	 _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,address)", p0, p1, p2, p3));
1840	 }
1841	 function log(address p0, string memory p1, address p2, uint p3) internal view {
1842	 _sendLogPayload(abi.encodeWithSignature("log(address,string,address,uint)", p0, p1, p2, p3));
1843	 }
1844	 function log(address p0, string memory p1, address p2, string memory p3) internal view {
1845	 _sendLogPayload(abi.encodeWithSignature("log(address,string,address,string)", p0, p1, p2, p3));
1846	 }
1847	 function log(address p0, string memory p1, address p2, bool p3) internal view {
1848	 _sendLogPayload(abi.encodeWithSignature("log(address,string,address,bool)", p0, p1, p2, p3));
1849	 }
1850	 function log(address p0, string memory p1, address p2, address p3) internal view {
1851	 _sendLogPayload(abi.encodeWithSignature("log(address,string,address,address)", p0, p1, p2, p3));
1852	 }
1853	 function log(address p0, bool p1, uint p2, uint p3) internal view {
1854	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,uint)", p0, p1, p2, p3));
1855	 }
1856	 function log(address p0, bool p1, uint p2, string memory p3) internal view {
1857	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,string)", p0, p1, p2, p3));
1858	 }
1859	 function log(address p0, bool p1, uint p2, bool p3) internal view {
1860	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,bool)", p0, p1, p2, p3));
1861	 }
1862	 function log(address p0, bool p1, uint p2, address p3) internal view {
1863	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,address)", p0, p1, p2, p3));
1864	 }
1865	 function log(address p0, bool p1, string memory p2, uint p3) internal view {
1866	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,uint)", p0, p1, p2, p3));
1867	 }
1868	 function log(address p0, bool p1, string memory p2, string memory p3) internal view {
1869	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,string)", p0, p1, p2, p3));
1870	 }
1871	 function log(address p0, bool p1, string memory p2, bool p3) internal view {
1872	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,bool)", p0, p1, p2, p3));
1873	 }
1874	 function log(address p0, bool p1, string memory p2, address p3) internal view {
1875	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,address)", p0, p1, p2, p3));
1876	 }
1877	 function log(address p0, bool p1, bool p2, uint p3) internal view {
1878	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,uint)", p0, p1, p2, p3));
1879	 }
1880	 function log(address p0, bool p1, bool p2, string memory p3) internal view {
1881	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,string)", p0, p1, p2, p3));
1882	 }
1883	 function log(address p0, bool p1, bool p2, bool p3) internal view {
1884	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,bool)", p0, p1, p2, p3));
1885	 }
1886	 function log(address p0, bool p1, bool p2, address p3) internal view {
1887	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,address)", p0, p1, p2, p3));
1888	 }
1889	 function log(address p0, bool p1, address p2, uint p3) internal view {
1890	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,uint)", p0, p1, p2, p3));
1891	 }
1892	 function log(address p0, bool p1, address p2, string memory p3) internal view {
1893	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,string)", p0, p1, p2, p3));
1894	 }
1895	 function log(address p0, bool p1, address p2, bool p3) internal view {
1896	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,bool)", p0, p1, p2, p3));
1897	 }
1898	 function log(address p0, bool p1, address p2, address p3) internal view {
1899	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,address)", p0, p1, p2, p3));
1900	 }
1901	 function log(address p0, address p1, uint p2, uint p3) internal view {
1902	 _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,uint)", p0, p1, p2, p3));
1903	 }
1904	 function log(address p0, address p1, uint p2, string memory p3) internal view {
1905	 _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,string)", p0, p1, p2, p3));
1906	 }
1907	 function log(address p0, address p1, uint p2, bool p3) internal view {
1908	 _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,bool)", p0, p1, p2, p3));
1909	 }
1910	 function log(address p0, address p1, uint p2, address p3) internal view {
1911	 _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,address)", p0, p1, p2, p3));
1912	 }
1913	 function log(address p0, address p1, string memory p2, uint p3) internal view {
1914	 _sendLogPayload(abi.encodeWithSignature("log(address,address,string,uint)", p0, p1, p2, p3));
1915	 }
1916	 function log(address p0, address p1, string memory p2, string memory p3) internal view {
1917	 _sendLogPayload(abi.encodeWithSignature("log(address,address,string,string)", p0, p1, p2, p3));
1918	 }
1919	 function log(address p0, address p1, string memory p2, bool p3) internal view {
1920	 _sendLogPayload(abi.encodeWithSignature("log(address,address,string,bool)", p0, p1, p2, p3));
1921	 }
1922	 function log(address p0, address p1, string memory p2, address p3) internal view {
1923	 _sendLogPayload(abi.encodeWithSignature("log(address,address,string,address)", p0, p1, p2, p3));
1924	 }
1925	 function log(address p0, address p1, bool p2, uint p3) internal view {
1926	 _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,uint)", p0, p1, p2, p3));
1927	 }
1928	 function log(address p0, address p1, bool p2, string memory p3) internal view {
1929	 _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,string)", p0, p1, p2, p3));
1930	 }
1931	 function log(address p0, address p1, bool p2, bool p3) internal view {
1932	 _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,bool)", p0, p1, p2, p3));
1933	 }
1934	 function log(address p0, address p1, bool p2, address p3) internal view {
1935	 _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,address)", p0, p1, p2, p3));
1936	 }
1937	 function log(address p0, address p1, address p2, uint p3) internal view {
1938	 _sendLogPayload(abi.encodeWithSignature("log(address,address,address,uint)", p0, p1, p2, p3));
1939	 }
1940	 function log(address p0, address p1, address p2, string memory p3) internal view {
1941	 _sendLogPayload(abi.encodeWithSignature("log(address,address,address,string)", p0, p1, p2, p3));
1942	 }
1943	 function log(address p0, address p1, address p2, bool p3) internal view {
1944	 _sendLogPayload(abi.encodeWithSignature("log(address,address,address,bool)", p0, p1, p2, p3));
1945	 }
1946	 function log(address p0, address p1, address p2, address p3) internal view {
1947	 _sendLogPayload(abi.encodeWithSignature("log(address,address,address,address)", p0, p1, p2, p3));
1948	 }
1949	 }
1950	 pragma solidity >=0.6.2 <0.8.0;
1951	 library LibERC1155LazyMint {
1952	 bytes4 constant public ERC1155_LAZY_ASSET_CLASS = bytes4(keccak256("ERC1155_LAZY"));
1953	 struct Mint1155Data {
1954	 uint tokenId;
1955	 string tokenURI;
1956	 uint supply;
1957	 LibPart.Part[] creators;
1958	 LibPart.Part[] royalties;
1959	 bytes[] signatures;
1960	 }
1961	 bytes32 public constant MINT_AND_TRANSFER_TYPEHASH = keccak256("Mint1155(uint256 tokenId,uint256 supply,string tokenURI,Part[] creators,Part[] royalties)Part(address account,uint96 value)");
1962	 function hash(Mint1155Data memory data) internal pure returns (bytes32) {
1963	 bytes32[] memory royaltiesBytes = new bytes32[](data.royalties.length);
1964	 for (uint i = 0; i < data.royalties.length; i++) {
1965	 royaltiesBytes[i] = LibPart.hash(data.royalties[i]);
1966	 }
1967	 bytes32[] memory creatorsBytes = new bytes32[](data.creators.length);
1968	 for (uint i = 0; i < data.creators.length; i++) {
1969	 creatorsBytes[i] = LibPart.hash(data.creators[i]);
1970	 }
1971	 return keccak256(abi.encode( MINT_AND_TRANSFER_TYPEHASH, data.tokenId, data.supply, keccak256(bytes(data.tokenURI)), keccak256(abi.encodePacked(creatorsBytes)), keccak256(abi.encodePacked(royaltiesBytes)) ));
1972	 }
1973	 }
1974	 pragma solidity 0.7.6;
1975	 abstract contract ERC1271 {
1976	 bytes4 constant public ERC1271_INTERFACE_ID = 0xfb855dc9;
1977	 bytes4 constant public ERC1271_RETURN_VALID_SIGNATURE = 0x1626ba7e;
1978	 bytes4 constant public ERC1271_RETURN_INVALID_SIGNATURE = 0x00000000;
1979	 function isValidSignature(bytes32 _hash, bytes memory _signature) public virtual view returns (bytes4);
1980	 function returnIsValidSignatureMagicNumber(bool isValid) internal pure returns (bytes4) {
1981	 return isValid ? ERC1271_RETURN_VALID_SIGNATURE : ERC1271_RETURN_INVALID_SIGNATURE;
1982	 }
1983	 }
