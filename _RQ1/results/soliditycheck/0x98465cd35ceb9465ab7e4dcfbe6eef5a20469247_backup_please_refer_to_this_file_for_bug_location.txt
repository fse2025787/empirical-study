row number 
1	  pragma experimental ABIEncoderV2;
2	 pragma solidity ^0.7.6;
3	 contract SiloExit {
4	 using SafeMath for uint256;
5	 using SafeMath for uint32;
6	 AppStorage internal s;
7	 function weth() public view returns (IWETH) {
8	 return IWETH(s.c.weth);
9	 }
10	 function index() internal view returns (uint8) {
11	 return s.index;
12	 }
13	 function pair() internal view returns (IUniswapV2Pair) {
14	 return IUniswapV2Pair(s.c.pair);
15	 }
16	 function bean() internal view returns (IBean) {
17	 return IBean(s.c.bean);
18	 }
19	 function season() internal view returns (uint32) {
20	 return s.season.current;
21	 }
22	 function totalStalk() public view returns (uint256) {
23	 return s.s.stalk;
24	 }
25	 function totalRoots() public view returns(uint256) {
26	 return s.s.roots;
27	 }
28	 function totalSeeds() public view returns (uint256) {
29	 return s.s.seeds;
30	 }
31	 function totalFarmableBeans() public view returns (uint256) {
32	 return s.si.beans;
33	 }
34	 function totalFarmableStalk() public view returns (uint256) {
35	 return s.si.stalk;
36	 }
37	 function balanceOfSeeds(address account) public view returns (uint256) {
38	 return s.a[account].s.seeds.add(balanceOfFarmableBeans(account).mul(C.getSeedsPerBean()));
39	 }
40	 function balanceOfStalk(address account) public view returns (uint256) {
41	 uint256 farmableBeans = balanceOfFarmableBeans(account);
42	 uint256 farmableStalk = balanceOfFarmableStalkFromBeans(account, farmableBeans);
43	 return s.a[account].s.stalk.add(farmableBeans.mul(C.getStalkPerBean())).add(farmableStalk);
44	 }
45	 function balanceOfRoots(address account) public view returns (uint256) {
46	 return s.a[account].roots;
47	 }
48	 function balanceOfGrownStalk(address account) public view returns (uint256) {
49	 return stalkReward(s.a[account].s.seeds, season()-lastUpdate(account));
50	 }
51	 function balanceOfFarmableStalk(address account) public view returns (uint256) {
52	 uint256 farmableBeans = balanceOfFarmableBeans(account);
53	 return balanceOfFarmableStalkFromBeans(account, farmableBeans);
54	 }
55	 function balanceOfFarmableBeans(address account) public view returns (uint256) {
56	 if (s.s.roots == 0 || s.si.beans == 0) return 0;
57	 uint256 stalk = totalStalk().sub(s.si.stalk).mul(balanceOfRoots(account)).div(s.s.roots);
58	 if (stalk <= s.a[account].s.stalk) return 0;
59	 uint256 beans = stalk.sub(s.a[account].s.stalk).div(C.getStalkPerBean());
60	 if (beans > s.si.beans) return s.si.beans;
61	 return beans;
62	 }
63	 function balanceOfFarmableSeeds(address account) public view returns (uint256) {
64	 return balanceOfFarmableBeans(account).mul(C.getSeedsPerBean());
65	 }
66	 function balanceOfFarmableStalkFromBeans(address account, uint256 beans) internal view returns (uint256) {
67	 if (beans == 0) return 0;
68	 uint256 seeds = beans.mul(C.getSeedsPerBean());
69	 uint256 stalk = balanceOfGrownFarmableStalk(account, beans);
70	 uint32 _s = uint32(stalk.div(seeds));
71	 if (_s >= season()) _s = season()-1;
72	 uint256 leftoverStalk = stalk.sub(seeds.mul(_s));
73	 if (_s < season()-1) {
74	 uint256 previousSeasonBeans = leftoverStalk.div(C.getSeedsPerBean());
75	 leftoverStalk = leftoverStalk.sub(previousSeasonBeans.mul(C.getSeedsPerBean()));
76	 }
77	 return stalk.sub(leftoverStalk);
78	 }
79	 function balanceOfGrownFarmableStalk(address account, uint256 beans) internal view returns (uint256) {
80	 if (s.s.roots == 0 || s.si.stalk == 0) return 0;
81	 uint256 stalk = balanceOfAllFarmableStalk(account);
82	 uint256 stalkFromBeans = beans.mul(C.getStalkPerBean());
83	 if (stalk <= stalkFromBeans) return 0;
84	 stalk = stalk.sub(stalkFromBeans);
85	 if (stalk > s.si.stalk) return s.si.stalk;
86	 return stalk;
87	 }
88	 function balanceOfAllFarmableStalk(address account) public view returns (uint256) {
89	 uint256 stalk = totalStalk().mul(balanceOfRoots(account)).div(s.s.roots);
90	 if (stalk <= s.a[account].s.stalk) return 0;
91	 return stalk.sub(s.a[account].s.stalk);
92	 }
93	 function lastUpdate(address account) public view returns (uint32) {
94	 return s.a[account].lastUpdate;
95	 }
96	 function lastSeasonOfPlenty() public view returns (uint32) {
97	 return s.sop.last;
98	 }
99	 function seasonsOfPlenty() public view returns (Storage.SeasonOfPlenty memory) {
100	 return s.sop;
101	 }
102	 function balanceOfEth(address account) public view returns (uint256) {
103	 if (s.sop.base == 0) return 0;
104	 return balanceOfPlentyBase(account).mul(s.sop.weth).div(s.sop.base);
105	 }
106	 function balanceOfPlentyBase(address account) public view returns (uint256) {
107	 uint256 plenty = s.a[account].sop.base;
108	 uint32 endSeason = s.a[account].lastSop;
109	 uint256 plentyPerRoot;
110	 uint256 rainSeasonBase = s.sops[s.a[account].lastRain];
111	 if (rainSeasonBase > 0) {
112	 if (endSeason == s.a[account].lastRain) {
113	 plentyPerRoot = rainSeasonBase.sub(s.a[account].sop.basePerRoot);
114	 }
115	 else {
116	 plentyPerRoot = rainSeasonBase.sub(s.sops[endSeason]);
117	 endSeason = s.a[account].lastRain;
118	 }
119	 if (plentyPerRoot > 0) plenty = plenty.add(plentyPerRoot.mul(s.a[account].sop.roots));
120	 }
121	 if (s.sop.last > lastUpdate(account)) {
122	 plentyPerRoot = s.sops[s.sop.last].sub(s.sops[endSeason]);
123	 plenty = plenty.add(plentyPerRoot.mul(balanceOfRoots(account)));
124	 }
125	 return plenty;
126	 }
127	 function balanceOfRainRoots(address account) public view returns (uint256) {
128	 return s.a[account].sop.roots;
129	 }
130	 function lockedUntil(address account) public view returns (uint32) {
131	 if (locked(account)) {
132	 return s.a[account].lockedUntil;
133	 }
134	 return 0;
135	 }
136	 function locked(address account) public view returns (bool) {
137	 if (s.a[account].lockedUntil >= season()) {
138	 for (uint256 i = 0; i < s.g.activeBips.length; i++) {
139	 uint32 activeBip = s.g.activeBips[i];
140	 if (s.g.voted[activeBip][account]) {
141	 return true;
142	 }
143	 }
144	 }
145	 return false;
146	 }
147	 function reserves() internal view returns (uint256, uint256) {
148	 (uint112 reserve0, uint112 reserve1,) = pair().getReserves();
149	 return (index() == 0 ? reserve1 : reserve0,index() == 0 ? reserve0 : reserve1);
150	 }
151	 function lpToLPBeans(uint256 amount) internal view returns (uint256) {
152	 (,uint256 beanReserve) = reserves();
153	 return amount.mul(beanReserve).mul(2).div(pair().totalSupply());
154	 }
155	 function stalkReward(uint256 seeds, uint32 seasons) internal pure returns (uint256) {
156	 return seeds.mul(seasons);
157	 }
158	 function balanceOfMigrationRoots(address account) internal view returns (uint256) {
159	 return balanceOfMigrationStalk(account).mul(C.getRootsBase());
160	 }
161	 function balanceOfMigrationStalk(address account) private view returns (uint256) {
162	 return s.a[account].s.stalk.add(stalkReward(s.a[account].s.seeds, s.bip0Start-lastUpdate(account)));
163	 }
164	 }
165	 pragma solidity ^0.7.6;
166	 contract SiloEntrance is SiloExit {
167	 using SafeMath for uint256;
168	 event BeanDeposit(address indexed account, uint256 season, uint256 beans);
169	 function updateSilo(address account) public payable {
170	 uint256 farmableStalk;
171	 uint32 update = lastUpdate(account);
172	 if (update > 0 && update <= s.bip0Start) update = migrateBip0(account);
173	 if (s.a[account].s.seeds > 0) farmableStalk = balanceOfGrownStalk(account);
174	 if (s.a[account].roots > 0 && update < season()) {
175	 farmSops(account);
176	 farmBeans(account);
177	 }
178	 else if (s.a[account].roots == 0) s.a[account].lastSop = s.r.start;
179	 if (farmableStalk > 0) incrementBalanceOfStalk(account, farmableStalk);
180	 s.a[account].lastUpdate = season();
181	 }
182	 function migrateBip0(address account) private returns (uint32) {
183	 uint32 update = s.bip0Start;
184	 s.a[account].lastUpdate = update;
185	 s.a[account].roots = balanceOfMigrationRoots(account);
186	 delete s.a[account].sop;
187	 delete s.a[account].lastSop;
188	 delete s.a[account].lastRain;
189	 return update;
190	 }
191	 function farmBeans(address account) private {
192	 uint256 beans = balanceOfFarmableBeans(account);
193	 if (beans > 0) {
194	 uint256 stalk = balanceOfGrownFarmableStalk(account, beans);
195	 uint256 seeds = beans.mul(C.getSeedsPerBean());
196	 uint32 _s = uint32(stalk.div(seeds));
197	 if (_s >= season()) _s = season()-1;
198	 uint256 leftoverStalk = stalk.sub(seeds.mul(_s));
199	 _s = season() - _s;
200	 uint256 previousSeasonBeans = 0;
201	 if (_s > 1) {
202	 previousSeasonBeans = leftoverStalk.div(C.getSeedsPerBean());
203	 leftoverStalk = leftoverStalk.sub(previousSeasonBeans.mul(C.getSeedsPerBean()));
204	 }
205	 stalk = stalk.sub(leftoverStalk);
206	 Account.State storage a = s.a[account];
207	 s.si.beans = s.si.beans.sub(beans);
208	 s.si.stalk = s.si.stalk.sub(stalk);
209	 a.s.seeds = a.s.seeds.add(seeds);
210	 a.s.stalk = a.s.stalk.add(beans.mul(C.getStalkPerBean())).add(stalk);
211	 addBeanDeposit(account, _s, beans.sub(previousSeasonBeans));
212	 if (previousSeasonBeans > 0) addBeanDeposit(account, _s-1, previousSeasonBeans);
213	 }
214	 }
215	 function farmSops(address account) internal {
216	 if (s.sop.last > lastUpdate(account) || s.sops[s.a[account].lastRain] > 0) {
217	 s.a[account].sop.base = balanceOfPlentyBase(account);
218	 s.a[account].lastSop = s.sop.last;
219	 }
220	 if (s.r.raining) {
221	 if (s.r.start > lastUpdate(account)) {
222	 s.a[account].lastRain = s.r.start;
223	 s.a[account].sop.roots = s.a[account].roots;
224	 }
225	 if (s.sop.last == s.r.start) s.a[account].sop.basePerRoot = s.sops[s.sop.last];
226	 }
227	 else if (s.a[account].lastRain > 0) {
228	 s.a[account].lastRain = 0;
229	 }
230	 }
231	 function depositSiloAssets(address account, uint256 seeds, uint256 stalk) internal {
232	 incrementBalanceOfStalk(account, stalk);
233	 incrementBalanceOfSeeds(account, seeds);
234	 }
235	 function incrementBalanceOfSeeds(address account, uint256 seeds) internal {
236	 s.s.seeds = s.s.seeds.add(seeds);
237	 s.a[account].s.seeds = s.a[account].s.seeds.add(seeds);
238	 }
239	 function incrementBalanceOfStalk(address account, uint256 stalk) internal {
240	 uint256 roots;
241	 if (s.s.roots == 0) roots = stalk.mul(C.getRootsBase());
242	 else roots = s.s.roots.mul(stalk).div(totalStalk());
243	 s.s.stalk = s.s.stalk.add(stalk);
244	 s.a[account].s.stalk = s.a[account].s.stalk.add(stalk);
245	 s.s.roots = s.s.roots.add(roots);
246	 s.a[account].roots = s.a[account].roots.add(roots);
247	 incrementBipRoots(account, roots);
248	 }
249	 function withdrawSiloAssets(address account, uint256 seeds, uint256 stalk) internal {
250	 decrementBalanceOfStalk(account, stalk);
251	 decrementBalanceOfSeeds(account, seeds);
252	 }
253	 function decrementBalanceOfSeeds(address account, uint256 seeds) internal {
254	 s.s.seeds = s.s.seeds.sub(seeds);
255	 s.a[account].s.seeds = s.a[account].s.seeds.sub(seeds);
256	 }
257	 function decrementBalanceOfStalk(address account, uint256 stalk) internal {
258	 if (stalk == 0) return;
259	 uint256 roots = s.a[account].roots.mul(stalk).sub(1).div(s.a[account].s.stalk).add(1);
260	 s.s.stalk = s.s.stalk.sub(stalk);
261	 s.a[account].s.stalk = s.a[account].s.stalk.sub(stalk);
262	 s.s.roots = s.s.roots.sub(roots);
263	 s.a[account].roots = s.a[account].roots.sub(roots);
264	 }
265	 function addBeanDeposit(address account, uint32 _s, uint256 amount) internal {
266	 s.a[account].bean.deposits[_s] += amount;
267	 emit BeanDeposit(account, _s, amount);
268	 }
269	 function incrementDepositedBeans(uint256 amount) internal {
270	 s.bean.deposited = s.bean.deposited.add(amount);
271	 }
272	 modifier notLocked(address account) {
273	 require(!(locked(account)),"locked");
274	 _;
275	 }
276	 function updateBalanceOfRainStalk(address account) internal {
277	 if (!s.r.raining) return;
278	 if (s.a[account].roots < s.a[account].sop.roots) {
279	 s.r.roots = s.r.roots.sub(s.a[account].sop.roots.sub(s.a[account].roots));
280	 s.a[account].sop.roots = s.a[account].roots;
281	 }
282	 }
283	 function incrementBipRoots(address account, uint256 roots) internal {
284	 if (s.a[account].lockedUntil >= season()) {
285	 for (uint256 i = 0; i < s.g.activeBips.length; i++) {
286	 uint32 bip = s.g.activeBips[i];
287	 if (s.g.voted[bip][account]) s.g.bips[bip].roots = s.g.bips[bip].roots.add(roots);
288	 }
289	 }
290	 }
291	 }
292	 pragma solidity ^0.7.6;
293	 contract LPSilo is SiloEntrance {
294	 struct WithdrawState {
295	 uint256 newLP;
296	 uint256 beansAdded;
297	 uint256 beansTransferred;
298	 uint256 beansRemoved;
299	 uint256 stalkRemoved;
300	 uint256 i;
301	 }
302	 using SafeMath for uint256;
303	 using SafeMath for uint32;
304	 event LPDeposit(address indexed account, uint256 season, uint256 lp, uint256 seeds);
305	 event LPRemove(address indexed account, uint32[] crates, uint256[] crateLP, uint256 lp);
306	 event LPWithdraw(address indexed account, uint256 season, uint256 lp);
307	 function totalDepositedLP() public view returns (uint256) {
308	 return s.lp.deposited;
309	 }
310	 function totalWithdrawnLP() public view returns (uint256) {
311	 return s.lp.withdrawn;
312	 }
313	 function lpDeposit(address account, uint32 id) public view returns (uint256, uint256) {
314	 return (s.a[account].lp.deposits[id], s.a[account].lp.depositSeeds[id]);
315	 }
316	 function lpWithdrawal(address account, uint32 i) public view returns (uint256) {
317	 return s.a[account].lp.withdrawals[i];
318	 }
319	 function _depositLP(uint256 amount, uint32 _s) internal {
320	 updateSilo(msg.sender);
321	 uint256 lpb = lpToLPBeans(amount);
322	 require(lpb > 0, "Silo: No Beans under LP.");
323	 incrementDepositedLP(amount);
324	 uint256 seeds = lpb.mul(C.getSeedsPerLPBean());
325	 if (season() == _s) depositSiloAssets(msg.sender, seeds, lpb.mul(10000));
326	 else depositSiloAssets(msg.sender, seeds, lpb.mul(10000).add(season().sub(_s).mul(seeds)));
327	 addLPDeposit(msg.sender, _s, amount, lpb.mul(C.getSeedsPerLPBean()));
328	 LibCheck.lpBalanceCheck();
329	 }
330	 function _withdrawLP(uint32[] calldata crates, uint256[] calldata amounts) internal {
331	 updateSilo(msg.sender);
332	 require(crates.length == amounts.length, "Silo: Crates, amounts are diff lengths.");
333	 ( uint256 lpRemoved, uint256 stalkRemoved, uint256 seedsRemoved ) = removeLPDeposits(crates, amounts);
334	 uint32 arrivalSeason = season() + C.getSiloWithdrawSeasons();
335	 addLPWithdrawal(msg.sender, arrivalSeason, lpRemoved);
336	 decrementDepositedLP(lpRemoved);
337	 withdrawSiloAssets(msg.sender, seedsRemoved, stalkRemoved);
338	 updateBalanceOfRainStalk(msg.sender);
339	 LibCheck.lpBalanceCheck();
340	 }
341	 function incrementDepositedLP(uint256 amount) private {
342	 s.lp.deposited = s.lp.deposited.add(amount);
343	 }
344	 function decrementDepositedLP(uint256 amount) private {
345	 s.lp.deposited = s.lp.deposited.sub(amount);
346	 }
347	 function addLPDeposit(address account, uint32 _s, uint256 amount, uint256 seeds) private {
348	 s.a[account].lp.deposits[_s] += amount;
349	 s.a[account].lp.depositSeeds[_s] += seeds;
350	 emit LPDeposit(msg.sender, _s, amount, seeds);
351	 }
352	 function removeLPDeposits(uint32[] calldata crates, uint256[] calldata amounts) private returns (uint256 lpRemoved, uint256 stalkRemoved, uint256 seedsRemoved) {
353	 for (uint256 i = 0; i < crates.length; i++) {
354	 (uint256 crateBeans, uint256 crateSeeds) = removeLPDeposit( msg.sender, crates[i], amounts[i] );
355	 lpRemoved = lpRemoved.add(crateBeans);
356	 stalkRemoved = stalkRemoved.add(crateSeeds.mul(C.getStalkPerLPSeed()).add( stalkReward(crateSeeds, season()-crates[i])) );
357	 seedsRemoved = seedsRemoved.add(crateSeeds);
358	 }
359	 emit LPRemove(msg.sender, crates, amounts, lpRemoved);
360	 }
361	 function removeLPDeposit(address account, uint32 id, uint256 amount) private returns (uint256, uint256) {
362	 require(id <= season(), "Silo: Future crate.");
363	 (uint256 crateAmount, uint256 crateBase) = lpDeposit(account, id);
364	 require(crateAmount >= amount, "Silo: Crate balance too low.");
365	 require(crateAmount > 0, "Silo: Crate empty.");
366	 if (amount < crateAmount) {
367	 uint256 base = amount.mul(crateBase).div(crateAmount);
368	 s.a[account].lp.deposits[id] -= amount;
369	 s.a[account].lp.depositSeeds[id] -= base;
370	 return (amount, base);
371	 }
372	 else {
373	 delete s.a[account].lp.deposits[id];
374	 delete s.a[account].lp.depositSeeds[id];
375	 return (crateAmount, crateBase);
376	 }
377	 }
378	 function addLPWithdrawal(address account, uint32 arrivalSeason, uint256 amount) private {
379	 s.a[account].lp.withdrawals[arrivalSeason] = s.a[account].lp.withdrawals[arrivalSeason].add(amount);
380	 s.lp.withdrawn = s.lp.withdrawn.add(amount);
381	 emit LPWithdraw(msg.sender, arrivalSeason, amount);
382	 }
383	 }
384	 pragma solidity ^0.7.6;
385	 contract BeanSilo is LPSilo {
386	 using SafeMath for uint256;
387	 using SafeMath for uint32;
388	 event BeanRemove(address indexed account, uint32[] crates, uint256[] crateBeans, uint256 beans);
389	 event BeanWithdraw(address indexed account, uint256 season, uint256 beans);
390	 function totalDepositedBeans() public view returns (uint256) {
391	 return s.bean.deposited;
392	 }
393	 function totalWithdrawnBeans() public view returns (uint256) {
394	 return s.bean.withdrawn;
395	 }
396	 function beanDeposit(address account, uint32 id) public view returns (uint256) {
397	 return s.a[account].bean.deposits[id];
398	 }
399	 function beanWithdrawal(address account, uint32 i) public view returns (uint256) {
400	 return s.a[account].bean.withdrawals[i];
401	 }
402	 function _depositBeans(uint256 amount) internal {
403	 require(amount > 0, "Silo: No beans.");
404	 updateSilo(msg.sender);
405	 incrementDepositedBeans(amount);
406	 depositSiloAssets(msg.sender, amount.mul(C.getSeedsPerBean()), amount.mul(C.getStalkPerBean()));
407	 addBeanDeposit(msg.sender, season(), amount);
408	 LibCheck.beanBalanceCheck();
409	 }
410	 function _withdrawBeans( uint32[] calldata crates, uint256[] calldata amounts ) internal {
411	 updateSilo(msg.sender);
412	 require(crates.length == amounts.length, "Silo: Crates, amounts are diff lengths.");
413	 (uint256 beansRemoved, uint256 stalkRemoved) = removeBeanDeposits(crates, amounts);
414	 addBeanWithdrawal(msg.sender, season()+C.getSiloWithdrawSeasons(), beansRemoved);
415	 decrementDepositedBeans(beansRemoved);
416	 withdrawSiloAssets(msg.sender, beansRemoved.mul(C.getSeedsPerBean()), stalkRemoved);
417	 updateBalanceOfRainStalk(msg.sender);
418	 LibCheck.beanBalanceCheck();
419	 }
420	 function _withdrawBeansForConvert( uint32[] memory crates, uint256[] memory amounts, uint256 maxBeans ) internal returns (uint256 beansRemoved, uint256 stalkRemoved) {
421	 require(crates.length == amounts.length, "Silo: Crates, amounts are diff lengths.");
422	 uint256 crateBeans;
423	 uint256 i = 0;
424	 while ((i < crates.length) && (beansRemoved < maxBeans)) {
425	 if (beansRemoved.add(amounts[i]) < maxBeans) crateBeans = removeBeanDeposit(msg.sender, crates[i], amounts[i]);
426	 else crateBeans = removeBeanDeposit(msg.sender, crates[i], maxBeans.sub(beansRemoved));
427	 beansRemoved = beansRemoved.add(crateBeans);
428	 stalkRemoved = stalkRemoved.add(crateBeans.mul(C.getStalkPerBean()).add( stalkReward(crateBeans.mul(C.getSeedsPerBean()), season()-crates[i] )));
429	 i++;
430	 }
431	 if (i > 0) amounts[i.sub(1)] = crateBeans;
432	 while (i < crates.length) {
433	 amounts[i] = 0;
434	 i++;
435	 }
436	 decrementDepositedBeans(beansRemoved);
437	 withdrawSiloAssets(msg.sender, beansRemoved.mul(C.getSeedsPerBean()), stalkRemoved);
438	 emit BeanRemove(msg.sender, crates, amounts, beansRemoved);
439	 return (beansRemoved, stalkRemoved);
440	 }
441	 function removeBeanDeposits(uint32[] calldata crates, uint256[] calldata amounts) private returns (uint256 beansRemoved, uint256 stalkRemoved) {
442	 for (uint256 i = 0; i < crates.length; i++) {
443	 uint256 crateBeans = removeBeanDeposit(msg.sender, crates[i], amounts[i]);
444	 beansRemoved = beansRemoved.add(crateBeans);
445	 stalkRemoved = stalkRemoved.add(crateBeans.mul(C.getStalkPerBean()).add( stalkReward(crateBeans.mul(C.getSeedsPerBean()), season()-crates[i])) );
446	 }
447	 emit BeanRemove(msg.sender, crates, amounts, beansRemoved);
448	 }
449	 function decrementDepositedBeans(uint256 amount) private {
450	 s.bean.deposited = s.bean.deposited.sub(amount);
451	 }
452	 function removeBeanDeposit(address account, uint32 id, uint256 amount) private returns (uint256) {
453	 require(id <= season(), "Silo: Future crate.");
454	 uint256 crateAmount = beanDeposit(account, id);
455	 require(crateAmount >= amount, "Silo: Crate balance too low.");
456	 require(crateAmount > 0, "Silo: Crate empty.");
457	 s.a[account].bean.deposits[id] -= amount;
458	 return amount;
459	 }
460	 function addBeanWithdrawal(address account, uint32 arrivalSeason, uint256 amount) private {
461	 s.a[account].bean.withdrawals[arrivalSeason] = s.a[account].bean.withdrawals[arrivalSeason].add(amount);
462	 s.bean.withdrawn = s.bean.withdrawn.add(amount);
463	 emit BeanWithdraw(msg.sender, arrivalSeason, amount);
464	 }
465	 }
466	 pragma solidity >=0.6.0 <0.8.0;
467	 interface IERC20 {
468	 function totalSupply() external view returns (uint256);
469	 function balanceOf(address account) external view returns (uint256);
470	 function transfer(address recipient, uint256 amount) external returns (bool);
471	 function allowance(address owner, address spender) external view returns (uint256);
472	 function approve(address spender, uint256 amount) external returns (bool);
473	 function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
474	 event Transfer(address indexed from, address indexed to, uint256 value);
475	 event Approval(address indexed owner, address indexed spender, uint256 value);
476	 }
477	 pragma solidity >=0.6.2;
478	 interface IUniswapV2Router01 {
479	 function factory() external pure returns (address);
480	 function WETH() external pure returns (address);
481	 function addLiquidity( address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline ) external returns (uint amountA, uint amountB, uint liquidity);
482	 function addLiquidityETH( address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
483	 function removeLiquidity( address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline ) external returns (uint amountA, uint amountB);
484	 function removeLiquidityETH( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) external returns (uint amountToken, uint amountETH);
485	 function removeLiquidityWithPermit( address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s ) external returns (uint amountA, uint amountB);
486	 function removeLiquidityETHWithPermit( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s ) external returns (uint amountToken, uint amountETH);
487	 function swapExactTokensForTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external returns (uint[] memory amounts);
488	 function swapTokensForExactTokens( uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline ) external returns (uint[] memory amounts);
489	 function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);
490	 function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);
491	 function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);
492	 function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);
493	 function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);
494	 function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);
495	 function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);
496	 function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);
497	 function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);
498	 }
499	 pragma solidity ^0.7.6;
500	 contract SiloFacet is BeanSilo {
501	 event BeanAllocation(address indexed account, uint256 beans);
502	 using SafeMath for uint256;
503	 using SafeMath for uint32;
504	 function claimAndDepositBeans(uint256 amount, LibClaim.Claim calldata claim) external {
505	 allocateBeans(claim, amount);
506	 _depositBeans(amount);
507	 }
508	 function claimBuyAndDepositBeans( uint256 amount, uint256 buyAmount, LibClaim.Claim calldata claim ) external payable {
509	 allocateBeans(claim, amount);
510	 uint256 boughtAmount = LibMarket.buyAndDeposit(buyAmount);
511	 _depositBeans(boughtAmount.add(amount));
512	 }
513	 function depositBeans(uint256 amount) public {
514	 bean().transferFrom(msg.sender, address(this), amount);
515	 _depositBeans(amount);
516	 }
517	 function buyAndDepositBeans(uint256 amount, uint256 buyAmount) public payable {
518	 uint256 boughtAmount = LibMarket.buyAndDeposit(buyAmount);
519	 if (amount > 0) bean().transferFrom(msg.sender, address(this), amount);
520	 _depositBeans(boughtAmount.add(amount));
521	 }
522	 function withdrawBeans( uint32[] calldata crates, uint256[] calldata amounts ) notLocked(msg.sender) external {
523	 _withdrawBeans(crates, amounts);
524	 }
525	 function claimAndWithdrawBeans( uint32[] calldata crates, uint256[] calldata amounts, LibClaim.Claim calldata claim ) notLocked(msg.sender) external {
526	 LibClaim.claim(claim, false);
527	 _withdrawBeans(crates, amounts);
528	 }
529	 function claimAndDepositLP(uint256 amount, LibClaim.Claim calldata claim) external {
530	 LibClaim.claim(claim, false);
531	 depositLP(amount);
532	 }
533	 function claimAddAndDepositLP( uint256 lp, uint256 buyBeanAmount, uint256 buyEthAmount, LibMarket.AddLiquidity calldata al, LibClaim.Claim calldata claim ) external payable {
534	 uint256 allocatedBeans = LibClaim.claim(claim, true);
535	 _addAndDepositLP(lp, buyBeanAmount, buyEthAmount, allocatedBeans, al);
536	 }
537	 function depositLP(uint256 amount) public {
538	 pair().transferFrom(msg.sender, address(this), amount);
539	 _depositLP(amount, season());
540	 }
541	 function addAndDepositLP(uint256 lp, uint256 buyBeanAmount, uint256 buyEthAmount, LibMarket.AddLiquidity calldata al ) public payable {
542	 require(buyBeanAmount == 0 || buyEthAmount == 0, "Silo: Silo: Cant buy Ether and Beans.");
543	 _addAndDepositLP(lp, buyBeanAmount, buyEthAmount, 0, al);
544	 }
545	 function _addAndDepositLP(uint256 lp, uint256 buyBeanAmount, uint256 buyEthAmount, uint256 allocatedBeans, LibMarket.AddLiquidity calldata al ) internal {
546	 uint256 boughtLP = LibMarket.swapAndAddLiquidity(buyBeanAmount, buyEthAmount, allocatedBeans, al);
547	 if (lp>0) pair().transferFrom(msg.sender, address(this), lp);
548	 _depositLP(lp.add(boughtLP), season());
549	 }
550	 function claimConvertAddAndDepositLP( uint256 lp, LibMarket.AddLiquidity calldata al, uint32[] memory crates, uint256[] memory amounts, LibClaim.Claim calldata claim ) external payable {
551	 _convertAddAndDepositLP(lp, al, crates, amounts, LibClaim.claim(claim, true));
552	 }
553	 function convertAddAndDepositLP( uint256 lp, LibMarket.AddLiquidity calldata al, uint32[] memory crates, uint256[] memory amounts ) public payable {
554	 _convertAddAndDepositLP(lp, al, crates, amounts, 0);
555	 }
556	 function _convertAddAndDepositLP( uint256 lp, LibMarket.AddLiquidity calldata al, uint32[] memory crates, uint256[] memory amounts, uint256 allocatedBeans ) private {
557	 updateSilo(msg.sender);
558	 WithdrawState memory w;
559	 if (IBean(s.c.bean).balanceOf(address(this)) < al.beanAmount) {
560	 w.beansTransferred = al.beanAmount.sub(totalDepositedBeans());
561	 bean().transferFrom(msg.sender, address(this), w.beansTransferred);
562	 }
563	 (w.beansAdded, w.newLP) = LibMarket.addLiquidity(al);
564	 require(w.newLP > 0, "Silo: No LP added.");
565	 (w.beansRemoved, w.stalkRemoved) = _withdrawBeansForConvert(crates, amounts, w.beansAdded);
566	 uint256 amountFromWallet = w.beansAdded.sub(w.beansRemoved, "Silo: Removed too many Beans.");
567	 if (amountFromWallet < w.beansTransferred) bean().transfer(msg.sender, w.beansTransferred.sub(amountFromWallet).add(allocatedBeans));
568	 else if (w.beansTransferred < amountFromWallet) {
569	 uint256 transferAmount = amountFromWallet.sub(w.beansTransferred);
570	 LibMarket.transferAllocatedBeans(allocatedBeans, transferAmount);
571	 }
572	 w.i = w.stalkRemoved.sub(w.beansRemoved.mul(C.getStalkPerBean()));
573	 w.i = w.i.div(lpToLPBeans(lp.add(w.newLP)), "Silo: No LP Beans.");
574	 uint32 depositSeason = uint32(season().sub(w.i.div(C.getSeedsPerLPBean())));
575	 if (lp > 0) pair().transferFrom(msg.sender, address(this), lp);
576	 _depositLP(lp.add(w.newLP), depositSeason);
577	 LibCheck.beanBalanceCheck();
578	 updateBalanceOfRainStalk(msg.sender);
579	 }
580	 function claimAndWithdrawLP( uint32[] calldata crates, uint256[] calldata amounts, LibClaim.Claim calldata claim ) notLocked(msg.sender) external {
581	 LibClaim.claim(claim, false);
582	 _withdrawLP(crates, amounts);
583	 }
584	 function withdrawLP( uint32[] calldata crates, uint256[] calldata amounts ) notLocked(msg.sender) external {
585	 _withdrawLP(crates, amounts);
586	 }
587	 function allocateBeans(LibClaim.Claim calldata c, uint256 transferBeans) private {
588	 LibMarket.transferAllocatedBeans(LibClaim.claim(c, true), transferBeans);
589	 }
590	 }
591	 pragma solidity ^0.7.6;
592	 library LibClaim {
593	 using SafeMath for uint256;
594	 using SafeMath for uint32;
595	 event BeanClaim(address indexed account, uint32[] withdrawals, uint256 beans);
596	 event LPClaim(address indexed account, uint32[] withdrawals, uint256 lp);
597	 event EtherClaim(address indexed account, uint256 ethereum);
598	 event Harvest(address indexed account, uint256[] plots, uint256 beans);
599	 struct Claim {
600	 uint32[] beanWithdrawals;
601	 uint32[] lpWithdrawals;
602	 uint256[] plots;
603	 bool claimEth;
604	 bool convertLP;
605	 uint256 minBeanAmount;
606	 uint256 minEthAmount;
607	 }
608	 function claim(Claim calldata c, bool allocate) public returns (uint256 beansClaimed) {
609	 AppStorage storage s = LibAppStorage.diamondStorage();
610	 if (c.beanWithdrawals.length > 0) beansClaimed = beansClaimed.add(claimBeans(c.beanWithdrawals));
611	 if (c.plots.length > 0) beansClaimed = beansClaimed.add(harvest(c.plots));
612	 if (c.lpWithdrawals.length > 0) {
613	 if (c.convertLP) {
614	 if (allocate) beansClaimed = beansClaimed.add(removeAllocationAndClaimLP(c.lpWithdrawals, c.minBeanAmount, c.minEthAmount));
615	 else removeAndClaimLP(c.lpWithdrawals, c.minBeanAmount, c.minEthAmount);
616	 }
617	 else claimLP(c.lpWithdrawals);
618	 }
619	 if (c.claimEth) claimEth();
620	 if (!allocate) IBean(s.c.bean).transfer(msg.sender, beansClaimed);
621	 }
622	 function claimBeans(uint32[] calldata withdrawals) public returns (uint256 beansClaimed) {
623	 AppStorage storage s = LibAppStorage.diamondStorage();
624	 for (uint256 i = 0; i < withdrawals.length; i++) {
625	 require(withdrawals[i] <= s.season.current, "Claim: Withdrawal not recievable.");
626	 beansClaimed = beansClaimed.add(claimBeanWithdrawal(msg.sender, withdrawals[i]));
627	 }
628	 emit BeanClaim(msg.sender, withdrawals, beansClaimed);
629	 }
630	 function claimBeanWithdrawal(address account, uint32 _s) private returns (uint256) {
631	 AppStorage storage s = LibAppStorage.diamondStorage();
632	 uint256 amount = s.a[account].bean.withdrawals[_s];
633	 require(amount > 0, "Claim: Bean withdrawal is empty.");
634	 delete s.a[account].bean.withdrawals[_s];
635	 s.bean.withdrawn = s.bean.withdrawn.sub(amount);
636	 return amount;
637	 }
638	 function claimLP(uint32[] calldata withdrawals) public {
639	 AppStorage storage s = LibAppStorage.diamondStorage();
640	 uint256 lpClaimed = _claimLP(withdrawals);
641	 IUniswapV2Pair(s.c.pair).transfer(msg.sender, lpClaimed);
642	 }
643	 function removeAndClaimLP( uint32[] calldata withdrawals, uint256 minBeanAmount, uint256 minEthAmount ) public {
644	 uint256 lpClaimd = _claimLP(withdrawals);
645	 LibMarket.removeLiquidity(lpClaimd, minBeanAmount, minEthAmount);
646	 }
647	 function removeAllocationAndClaimLP( uint32[] calldata withdrawals, uint256 minBeanAmount, uint256 minEthAmount ) private returns (uint256 beans) {
648	 uint256 lpClaimd = _claimLP(withdrawals);
649	 (beans,) = LibMarket.removeLiquidityWithBeanAllocation(lpClaimd, minBeanAmount, minEthAmount);
650	 }
651	 function _claimLP(uint32[] calldata withdrawals) private returns (uint256) {
652	 AppStorage storage s = LibAppStorage.diamondStorage();
653	 uint256 lpClaimd = 0;
654	 for(uint256 i = 0; i < withdrawals.length; i++) {
655	 require(withdrawals[i] <= s.season.current, "Claim: Withdrawal not recievable.");
656	 lpClaimd = lpClaimd.add(claimLPWithdrawal(msg.sender, withdrawals[i]));
657	 }
658	 emit LPClaim(msg.sender, withdrawals, lpClaimd);
659	 return lpClaimd;
660	 }
661	 function claimLPWithdrawal(address account, uint32 _s) private returns (uint256) {
662	 AppStorage storage s = LibAppStorage.diamondStorage();
663	 uint256 amount = s.a[account].lp.withdrawals[_s];
664	 require(amount > 0, "Claim: LP withdrawal is empty.");
665	 delete s.a[account].lp.withdrawals[_s];
666	 s.lp.withdrawn = s.lp.withdrawn.sub(amount);
667	 return amount;
668	 }
669	 function claimEth() public {
670	 LibInternal.updateSilo(msg.sender);
671	 uint256 eth = claimPlenty(msg.sender);
672	 emit EtherClaim(msg.sender, eth);
673	 }
674	 function claimPlenty(address account) private returns (uint256) {
675	 AppStorage storage s = LibAppStorage.diamondStorage();
676	 if (s.sop.base == 0) return 0;
677	 uint256 eth = s.a[account].sop.base.mul(s.sop.weth).div(s.sop.base);
678	 s.sop.weth = s.sop.weth.sub(eth);
679	 s.sop.base = s.sop.base.sub(s.a[account].sop.base);
680	 s.a[account].sop.base = 0;
681	 IWETH(s.c.weth).withdraw(eth);
682	 (bool success, ) = account.call{
683	 value: eth}
684	 ("");
685	 require(success, "WETH: ETH transfer failed");
686	 return eth;
687	 }
688	 function harvest(uint256[] calldata plots) public returns (uint256 beansHarvested) {
689	 AppStorage storage s = LibAppStorage.diamondStorage();
690	 for (uint256 i = 0; i < plots.length; i++) {
691	 require(plots[i] < s.f.harvestable, "Claim: Plot not harvestable.");
692	 require(s.a[msg.sender].field.plots[plots[i]] > 0, "Claim: Plot not harvestable.");
693	 uint256 harvested = harvestPlot(msg.sender, plots[i]);
694	 beansHarvested = beansHarvested.add(harvested);
695	 }
696	 require(s.f.harvestable.sub(s.f.harvested) >= beansHarvested, "Claim: Not enough Harvestable.");
697	 s.f.harvested = s.f.harvested.add(beansHarvested);
698	 emit Harvest(msg.sender, plots, beansHarvested);
699	 }
700	 function harvestPlot(address account, uint256 plotId) private returns (uint256) {
701	 AppStorage storage s = LibAppStorage.diamondStorage();
702	 uint256 pods = s.a[account].field.plots[plotId];
703	 require(pods > 0, "Claim: Plot is empty.");
704	 uint256 harvestablePods = s.f.harvestable.sub(plotId);
705	 delete s.a[account].field.plots[plotId];
706	 if (harvestablePods >= pods) return pods;
707	 s.a[account].field.plots[plotId.add(harvestablePods)] = pods.sub(harvestablePods);
708	 return harvestablePods;
709	 }
710	 }
711	 pragma solidity ^0.7.6;
712	 library LibCheck {
713	 using SafeMath for uint256;
714	 function beanBalanceCheck() internal view {
715	 AppStorage storage s = LibAppStorage.diamondStorage();
716	 require( IBean(s.c.bean).balanceOf(address(this)) >= s.f.harvestable.sub(s.f.harvested).add(s.bean.deposited).add(s.bean.withdrawn), "Check: Bean balance fail." );
717	 }
718	 function lpBalanceCheck() internal view {
719	 AppStorage storage s = LibAppStorage.diamondStorage();
720	 require( IUniswapV2Pair(s.c.pair).balanceOf(address(this)) >= s.lp.deposited.add(s.lp.withdrawn), "Check: LP balance fail." );
721	 }
722	 function balanceCheck() internal view {
723	 AppStorage storage s = LibAppStorage.diamondStorage();
724	 require( IBean(s.c.bean).balanceOf(address(this)) >= s.f.harvestable.sub(s.f.harvested).add(s.bean.deposited).add(s.bean.withdrawn), "Check: Bean balance fail." );
725	 require( IUniswapV2Pair(s.c.pair).balanceOf(address(this)) >= s.lp.deposited.add(s.lp.withdrawn), "Check: LP balance fail." );
726	 }
727	 }
728	 pragma solidity ^0.7.6;
729	 library LibInternal {
730	 bytes32 constant DIAMOND_STORAGE_POSITION = keccak256("diamond.standard.diamond.storage");
731	 struct FacetAddressAndPosition {
732	 address facetAddress;
733	 uint16 functionSelectorPosition;
734	 }
735	 struct FacetFunctionSelectors {
736	 bytes4[] functionSelectors;
737	 uint16 facetAddressPosition;
738	 }
739	 struct DiamondStorage {
740	 mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;
741	 mapping(address => FacetFunctionSelectors) facetFunctionSelectors;
742	 address[] facetAddresses;
743	 mapping(bytes4 => bool) supportedInterfaces;
744	 address contractOwner;
745	 }
746	 function diamondStorage() internal pure returns (DiamondStorage storage ds) {
747	 bytes32 position = DIAMOND_STORAGE_POSITION;
748	 assembly {
749	 ds.slot := position }
750	 }
751	 struct Claim {
752	 uint32[] beanWithdrawals;
753	 uint32[] lpWithdrawals;
754	 uint256[] plots;
755	 bool claimEth;
756	 bool convertLP;
757	 uint256 minBeanAmount;
758	 uint256 minEthAmount;
759	 }
760	 function updateSilo(address account) internal {
761	 DiamondStorage storage ds = diamondStorage();
762	 bytes4 functionSelector = bytes4(keccak256("updateSilo(address)"));
763	 address facet = ds.selectorToFacetAndPosition[functionSelector].facetAddress;
764	 bytes memory myFunctionCall = abi.encodeWithSelector(functionSelector, account);
765	 (bool success,) = address(facet).delegatecall(myFunctionCall);
766	 require(success, "Silo: updateSilo failed.");
767	 }
768	 function updateBip(uint32 bip) internal {
769	 DiamondStorage storage ds = diamondStorage();
770	 bytes4 functionSelector = bytes4(keccak256("updateBip(uint32)"));
771	 address facet = ds.selectorToFacetAndPosition[functionSelector].facetAddress;
772	 bytes memory myFunctionCall = abi.encodeWithSelector(functionSelector, bip);
773	 (bool success,) = address(facet).delegatecall(myFunctionCall);
774	 require(success, "Silo: updateBip failed.");
775	 }
776	 function stalkFor(uint32 bip) internal returns (uint256 stalk) {
777	 DiamondStorage storage ds = diamondStorage();
778	 bytes4 functionSelector = bytes4(keccak256("stalkFor(uint32)"));
779	 address facet = ds.selectorToFacetAndPosition[functionSelector].facetAddress;
780	 bytes memory myFunctionCall = abi.encodeWithSelector(functionSelector, bip);
781	 (bool success, bytes memory data) = address(facet).delegatecall(myFunctionCall);
782	 require(success, "Governance: stalkFor failed.");
783	 assembly {
784	 stalk := mload(add(data, add(0x20, 0))) }
785	 }
786	 }
787	 pragma solidity ^0.7.6;
788	 library LibMarket {
789	 event BeanAllocation(address indexed account, uint256 beans);
790	 struct DiamondStorage {
791	 address bean;
792	 address weth;
793	 address router;
794	 }
795	 struct AddLiquidity {
796	 uint256 beanAmount;
797	 uint256 minBeanAmount;
798	 uint256 minEthAmount;
799	 }
800	 using SafeMath for uint256;
801	 bytes32 private constant MARKET_STORAGE_POSITION = keccak256("diamond.standard.market.storage");
802	 function diamondStorage() internal pure returns (DiamondStorage storage ds) {
803	 bytes32 position = MARKET_STORAGE_POSITION;
804	 assembly {
805	 ds.slot := position }
806	 }
807	 function initMarket(address bean, address weth, address router) internal {
808	 DiamondStorage storage ds = diamondStorage();
809	 ds.bean = bean;
810	 ds.weth = weth;
811	 ds.router = router;
812	 }
813	 function buy(uint256 buyBeanAmount) internal returns (uint256 amount) {
814	 (uint256 ethAmount, uint256 beanAmount) = _buy(buyBeanAmount, msg.value, msg.sender);
815	 (bool success,) = msg.sender.call{
816	 value: msg.value.sub(ethAmount) }
817	 ("");
818	 require(success, "Market: Refund failed.");
819	 return beanAmount;
820	 }
821	 function buyAndDeposit(uint256 buyBeanAmount) internal returns (uint256 amount) {
822	 (uint256 ethAmount, uint256 beanAmount) = _buy(buyBeanAmount, msg.value, address(this));
823	 (bool success,) = msg.sender.call{
824	 value: msg.value.sub(ethAmount) }
825	 ("");
826	 require(success, "Market: Refund failed.");
827	 return beanAmount;
828	 }
829	 function sellToWETH(uint256 sellBeanAmount, uint256 minBuyEthAmount) internal returns (uint256 amount) {
830	 (,uint256 outAmount) = _sell(sellBeanAmount, minBuyEthAmount, address(this));
831	 return outAmount;
832	 }
833	 function addLiquidity(AddLiquidity calldata al) internal returns (uint256, uint256) {
834	 (uint256 beansDeposited, uint256 ethDeposited, uint256 liquidity) = _addLiquidity( msg.value, al.beanAmount, al.minEthAmount, al.minBeanAmount );
835	 (bool success,) = msg.sender.call{
836	 value: msg.value.sub(ethDeposited) }
837	 ("");
838	 require(success, "Market: Refund failed.");
839	 return (beansDeposited, liquidity);
840	 }
841	 function removeLiquidity(uint256 liqudity, uint256 minBeanAmount,uint256 minEthAmount) internal returns (uint256 beanAmount, uint256 ethAmount) {
842	 DiamondStorage storage ds = diamondStorage();
843	 return IUniswapV2Router02(ds.router).removeLiquidityETH( ds.bean, liqudity, minBeanAmount, minEthAmount, msg.sender, block.timestamp.add(1) );
844	 }
845	 function removeLiquidityWithBeanAllocation(uint256 liqudity, uint256 minBeanAmount,uint256 minEthAmount) internal returns (uint256 beanAmount, uint256 ethAmount) {
846	 DiamondStorage storage ds = diamondStorage();
847	 (beanAmount, ethAmount) = IUniswapV2Router02(ds.router).removeLiquidity( ds.bean, ds.weth, liqudity, minBeanAmount, minEthAmount, address(this), block.timestamp.add(1) );
848	 IWETH(ds.weth).withdraw(ethAmount);
849	 (bool success, ) = msg.sender.call{
850	 value: ethAmount}
851	 ("");
852	 require(success, "WETH: ETH transfer failed");
853	 }
854	 function addAndDepositLiquidity(uint256 allocatedBeans, AddLiquidity calldata al) internal returns (uint256) {
855	 DiamondStorage storage ds = diamondStorage();
856	 transferAllocatedBeans(allocatedBeans, al.beanAmount);
857	 (uint256 beans, uint256 liquidity) = addLiquidity(al);
858	 if (al.beanAmount > beans) IBean(ds.bean).transfer(msg.sender, al.beanAmount.sub(beans));
859	 return liquidity;
860	 }
861	 function swapAndAddLiquidity( uint256 buyBeanAmount, uint256 buyEthAmount, uint256 allocatedBeans, LibMarket.AddLiquidity calldata al ) internal returns (uint256) {
862	 uint256 boughtLP;
863	 if (buyBeanAmount > 0) boughtLP = LibMarket.buyBeansAndAddLiquidity(buyBeanAmount, allocatedBeans, al);
864	 else if (buyEthAmount > 0) boughtLP = LibMarket.buyEthAndAddLiquidity(buyEthAmount, allocatedBeans, al);
865	 else boughtLP = LibMarket.addAndDepositLiquidity(allocatedBeans, al);
866	 return boughtLP;
867	 }
868	 function buyBeansAndAddLiquidity(uint256 buyBeanAmount, uint256 allocatedBeans, AddLiquidity calldata al) internal returns (uint256) {
869	 DiamondStorage storage ds = diamondStorage();
870	 IWETH(ds.weth).deposit{
871	 value: msg.value}
872	 ();
873	 address[] memory path = new address[](2);
874	 path[0] = ds.weth;
875	 path[1] = ds.bean;
876	 uint256[] memory amounts = IUniswapV2Router02(ds.router).getAmountsIn(buyBeanAmount, path);
877	 (uint256 ethSold, uint256 beans) = _buyWithWETH(buyBeanAmount, amounts[0], address(this));
878	 if (al.beanAmount > buyBeanAmount) {
879	 transferAllocatedBeans(allocatedBeans, al.beanAmount.sub(buyBeanAmount));
880	 beans = beans.add(al.beanAmount.sub(buyBeanAmount));
881	 }
882	 else if (allocatedBeans > 0) {
883	 IBean(ds.bean).transfer(msg.sender, allocatedBeans);
884	 }
885	 uint256 liquidity;
886	 uint256 ethAdded;
887	 (beans, ethAdded, liquidity) = _addLiquidityWETH( msg.value.sub(ethSold), beans, al.minEthAmount, al.minBeanAmount );
888	 if (al.beanAmount > beans) IBean(ds.bean).transfer(msg.sender, al.beanAmount.sub(beans));
889	 if (msg.value > ethAdded.add(ethSold)) {
890	 uint256 returnETH = msg.value.sub(ethAdded).sub(ethSold);
891	 IWETH(ds.weth).withdraw(returnETH);
892	 (bool success,) = msg.sender.call{
893	 value: returnETH }
894	 ("");
895	 require(success, "Market: Refund failed.");
896	 }
897	 return liquidity;
898	 }
899	 function buyEthAndAddLiquidity(uint256 buyWethAmount, uint256 allocatedBeans, AddLiquidity calldata al) internal returns (uint256) {
900	 DiamondStorage storage ds = diamondStorage();
901	 uint256 sellBeans = _amountIn(buyWethAmount);
902	 transferAllocatedBeans(allocatedBeans, al.beanAmount.add(sellBeans));
903	 (uint256 beansSold, uint256 wethBought) = _sell(sellBeans, buyWethAmount, address(this));
904	 if (msg.value > 0) IWETH(ds.weth).deposit{
905	 value: msg.value}
906	 ();
907	 (uint256 beans, uint256 ethAdded, uint256 liquidity) = _addLiquidityWETH( msg.value.add(wethBought), al.beanAmount, al.minEthAmount, al.minBeanAmount );
908	 if (al.beanAmount.add(sellBeans) > beans.add(beansSold)) IBean(ds.bean).transfer( msg.sender, al.beanAmount.add(sellBeans).sub(beans.add(beansSold)) );
909	 if (ethAdded < wethBought.add(msg.value)) {
910	 uint256 eth = wethBought.add(msg.value).sub(ethAdded);
911	 IWETH(ds.weth).withdraw(eth);
912	 (bool success, ) = msg.sender.call{
913	 value: eth}
914	 ("");
915	 require(success, "Market: Ether transfer failed.");
916	 }
917	 return liquidity;
918	 }
919	 function _sell(uint256 sellBeanAmount, uint256 minBuyEthAmount, address to) private returns (uint256 inAmount, uint256 outAmount) {
920	 DiamondStorage storage ds = diamondStorage();
921	 address[] memory path = new address[](2);
922	 path[0] = ds.bean;
923	 path[1] = ds.weth;
924	 uint[] memory amounts = IUniswapV2Router02(ds.router).swapExactTokensForTokens( sellBeanAmount, minBuyEthAmount, path, to, block.timestamp.add(1) );
925	 return (amounts[0], amounts[1]);
926	 }
927	 function _buy(uint256 beanAmount, uint256 ethAmount, address to) private returns (uint256 inAmount, uint256 outAmount) {
928	 DiamondStorage storage ds = diamondStorage();
929	 address[] memory path = new address[](2);
930	 path[0] = ds.weth;
931	 path[1] = ds.bean;
932	 uint[] memory amounts = IUniswapV2Router02(ds.router).swapExactETHForTokens{
933	 value: ethAmount}
934	 ( beanAmount, path, to, block.timestamp.add(1) );
935	 return (amounts[0], amounts[1]);
936	 }
937	 function _buyWithWETH(uint256 beanAmount, uint256 ethAmount, address to) private returns (uint256 inAmount, uint256 outAmount) {
938	 DiamondStorage storage ds = diamondStorage();
939	 address[] memory path = new address[](2);
940	 path[0] = ds.weth;
941	 path[1] = ds.bean;
942	 uint[] memory amounts = IUniswapV2Router02(ds.router).swapExactTokensForTokens( ethAmount, beanAmount, path, to, block.timestamp.add(1) );
943	 return (amounts[0], amounts[1]);
944	 }
945	 function _addLiquidity(uint256 ethAmount, uint256 beanAmount, uint256 minEthAmount, uint256 minBeanAmount) private returns (uint256, uint256, uint256) {
946	 DiamondStorage storage ds = diamondStorage();
947	 return IUniswapV2Router02(ds.router).addLiquidityETH{
948	 value: ethAmount}
949	 ( ds.bean, beanAmount, minBeanAmount, minEthAmount, address(this), block.timestamp.add(1));
950	 }
951	 function _addLiquidityWETH(uint256 wethAmount, uint256 beanAmount, uint256 minWethAmount, uint256 minBeanAmount) private returns (uint256, uint256, uint256) {
952	 DiamondStorage storage ds = diamondStorage();
953	 return IUniswapV2Router02(ds.router).addLiquidity( ds.bean, ds.weth, beanAmount, wethAmount, minBeanAmount, minWethAmount, address(this), block.timestamp.add(1));
954	 }
955	 function _amountIn(uint256 buyWethAmount) internal view returns (uint256) {
956	 DiamondStorage storage ds = diamondStorage();
957	 address[] memory path = new address[](2);
958	 path[0] = ds.bean;
959	 path[1] = ds.weth;
960	 uint256[] memory amounts = IUniswapV2Router02(ds.router).getAmountsIn(buyWethAmount, path);
961	 return amounts[0];
962	 }
963	 function transferAllocatedBeans(uint256 allocatedBeans, uint256 transferBeans) internal {
964	 DiamondStorage storage ds = diamondStorage();
965	 if (allocatedBeans == 0) {
966	 IBean(ds.bean).transferFrom(msg.sender, address(this), transferBeans);
967	 }
968	 else if (allocatedBeans >= transferBeans) {
969	 emit BeanAllocation(msg.sender, transferBeans);
970	 if (allocatedBeans > transferBeans) IBean(ds.bean).transfer(msg.sender, allocatedBeans.sub(transferBeans));
971	 }
972	 else {
973	 emit BeanAllocation(msg.sender, allocatedBeans);
974	 IBean(ds.bean).transferFrom(msg.sender, address(this), transferBeans.sub(allocatedBeans));
975	 }
976	 }
977	 }
978	 pragma solidity >=0.6.0 <0.8.0;
979	 library SafeMath {
980	 function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
981	 uint256 c = a + b;
982	 if (c < a) return (false, 0);
983	 return (true, c);
984	 }
985	 function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
986	 if (b > a) return (false, 0);
987	 return (true, a - b);
988	 }
989	 function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
990	 if (a == 0) return (true, 0);
991	 uint256 c = a * b;
992	 if (c / a != b) return (false, 0);
993	 return (true, c);
994	 }
995	 function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
996	 if (b == 0) return (false, 0);
997	 return (true, a / b);
998	 }
999	 function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
1000	 if (b == 0) return (false, 0);
1001	 return (true, a % b);
1002	 }
1003	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
1004	 uint256 c = a + b;
1005	 require(c >= a, "SafeMath: addition overflow");
1006	 return c;
1007	 }
1008	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
1009	 require(b <= a, "SafeMath: subtraction overflow");
1010	 return a - b;
1011	 }
1012	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
1013	 if (a == 0) return 0;
1014	 uint256 c = a * b;
1015	 require(c / a == b, "SafeMath: multiplication overflow");
1016	 return c;
1017	 }
1018	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
1019	 require(b > 0, "SafeMath: division by zero");
1020	 return a / b;
1021	 }
1022	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
1023	 require(b > 0, "SafeMath: modulo by zero");
1024	 return a % b;
1025	 }
1026	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
1027	 require(b <= a, errorMessage);
1028	 return a - b;
1029	 }
1030	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
1031	 require(b > 0, errorMessage);
1032	 return a / b;
1033	 }
1034	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
1035	 require(b > 0, errorMessage);
1036	 return a % b;
1037	 }
1038	 }
1039	 pragma solidity >=0.5.0;
1040	 interface IUniswapV2Pair {
1041	 event Approval(address indexed owner, address indexed spender, uint value);
1042	 event Transfer(address indexed from, address indexed to, uint value);
1043	 function name() external pure returns (string memory);
1044	 function symbol() external pure returns (string memory);
1045	 function decimals() external pure returns (uint8);
1046	 function totalSupply() external view returns (uint);
1047	 function balanceOf(address owner) external view returns (uint);
1048	 function allowance(address owner, address spender) external view returns (uint);
1049	 function approve(address spender, uint value) external returns (bool);
1050	 function transfer(address to, uint value) external returns (bool);
1051	 function transferFrom(address from, address to, uint value) external returns (bool);
1052	 function DOMAIN_SEPARATOR() external view returns (bytes32);
1053	 function PERMIT_TYPEHASH() external pure returns (bytes32);
1054	 function nonces(address owner) external view returns (uint);
1055	 function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;
1056	 event Mint(address indexed sender, uint amount0, uint amount1);
1057	 event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
1058	 event Swap( address indexed sender, uint amount0In, uint amount1In, uint amount0Out, uint amount1Out, address indexed to );
1059	 event Sync(uint112 reserve0, uint112 reserve1);
1060	 function MINIMUM_LIQUIDITY() external pure returns (uint);
1061	 function factory() external view returns (address);
1062	 function token0() external view returns (address);
1063	 function token1() external view returns (address);
1064	 function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
1065	 function price0CumulativeLast() external view returns (uint);
1066	 function price1CumulativeLast() external view returns (uint);
1067	 function kLast() external view returns (uint);
1068	 function mint(address to) external returns (uint liquidity);
1069	 function burn(address to) external returns (uint amount0, uint amount1);
1070	 function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
1071	 function skim(address to) external;
1072	 function sync() external;
1073	 function initialize(address, address) external;
1074	 }
1075	 pragma solidity ^0.7.6;
1076	 library C {
1077	 using Decimal for Decimal.D256;
1078	 using SafeMath for uint256;
1079	 uint256 private constant CHAIN_ID = 1;
1080	 uint256 private constant CURRENT_SEASON_PERIOD = 3600;
1081	 uint256 private constant HARVESET_PERCENTAGE = 5e17;
1082	 uint256 private constant POD_RATE_LOWER_BOUND = 5e16;
1083	 uint256 private constant OPTIMAL_POD_RATE = 15e16;
1084	 uint256 private constant POD_RATE_UPPER_BOUND = 25e16;
1085	 uint256 private constant DELTA_POD_DEMAND_LOWER_BOUND = 95e16;
1086	 uint256 private constant DELTA_POD_DEMAND_UPPER_BOUND = 105e16;
1087	 uint256 private constant STEADY_SOW_TIME = 60;
1088	 uint256 private constant RAIN_TIME = 24;
1089	 uint32 private constant GOVERNANCE_PERIOD = 168;
1090	 uint32 private constant GOVERNANCE_EMERGENCY_PERIOD = 86400;
1091	 uint256 private constant GOVERNANCE_PASS_THRESHOLD = 5e17;
1092	 uint256 private constant GOVERNANCE_EMERGENCY_THRESHOLD_NUMERATOR = 2;
1093	 uint256 private constant GOVERNANCE_EMERGENCY_THRESHOLD_DEMONINATOR = 3;
1094	 uint32 private constant GOVERNANCE_EXPIRATION = 24;
1095	 uint256 private constant GOVERNANCE_PROPOSAL_THRESHOLD = 1e15;
1096	 uint256 private constant BASE_COMMIT_INCENTIVE = 1e8;
1097	 uint256 private constant MAX_PROPOSITIONS = 5;
1098	 uint256 private constant BASE_ADVANCE_INCENTIVE = 1e8;
1099	 uint32 private constant WITHDRAW_TIME = 0;
1100	 uint256 private constant SEEDS_PER_BEAN = 2;
1101	 uint256 private constant SEEDS_PER_LP_BEAN = 4;
1102	 uint256 private constant STALK_PER_BEAN = 10000;
1103	 uint256 private constant ROOTS_BASE = 1e12;
1104	 uint256 private constant SOIL_MAX_RATIO_CAP = 25e16;
1105	 uint256 private constant SOIL_MIN_RATIO_CAP = 1e15;
1106	 function getSeasonPeriod() internal pure returns (uint256) {
1107	 return CURRENT_SEASON_PERIOD;
1108	 }
1109	 function getGovernancePeriod() internal pure returns (uint32) {
1110	 return GOVERNANCE_PERIOD;
1111	 }
1112	 function getGovernanceEmergencyPeriod() internal pure returns (uint32) {
1113	 return GOVERNANCE_EMERGENCY_PERIOD;
1114	 }
1115	 function getGovernanceExpiration() internal pure returns (uint256) {
1116	 return GOVERNANCE_EXPIRATION;
1117	 }
1118	 function getGovernancePassThreshold() internal pure returns (Decimal.D256 memory) {
1119	 return Decimal.D256({
1120	 value: GOVERNANCE_PASS_THRESHOLD}
1121	 );
1122	 }
1123	 function getGovernanceEmergencyThreshold() internal pure returns (Decimal.D256 memory) {
1124	 return Decimal.ratio(GOVERNANCE_EMERGENCY_THRESHOLD_NUMERATOR,GOVERNANCE_EMERGENCY_THRESHOLD_DEMONINATOR);
1125	 }
1126	 function getGovernanceProposalThreshold() internal pure returns (Decimal.D256 memory) {
1127	 return Decimal.D256({
1128	 value: GOVERNANCE_PROPOSAL_THRESHOLD}
1129	 );
1130	 }
1131	 function getAdvanceIncentive() internal pure returns (uint256) {
1132	 return BASE_ADVANCE_INCENTIVE;
1133	 }
1134	 function getCommitIncentive() internal pure returns (uint256) {
1135	 return BASE_COMMIT_INCENTIVE;
1136	 }
1137	 function getSiloWithdrawSeasons() internal pure returns (uint32) {
1138	 return WITHDRAW_TIME;
1139	 }
1140	 function getMinSoilRatioCap() internal pure returns (uint256) {
1141	 return SOIL_MIN_RATIO_CAP;
1142	 }
1143	 function getMaxSoilRatioCap() internal pure returns (uint256) {
1144	 return SOIL_MAX_RATIO_CAP;
1145	 }
1146	 function getHarvestPercentage() internal pure returns (uint256) {
1147	 return HARVESET_PERCENTAGE;
1148	 }
1149	 function getChainId() internal pure returns (uint256) {
1150	 return CHAIN_ID;
1151	 }
1152	 function getOptimalPodRate() internal pure returns (Decimal.D256 memory) {
1153	 return Decimal.ratio(OPTIMAL_POD_RATE,1e18);
1154	 }
1155	 function getUpperBoundPodRate() internal pure returns (Decimal.D256 memory) {
1156	 return Decimal.ratio(POD_RATE_UPPER_BOUND,1e18);
1157	 }
1158	 function getLowerBoundPodRate() internal pure returns (Decimal.D256 memory) {
1159	 return Decimal.ratio(POD_RATE_LOWER_BOUND,1e18);
1160	 }
1161	 function getUpperBoundDPD() internal pure returns (Decimal.D256 memory) {
1162	 return Decimal.ratio(DELTA_POD_DEMAND_UPPER_BOUND,1e18);
1163	 }
1164	 function getLowerBoundDPD() internal pure returns (Decimal.D256 memory) {
1165	 return Decimal.ratio(DELTA_POD_DEMAND_LOWER_BOUND,1e18);
1166	 }
1167	 function getSteadySowTime() internal pure returns (uint256) {
1168	 return STEADY_SOW_TIME;
1169	 }
1170	 function getRainTime() internal pure returns (uint256) {
1171	 return RAIN_TIME;
1172	 }
1173	 function getMaxPropositions() internal pure returns (uint256) {
1174	 return MAX_PROPOSITIONS;
1175	 }
1176	 function getSeedsPerBean() internal pure returns (uint256) {
1177	 return SEEDS_PER_BEAN;
1178	 }
1179	 function getSeedsPerLPBean() internal pure returns (uint256) {
1180	 return SEEDS_PER_LP_BEAN;
1181	 }
1182	 function getStalkPerBean() internal pure returns (uint256) {
1183	 return STALK_PER_BEAN;
1184	 }
1185	 function getStalkPerLPSeed() internal pure returns (uint256) {
1186	 return STALK_PER_BEAN/SEEDS_PER_LP_BEAN;
1187	 }
1188	 function getRootsBase() internal pure returns (uint256) {
1189	 return ROOTS_BASE;
1190	 }
1191	 }
1192	 pragma solidity ^0.7.6;
1193	 interface IWETH is IERC20 {
1194	 function deposit() external payable;
1195	 function withdraw(uint) external;
1196	 }
1197	 pragma solidity ^0.7.6;
1198	 contract Account {
1199	 struct Field {
1200	 mapping(uint256 => uint256) plots;
1201	 mapping(address => uint256) podAllowances;
1202	 }
1203	 struct AssetSilo {
1204	 mapping(uint32 => uint256) withdrawals;
1205	 mapping(uint32 => uint256) deposits;
1206	 mapping(uint32 => uint256) depositSeeds;
1207	 }
1208	 struct Silo {
1209	 uint256 stalk;
1210	 uint256 seeds;
1211	 }
1212	 struct SeasonOfPlenty {
1213	 uint256 base;
1214	 uint256 roots;
1215	 uint256 basePerRoot;
1216	 }
1217	 struct State {
1218	 Field field;
1219	 AssetSilo bean;
1220	 AssetSilo lp;
1221	 Silo s;
1222	 uint32 lockedUntil;
1223	 uint32 lastUpdate;
1224	 uint32 lastSop;
1225	 uint32 lastRain;
1226	 SeasonOfPlenty sop;
1227	 uint256 roots;
1228	 }
1229	 }
1230	 contract Storage {
1231	 struct Contracts {
1232	 address bean;
1233	 address pair;
1234	 address pegPair;
1235	 address weth;
1236	 }
1237	 struct Field {
1238	 uint256 soil;
1239	 uint256 pods;
1240	 uint256 harvested;
1241	 uint256 harvestable;
1242	 }
1243	 struct Bip {
1244	 address proposer;
1245	 uint32 start;
1246	 uint32 period;
1247	 bool executed;
1248	 int pauseOrUnpause;
1249	 uint128 timestamp;
1250	 uint256 roots;
1251	 uint256 endTotalRoots;
1252	 }
1253	 struct DiamondCut {
1254	 IDiamondCut.FacetCut[] diamondCut;
1255	 address initAddress;
1256	 bytes initData;
1257	 }
1258	 struct Governance {
1259	 uint32[] activeBips;
1260	 uint32 bipIndex;
1261	 mapping(uint32 => DiamondCut) diamondCuts;
1262	 mapping(uint32 => mapping(address => bool)) voted;
1263	 mapping(uint32 => Bip) bips;
1264	 }
1265	 struct AssetSilo {
1266	 uint256 deposited;
1267	 uint256 withdrawn;
1268	 }
1269	 struct IncreaseSilo {
1270	 uint256 beans;
1271	 uint256 stalk;
1272	 }
1273	 struct SeasonOfPlenty {
1274	 uint256 weth;
1275	 uint256 base;
1276	 uint32 last;
1277	 }
1278	 struct Silo {
1279	 uint256 stalk;
1280	 uint256 seeds;
1281	 uint256 roots;
1282	 }
1283	 struct Oracle {
1284	 bool initialized;
1285	 uint256 cumulative;
1286	 uint256 pegCumulative;
1287	 uint32 timestamp;
1288	 uint32 pegTimestamp;
1289	 }
1290	 struct Rain {
1291	 uint32 start;
1292	 bool raining;
1293	 uint256 pods;
1294	 uint256 roots;
1295	 }
1296	 struct Season {
1297	 uint32 current;
1298	 uint256 start;
1299	 uint256 period;
1300	 uint256 timestamp;
1301	 }
1302	 struct Weather {
1303	 uint256 startSoil;
1304	 uint256 lastDSoil;
1305	 uint96 lastSoilPercent;
1306	 uint32 lastSowTime;
1307	 uint32 nextSowTime;
1308	 uint32 yield;
1309	 bool didSowBelowMin;
1310	 bool didSowFaster;
1311	 }
1312	 }
1313	 struct AppStorage {
1314	 uint8 index;
1315	 int8[32] cases;
1316	 bool paused;
1317	 uint128 pausedAt;
1318	 Storage.Season season;
1319	 Storage.Contracts c;
1320	 Storage.Field f;
1321	 Storage.Governance g;
1322	 Storage.Oracle o;
1323	 Storage.Rain r;
1324	 Storage.Silo s;
1325	 uint256 depreciated1;
1326	 Storage.Weather w;
1327	 Storage.AssetSilo bean;
1328	 Storage.AssetSilo lp;
1329	 Storage.IncreaseSilo si;
1330	 Storage.SeasonOfPlenty sop;
1331	 uint256 depreciated2;
1332	 uint256 depreciated3;
1333	 uint256 depreciated4;
1334	 uint256 depreciated5;
1335	 uint256 depreciated6;
1336	 mapping (uint32 => uint256) sops;
1337	 mapping (address => Account.State) a;
1338	 uint32 bip0Start;
1339	 }
1340	 pragma solidity ^0.7.6;
1341	 abstract contract IBean is IERC20 {
1342	 function burn(uint256 amount) public virtual;
1343	 function burnFrom(address account, uint256 amount) public virtual;
1344	 function mint(address account, uint256 amount) public virtual returns (bool);
1345	 }
1346	 pragma solidity ^0.7.6;
1347	 library Decimal {
1348	 using SafeMath for uint256;
1349	 uint256 constant BASE = 10**18;
1350	 struct D256 {
1351	 uint256 value;
1352	 }
1353	 function zero() internal pure returns (D256 memory) {
1354	 return D256({
1355	 value: 0 }
1356	 );
1357	 }
1358	 function one() internal pure returns (D256 memory) {
1359	 return D256({
1360	 value: BASE }
1361	 );
1362	 }
1363	 function from( uint256 a ) internal pure returns (D256 memory) {
1364	 return D256({
1365	 value: a.mul(BASE) }
1366	 );
1367	 }
1368	 function ratio( uint256 a, uint256 b ) internal pure returns (D256 memory) {
1369	 return D256({
1370	 value: getPartial(a, BASE, b) }
1371	 );
1372	 }
1373	 function add( D256 memory self, uint256 b ) internal pure returns (D256 memory) {
1374	 return D256({
1375	 value: self.value.add(b.mul(BASE)) }
1376	 );
1377	 }
1378	 function sub( D256 memory self, uint256 b ) internal pure returns (D256 memory) {
1379	 return D256({
1380	 value: self.value.sub(b.mul(BASE)) }
1381	 );
1382	 }
1383	 function sub( D256 memory self, uint256 b, string memory reason ) internal pure returns (D256 memory) {
1384	 return D256({
1385	 value: self.value.sub(b.mul(BASE), reason) }
1386	 );
1387	 }
1388	 function mul( D256 memory self, uint256 b ) internal pure returns (D256 memory) {
1389	 return D256({
1390	 value: self.value.mul(b) }
1391	 );
1392	 }
1393	 function div( D256 memory self, uint256 b ) internal pure returns (D256 memory) {
1394	 return D256({
1395	 value: self.value.div(b) }
1396	 );
1397	 }
1398	 function pow( D256 memory self, uint256 b ) internal pure returns (D256 memory) {
1399	 if (b == 0) {
1400	 return from(1);
1401	 }
1402	 D256 memory temp = D256({
1403	 value: self.value }
1404	 );
1405	 for (uint256 i = 1; i < b; i++) {
1406	 temp = mul(temp, self);
1407	 }
1408	 return temp;
1409	 }
1410	 function add( D256 memory self, D256 memory b ) internal pure returns (D256 memory) {
1411	 return D256({
1412	 value: self.value.add(b.value) }
1413	 );
1414	 }
1415	 function sub( D256 memory self, D256 memory b ) internal pure returns (D256 memory) {
1416	 return D256({
1417	 value: self.value.sub(b.value) }
1418	 );
1419	 }
1420	 function sub( D256 memory self, D256 memory b, string memory reason ) internal pure returns (D256 memory) {
1421	 return D256({
1422	 value: self.value.sub(b.value, reason) }
1423	 );
1424	 }
1425	 function mul( D256 memory self, D256 memory b ) internal pure returns (D256 memory) {
1426	 return D256({
1427	 value: getPartial(self.value, b.value, BASE) }
1428	 );
1429	 }
1430	 function div( D256 memory self, D256 memory b ) internal pure returns (D256 memory) {
1431	 return D256({
1432	 value: getPartial(self.value, BASE, b.value) }
1433	 );
1434	 }
1435	 function equals(D256 memory self, D256 memory b) internal pure returns (bool) {
1436	 return self.value == b.value;
1437	 }
1438	 function greaterThan(D256 memory self, D256 memory b) internal pure returns (bool) {
1439	 return compareTo(self, b) == 2;
1440	 }
1441	 function lessThan(D256 memory self, D256 memory b) internal pure returns (bool) {
1442	 return compareTo(self, b) == 0;
1443	 }
1444	 function greaterThanOrEqualTo(D256 memory self, D256 memory b) internal pure returns (bool) {
1445	 return compareTo(self, b) > 0;
1446	 }
1447	 function lessThanOrEqualTo(D256 memory self, D256 memory b) internal pure returns (bool) {
1448	 return compareTo(self, b) < 2;
1449	 }
1450	 function isZero(D256 memory self) internal pure returns (bool) {
1451	 return self.value == 0;
1452	 }
1453	 function asUint256(D256 memory self) internal pure returns (uint256) {
1454	 return self.value.div(BASE);
1455	 }
1456	 function getPartial( uint256 target, uint256 numerator, uint256 denominator ) private pure returns (uint256) {
1457	 return target.mul(numerator).div(denominator);
1458	 }
1459	 function compareTo( D256 memory a, D256 memory b ) private pure returns (uint256) {
1460	 if (a.value == b.value) {
1461	 return 1;
1462	 }
1463	 return a.value > b.value ? 2 : 0;
1464	 }
1465	 }
1466	 pragma solidity ^0.7.6;
1467	 interface IDiamondCut {
1468	 enum FacetCutAction {
1469	 Add, Replace, Remove}
1470	 struct FacetCut {
1471	 address facetAddress;
1472	 FacetCutAction action;
1473	 bytes4[] functionSelectors;
1474	 }
1475	 function diamondCut( FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata ) external;
1476	 event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);
1477	 }
1478	 pragma solidity ^0.7.6;
1479	 library LibAppStorage {
1480	 function diamondStorage() internal pure returns (AppStorage storage ds) {
1481	 assembly {
1482	 ds.slot := 0 }
1483	 }
1484	 }
1485	 pragma solidity >=0.6.2;
1486	 interface IUniswapV2Router02 is IUniswapV2Router01 {
1487	 function removeLiquidityETHSupportingFeeOnTransferTokens( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) external returns (uint amountETH);
1488	 function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s ) external returns (uint amountETH);
1489	 function swapExactTokensForTokensSupportingFeeOnTransferTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external;
1490	 function swapExactETHForTokensSupportingFeeOnTransferTokens( uint amountOutMin, address[] calldata path, address to, uint deadline ) external payable;
1491	 function swapExactTokensForETHSupportingFeeOnTransferTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external;
1492	 }
