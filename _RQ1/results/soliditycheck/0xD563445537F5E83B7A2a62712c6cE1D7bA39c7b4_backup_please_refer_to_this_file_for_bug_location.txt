row number 
1	  pragma experimental ABIEncoderV2;
2	 pragma solidity 0.6.12;
3	 interface IERC20 {
4	 function totalSupply() external view returns (uint256);
5	 function balanceOf(address account) external view returns (uint256);
6	 function transfer(address recipient, uint256 amount) external returns (bool);
7	 function allowance(address owner, address spender) external view returns (uint256);
8	 function approve(address spender, uint256 amount) external returns (bool);
9	 function transferFrom( address sender, address recipient, uint256 amount ) external returns (bool);
10	 event Transfer(address indexed from, address indexed to, uint256 value);
11	 event Approval(address indexed owner, address indexed spender, uint256 value);
12	 }
13	 pragma solidity 0.6.12;
14	 interface IScaledBalanceToken {
15	 function scaledBalanceOf(address user) external view returns (uint256);
16	 function getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256);
17	 function scaledTotalSupply() external view returns (uint256);
18	 }
19	 pragma solidity 0.6.12;
20	 interface IInitializableAToken {
21	 event Initialized( address indexed underlyingAsset, address indexed pool, address treasury, address incentivesController, uint8 aTokenDecimals, string aTokenName, string aTokenSymbol, bytes params );
22	 function initialize( ILendingPool pool, address treasury, address underlyingAsset, IAaveIncentivesController incentivesController, uint8 aTokenDecimals, string calldata aTokenName, string calldata aTokenSymbol, bytes calldata params ) external;
23	 }
24	 pragma solidity 0.6.12;
25	 interface IInitializableDebtToken {
26	 event Initialized( address indexed underlyingAsset, address indexed pool, address incentivesController, uint8 debtTokenDecimals, string debtTokenName, string debtTokenSymbol, bytes params );
27	 function initialize( ILendingPool pool, address underlyingAsset, IAaveIncentivesController incentivesController, uint8 debtTokenDecimals, string memory debtTokenName, string memory debtTokenSymbol, bytes calldata params ) external;
28	 }
29	 pragma solidity 0.6.12;
30	 library ReserveLogic {
31	 using SafeMath for uint256;
32	 using WadRayMath for uint256;
33	 using PercentageMath for uint256;
34	 using SafeERC20 for IERC20;
35	 event ReserveDataUpdated( address indexed asset, uint256 liquidityRate, uint256 stableBorrowRate, uint256 variableBorrowRate, uint256 liquidityIndex, uint256 variableBorrowIndex );
36	 using ReserveLogic for DataTypes.ReserveData;
37	 using ReserveConfiguration for DataTypes.ReserveConfigurationMap;
38	 function getNormalizedIncome(DataTypes.ReserveData storage reserve) internal view returns (uint256) {
39	 uint40 timestamp = reserve.lastUpdateTimestamp;
40	 if (timestamp == uint40(block.timestamp)) {
41	 return reserve.liquidityIndex;
42	 }
43	 uint256 cumulated = MathUtils.calculateLinearInterest(reserve.currentLiquidityRate, timestamp).rayMul( reserve.liquidityIndex );
44	 return cumulated;
45	 }
46	 function getNormalizedDebt(DataTypes.ReserveData storage reserve) internal view returns (uint256) {
47	 uint40 timestamp = reserve.lastUpdateTimestamp;
48	 if (timestamp == uint40(block.timestamp)) {
49	 return reserve.variableBorrowIndex;
50	 }
51	 uint256 cumulated = MathUtils.calculateCompoundedInterest(reserve.currentVariableBorrowRate, timestamp).rayMul( reserve.variableBorrowIndex );
52	 return cumulated;
53	 }
54	 function updateState(DataTypes.ReserveData storage reserve) internal {
55	 uint256 scaledVariableDebt = IVariableDebtToken(reserve.variableDebtTokenAddress).scaledTotalSupply();
56	 uint256 previousVariableBorrowIndex = reserve.variableBorrowIndex;
57	 uint256 previousLiquidityIndex = reserve.liquidityIndex;
58	 uint40 lastUpdatedTimestamp = reserve.lastUpdateTimestamp;
59	 (uint256 newLiquidityIndex, uint256 newVariableBorrowIndex) = _updateIndexes( reserve, scaledVariableDebt, previousLiquidityIndex, previousVariableBorrowIndex, lastUpdatedTimestamp );
60	 _mintToTreasury( reserve, scaledVariableDebt, previousVariableBorrowIndex, newLiquidityIndex, newVariableBorrowIndex, lastUpdatedTimestamp );
61	 }
62	 function cumulateToLiquidityIndex( DataTypes.ReserveData storage reserve, uint256 totalLiquidity, uint256 amount ) internal {
63	 uint256 amountToLiquidityRatio = amount.wadToRay().rayDiv(totalLiquidity.wadToRay());
64	 uint256 result = amountToLiquidityRatio.add(WadRayMath.ray());
65	 result = result.rayMul(reserve.liquidityIndex);
66	 require(result <= type(uint128).max, Errors.RL_LIQUIDITY_INDEX_OVERFLOW);
67	 reserve.liquidityIndex = uint128(result);
68	 }
69	 function init( DataTypes.ReserveData storage reserve, address aTokenAddress, address stableDebtTokenAddress, address variableDebtTokenAddress, address interestRateStrategyAddress ) external {
70	 require(reserve.aTokenAddress == address(0), Errors.RL_RESERVE_ALREADY_INITIALIZED);
71	 reserve.liquidityIndex = uint128(WadRayMath.ray());
72	 reserve.variableBorrowIndex = uint128(WadRayMath.ray());
73	 reserve.aTokenAddress = aTokenAddress;
74	 reserve.stableDebtTokenAddress = stableDebtTokenAddress;
75	 reserve.variableDebtTokenAddress = variableDebtTokenAddress;
76	 reserve.interestRateStrategyAddress = interestRateStrategyAddress;
77	 }
78	 struct UpdateInterestRatesLocalVars {
79	 address stableDebtTokenAddress;
80	 uint256 availableLiquidity;
81	 uint256 totalStableDebt;
82	 uint256 newLiquidityRate;
83	 uint256 newStableRate;
84	 uint256 newVariableRate;
85	 uint256 avgStableRate;
86	 uint256 totalVariableDebt;
87	 }
88	 function updateInterestRates( DataTypes.ReserveData storage reserve, address reserveAddress, address aTokenAddress, uint256 liquidityAdded, uint256 liquidityTaken ) internal {
89	 UpdateInterestRatesLocalVars memory vars;
90	 vars.stableDebtTokenAddress = reserve.stableDebtTokenAddress;
91	 (vars.totalStableDebt, vars.avgStableRate) = IStableDebtToken(vars.stableDebtTokenAddress) .getTotalSupplyAndAvgRate();
92	 vars.totalVariableDebt = IVariableDebtToken(reserve.variableDebtTokenAddress) .scaledTotalSupply() .rayMul(reserve.variableBorrowIndex);
93	 ( vars.newLiquidityRate, vars.newStableRate, vars.newVariableRate ) = IReserveInterestRateStrategy(reserve.interestRateStrategyAddress).calculateInterestRates( reserveAddress, aTokenAddress, liquidityAdded, liquidityTaken, vars.totalStableDebt, vars.totalVariableDebt, vars.avgStableRate, reserve.configuration.getReserveFactor() );
94	 require(vars.newLiquidityRate <= type(uint128).max, Errors.RL_LIQUIDITY_RATE_OVERFLOW);
95	 require(vars.newStableRate <= type(uint128).max, Errors.RL_STABLE_BORROW_RATE_OVERFLOW);
96	 require(vars.newVariableRate <= type(uint128).max, Errors.RL_VARIABLE_BORROW_RATE_OVERFLOW);
97	 reserve.currentLiquidityRate = uint128(vars.newLiquidityRate);
98	 reserve.currentStableBorrowRate = uint128(vars.newStableRate);
99	 reserve.currentVariableBorrowRate = uint128(vars.newVariableRate);
100	 emit ReserveDataUpdated( reserveAddress, vars.newLiquidityRate, vars.newStableRate, vars.newVariableRate, reserve.liquidityIndex, reserve.variableBorrowIndex );
101	 }
102	 struct MintToTreasuryLocalVars {
103	 uint256 currentStableDebt;
104	 uint256 principalStableDebt;
105	 uint256 previousStableDebt;
106	 uint256 currentVariableDebt;
107	 uint256 previousVariableDebt;
108	 uint256 avgStableRate;
109	 uint256 cumulatedStableInterest;
110	 uint256 totalDebtAccrued;
111	 uint256 amountToMint;
112	 uint256 reserveFactor;
113	 uint40 stableSupplyUpdatedTimestamp;
114	 }
115	 function _mintToTreasury( DataTypes.ReserveData storage reserve, uint256 scaledVariableDebt, uint256 previousVariableBorrowIndex, uint256 newLiquidityIndex, uint256 newVariableBorrowIndex, uint40 timestamp ) internal {
116	 MintToTreasuryLocalVars memory vars;
117	 vars.reserveFactor = reserve.configuration.getReserveFactor();
118	 if (vars.reserveFactor == 0) {
119	 return;
120	 }
121	 ( vars.principalStableDebt, vars.currentStableDebt, vars.avgStableRate, vars.stableSupplyUpdatedTimestamp ) = IStableDebtToken(reserve.stableDebtTokenAddress).getSupplyData();
122	 vars.previousVariableDebt = scaledVariableDebt.rayMul(previousVariableBorrowIndex);
123	 vars.currentVariableDebt = scaledVariableDebt.rayMul(newVariableBorrowIndex);
124	 vars.cumulatedStableInterest = MathUtils.calculateCompoundedInterest( vars.avgStableRate, vars.stableSupplyUpdatedTimestamp, timestamp );
125	 vars.previousStableDebt = vars.principalStableDebt.rayMul(vars.cumulatedStableInterest);
126	 vars.totalDebtAccrued = vars .currentVariableDebt .add(vars.currentStableDebt) .sub(vars.previousVariableDebt) .sub(vars.previousStableDebt);
127	 vars.amountToMint = vars.totalDebtAccrued.percentMul(vars.reserveFactor);
128	 if (vars.amountToMint != 0) {
129	 IAToken(reserve.aTokenAddress).mintToTreasury(vars.amountToMint, newLiquidityIndex);
130	 }
131	 }
132	 function _updateIndexes( DataTypes.ReserveData storage reserve, uint256 scaledVariableDebt, uint256 liquidityIndex, uint256 variableBorrowIndex, uint40 timestamp ) internal returns (uint256, uint256) {
133	 uint256 currentLiquidityRate = reserve.currentLiquidityRate;
134	 uint256 newLiquidityIndex = liquidityIndex;
135	 uint256 newVariableBorrowIndex = variableBorrowIndex;
136	 if (currentLiquidityRate > 0) {
137	 uint256 cumulatedLiquidityInterest = MathUtils.calculateLinearInterest(currentLiquidityRate, timestamp);
138	 newLiquidityIndex = cumulatedLiquidityInterest.rayMul(liquidityIndex);
139	 require(newLiquidityIndex <= type(uint128).max, Errors.RL_LIQUIDITY_INDEX_OVERFLOW);
140	 reserve.liquidityIndex = uint128(newLiquidityIndex);
141	 if (scaledVariableDebt != 0) {
142	 uint256 cumulatedVariableBorrowInterest = MathUtils.calculateCompoundedInterest(reserve.currentVariableBorrowRate, timestamp);
143	 newVariableBorrowIndex = cumulatedVariableBorrowInterest.rayMul(variableBorrowIndex);
144	 require( newVariableBorrowIndex <= type(uint128).max, Errors.RL_VARIABLE_BORROW_INDEX_OVERFLOW );
145	 reserve.variableBorrowIndex = uint128(newVariableBorrowIndex);
146	 }
147	 }
148	 reserve.lastUpdateTimestamp = uint40(block.timestamp);
149	 return (newLiquidityIndex, newVariableBorrowIndex);
150	 }
151	 }
152	 pragma solidity 0.6.12;
153	 library SafeMath {
154	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
155	 uint256 c = a + b;
156	 require(c >= a, 'SafeMath: addition overflow');
157	 return c;
158	 }
159	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
160	 return sub(a, b, 'SafeMath: subtraction overflow');
161	 }
162	 function sub( uint256 a, uint256 b, string memory errorMessage ) internal pure returns (uint256) {
163	 require(b <= a, errorMessage);
164	 uint256 c = a - b;
165	 return c;
166	 }
167	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
168	 if (a == 0) {
169	 return 0;
170	 }
171	 uint256 c = a * b;
172	 require(c / a == b, 'SafeMath: multiplication overflow');
173	 return c;
174	 }
175	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
176	 return div(a, b, 'SafeMath: division by zero');
177	 }
178	 function div( uint256 a, uint256 b, string memory errorMessage ) internal pure returns (uint256) {
179	 require(b > 0, errorMessage);
180	 uint256 c = a / b;
181	 return c;
182	 }
183	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
184	 return mod(a, b, 'SafeMath: modulo by zero');
185	 }
186	 function mod( uint256 a, uint256 b, string memory errorMessage ) internal pure returns (uint256) {
187	 require(b != 0, errorMessage);
188	 return a % b;
189	 }
190	 }
191	 pragma solidity 0.6.12;
192	 library SafeERC20 {
193	 using SafeMath for uint256;
194	 using Address for address;
195	 function safeTransfer( IERC20 token, address to, uint256 value ) internal {
196	 callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
197	 }
198	 function safeTransferFrom( IERC20 token, address from, address to, uint256 value ) internal {
199	 callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
200	 }
201	 function safeApprove( IERC20 token, address spender, uint256 value ) internal {
202	 require( (value == 0) || (token.allowance(address(this), spender) == 0), 'SafeERC20: approve from non-zero to non-zero allowance' );
203	 callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
204	 }
205	 function callOptionalReturn(IERC20 token, bytes memory data) private {
206	 require(address(token).isContract(), 'SafeERC20: call to non-contract');
207	 (bool success, bytes memory returndata) = address(token).call(data);
208	 require(success, 'SafeERC20: low-level call failed');
209	 if (returndata.length > 0) {
210	 require(abi.decode(returndata, (bool)), 'SafeERC20: ERC20 operation did not succeed');
211	 }
212	 }
213	 }
214	 pragma solidity 0.6.12;
215	 library Address {
216	 function isContract(address account) internal view returns (bool) {
217	 bytes32 codehash;
218	 bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
219	 assembly {
220	 codehash := extcodehash(account) }
221	 return (codehash != accountHash && codehash != 0x0);
222	 }
223	 function sendValue(address payable recipient, uint256 amount) internal {
224	 require(address(this).balance >= amount, 'Address: insufficient balance');
225	 (bool success, ) = recipient.call{
226	 value: amount}
227	 ('');
228	 require(success, 'Address: unable to send value, recipient may have reverted');
229	 }
230	 }
231	 pragma solidity 0.6.12;
232	 interface IAToken is IERC20, IScaledBalanceToken, IInitializableAToken {
233	 event Mint(address indexed from, uint256 value, uint256 index);
234	 function mint( address user, uint256 amount, uint256 index ) external returns (bool);
235	 event Burn(address indexed from, address indexed target, uint256 value, uint256 index);
236	 event BalanceTransfer(address indexed from, address indexed to, uint256 value, uint256 index);
237	 function burn( address user, address receiverOfUnderlying, uint256 amount, uint256 index ) external;
238	 function mintToTreasury(uint256 amount, uint256 index) external;
239	 function transferOnLiquidation( address from, address to, uint256 value ) external;
240	 function transferUnderlyingTo(address user, uint256 amount) external returns (uint256);
241	 function handleRepayment(address user, uint256 amount) external;
242	 function getIncentivesController() external view returns (IAaveIncentivesController);
243	 function UNDERLYING_ASSET_ADDRESS() external view returns (address);
244	 }
245	 pragma solidity 0.6.12;
246	 interface ILendingPool {
247	 event Deposit( address indexed reserve, address user, address indexed onBehalfOf, uint256 amount, uint16 indexed referral );
248	 event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);
249	 event Borrow( address indexed reserve, address user, address indexed onBehalfOf, uint256 amount, uint256 borrowRateMode, uint256 borrowRate, uint16 indexed referral );
250	 event Repay( address indexed reserve, address indexed user, address indexed repayer, uint256 amount );
251	 event Swap(address indexed reserve, address indexed user, uint256 rateMode);
252	 event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);
253	 event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);
254	 event RebalanceStableBorrowRate(address indexed reserve, address indexed user);
255	 event FlashLoan( address indexed target, address indexed initiator, address indexed asset, uint256 amount, uint256 premium, uint16 referralCode );
256	 event Paused();
257	 event Unpaused();
258	 event LiquidationCall( address indexed collateralAsset, address indexed debtAsset, address indexed user, uint256 debtToCover, uint256 liquidatedCollateralAmount, address liquidator, bool receiveAToken );
259	 event ReserveDataUpdated( address indexed reserve, uint256 liquidityRate, uint256 stableBorrowRate, uint256 variableBorrowRate, uint256 liquidityIndex, uint256 variableBorrowIndex );
260	 function deposit( address asset, uint256 amount, address onBehalfOf, uint16 referralCode ) external;
261	 function withdraw( address asset, uint256 amount, address to ) external returns (uint256);
262	 function borrow( address asset, uint256 amount, uint256 interestRateMode, uint16 referralCode, address onBehalfOf ) external;
263	 function repay( address asset, uint256 amount, uint256 rateMode, address onBehalfOf ) external returns (uint256);
264	 function swapBorrowRateMode(address asset, uint256 rateMode) external;
265	 function rebalanceStableBorrowRate(address asset, address user) external;
266	 function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;
267	 function liquidationCall( address collateralAsset, address debtAsset, address user, uint256 debtToCover, bool receiveAToken ) external;
268	 function flashLoan( address receiverAddress, address[] calldata assets, uint256[] calldata amounts, uint256[] calldata modes, address onBehalfOf, bytes calldata params, uint16 referralCode ) external;
269	 function getUserAccountData(address user) external view returns ( uint256 totalCollateralETH, uint256 totalDebtETH, uint256 availableBorrowsETH, uint256 currentLiquidationThreshold, uint256 ltv, uint256 healthFactor );
270	 function initReserve( address reserve, address aTokenAddress, address stableDebtAddress, address variableDebtAddress, address interestRateStrategyAddress ) external;
271	 function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress) external;
272	 function setConfiguration(address reserve, uint256 configuration) external;
273	 function getConfiguration(address asset) external view returns (DataTypes.ReserveConfigurationMap memory);
274	 function getUserConfiguration(address user) external view returns (DataTypes.UserConfigurationMap memory);
275	 function getReserveNormalizedIncome(address asset) external view returns (uint256);
276	 function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);
277	 function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);
278	 function finalizeTransfer( address asset, address from, address to, uint256 amount, uint256 balanceFromAfter, uint256 balanceToBefore ) external;
279	 function getReservesList() external view returns (address[] memory);
280	 function getAddressesProvider() external view returns (ILendingPoolAddressesProvider);
281	 function setPause(bool val) external;
282	 function paused() external view returns (bool);
283	 }
284	 pragma solidity 0.6.12;
285	 interface ILendingPoolAddressesProvider {
286	 event MarketIdSet(string newMarketId);
287	 event LendingPoolUpdated(address indexed newAddress);
288	 event ConfigurationAdminUpdated(address indexed newAddress);
289	 event EmergencyAdminUpdated(address indexed newAddress);
290	 event LendingPoolConfiguratorUpdated(address indexed newAddress);
291	 event LendingPoolCollateralManagerUpdated(address indexed newAddress);
292	 event PriceOracleUpdated(address indexed newAddress);
293	 event LendingRateOracleUpdated(address indexed newAddress);
294	 event ProxyCreated(bytes32 id, address indexed newAddress);
295	 event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);
296	 function getMarketId() external view returns (string memory);
297	 function setMarketId(string calldata marketId) external;
298	 function setAddress(bytes32 id, address newAddress) external;
299	 function setAddressAsProxy(bytes32 id, address impl) external;
300	 function getAddress(bytes32 id) external view returns (address);
301	 function getLendingPool() external view returns (address);
302	 function setLendingPoolImpl(address pool) external;
303	 function getLendingPoolConfigurator() external view returns (address);
304	 function setLendingPoolConfiguratorImpl(address configurator) external;
305	 function getLendingPoolCollateralManager() external view returns (address);
306	 function setLendingPoolCollateralManager(address manager) external;
307	 function getPoolAdmin() external view returns (address);
308	 function setPoolAdmin(address admin) external;
309	 function getEmergencyAdmin() external view returns (address);
310	 function setEmergencyAdmin(address admin) external;
311	 function getPriceOracle() external view returns (address);
312	 function setPriceOracle(address priceOracle) external;
313	 function getLendingRateOracle() external view returns (address);
314	 function setLendingRateOracle(address lendingRateOracle) external;
315	 }
316	 pragma solidity 0.6.12;
317	 library DataTypes {
318	 struct ReserveData {
319	 ReserveConfigurationMap configuration;
320	 uint128 liquidityIndex;
321	 uint128 variableBorrowIndex;
322	 uint128 currentLiquidityRate;
323	 uint128 currentVariableBorrowRate;
324	 uint128 currentStableBorrowRate;
325	 uint40 lastUpdateTimestamp;
326	 address aTokenAddress;
327	 address stableDebtTokenAddress;
328	 address variableDebtTokenAddress;
329	 address interestRateStrategyAddress;
330	 uint8 id;
331	 }
332	 struct ReserveConfigurationMap {
333	 uint256 data;
334	 }
335	 struct UserConfigurationMap {
336	 uint256 data;
337	 }
338	 enum InterestRateMode {
339	 NONE, STABLE, VARIABLE}
340	 }
341	 pragma solidity 0.6.12;
342	 interface IAaveIncentivesController {
343	 event RewardsAccrued(address indexed user, uint256 amount);
344	 event RewardsClaimed(address indexed user, address indexed to, uint256 amount);
345	 event RewardsClaimed(address indexed user, address indexed to, address indexed claimer, uint256 amount);
346	 event ClaimerSet(address indexed user, address indexed claimer);
347	 function getAssetData(address asset) external view returns ( uint256, uint256, uint256 );
348	 function assets(address asset) external view returns ( uint128, uint128, uint256 );
349	 function setClaimer(address user, address claimer) external;
350	 function getClaimer(address user) external view returns (address);
351	 function configureAssets(address[] calldata assets, uint256[] calldata emissionsPerSecond) external;
352	 function handleAction( address asset, uint256 userBalance, uint256 totalSupply ) external;
353	 function getRewardsBalance(address[] calldata assets, address user) external view returns (uint256);
354	 function claimRewards( address[] calldata assets, uint256 amount, address to ) external returns (uint256);
355	 function claimRewardsOnBehalf( address[] calldata assets, uint256 amount, address user, address to ) external returns (uint256);
356	 function getUserUnclaimedRewards(address user) external view returns (uint256);
357	 function getUserAssetData(address user, address asset) external view returns (uint256);
358	 function REWARD_TOKEN() external view returns (address);
359	 function PRECISION() external view returns (uint8);
360	 function DISTRIBUTION_END() external view returns (uint256);
361	 }
362	 pragma solidity 0.6.12;
363	 interface IStableDebtToken is IInitializableDebtToken {
364	 event Mint( address indexed user, address indexed onBehalfOf, uint256 amount, uint256 currentBalance, uint256 balanceIncrease, uint256 newRate, uint256 avgStableRate, uint256 newTotalSupply );
365	 event Burn( address indexed user, uint256 amount, uint256 currentBalance, uint256 balanceIncrease, uint256 avgStableRate, uint256 newTotalSupply );
366	 function mint( address user, address onBehalfOf, uint256 amount, uint256 rate ) external returns (bool);
367	 function burn(address user, uint256 amount) external;
368	 function getAverageStableRate() external view returns (uint256);
369	 function getUserStableRate(address user) external view returns (uint256);
370	 function getUserLastUpdated(address user) external view returns (uint40);
371	 function getSupplyData() external view returns ( uint256, uint256, uint256, uint40 );
372	 function getTotalSupplyLastUpdated() external view returns (uint40);
373	 function getTotalSupplyAndAvgRate() external view returns (uint256, uint256);
374	 function principalBalanceOf(address user) external view returns (uint256);
375	 function getIncentivesController() external view returns (IAaveIncentivesController);
376	 }
377	 pragma solidity 0.6.12;
378	 interface IVariableDebtToken is IScaledBalanceToken, IInitializableDebtToken {
379	 event Mint(address indexed from, address indexed onBehalfOf, uint256 value, uint256 index);
380	 function mint( address user, address onBehalfOf, uint256 amount, uint256 index ) external returns (bool);
381	 event Burn(address indexed user, uint256 amount, uint256 index);
382	 function burn( address user, uint256 amount, uint256 index ) external;
383	 function getIncentivesController() external view returns (IAaveIncentivesController);
384	 }
385	 pragma solidity 0.6.12;
386	 interface IReserveInterestRateStrategy {
387	 function baseVariableBorrowRate() external view returns (uint256);
388	 function getMaxVariableBorrowRate() external view returns (uint256);
389	 function calculateInterestRates( address reserve, uint256 availableLiquidity, uint256 totalStableDebt, uint256 totalVariableDebt, uint256 averageStableBorrowRate, uint256 reserveFactor ) external view returns ( uint256, uint256, uint256 );
390	 function calculateInterestRates( address reserve, address aToken, uint256 liquidityAdded, uint256 liquidityTaken, uint256 totalStableDebt, uint256 totalVariableDebt, uint256 averageStableBorrowRate, uint256 reserveFactor ) external view returns ( uint256 liquidityRate, uint256 stableBorrowRate, uint256 variableBorrowRate );
391	 }
392	 pragma solidity 0.6.12;
393	 library ReserveConfiguration {
394	 uint256 constant LTV_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000;
395	 uint256 constant LIQUIDATION_THRESHOLD_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFF;
396	 uint256 constant LIQUIDATION_BONUS_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFF;
397	 uint256 constant DECIMALS_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFF;
398	 uint256 constant ACTIVE_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFF;
399	 uint256 constant FROZEN_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFF;
400	 uint256 constant BORROWING_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFF;
401	 uint256 constant STABLE_BORROWING_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFF;
402	 uint256 constant RESERVE_FACTOR_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFF;
403	 uint256 constant LIQUIDATION_THRESHOLD_START_BIT_POSITION = 16;
404	 uint256 constant LIQUIDATION_BONUS_START_BIT_POSITION = 32;
405	 uint256 constant RESERVE_DECIMALS_START_BIT_POSITION = 48;
406	 uint256 constant IS_ACTIVE_START_BIT_POSITION = 56;
407	 uint256 constant IS_FROZEN_START_BIT_POSITION = 57;
408	 uint256 constant BORROWING_ENABLED_START_BIT_POSITION = 58;
409	 uint256 constant STABLE_BORROWING_ENABLED_START_BIT_POSITION = 59;
410	 uint256 constant RESERVE_FACTOR_START_BIT_POSITION = 64;
411	 uint256 constant MAX_VALID_LTV = 65535;
412	 uint256 constant MAX_VALID_LIQUIDATION_THRESHOLD = 65535;
413	 uint256 constant MAX_VALID_LIQUIDATION_BONUS = 65535;
414	 uint256 constant MAX_VALID_DECIMALS = 255;
415	 uint256 constant MAX_VALID_RESERVE_FACTOR = 65535;
416	 function setLtv(DataTypes.ReserveConfigurationMap memory self, uint256 ltv) internal pure {
417	 require(ltv <= MAX_VALID_LTV, Errors.RC_INVALID_LTV);
418	 self.data = (self.data & LTV_MASK) | ltv;
419	 }
420	 function getLtv(DataTypes.ReserveConfigurationMap storage self) internal view returns (uint256) {
421	 return self.data & ~LTV_MASK;
422	 }
423	 function setLiquidationThreshold(DataTypes.ReserveConfigurationMap memory self, uint256 threshold) internal pure {
424	 require(threshold <= MAX_VALID_LIQUIDATION_THRESHOLD, Errors.RC_INVALID_LIQ_THRESHOLD);
425	 self.data = (self.data & LIQUIDATION_THRESHOLD_MASK) | (threshold << LIQUIDATION_THRESHOLD_START_BIT_POSITION);
426	 }
427	 function getLiquidationThreshold(DataTypes.ReserveConfigurationMap storage self) internal view returns (uint256) {
428	 return (self.data & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION;
429	 }
430	 function setLiquidationBonus(DataTypes.ReserveConfigurationMap memory self, uint256 bonus) internal pure {
431	 require(bonus <= MAX_VALID_LIQUIDATION_BONUS, Errors.RC_INVALID_LIQ_BONUS);
432	 self.data = (self.data & LIQUIDATION_BONUS_MASK) | (bonus << LIQUIDATION_BONUS_START_BIT_POSITION);
433	 }
434	 function getLiquidationBonus(DataTypes.ReserveConfigurationMap storage self) internal view returns (uint256) {
435	 return (self.data & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION;
436	 }
437	 function setDecimals(DataTypes.ReserveConfigurationMap memory self, uint256 decimals) internal pure {
438	 require(decimals <= MAX_VALID_DECIMALS, Errors.RC_INVALID_DECIMALS);
439	 self.data = (self.data & DECIMALS_MASK) | (decimals << RESERVE_DECIMALS_START_BIT_POSITION);
440	 }
441	 function getDecimals(DataTypes.ReserveConfigurationMap storage self) internal view returns (uint256) {
442	 return (self.data & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION;
443	 }
444	 function setActive(DataTypes.ReserveConfigurationMap memory self, bool active) internal pure {
445	 self.data = (self.data & ACTIVE_MASK) | (uint256(active ? 1 : 0) << IS_ACTIVE_START_BIT_POSITION);
446	 }
447	 function getActive(DataTypes.ReserveConfigurationMap storage self) internal view returns (bool) {
448	 return (self.data & ~ACTIVE_MASK) != 0;
449	 }
450	 function setFrozen(DataTypes.ReserveConfigurationMap memory self, bool frozen) internal pure {
451	 self.data = (self.data & FROZEN_MASK) | (uint256(frozen ? 1 : 0) << IS_FROZEN_START_BIT_POSITION);
452	 }
453	 function getFrozen(DataTypes.ReserveConfigurationMap storage self) internal view returns (bool) {
454	 return (self.data & ~FROZEN_MASK) != 0;
455	 }
456	 function setBorrowingEnabled(DataTypes.ReserveConfigurationMap memory self, bool enabled) internal pure {
457	 self.data = (self.data & BORROWING_MASK) | (uint256(enabled ? 1 : 0) << BORROWING_ENABLED_START_BIT_POSITION);
458	 }
459	 function getBorrowingEnabled(DataTypes.ReserveConfigurationMap storage self) internal view returns (bool) {
460	 return (self.data & ~BORROWING_MASK) != 0;
461	 }
462	 function setStableRateBorrowingEnabled( DataTypes.ReserveConfigurationMap memory self, bool enabled ) internal pure {
463	 self.data = (self.data & STABLE_BORROWING_MASK) | (uint256(enabled ? 1 : 0) << STABLE_BORROWING_ENABLED_START_BIT_POSITION);
464	 }
465	 function getStableRateBorrowingEnabled(DataTypes.ReserveConfigurationMap storage self) internal view returns (bool) {
466	 return (self.data & ~STABLE_BORROWING_MASK) != 0;
467	 }
468	 function setReserveFactor(DataTypes.ReserveConfigurationMap memory self, uint256 reserveFactor) internal pure {
469	 require(reserveFactor <= MAX_VALID_RESERVE_FACTOR, Errors.RC_INVALID_RESERVE_FACTOR);
470	 self.data = (self.data & RESERVE_FACTOR_MASK) | (reserveFactor << RESERVE_FACTOR_START_BIT_POSITION);
471	 }
472	 function getReserveFactor(DataTypes.ReserveConfigurationMap storage self) internal view returns (uint256) {
473	 return (self.data & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION;
474	 }
475	 function getFlags(DataTypes.ReserveConfigurationMap storage self) internal view returns ( bool, bool, bool, bool ) {
476	 uint256 dataLocal = self.data;
477	 return ( (dataLocal & ~ACTIVE_MASK) != 0, (dataLocal & ~FROZEN_MASK) != 0, (dataLocal & ~BORROWING_MASK) != 0, (dataLocal & ~STABLE_BORROWING_MASK) != 0 );
478	 }
479	 function getParams(DataTypes.ReserveConfigurationMap storage self) internal view returns ( uint256, uint256, uint256, uint256, uint256 ) {
480	 uint256 dataLocal = self.data;
481	 return ( dataLocal & ~LTV_MASK, (dataLocal & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION, (dataLocal & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION, (dataLocal & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION, (dataLocal & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION );
482	 }
483	 function getParamsMemory(DataTypes.ReserveConfigurationMap memory self) internal pure returns ( uint256, uint256, uint256, uint256, uint256 ) {
484	 return ( self.data & ~LTV_MASK, (self.data & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION, (self.data & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION, (self.data & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION, (self.data & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION );
485	 }
486	 function getFlagsMemory(DataTypes.ReserveConfigurationMap memory self) internal pure returns ( bool, bool, bool, bool ) {
487	 return ( (self.data & ~ACTIVE_MASK) != 0, (self.data & ~FROZEN_MASK) != 0, (self.data & ~BORROWING_MASK) != 0, (self.data & ~STABLE_BORROWING_MASK) != 0 );
488	 }
489	 }
490	 pragma solidity 0.6.12;
491	 library Errors {
492	 string public constant CALLER_NOT_POOL_ADMIN = '33';
493	 string public constant BORROW_ALLOWANCE_NOT_ENOUGH = '59';
494	 string public constant VL_INVALID_AMOUNT = '1';
495	 string public constant VL_NO_ACTIVE_RESERVE = '2';
496	 string public constant VL_RESERVE_FROZEN = '3';
497	 string public constant VL_CURRENT_AVAILABLE_LIQUIDITY_NOT_ENOUGH = '4';
498	 string public constant VL_NOT_ENOUGH_AVAILABLE_USER_BALANCE = '5';
499	 string public constant VL_TRANSFER_NOT_ALLOWED = '6';
500	 string public constant VL_BORROWING_NOT_ENABLED = '7';
501	 string public constant VL_INVALID_INTEREST_RATE_MODE_SELECTED = '8';
502	 string public constant VL_COLLATERAL_BALANCE_IS_0 = '9';
503	 string public constant VL_HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD = '10';
504	 string public constant VL_COLLATERAL_CANNOT_COVER_NEW_BORROW = '11';
505	 string public constant VL_STABLE_BORROWING_NOT_ENABLED = '12';
506	 string public constant VL_COLLATERAL_SAME_AS_BORROWING_CURRENCY = '13';
507	 string public constant VL_AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE = '14';
508	 string public constant VL_NO_DEBT_OF_SELECTED_TYPE = '15';
509	 string public constant VL_NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF = '16';
510	 string public constant VL_NO_STABLE_RATE_LOAN_IN_RESERVE = '17';
511	 string public constant VL_NO_VARIABLE_RATE_LOAN_IN_RESERVE = '18';
512	 string public constant VL_UNDERLYING_BALANCE_NOT_GREATER_THAN_0 = '19';
513	 string public constant VL_DEPOSIT_ALREADY_IN_USE = '20';
514	 string public constant LP_NOT_ENOUGH_STABLE_BORROW_BALANCE = '21';
515	 string public constant LP_INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET = '22';
516	 string public constant LP_LIQUIDATION_CALL_FAILED = '23';
517	 string public constant LP_NOT_ENOUGH_LIQUIDITY_TO_BORROW = '24';
518	 string public constant LP_REQUESTED_AMOUNT_TOO_SMALL = '25';
519	 string public constant LP_INCONSISTENT_PROTOCOL_ACTUAL_BALANCE = '26';
520	 string public constant LP_CALLER_NOT_LENDING_POOL_CONFIGURATOR = '27';
521	 string public constant LP_INCONSISTENT_FLASHLOAN_PARAMS = '28';
522	 string public constant CT_CALLER_MUST_BE_LENDING_POOL = '29';
523	 string public constant CT_CANNOT_GIVE_ALLOWANCE_TO_HIMSELF = '30';
524	 string public constant CT_TRANSFER_AMOUNT_NOT_GT_0 = '31';
525	 string public constant RL_RESERVE_ALREADY_INITIALIZED = '32';
526	 string public constant LPC_RESERVE_LIQUIDITY_NOT_0 = '34';
527	 string public constant LPC_INVALID_ATOKEN_POOL_ADDRESS = '35';
528	 string public constant LPC_INVALID_STABLE_DEBT_TOKEN_POOL_ADDRESS = '36';
529	 string public constant LPC_INVALID_VARIABLE_DEBT_TOKEN_POOL_ADDRESS = '37';
530	 string public constant LPC_INVALID_STABLE_DEBT_TOKEN_UNDERLYING_ADDRESS = '38';
531	 string public constant LPC_INVALID_VARIABLE_DEBT_TOKEN_UNDERLYING_ADDRESS = '39';
532	 string public constant LPC_INVALID_ADDRESSES_PROVIDER_ID = '40';
533	 string public constant LPC_INVALID_CONFIGURATION = '75';
534	 string public constant LPC_CALLER_NOT_EMERGENCY_ADMIN = '76';
535	 string public constant LPAPR_PROVIDER_NOT_REGISTERED = '41';
536	 string public constant LPCM_HEALTH_FACTOR_NOT_BELOW_THRESHOLD = '42';
537	 string public constant LPCM_COLLATERAL_CANNOT_BE_LIQUIDATED = '43';
538	 string public constant LPCM_SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER = '44';
539	 string public constant LPCM_NOT_ENOUGH_LIQUIDITY_TO_LIQUIDATE = '45';
540	 string public constant LPCM_NO_ERRORS = '46';
541	 string public constant LP_INVALID_FLASHLOAN_MODE = '47';
542	 string public constant MATH_MULTIPLICATION_OVERFLOW = '48';
543	 string public constant MATH_ADDITION_OVERFLOW = '49';
544	 string public constant MATH_DIVISION_BY_ZERO = '50';
545	 string public constant RL_LIQUIDITY_INDEX_OVERFLOW = '51';
546	 string public constant RL_VARIABLE_BORROW_INDEX_OVERFLOW = '52';
547	 string public constant RL_LIQUIDITY_RATE_OVERFLOW = '53';
548	 string public constant RL_VARIABLE_BORROW_RATE_OVERFLOW = '54';
549	 string public constant RL_STABLE_BORROW_RATE_OVERFLOW = '55';
550	 string public constant CT_INVALID_MINT_AMOUNT = '56';
551	 string public constant LP_FAILED_REPAY_WITH_COLLATERAL = '57';
552	 string public constant CT_INVALID_BURN_AMOUNT = '58';
553	 string public constant LP_FAILED_COLLATERAL_SWAP = '60';
554	 string public constant LP_INVALID_EQUAL_ASSETS_TO_SWAP = '61';
555	 string public constant LP_REENTRANCY_NOT_ALLOWED = '62';
556	 string public constant LP_CALLER_MUST_BE_AN_ATOKEN = '63';
557	 string public constant LP_IS_PAUSED = '64';
558	 string public constant LP_NO_MORE_RESERVES_ALLOWED = '65';
559	 string public constant LP_INVALID_FLASH_LOAN_EXECUTOR_RETURN = '66';
560	 string public constant RC_INVALID_LTV = '67';
561	 string public constant RC_INVALID_LIQ_THRESHOLD = '68';
562	 string public constant RC_INVALID_LIQ_BONUS = '69';
563	 string public constant RC_INVALID_DECIMALS = '70';
564	 string public constant RC_INVALID_RESERVE_FACTOR = '71';
565	 string public constant LPAPR_INVALID_ADDRESSES_PROVIDER_ID = '72';
566	 string public constant VL_INCONSISTENT_FLASHLOAN_PARAMS = '73';
567	 string public constant LP_INCONSISTENT_PARAMS_LENGTH = '74';
568	 string public constant UL_INVALID_INDEX = '77';
569	 string public constant LP_NOT_CONTRACT = '78';
570	 string public constant SDT_STABLE_DEBT_OVERFLOW = '79';
571	 string public constant SDT_BURN_EXCEEDS_BALANCE = '80';
572	 enum CollateralManagerErrors {
573	 NO_ERROR, NO_COLLATERAL_AVAILABLE, COLLATERAL_CANNOT_BE_LIQUIDATED, CURRRENCY_NOT_BORROWED, HEALTH_FACTOR_ABOVE_THRESHOLD, NOT_ENOUGH_LIQUIDITY, NO_ACTIVE_RESERVE, HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD, INVALID_EQUAL_ASSETS_TO_SWAP, FROZEN_RESERVE }
574	 }
575	 pragma solidity 0.6.12;
576	 library MathUtils {
577	 using SafeMath for uint256;
578	 using WadRayMath for uint256;
579	 uint256 internal constant SECONDS_PER_YEAR = 365 days;
580	 function calculateLinearInterest(uint256 rate, uint40 lastUpdateTimestamp) internal view returns (uint256) {
581	 uint256 timeDifference = block.timestamp.sub(uint256(lastUpdateTimestamp));
582	 return (rate.mul(timeDifference) / SECONDS_PER_YEAR).add(WadRayMath.ray());
583	 }
584	 function calculateCompoundedInterest( uint256 rate, uint40 lastUpdateTimestamp, uint256 currentTimestamp ) internal pure returns (uint256) {
585	 uint256 exp = currentTimestamp.sub(uint256(lastUpdateTimestamp));
586	 if (exp == 0) {
587	 return WadRayMath.ray();
588	 }
589	 uint256 expMinusOne = exp - 1;
590	 uint256 expMinusTwo = exp > 2 ? exp - 2 : 0;
591	 uint256 ratePerSecond = rate / SECONDS_PER_YEAR;
592	 uint256 basePowerTwo = ratePerSecond.rayMul(ratePerSecond);
593	 uint256 basePowerThree = basePowerTwo.rayMul(ratePerSecond);
594	 uint256 secondTerm = exp.mul(expMinusOne).mul(basePowerTwo) / 2;
595	 uint256 thirdTerm = exp.mul(expMinusOne).mul(expMinusTwo).mul(basePowerThree) / 6;
596	 return WadRayMath.ray().add(ratePerSecond.mul(exp)).add(secondTerm).add(thirdTerm);
597	 }
598	 function calculateCompoundedInterest(uint256 rate, uint40 lastUpdateTimestamp) internal view returns (uint256) {
599	 return calculateCompoundedInterest(rate, lastUpdateTimestamp, block.timestamp);
600	 }
601	 }
602	 pragma solidity 0.6.12;
603	 library WadRayMath {
604	 uint256 internal constant WAD = 1e18;
605	 uint256 internal constant halfWAD = WAD / 2;
606	 uint256 internal constant RAY = 1e27;
607	 uint256 internal constant halfRAY = RAY / 2;
608	 uint256 internal constant WAD_RAY_RATIO = 1e9;
609	 function ray() internal pure returns (uint256) {
610	 return RAY;
611	 }
612	 function wad() internal pure returns (uint256) {
613	 return WAD;
614	 }
615	 function halfRay() internal pure returns (uint256) {
616	 return halfRAY;
617	 }
618	 function halfWad() internal pure returns (uint256) {
619	 return halfWAD;
620	 }
621	 function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {
622	 if (a == 0 || b == 0) {
623	 return 0;
624	 }
625	 require(a <= (type(uint256).max - halfWAD) / b, Errors.MATH_MULTIPLICATION_OVERFLOW);
626	 return (a * b + halfWAD) / WAD;
627	 }
628	 function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {
629	 require(b != 0, Errors.MATH_DIVISION_BY_ZERO);
630	 uint256 halfB = b / 2;
631	 require(a <= (type(uint256).max - halfB) / WAD, Errors.MATH_MULTIPLICATION_OVERFLOW);
632	 return (a * WAD + halfB) / b;
633	 }
634	 function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {
635	 if (a == 0 || b == 0) {
636	 return 0;
637	 }
638	 require(a <= (type(uint256).max - halfRAY) / b, Errors.MATH_MULTIPLICATION_OVERFLOW);
639	 return (a * b + halfRAY) / RAY;
640	 }
641	 function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {
642	 require(b != 0, Errors.MATH_DIVISION_BY_ZERO);
643	 uint256 halfB = b / 2;
644	 require(a <= (type(uint256).max - halfB) / RAY, Errors.MATH_MULTIPLICATION_OVERFLOW);
645	 return (a * RAY + halfB) / b;
646	 }
647	 function rayToWad(uint256 a) internal pure returns (uint256) {
648	 uint256 halfRatio = WAD_RAY_RATIO / 2;
649	 uint256 result = halfRatio + a;
650	 require(result >= halfRatio, Errors.MATH_ADDITION_OVERFLOW);
651	 return result / WAD_RAY_RATIO;
652	 }
653	 function wadToRay(uint256 a) internal pure returns (uint256) {
654	 uint256 result = a * WAD_RAY_RATIO;
655	 require(result / WAD_RAY_RATIO == a, Errors.MATH_MULTIPLICATION_OVERFLOW);
656	 return result;
657	 }
658	 }
659	 pragma solidity 0.6.12;
660	 library PercentageMath {
661	 uint256 constant PERCENTAGE_FACTOR = 1e4;
662	 uint256 constant HALF_PERCENT = PERCENTAGE_FACTOR / 2;
663	 function percentMul(uint256 value, uint256 percentage) internal pure returns (uint256) {
664	 if (value == 0 || percentage == 0) {
665	 return 0;
666	 }
667	 require( value <= (type(uint256).max - HALF_PERCENT) / percentage, Errors.MATH_MULTIPLICATION_OVERFLOW );
668	 return (value * percentage + HALF_PERCENT) / PERCENTAGE_FACTOR;
669	 }
670	 function percentDiv(uint256 value, uint256 percentage) internal pure returns (uint256) {
671	 require(percentage != 0, Errors.MATH_DIVISION_BY_ZERO);
672	 uint256 halfPercentage = percentage / 2;
673	 require( value <= (type(uint256).max - halfPercentage) / PERCENTAGE_FACTOR, Errors.MATH_MULTIPLICATION_OVERFLOW );
674	 return (value * PERCENTAGE_FACTOR + halfPercentage) / percentage;
675	 }
676	 }
