row number 
1	  pragma abicoder v2;
2	 pragma solidity 0.7.6;
3	 interface IERC20 {
4	 function totalSupply() external view returns (uint256);
5	 function balanceOf(address account) external view returns (uint256);
6	 function transfer(address recipient, uint256 amount) external returns (bool);
7	 function allowance(address owner, address spender) external view returns (uint256);
8	 function approve(address spender, uint256 amount) external returns (bool);
9	 function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
10	 event Transfer(address indexed from, address indexed to, uint256 value);
11	 event Approval(address indexed owner, address indexed spender, uint256 value);
12	 }
13	 interface IPopsicleV3Optimizer {
14	 function token0() external view returns (address);
15	 function token1() external view returns (address);
16	 function tickSpacing() external view returns (int24);
17	 function pool() external view returns (IUniswapV3Pool);
18	 function tickLower() external view returns (int24);
19	 function tickUpper() external view returns (int24);
20	 function deposit(uint256 amount0Desired, uint256 amount1Desired, address to) external returns (uint256 shares, uint256 amount0,uint256 amount1);
21	 function withdraw(uint256 shares, address to) external returns (uint256 amount0, uint256 amount1);
22	 function rerange() external;
23	 function rebalance() external;
24	 }
25	 interface IOptimizerStrategy {
26	 function maxTotalSupply() external view returns (uint256);
27	 function twapDuration() external view returns (uint32);
28	 function maxTwapDeviation() external view returns (int24);
29	 function tickRangeMultiplier() external view returns (int24);
30	 function priceImpactPercentage() external view returns (uint24);
31	 }
32	 library PositionKey {
33	 function compute( address owner, int24 tickLower, int24 tickUpper ) internal pure returns (bytes32) {
34	 return keccak256(abi.encodePacked(owner, tickLower, tickUpper));
35	 }
36	 }
37	 library TickMath {
38	 int24 internal constant MIN_TICK = -887272;
39	 int24 internal constant MAX_TICK = -MIN_TICK;
40	 uint160 internal constant MIN_SQRT_RATIO = 4295128739;
41	 uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;
42	 function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {
43	 uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));
44	 require(absTick <= uint256(MAX_TICK), 'T');
45	 uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;
46	 if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;
47	 if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;
48	 if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;
49	 if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;
50	 if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;
51	 if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;
52	 if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;
53	 if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;
54	 if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;
55	 if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;
56	 if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;
57	 if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;
58	 if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;
59	 if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;
60	 if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;
61	 if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;
62	 if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;
63	 if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;
64	 if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;
65	 if (tick > 0) ratio = type(uint256).max / ratio;
66	 sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));
67	 }
68	 function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {
69	 require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');
70	 uint256 ratio = uint256(sqrtPriceX96) << 32;
71	 uint256 r = ratio;
72	 uint256 msb = 0;
73	 assembly {
74	 let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) msb := or(msb, f) r := shr(f, r) }
75	 assembly {
76	 let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF)) msb := or(msb, f) r := shr(f, r) }
77	 assembly {
78	 let f := shl(5, gt(r, 0xFFFFFFFF)) msb := or(msb, f) r := shr(f, r) }
79	 assembly {
80	 let f := shl(4, gt(r, 0xFFFF)) msb := or(msb, f) r := shr(f, r) }
81	 assembly {
82	 let f := shl(3, gt(r, 0xFF)) msb := or(msb, f) r := shr(f, r) }
83	 assembly {
84	 let f := shl(2, gt(r, 0xF)) msb := or(msb, f) r := shr(f, r) }
85	 assembly {
86	 let f := shl(1, gt(r, 0x3)) msb := or(msb, f) r := shr(f, r) }
87	 assembly {
88	 let f := gt(r, 0x1) msb := or(msb, f) }
89	 if (msb >= 128) r = ratio >> (msb - 127);
90	 else r = ratio << (127 - msb);
91	 int256 log_2 = (int256(msb) - 128) << 64;
92	 assembly {
93	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(63, f)) r := shr(f, r) }
94	 assembly {
95	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(62, f)) r := shr(f, r) }
96	 assembly {
97	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(61, f)) r := shr(f, r) }
98	 assembly {
99	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(60, f)) r := shr(f, r) }
100	 assembly {
101	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(59, f)) r := shr(f, r) }
102	 assembly {
103	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(58, f)) r := shr(f, r) }
104	 assembly {
105	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(57, f)) r := shr(f, r) }
106	 assembly {
107	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(56, f)) r := shr(f, r) }
108	 assembly {
109	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(55, f)) r := shr(f, r) }
110	 assembly {
111	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(54, f)) r := shr(f, r) }
112	 assembly {
113	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(53, f)) r := shr(f, r) }
114	 assembly {
115	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(52, f)) r := shr(f, r) }
116	 assembly {
117	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(51, f)) r := shr(f, r) }
118	 assembly {
119	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(50, f)) }
120	 int256 log_sqrt10001 = log_2 * 255738958999603826347141;
121	 int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);
122	 int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);
123	 tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;
124	 }
125	 }
126	 library LiquidityAmounts {
127	 function toUint128(uint256 x) private pure returns (uint128 y) {
128	 require((y = uint128(x)) == x);
129	 }
130	 function getLiquidityForAmount0( uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint256 amount0 ) internal pure returns (uint128 liquidity) {
131	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
132	 uint256 intermediate = FullMath.mulDiv(sqrtRatioAX96, sqrtRatioBX96, FixedPoint96.Q96);
133	 return toUint128(FullMath.mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));
134	 }
135	 function getLiquidityForAmount1( uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint256 amount1 ) internal pure returns (uint128 liquidity) {
136	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
137	 return toUint128(FullMath.mulDiv(amount1, FixedPoint96.Q96, sqrtRatioBX96 - sqrtRatioAX96));
138	 }
139	 function getLiquidityForAmounts( uint160 sqrtRatioX96, uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint256 amount0, uint256 amount1 ) internal pure returns (uint128 liquidity) {
140	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
141	 if (sqrtRatioX96 <= sqrtRatioAX96) {
142	 liquidity = getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);
143	 }
144	 else if (sqrtRatioX96 < sqrtRatioBX96) {
145	 uint128 liquidity0 = getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);
146	 uint128 liquidity1 = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);
147	 liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;
148	 }
149	 else {
150	 liquidity = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);
151	 }
152	 }
153	 function getAmount0ForLiquidity( uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity ) internal pure returns (uint256 amount0) {
154	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
155	 return FullMath.mulDiv( uint256(liquidity) << FixedPoint96.RESOLUTION, sqrtRatioBX96 - sqrtRatioAX96, sqrtRatioBX96 ) / sqrtRatioAX96;
156	 }
157	 function getAmount1ForLiquidity( uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity ) internal pure returns (uint256 amount1) {
158	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
159	 return FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);
160	 }
161	 function getAmountsForLiquidity( uint160 sqrtRatioX96, uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity ) internal pure returns (uint256 amount0, uint256 amount1) {
162	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
163	 if (sqrtRatioX96 <= sqrtRatioAX96) {
164	 amount0 = getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);
165	 }
166	 else if (sqrtRatioX96 < sqrtRatioBX96) {
167	 amount0 = getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);
168	 amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);
169	 }
170	 else {
171	 amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);
172	 }
173	 }
174	 }
175	 library PoolVariables {
176	 using LowGasSafeMath for uint256;
177	 using LowGasSafeMath for uint128;
178	 struct Info {
179	 uint256 amount0Desired;
180	 uint256 amount1Desired;
181	 uint256 amount0;
182	 uint256 amount1;
183	 uint128 liquidity;
184	 int24 tickLower;
185	 int24 tickUpper;
186	 }
187	 function amountsForLiquidity( IUniswapV3Pool pool, uint128 liquidity, int24 _tickLower, int24 _tickUpper ) internal view returns (uint256, uint256) {
188	 (uint160 sqrtRatioX96, , , , , , ) = pool.slot0();
189	 return LiquidityAmounts.getAmountsForLiquidity( sqrtRatioX96, TickMath.getSqrtRatioAtTick(_tickLower), TickMath.getSqrtRatioAtTick(_tickUpper), liquidity );
190	 }
191	 function liquidityForAmounts( IUniswapV3Pool pool, uint256 amount0, uint256 amount1, int24 _tickLower, int24 _tickUpper ) internal view returns (uint128) {
192	 (uint160 sqrtRatioX96, , , , , , ) = pool.slot0();
193	 return LiquidityAmounts.getLiquidityForAmounts( sqrtRatioX96, TickMath.getSqrtRatioAtTick(_tickLower), TickMath.getSqrtRatioAtTick(_tickUpper), amount0, amount1 );
194	 }
195	 function usersAmounts(IUniswapV3Pool pool, int24 _tickLower, int24 _tickUpper) internal view returns (uint256 amount0, uint256 amount1) {
196	 bytes32 positionKey = PositionKey.compute(address(this), _tickLower, _tickUpper);
197	 (uint128 liquidity, , , uint128 tokensOwed0, uint128 tokensOwed1) = pool.positions(positionKey);
198	 (amount0, amount1) = amountsForLiquidity(pool, liquidity, _tickLower, _tickUpper);
199	 amount0 = amount0.add(tokensOwed0);
200	 amount1 = amount1.add(tokensOwed1);
201	 }
202	 function positionLiquidity(IUniswapV3Pool pool, int24 _tickLower, int24 _tickUpper) internal view returns (uint128 liquidity) {
203	 bytes32 positionKey = PositionKey.compute(address(this), _tickLower, _tickUpper);
204	 (liquidity, , , , ) = pool.positions(positionKey);
205	 }
206	 function checkRange(int24 tickLower, int24 tickUpper) internal pure {
207	 require(tickLower < tickUpper, "TLU");
208	 require(tickLower >= TickMath.MIN_TICK, "TLM");
209	 require(tickUpper <= TickMath.MAX_TICK, "TUM");
210	 }
211	 function floor(int24 tick, int24 tickSpacing) internal pure returns (int24) {
212	 int24 compressed = tick / tickSpacing;
213	 if (tick < 0 && tick % tickSpacing != 0) compressed--;
214	 return compressed * tickSpacing;
215	 }
216	 function getPositionTicks(IUniswapV3Pool pool, uint256 amount0Desired, uint256 amount1Desired, int24 baseThreshold, int24 tickSpacing) internal view returns(int24 tickLower, int24 tickUpper) {
217	 Info memory cache = Info(amount0Desired, amount1Desired, 0, 0, 0, 0, 0);
218	 ( uint160 sqrtPriceX96, int24 currentTick, , , , , ) = pool.slot0();
219	 (cache.tickLower, cache.tickUpper) = baseTicks(currentTick, baseThreshold, tickSpacing);
220	 (cache.amount0, cache.amount1) = amountsForTicks(pool, cache.amount0Desired, cache.amount1Desired, cache.tickLower, cache.tickUpper);
221	 cache.liquidity = liquidityForAmounts(pool, cache.amount0, cache.amount1, cache.tickLower, cache.tickUpper);
222	 bool zeroGreaterOne = amountsDirection(cache.amount0Desired, cache.amount1Desired, cache.amount0, cache.amount1);
223	 if ( zeroGreaterOne) {
224	 uint160 nextSqrtPrice0 = SqrtPriceMath.getNextSqrtPriceFromAmount0RoundingUp(sqrtPriceX96, cache.liquidity, cache.amount0Desired, false);
225	 cache.tickUpper = PoolVariables.floor(TickMath.getTickAtSqrtRatio(nextSqrtPrice0), tickSpacing);
226	 }
227	 else{
228	 uint160 nextSqrtPrice1 = SqrtPriceMath.getNextSqrtPriceFromAmount1RoundingDown(sqrtPriceX96, cache.liquidity, cache.amount1Desired, false);
229	 cache.tickLower = PoolVariables.floor(TickMath.getTickAtSqrtRatio(nextSqrtPrice1), tickSpacing);
230	 }
231	 checkRange(cache.tickLower, cache.tickUpper);
232	 tickLower = cache.tickLower;
233	 tickUpper = cache.tickUpper;
234	 }
235	 function amountsForTicks(IUniswapV3Pool pool, uint256 amount0Desired, uint256 amount1Desired, int24 _tickLower, int24 _tickUpper) internal view returns(uint256 amount0, uint256 amount1) {
236	 uint128 liquidity = liquidityForAmounts(pool, amount0Desired, amount1Desired, _tickLower, _tickUpper);
237	 (amount0, amount1) = amountsForLiquidity(pool, liquidity, _tickLower, _tickUpper);
238	 }
239	 function baseTicks(int24 currentTick, int24 baseThreshold, int24 tickSpacing) internal pure returns(int24 tickLower, int24 tickUpper) {
240	 int24 tickFloor = floor(currentTick, tickSpacing);
241	 tickLower = tickFloor - baseThreshold;
242	 tickUpper = tickFloor + baseThreshold;
243	 }
244	 function amountsDirection(uint256 amount0Desired, uint256 amount1Desired, uint256 amount0, uint256 amount1) internal pure returns (bool zeroGreaterOne) {
245	 zeroGreaterOne = amount0Desired.sub(amount0).mul(amount1Desired) > amount1Desired.sub(amount1).mul(amount0Desired) ? true : false;
246	 }
247	 function checkDeviation(IUniswapV3Pool pool, int24 maxTwapDeviation, uint32 twapDuration) internal view {
248	 (, int24 currentTick, , , , , ) = pool.slot0();
249	 int24 twap = getTwap(pool, twapDuration);
250	 int24 deviation = currentTick > twap ? currentTick - twap : twap - currentTick;
251	 require(deviation <= maxTwapDeviation, "PSC");
252	 }
253	 function getTwap(IUniswapV3Pool pool, uint32 twapDuration) internal view returns (int24) {
254	 uint32 _twapDuration = twapDuration;
255	 uint32[] memory secondsAgo = new uint32[](2);
256	 secondsAgo[0] = _twapDuration;
257	 secondsAgo[1] = 0;
258	 (int56[] memory tickCumulatives, ) = pool.observe(secondsAgo);
259	 return int24((tickCumulatives[1] - tickCumulatives[0]) / _twapDuration);
260	 }
261	 }
262	 interface IUniswapV3PoolActions {
263	 function mint( address recipient, int24 tickLower, int24 tickUpper, uint128 amount, bytes calldata data ) external returns (uint256 amount0, uint256 amount1);
264	 function collect( address recipient, int24 tickLower, int24 tickUpper, uint128 amount0Requested, uint128 amount1Requested ) external returns (uint128 amount0, uint128 amount1);
265	 function burn( int24 tickLower, int24 tickUpper, uint128 amount ) external returns (uint256 amount0, uint256 amount1);
266	 function swap( address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes calldata data ) external returns (int256 amount0, int256 amount1);
267	 }
268	 interface IUniswapV3PoolDerivedState {
269	 function observe(uint32[] calldata secondsAgos) external view returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);
270	 }
271	 interface IUniswapV3PoolState {
272	 function slot0() external view returns ( uint160 sqrtPriceX96, int24 tick, uint16 observationIndex, uint16 observationCardinality, uint16 observationCardinalityNext, uint8 feeProtocol, bool unlocked );
273	 function positions(bytes32 key) external view returns ( uint128 _liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, uint128 tokensOwed0, uint128 tokensOwed1 );
274	 }
275	 interface IUniswapV3PoolImmutables {
276	 function token0() external view returns (address);
277	 function token1() external view returns (address);
278	 function tickSpacing() external view returns (int24);
279	 }
280	 interface IUniswapV3Pool is IUniswapV3PoolImmutables, IUniswapV3PoolState, IUniswapV3PoolDerivedState, IUniswapV3PoolActions {
281	 }
282	 library PoolActions {
283	 using PoolVariables for IUniswapV3Pool;
284	 using LowGasSafeMath for uint256;
285	 using SafeCast for uint256;
286	 function burnLiquidityShare( IUniswapV3Pool pool, int24 tickLower, int24 tickUpper, uint256 totalSupply, uint256 share, address to ) internal returns (uint256 amount0, uint256 amount1) {
287	 require(totalSupply > 0, "TS");
288	 uint128 liquidityInPool = pool.positionLiquidity(tickLower, tickUpper);
289	 uint256 liquidity = uint256(liquidityInPool).mul(share) / totalSupply;
290	 if (liquidity > 0) {
291	 (amount0, amount1) = pool.burn(tickLower, tickUpper, liquidity.toUint128());
292	 if (amount0 > 0 || amount1 > 0) {
293	 (amount0, amount1) = pool.collect( to, tickLower, tickUpper, amount0.toUint128(), amount1.toUint128() );
294	 }
295	 }
296	 }
297	 function burnAllLiquidity( IUniswapV3Pool pool, int24 tickLower, int24 tickUpper ) internal {
298	 uint128 liquidity = pool.positionLiquidity(tickLower, tickUpper);
299	 if (liquidity > 0) {
300	 pool.burn(tickLower, tickUpper, liquidity);
301	 }
302	 pool.collect( address(this), tickLower, tickUpper, type(uint128).max, type(uint128).max );
303	 }
304	 }
305	 library Counters {
306	 using LowGasSafeMath for uint256;
307	 struct Counter {
308	 uint256 _value;
309	 }
310	 function current(Counter storage counter) internal view returns (uint256) {
311	 return counter._value;
312	 }
313	 function increment(Counter storage counter) internal {
314	 counter._value += 1;
315	 }
316	 }
317	 library ChainId {
318	 function get() internal pure returns (uint256 chainId) {
319	 assembly {
320	 chainId := chainid() }
321	 }
322	 }
323	 library ECDSA {
324	 function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {
325	 require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, "ISS");
326	 require(v == 27 || v == 28, "ISV");
327	 address signer = ecrecover(hash, v, r, s);
328	 require(signer != address(0), "IS");
329	 return signer;
330	 }
331	 function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {
332	 return keccak256(abi.encodePacked("\x19\x01", domainSeparator, structHash));
333	 }
334	 }
335	 abstract contract EIP712 {
336	 bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;
337	 uint256 private immutable _CACHED_CHAIN_ID;
338	 bytes32 private immutable _HASHED_NAME;
339	 bytes32 private immutable _HASHED_VERSION;
340	 bytes32 private immutable _TYPE_HASH;
341	 constructor(string memory name, string memory version) {
342	 bytes32 hashedName = keccak256(bytes(name));
343	 bytes32 hashedVersion = keccak256(bytes(version));
344	 bytes32 typeHash = keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");
345	 _HASHED_NAME = hashedName;
346	 _HASHED_VERSION = hashedVersion;
347	 _CACHED_CHAIN_ID = ChainId.get();
348	 _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);
349	 _TYPE_HASH = typeHash;
350	 }
351	 function _domainSeparatorV4() internal view returns (bytes32) {
352	 if (ChainId.get() == _CACHED_CHAIN_ID) {
353	 return _CACHED_DOMAIN_SEPARATOR;
354	 }
355	 else {
356	 return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);
357	 }
358	 }
359	 function _buildDomainSeparator(bytes32 typeHash, bytes32 name, bytes32 version) private view returns (bytes32) {
360	 return keccak256( abi.encode( typeHash, name, version, ChainId.get(), address(this) ) );
361	 }
362	 function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {
363	 return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);
364	 }
365	 }
366	 interface IERC20Permit {
367	 function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;
368	 function nonces(address owner) external view returns (uint256);
369	 function DOMAIN_SEPARATOR() external view returns (bytes32);
370	 }
371	 abstract contract Context {
372	 function _msgSender() internal view virtual returns (address payable) {
373	 return msg.sender;
374	 }
375	 function _msgData() internal view virtual returns (bytes memory) {
376	 this;
377	 return msg.data;
378	 }
379	 }
380	 contract ERC20 is Context, IERC20 {
381	 using LowGasSafeMath for uint256;
382	 mapping (address => uint256) private _balances;
383	 mapping (address => mapping (address => uint256)) private _allowances;
384	 uint256 private _totalSupply;
385	 string private _name;
386	 string private _symbol;
387	 uint8 private _decimals;
388	 constructor (string memory name_, string memory symbol_) {
389	 _name = name_;
390	 _symbol = symbol_;
391	 _decimals = 18;
392	 }
393	 function name() public view virtual returns (string memory) {
394	 return _name;
395	 }
396	 function symbol() public view virtual returns (string memory) {
397	 return _symbol;
398	 }
399	 function decimals() public view virtual returns (uint8) {
400	 return _decimals;
401	 }
402	 function totalSupply() public view virtual override returns (uint256) {
403	 return _totalSupply;
404	 }
405	 function balanceOf(address account) public view virtual override returns (uint256) {
406	 return _balances[account];
407	 }
408	 function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
409	 _transfer(_msgSender(), recipient, amount);
410	 return true;
411	 }
412	 function allowance(address owner, address spender) public view virtual override returns (uint256) {
413	 return _allowances[owner][spender];
414	 }
415	 function approve(address spender, uint256 amount) public virtual override returns (bool) {
416	 _approve(_msgSender(), spender, amount);
417	 return true;
418	 }
419	 function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
420	 _transfer(sender, recipient, amount);
421	 _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "TEA"));
422	 return true;
423	 }
424	 function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
425	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
426	 return true;
427	 }
428	 function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
429	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "DEB"));
430	 return true;
431	 }
432	 function _transfer(address sender, address recipient, uint256 amount) internal virtual {
433	 require(sender != address(0), "FZA");
434	 require(recipient != address(0), "TZA");
435	 _beforeTokenTransfer(sender, recipient, amount);
436	 _balances[sender] = _balances[sender].sub(amount, "TEB");
437	 _balances[recipient] = _balances[recipient].add(amount);
438	 emit Transfer(sender, recipient, amount);
439	 }
440	 function _mint(address account, uint256 amount) internal virtual {
441	 require(account != address(0), "MZA");
442	 _beforeTokenTransfer(address(0), account, amount);
443	 _totalSupply = _totalSupply.add(amount);
444	 _balances[account] = _balances[account].add(amount);
445	 emit Transfer(address(0), account, amount);
446	 }
447	 function _burn(address account, uint256 amount) internal virtual {
448	 require(account != address(0), "BZA");
449	 _beforeTokenTransfer(account, address(0), amount);
450	 _balances[account] = _balances[account].sub(amount, "BEB");
451	 _totalSupply = _totalSupply.sub(amount);
452	 emit Transfer(account, address(0), amount);
453	 }
454	 function _approve(address owner, address spender, uint256 amount) internal virtual {
455	 require(owner != address(0), "AFZA");
456	 require(spender != address(0), "ATZA");
457	 _allowances[owner][spender] = amount;
458	 emit Approval(owner, spender, amount);
459	 }
460	 function _setupDecimals(uint8 decimals_) internal virtual {
461	 _decimals = decimals_;
462	 }
463	 function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {
464	 }
465	 }
466	 abstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {
467	 using Counters for Counters.Counter;
468	 mapping (address => Counters.Counter) private _nonces;
469	 bytes32 private immutable _PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;
470	 constructor(string memory name) EIP712(name, "1") {
471	 }
472	 function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public virtual override {
473	 require(block.timestamp <= deadline, "ED");
474	 bytes32 structHash = keccak256( abi.encode( _PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline ) );
475	 bytes32 hash = _hashTypedDataV4(structHash);
476	 address signer = ECDSA.recover(hash, v, r, s);
477	 require(signer == owner, "IS");
478	 _approve(owner, spender, value);
479	 }
480	 function nonces(address owner) public view virtual override returns (uint256) {
481	 return _nonces[owner].current();
482	 }
483	 function DOMAIN_SEPARATOR() external view override returns (bytes32) {
484	 return _domainSeparatorV4();
485	 }
486	 function _useNonce(address owner) internal virtual returns (uint256 current) {
487	 Counters.Counter storage nonce = _nonces[owner];
488	 current = nonce.current();
489	 nonce.increment();
490	 }
491	 }
492	 library FixedPoint96 {
493	 uint8 internal constant RESOLUTION = 96;
494	 uint256 internal constant Q96 = 0x1000000000000000000000000;
495	 }
496	 library UnsafeMath {
497	 function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {
498	 assembly {
499	 z := add(div(x, y), gt(mod(x, y), 0)) }
500	 }
501	 function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {
502	 assembly {
503	 z := div(x, y) }
504	 }
505	 }
506	 library FullMath {
507	 function mulDiv( uint256 a, uint256 b, uint256 denominator ) internal pure returns (uint256 result) {
508	 uint256 prod0;
509	 uint256 prod1;
510	 assembly {
511	 let mm := mulmod(a, b, not(0)) prod0 := mul(a, b) prod1 := sub(sub(mm, prod0), lt(mm, prod0)) }
512	 if (prod1 == 0) {
513	 require(denominator > 0);
514	 assembly {
515	 result := div(prod0, denominator) }
516	 return result;
517	 }
518	 require(denominator > prod1);
519	 uint256 remainder;
520	 assembly {
521	 remainder := mulmod(a, b, denominator) }
522	 assembly {
523	 prod1 := sub(prod1, gt(remainder, prod0)) prod0 := sub(prod0, remainder) }
524	 uint256 twos = -denominator & denominator;
525	 assembly {
526	 denominator := div(denominator, twos) }
527	 assembly {
528	 prod0 := div(prod0, twos) }
529	 assembly {
530	 twos := add(div(sub(0, twos), twos), 1) }
531	 prod0 |= prod1 * twos;
532	 uint256 inv = (3 * denominator) ^ 2;
533	 inv *= 2 - denominator * inv;
534	 inv *= 2 - denominator * inv;
535	 inv *= 2 - denominator * inv;
536	 inv *= 2 - denominator * inv;
537	 inv *= 2 - denominator * inv;
538	 inv *= 2 - denominator * inv;
539	 result = prod0 * inv;
540	 return result;
541	 }
542	 function mulDivRoundingUp( uint256 a, uint256 b, uint256 denominator ) internal pure returns (uint256 result) {
543	 result = mulDiv(a, b, denominator);
544	 if (mulmod(a, b, denominator) > 0) {
545	 require(result < type(uint256).max);
546	 result++;
547	 }
548	 }
549	 }
550	 library SafeCast {
551	 function toUint160(uint256 y) internal pure returns (uint160 z) {
552	 require((z = uint160(y)) == y);
553	 }
554	 function toUint128(uint256 y) internal pure returns (uint128 z) {
555	 require((z = uint128(y)) == y);
556	 }
557	 function toInt128(int256 y) internal pure returns (int128 z) {
558	 require((z = int128(y)) == y);
559	 }
560	 function toInt256(uint256 y) internal pure returns (int256 z) {
561	 require(y < 2**255);
562	 z = int256(y);
563	 }
564	 }
565	 library LowGasSafeMath {
566	 function add(uint256 x, uint256 y) internal pure returns (uint256 z) {
567	 require((z = x + y) >= x);
568	 }
569	 function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {
570	 require((z = x - y) <= x);
571	 }
572	 function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {
573	 require(x == 0 || (z = x * y) / x == y);
574	 }
575	 function sub(uint256 x, uint256 y, string memory errorMessage) internal pure returns (uint256 z) {
576	 require((z = x - y) <= x, errorMessage);
577	 }
578	 function add(int256 x, int256 y) internal pure returns (int256 z) {
579	 require((z = x + y) >= x == (y >= 0));
580	 }
581	 function sub(int256 x, int256 y) internal pure returns (int256 z) {
582	 require((z = x - y) <= x == (y >= 0));
583	 }
584	 function add128(uint128 x, uint128 y) internal pure returns (uint128 z) {
585	 require((z = x + y) >= x);
586	 }
587	 function sub128(uint128 x, uint128 y) internal pure returns (uint128 z) {
588	 require((z = x - y) <= x);
589	 }
590	 function mul128(uint128 x, uint128 y) internal pure returns (uint128 z) {
591	 require(x == 0 || (z = x * y) / x == y);
592	 }
593	 function add160(uint160 x, uint160 y) internal pure returns (uint160 z) {
594	 require((z = x + y) >= x);
595	 }
596	 function sub160(uint160 x, uint160 y) internal pure returns (uint160 z) {
597	 require((z = x - y) <= x);
598	 }
599	 function mul160(uint160 x, uint160 y) internal pure returns (uint160 z) {
600	 require(x == 0 || (z = x * y) / x == y);
601	 }
602	 }
603	 library SqrtPriceMath {
604	 using LowGasSafeMath for uint256;
605	 using SafeCast for uint256;
606	 function getNextSqrtPriceFromAmount0RoundingUp( uint160 sqrtPX96, uint128 liquidity, uint256 amount, bool add ) internal pure returns (uint160) {
607	 if (amount == 0) return sqrtPX96;
608	 uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;
609	 if (add) {
610	 uint256 product;
611	 if ((product = amount * sqrtPX96) / amount == sqrtPX96) {
612	 uint256 denominator = numerator1 + product;
613	 if (denominator >= numerator1) return uint160(FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator));
614	 }
615	 return uint160(UnsafeMath.divRoundingUp(numerator1, (numerator1 / sqrtPX96).add(amount)));
616	 }
617	 else {
618	 uint256 product;
619	 require((product = amount * sqrtPX96) / amount == sqrtPX96 && numerator1 > product);
620	 uint256 denominator = numerator1 - product;
621	 return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator).toUint160();
622	 }
623	 }
624	 function getNextSqrtPriceFromAmount1RoundingDown( uint160 sqrtPX96, uint128 liquidity, uint256 amount, bool add ) internal pure returns (uint160) {
625	 if (add) {
626	 uint256 quotient = ( amount <= type(uint160).max ? (amount << FixedPoint96.RESOLUTION) / liquidity : FullMath.mulDiv(amount, FixedPoint96.Q96, liquidity) );
627	 return uint256(sqrtPX96).add(quotient).toUint160();
628	 }
629	 else {
630	 uint256 quotient = ( amount <= type(uint160).max ? UnsafeMath.divRoundingUp(amount << FixedPoint96.RESOLUTION, liquidity) : FullMath.mulDivRoundingUp(amount, FixedPoint96.Q96, liquidity) );
631	 require(sqrtPX96 > quotient);
632	 return uint160(sqrtPX96 - quotient);
633	 }
634	 }
635	 }
636	 library TransferHelper {
637	 function safeTransferFrom( address token, address from, address to, uint256 value ) internal {
638	 (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));
639	 require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');
640	 }
641	 function safeTransfer( address token, address to, uint256 value ) internal {
642	 (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));
643	 require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');
644	 }
645	 }
646	 abstract contract ReentrancyGuard {
647	 uint256 private constant _NOT_ENTERED = 1;
648	 uint256 private constant _ENTERED = 2;
649	 uint256 private _status;
650	 constructor () {
651	 _status = _NOT_ENTERED;
652	 }
653	 modifier nonReentrant() {
654	 require(_status != _ENTERED, "RC");
655	 _status = _ENTERED;
656	 _;
657	 _status = _NOT_ENTERED;
658	 }
659	 }
660	 contract PopsicleV3Optimizer is ERC20Permit, ReentrancyGuard, IPopsicleV3Optimizer {
661	 using LowGasSafeMath for uint256;
662	 using LowGasSafeMath for uint160;
663	 using LowGasSafeMath for uint128;
664	 using UnsafeMath for uint256;
665	 using SafeCast for uint256;
666	 using PoolVariables for IUniswapV3Pool;
667	 using PoolActions for IUniswapV3Pool;
668	 struct MintCallbackData {
669	 address payer;
670	 }
671	 struct SwapCallbackData {
672	 bool zeroForOne;
673	 }
674	 event Deposit( address indexed sender, address indexed recipient, uint256 share, uint256 amount0, uint256 amount1 );
675	 event Withdraw( address indexed sender, address indexed recipient, uint256 shares, uint256 amount0, uint256 amount1 );
676	 event CollectFees( uint256 feesFromPool0, uint256 feesFromPool1, uint256 usersFees0, uint256 usersFees1 );
677	 event CompoundFees( uint256 amount0, uint256 amount1 );
678	 event Rerange( int24 tickLower, int24 tickUpper, uint256 amount0, uint256 amount1 );
679	 event RewardPaid( address indexed sender, uint256 fees0, uint256 fees1 );
680	 event Snapshot(uint256 totalAmount0, uint256 totalAmount1);
681	 event TransferGovernance(address indexed previousGovernance, address indexed newGovernance);
682	 modifier onlyGovernance {
683	 require(msg.sender == governance, "OG");
684	 _;
685	 }
686	 address public immutable override token0;
687	 address public immutable override token1;
688	 int24 public immutable override tickSpacing;
689	 uint24 constant MULTIPLIER = 1e6;
690	 uint24 constant GLOBAL_DIVISIONER = 1e6;
691	 uint24 constant protocolFee = 1e5;
692	 mapping (address => bool) private _operatorApproved;
693	 IUniswapV3Pool public override pool;
694	 uint256 public protocolFees0;
695	 uint256 public protocolFees1;
696	 uint256 public totalFees0;
697	 uint256 public totalFees1;
698	 address public governance;
699	 address public pendingGovernance;
700	 address public strategy;
701	 int24 public override tickLower;
702	 int24 public override tickUpper;
703	 bool public initialized;
704	 bool private _paused = false;
705	 constructor( address _pool, address _strategy ) ERC20("Popsicle LP V3 MIM/USDC", "PLP") ERC20Permit("Popsicle LP V3 MIM/USDC") {
706	 pool = IUniswapV3Pool(_pool);
707	 strategy = _strategy;
708	 token0 = pool.token0();
709	 token1 = pool.token1();
710	 tickSpacing = pool.tickSpacing();
711	 governance = msg.sender;
712	 _operatorApproved[msg.sender] = true;
713	 }
714	 function init() external onlyGovernance {
715	 require(!initialized, "F");
716	 initialized = true;
717	 int24 baseThreshold = tickSpacing * IOptimizerStrategy(strategy).tickRangeMultiplier();
718	 ( , int24 currentTick, , , , , ) = pool.slot0();
719	 int24 tickFloor = PoolVariables.floor(currentTick, tickSpacing);
720	 tickLower = tickFloor - baseThreshold;
721	 tickUpper = tickFloor + baseThreshold;
722	 PoolVariables.checkRange(tickLower, tickUpper);
723	 }
724	 function deposit( uint256 amount0Desired, uint256 amount1Desired, address to ) external override nonReentrant checkDeviation whenNotPaused returns ( uint256 shares, uint256 amount0, uint256 amount1 ) {
725	 _earnFees();
726	 _compoundFees();
727	 uint128 liquidityLast = pool.positionLiquidity(tickLower, tickUpper);
728	 uint128 liquidity = pool.liquidityForAmounts(amount0Desired, amount1Desired, tickLower, tickUpper);
729	 (amount0, amount1) = pool.mint( address(this), tickLower, tickUpper, liquidity, abi.encode(MintCallbackData({
730	 payer: msg.sender}
731	 )));
732	 require(amount0 > 0 && amount1 > 0, "ANV");
733	 shares = totalSupply() == 0 ? liquidity*MULTIPLIER : FullMath.mulDiv(liquidity, totalSupply(), liquidityLast);
734	 _mint(to, shares);
735	 require(IOptimizerStrategy(strategy).maxTotalSupply() >= totalSupply(), "MTS");
736	 emit Deposit(msg.sender, to, shares, amount0, amount1);
737	 }
738	 function withdraw( uint256 shares, address to ) external override nonReentrant checkDeviation whenNotPaused returns ( uint256 amount0, uint256 amount1 ) {
739	 require(shares > 0, "S");
740	 require(to != address(0), "WZA");
741	 _earnFees();
742	 _compoundFees();
743	 (amount0, amount1) = pool.burnLiquidityShare(tickLower, tickUpper, totalSupply(), shares, to);
744	 require(amount0 > 0 || amount1 > 0, "EA");
745	 _burn(msg.sender, shares);
746	 emit Withdraw(msg.sender, to, shares, amount0, amount1);
747	 }
748	 function rerange() external override nonReentrant checkDeviation {
749	 require(_operatorApproved[msg.sender], "ONA");
750	 _earnFees();
751	 pool.burnAllLiquidity(tickLower, tickUpper);
752	 uint256 balance0 = _balance0();
753	 uint256 balance1 = _balance1();
754	 emit Snapshot(balance0, balance1);
755	 int24 baseThreshold = tickSpacing * IOptimizerStrategy(strategy).tickRangeMultiplier();
756	 (tickLower, tickUpper) = pool.getPositionTicks(balance0, balance1, baseThreshold, tickSpacing);
757	 uint128 liquidity = pool.liquidityForAmounts(balance0, balance1, tickLower, tickUpper);
758	 (uint256 amount0, uint256 amount1) = pool.mint( address(this), tickLower, tickUpper, liquidity, abi.encode(MintCallbackData({
759	 payer: address(this)}
760	 )));
761	 emit Rerange(tickLower, tickUpper, amount0, amount1);
762	 }
763	 function rebalance() external override nonReentrant checkDeviation {
764	 require(_operatorApproved[msg.sender], "ONA");
765	 _earnFees();
766	 pool.burnAllLiquidity(tickLower, tickUpper);
767	 (uint160 sqrtPriceX96, int24 currentTick, , , , , ) = pool.slot0();
768	 PoolVariables.Info memory cache;
769	 int24 baseThreshold = tickSpacing * IOptimizerStrategy(strategy).tickRangeMultiplier();
770	 (cache.tickLower, cache.tickUpper) = PoolVariables.baseTicks(currentTick, baseThreshold, tickSpacing);
771	 cache.amount0Desired = _balance0();
772	 cache.amount1Desired = _balance1();
773	 emit Snapshot(cache.amount0Desired, cache.amount1Desired);
774	 cache.liquidity = pool.liquidityForAmounts(cache.amount0Desired, cache.amount1Desired, cache.tickLower, cache.tickUpper);
775	 (cache.amount0, cache.amount1) = pool.amountsForLiquidity(cache.liquidity, cache.tickLower, cache.tickUpper);
776	 bool zeroForOne = PoolVariables.amountsDirection(cache.amount0Desired, cache.amount1Desired, cache.amount0, cache.amount1);
777	 int256 amountSpecified = zeroForOne ? int256(cache.amount0Desired.sub(cache.amount0).unsafeDiv(2)) : int256(cache.amount1Desired.sub(cache.amount1).unsafeDiv(2));
778	 uint160 exactSqrtPriceImpact = sqrtPriceX96.mul160(IOptimizerStrategy(strategy).priceImpactPercentage() / 2) / GLOBAL_DIVISIONER;
779	 uint160 sqrtPriceLimitX96 = zeroForOne ? sqrtPriceX96.sub160(exactSqrtPriceImpact) : sqrtPriceX96.add160(exactSqrtPriceImpact);
780	 pool.swap( address(this), zeroForOne, amountSpecified, sqrtPriceLimitX96, abi.encode(SwapCallbackData({
781	 zeroForOne: zeroForOne}
782	 )) );
783	 (sqrtPriceX96, currentTick, , , , , ) = pool.slot0();
784	 cache.amount0Desired = _balance0();
785	 cache.amount1Desired = _balance1();
786	 emit Snapshot(cache.amount0Desired, cache.amount1Desired);
787	 (tickLower, tickUpper) = pool.getPositionTicks(cache.amount0Desired, cache.amount1Desired, baseThreshold, tickSpacing);
788	 cache.liquidity = pool.liquidityForAmounts(cache.amount0Desired, cache.amount1Desired, tickLower, tickUpper);
789	 (cache.amount0, cache.amount1) = pool.mint( address(this), tickLower, tickUpper, cache.liquidity, abi.encode(MintCallbackData({
790	 payer: address(this)}
791	 )));
792	 emit Rerange(tickLower, tickUpper, cache.amount0, cache.amount1);
793	 }
794	 function _balance0() internal view returns (uint256) {
795	 return IERC20(token0).balanceOf(address(this)).sub(protocolFees0);
796	 }
797	 function _balance1() internal view returns (uint256) {
798	 return IERC20(token1).balanceOf(address(this)).sub(protocolFees1);
799	 }
800	 function _earnFees() internal {
801	 uint liquidity = pool.positionLiquidity(tickLower, tickUpper);
802	 if (liquidity == 0) return;
803	 pool.burn(tickLower, tickUpper, 0);
804	 (uint256 collect0, uint256 collect1) = pool.collect( address(this), tickLower, tickUpper, type(uint128).max, type(uint128).max );
805	 uint256 earnedProtocolFees0 = collect0.mul(protocolFee).unsafeDiv(GLOBAL_DIVISIONER);
806	 uint256 earnedProtocolFees1 = collect1.mul(protocolFee).unsafeDiv(GLOBAL_DIVISIONER);
807	 protocolFees0 = protocolFees0.add(earnedProtocolFees0);
808	 protocolFees1 = protocolFees1.add(earnedProtocolFees1);
809	 totalFees0 = totalFees0.add(collect0);
810	 totalFees1 = totalFees1.add(collect1);
811	 emit CollectFees(collect0, collect1, totalFees0, totalFees1);
812	 }
813	 function _compoundFees() internal returns (uint256 amount0, uint256 amount1){
814	 uint256 balance0 = _balance0();
815	 uint256 balance1 = _balance1();
816	 emit Snapshot(balance0, balance1);
817	 uint128 liquidity = pool.liquidityForAmounts(balance0, balance1, tickLower, tickUpper);
818	 if (liquidity > 0) {
819	 (amount0, amount1) = pool.mint( address(this), tickLower, tickUpper, liquidity, abi.encode(MintCallbackData({
820	 payer: address(this)}
821	 )));
822	 emit CompoundFees(amount0, amount1);
823	 }
824	 }
825	 function position() external view returns (uint128 liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, uint128 tokensOwed0, uint128 tokensOwed1) {
826	 bytes32 positionKey = PositionKey.compute(address(this), tickLower, tickUpper);
827	 (liquidity, feeGrowthInside0LastX128, feeGrowthInside1LastX128, tokensOwed0, tokensOwed1) = pool.positions(positionKey);
828	 }
829	 function usersAmounts() public view returns (uint256 amount0, uint256 amount1) {
830	 (amount0, amount1) = pool.usersAmounts(tickLower, tickUpper);
831	 amount0 = amount0.add(_balance0());
832	 amount1 = amount1.add(_balance1());
833	 }
834	 function uniswapV3MintCallback( uint256 amount0, uint256 amount1, bytes calldata data ) external {
835	 require(msg.sender == address(pool), "FP");
836	 MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));
837	 if (amount0 > 0) pay(token0, decoded.payer, msg.sender, amount0);
838	 if (amount1 > 0) pay(token1, decoded.payer, msg.sender, amount1);
839	 }
840	 function uniswapV3SwapCallback( int256 amount0, int256 amount1, bytes calldata _data ) external {
841	 require(msg.sender == address(pool), "FP");
842	 require(amount0 > 0 || amount1 > 0, "LEZ");
843	 SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));
844	 bool zeroForOne = data.zeroForOne;
845	 if (zeroForOne) pay(token0, address(this), msg.sender, uint256(amount0));
846	 else pay(token1, address(this), msg.sender, uint256(amount1));
847	 }
848	 function pay( address token, address payer, address recipient, uint256 value ) internal {
849	 if (payer == address(this)) {
850	 TransferHelper.safeTransfer(token, recipient, value);
851	 }
852	 else {
853	 TransferHelper.safeTransferFrom(token, payer, recipient, value);
854	 }
855	 }
856	 function collectProtocolFees( uint256 amount0, uint256 amount1 ) external nonReentrant onlyGovernance {
857	 _earnFees();
858	 require(protocolFees0 >= amount0, "A0F");
859	 require(protocolFees1 >= amount1, "A1F");
860	 uint256 balance0 = IERC20(token0).balanceOf(address(this));
861	 uint256 balance1 = IERC20(token1).balanceOf(address(this));
862	 require(balance0 >= amount0 && balance1 >= amount1);
863	 if (amount0 > 0) pay(token0, address(this), msg.sender, amount0);
864	 if (amount1 > 0) pay(token1, address(this), msg.sender, amount1);
865	 protocolFees0 = protocolFees0.sub(amount0);
866	 protocolFees1 = protocolFees1.sub(amount1);
867	 _compoundFees();
868	 emit RewardPaid(msg.sender, amount0, amount1);
869	 }
870	 modifier checkDeviation() {
871	 pool.checkDeviation(IOptimizerStrategy(strategy).maxTwapDeviation(), IOptimizerStrategy(strategy).twapDuration());
872	 _;
873	 }
874	 function setGovernance(address _governance) external onlyGovernance {
875	 pendingGovernance = _governance;
876	 }
877	 function acceptGovernance() external {
878	 require(msg.sender == pendingGovernance, "PG");
879	 emit TransferGovernance(governance, pendingGovernance);
880	 pendingGovernance = address(0);
881	 governance = msg.sender;
882	 }
883	 function setStrategy(address _strategy) external onlyGovernance {
884	 require(_strategy != address(0), "NA");
885	 strategy = _strategy;
886	 }
887	 function approveOperator(address _operator) external onlyGovernance {
888	 _operatorApproved[_operator] = true;
889	 }
890	 function disableOperator(address _operator) external onlyGovernance {
891	 _operatorApproved[_operator] = false;
892	 }
893	 function isOperator(address _operator) external view returns (bool) {
894	 return _operatorApproved[_operator];
895	 }
896	 modifier whenNotPaused() {
897	 require(!_paused, "P");
898	 _;
899	 }
900	 modifier whenPaused() {
901	 require(_paused, "NP");
902	 _;
903	 }
904	 function pause() external onlyGovernance whenNotPaused {
905	 _paused = true;
906	 }
907	 function unpause() external onlyGovernance whenPaused {
908	 _paused = false;
909	 }
910	 }
