row number 
1	  pragma abicoder v2;
2	 pragma solidity >=0.6.0 <0.8.0;
3	 interface IERC20 {
4	 function totalSupply() external view returns (uint256);
5	 function balanceOf(address account) external view returns (uint256);
6	 function transfer(address recipient, uint256 amount) external returns (bool);
7	 function allowance(address owner, address spender) external view returns (uint256);
8	 function approve(address spender, uint256 amount) external returns (bool);
9	 function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
10	 event Transfer(address indexed from, address indexed to, uint256 value);
11	 event Approval(address indexed owner, address indexed spender, uint256 value);
12	 }
13	 pragma solidity >=0.6.0 <0.8.0;
14	 abstract contract Context {
15	 function _msgSender() internal view virtual returns (address payable) {
16	 return msg.sender;
17	 }
18	 function _msgData() internal view virtual returns (bytes memory) {
19	 this;
20	 return msg.data;
21	 }
22	 }
23	 pragma solidity >=0.6.0 <0.8.0;
24	 contract ERC20 is Context, IERC20 {
25	 using SafeMath for uint256;
26	 mapping (address => uint256) private _balances;
27	 mapping (address => mapping (address => uint256)) private _allowances;
28	 uint256 private _totalSupply;
29	 string private _name;
30	 string private _symbol;
31	 uint8 private _decimals;
32	 constructor (string memory name_, string memory symbol_) public {
33	 _name = name_;
34	 _symbol = symbol_;
35	 _decimals = 18;
36	 }
37	 function name() public view virtual returns (string memory) {
38	 return _name;
39	 }
40	 function symbol() public view virtual returns (string memory) {
41	 return _symbol;
42	 }
43	 function decimals() public view virtual returns (uint8) {
44	 return _decimals;
45	 }
46	 function totalSupply() public view virtual override returns (uint256) {
47	 return _totalSupply;
48	 }
49	 function balanceOf(address account) public view virtual override returns (uint256) {
50	 return _balances[account];
51	 }
52	 function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
53	 _transfer(_msgSender(), recipient, amount);
54	 return true;
55	 }
56	 function allowance(address owner, address spender) public view virtual override returns (uint256) {
57	 return _allowances[owner][spender];
58	 }
59	 function approve(address spender, uint256 amount) public virtual override returns (bool) {
60	 _approve(_msgSender(), spender, amount);
61	 return true;
62	 }
63	 function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
64	 _transfer(sender, recipient, amount);
65	 _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
66	 return true;
67	 }
68	 function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
69	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
70	 return true;
71	 }
72	 function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
73	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
74	 return true;
75	 }
76	 function _transfer(address sender, address recipient, uint256 amount) internal virtual {
77	 require(sender != address(0), "ERC20: transfer from the zero address");
78	 require(recipient != address(0), "ERC20: transfer to the zero address");
79	 _beforeTokenTransfer(sender, recipient, amount);
80	 _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
81	 _balances[recipient] = _balances[recipient].add(amount);
82	 emit Transfer(sender, recipient, amount);
83	 }
84	 function _mint(address account, uint256 amount) internal virtual {
85	 require(account != address(0), "ERC20: mint to the zero address");
86	 _beforeTokenTransfer(address(0), account, amount);
87	 _totalSupply = _totalSupply.add(amount);
88	 _balances[account] = _balances[account].add(amount);
89	 emit Transfer(address(0), account, amount);
90	 }
91	 function _burn(address account, uint256 amount) internal virtual {
92	 require(account != address(0), "ERC20: burn from the zero address");
93	 _beforeTokenTransfer(account, address(0), amount);
94	 _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
95	 _totalSupply = _totalSupply.sub(amount);
96	 emit Transfer(account, address(0), amount);
97	 }
98	 function _approve(address owner, address spender, uint256 amount) internal virtual {
99	 require(owner != address(0), "ERC20: approve from the zero address");
100	 require(spender != address(0), "ERC20: approve to the zero address");
101	 _allowances[owner][spender] = amount;
102	 emit Approval(owner, spender, amount);
103	 }
104	 function _setupDecimals(uint8 decimals_) internal virtual {
105	 _decimals = decimals_;
106	 }
107	 function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {
108	 }
109	 }
110	 pragma solidity >=0.6.0 <0.8.0;
111	 abstract contract ReentrancyGuard {
112	 uint256 private constant _NOT_ENTERED = 1;
113	 uint256 private constant _ENTERED = 2;
114	 uint256 private _status;
115	 constructor () internal {
116	 _status = _NOT_ENTERED;
117	 }
118	 modifier nonReentrant() {
119	 require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
120	 _status = _ENTERED;
121	 _;
122	 _status = _NOT_ENTERED;
123	 }
124	 }
125	 pragma solidity >=0.5.0;
126	 interface IUniswapV3MintCallback {
127	 function uniswapV3MintCallback( uint256 amount0Owed, uint256 amount1Owed, bytes calldata data ) external;
128	 }
129	 pragma solidity >=0.5.0;
130	 interface IUniswapV3SwapCallback {
131	 function uniswapV3SwapCallback( int256 amount0Delta, int256 amount1Delta, bytes calldata data ) external;
132	 }
133	 pragma solidity 0.7.6;
134	 interface IVault {
135	 function deposit( uint256, uint256, address ) external returns (uint256, uint256);
136	 function withdraw( uint256, address, address ) external returns (uint256, uint256);
137	 function rebalance(int24 _baseLower, int24 _baseUpper, int24 _limitLower, int24 _limitUpper, address feeRecipient) external;
138	 function getTotalAmounts() external view returns (uint256, uint256);
139	 event Deposit( address indexed sender, address indexed to, uint256 shares, uint256 amount0, uint256 amount1 );
140	 event Withdraw( address indexed sender, address indexed to, uint256 shares, uint256 amount0, uint256 amount1 );
141	 event Rebalance( int24 tick, uint256 totalAmount0, uint256 totalAmount1, uint256 feeAmount0, uint256 feeAmount1, uint256 totalSupply );
142	 }
143	 pragma solidity >=0.5.0;
144	 interface IUniswapV3PoolImmutables {
145	 function factory() external view returns (address);
146	 function token0() external view returns (address);
147	 function token1() external view returns (address);
148	 function fee() external view returns (uint24);
149	 function tickSpacing() external view returns (int24);
150	 function maxLiquidityPerTick() external view returns (uint128);
151	 }
152	 pragma solidity >=0.5.0;
153	 interface IUniswapV3PoolState {
154	 function slot0() external view returns ( uint160 sqrtPriceX96, int24 tick, uint16 observationIndex, uint16 observationCardinality, uint16 observationCardinalityNext, uint8 feeProtocol, bool unlocked );
155	 function feeGrowthGlobal0X128() external view returns (uint256);
156	 function feeGrowthGlobal1X128() external view returns (uint256);
157	 function protocolFees() external view returns (uint128 token0, uint128 token1);
158	 function liquidity() external view returns (uint128);
159	 function ticks(int24 tick) external view returns ( uint128 liquidityGross, int128 liquidityNet, uint256 feeGrowthOutside0X128, uint256 feeGrowthOutside1X128, int56 tickCumulativeOutside, uint160 secondsPerLiquidityOutsideX128, uint32 secondsOutside, bool initialized );
160	 function tickBitmap(int16 wordPosition) external view returns (uint256);
161	 function positions(bytes32 key) external view returns ( uint128 _liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, uint128 tokensOwed0, uint128 tokensOwed1 );
162	 function observations(uint256 index) external view returns ( uint32 blockTimestamp, int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128, bool initialized );
163	 }
164	 pragma solidity >=0.5.0;
165	 interface IUniswapV3PoolDerivedState {
166	 function observe(uint32[] calldata secondsAgos) external view returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);
167	 function snapshotCumulativesInside(int24 tickLower, int24 tickUpper) external view returns ( int56 tickCumulativeInside, uint160 secondsPerLiquidityInsideX128, uint32 secondsInside );
168	 }
169	 pragma solidity >=0.5.0;
170	 interface IUniswapV3PoolActions {
171	 function initialize(uint160 sqrtPriceX96) external;
172	 function mint( address recipient, int24 tickLower, int24 tickUpper, uint128 amount, bytes calldata data ) external returns (uint256 amount0, uint256 amount1);
173	 function collect( address recipient, int24 tickLower, int24 tickUpper, uint128 amount0Requested, uint128 amount1Requested ) external returns (uint128 amount0, uint128 amount1);
174	 function burn( int24 tickLower, int24 tickUpper, uint128 amount ) external returns (uint256 amount0, uint256 amount1);
175	 function swap( address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes calldata data ) external returns (int256 amount0, int256 amount1);
176	 function flash( address recipient, uint256 amount0, uint256 amount1, bytes calldata data ) external;
177	 function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;
178	 }
179	 pragma solidity >=0.5.0;
180	 interface IUniswapV3PoolOwnerActions {
181	 function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;
182	 function collectProtocol( address recipient, uint128 amount0Requested, uint128 amount1Requested ) external returns (uint128 amount0, uint128 amount1);
183	 }
184	 pragma solidity >=0.5.0;
185	 interface IUniswapV3PoolEvents {
186	 event Initialize(uint160 sqrtPriceX96, int24 tick);
187	 event Mint( address sender, address indexed owner, int24 indexed tickLower, int24 indexed tickUpper, uint128 amount, uint256 amount0, uint256 amount1 );
188	 event Collect( address indexed owner, address recipient, int24 indexed tickLower, int24 indexed tickUpper, uint128 amount0, uint128 amount1 );
189	 event Burn( address indexed owner, int24 indexed tickLower, int24 indexed tickUpper, uint128 amount, uint256 amount0, uint256 amount1 );
190	 event Swap( address indexed sender, address indexed recipient, int256 amount0, int256 amount1, uint160 sqrtPriceX96, uint128 liquidity, int24 tick );
191	 event Flash( address indexed sender, address indexed recipient, uint256 amount0, uint256 amount1, uint256 paid0, uint256 paid1 );
192	 event IncreaseObservationCardinalityNext( uint16 observationCardinalityNextOld, uint16 observationCardinalityNextNew );
193	 event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);
194	 event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);
195	 }
196	 pragma solidity 0.7.6;
197	 contract Hypervisor is IVault, IUniswapV3MintCallback, IUniswapV3SwapCallback, ERC20, ReentrancyGuard {
198	 using SafeERC20 for IERC20;
199	 using SafeMath for uint256;
200	 using SignedSafeMath for int256;
201	 uint256 public constant DUST_THRESHOLD = 1000;
202	 IUniswapV3Pool public pool;
203	 IERC20 public token0;
204	 IERC20 public token1;
205	 uint24 public fee;
206	 int24 public tickSpacing;
207	 int24 public baseLower;
208	 int24 public baseUpper;
209	 int24 public limitLower;
210	 int24 public limitUpper;
211	 address public owner;
212	 uint256 public maxTotalSupply;
213	 constructor( address _pool, address _owner, int24 _baseLower, int24 _baseUpper, int24 _limitLower, int24 _limitUpper ) ERC20("Fungible Liquidity", "LIQ") {
214	 pool = IUniswapV3Pool(_pool);
215	 token0 = IERC20(pool.token0());
216	 token1 = IERC20(pool.token1());
217	 fee = pool.fee();
218	 tickSpacing = pool.tickSpacing();
219	 owner = _owner;
220	 baseLower = _baseLower;
221	 baseUpper = _baseUpper;
222	 limitLower = _limitLower;
223	 limitUpper = _limitUpper;
224	 maxTotalSupply = 0;
225	 }
226	 function deposit( uint256 deposit0, uint256 deposit1, address to ) external override nonReentrant returns (uint256 amount0, uint256 amount1) {
227	 require(to != address(0), "to");
228	 if (totalSupply() == 0) {
229	 uint128 shares = _liquidityForAmounts(baseLower, baseUpper, deposit0, deposit1);
230	 (amount0, amount1) = _mintLiquidity( baseLower, baseUpper, _uint128Safe(shares), msg.sender );
231	 _mint(to, shares);
232	 emit Deposit(msg.sender, to, shares, amount0, amount1);
233	 }
234	 else {
235	 uint256 finalDeposit0 = deposit0;
236	 uint256 finalDeposit1 = deposit1;
237	 {
238	 (uint256 pool0, uint256 pool1) = getTotalAmounts();
239	 uint256 price = 1;
240	 {
241	 int24 mid = _mid();
242	 uint160 sqrtPrice = TickMath.getSqrtRatioAtTick(mid);
243	 price = uint256(sqrtPrice).mul(uint256(sqrtPrice)).mul(1e18) >> (96 * 2);
244	 }
245	 int256 zeroForOneTerm = int256(deposit0).mul(int256(pool1)).sub(int256(pool0).mul(int256(deposit1)));
246	 uint256 token1Exchanged = FullMath.mulDiv(price, zeroForOneTerm > 0 ? uint256(zeroForOneTerm) : uint256(zeroForOneTerm.mul(-1)), pool0.mul(price).div(1e18).add(pool1).mul(1e18));
247	 if(deposit0 > 0) {
248	 token0.safeTransferFrom(msg.sender, address(this), deposit0);
249	 }
250	 if(deposit1 > 0) {
251	 token1.safeTransferFrom(msg.sender, address(this), deposit1);
252	 }
253	 if (token1Exchanged > 0) {
254	 (int256 amount0Delta, int256 amount1Delta) = pool.swap( address(this), zeroForOneTerm > 0, zeroForOneTerm > 0 ? int256(token1Exchanged).mul(-1) : int256(token1Exchanged), zeroForOneTerm > 0 ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1, abi.encode(address(this)) );
255	 finalDeposit0 = uint256(int256(finalDeposit0).sub(amount0Delta));
256	 finalDeposit1 = uint256(int256(finalDeposit1).sub(amount1Delta));
257	 }
258	 }
259	 uint128 shares = _liquidityForAmounts(baseLower, baseUpper, finalDeposit0, finalDeposit1);
260	 uint128 baseLiquidity = _liquidityForShares(baseLower, baseUpper, shares);
261	 uint128 limitLiquidity = _liquidityForShares(limitLower, limitUpper, shares);
262	 (uint256 base0, uint256 base1) = _mintLiquidity(baseLower, baseUpper, baseLiquidity, address(this));
263	 (uint256 limit0, uint256 limit1) = _mintLiquidity(limitLower, limitUpper, limitLiquidity, address(this));
264	 {
265	 uint256 unused0 = _depositUnused(token0, shares);
266	 uint256 unused1 = _depositUnused(token1, shares);
267	 amount0 = base0.add(limit0).add(unused0);
268	 amount1 = base1.add(limit1).add(unused1);
269	 }
270	 _mint(to, shares);
271	 emit Deposit(msg.sender, to, shares, amount0, amount1);
272	 require(maxTotalSupply == 0 || totalSupply() <= maxTotalSupply, "maxTotalSupply");
273	 }
274	 }
275	 function withdraw( uint256 shares, address to, address from ) external override nonReentrant returns (uint256 amount0, uint256 amount1) {
276	 require(shares > 0, "shares");
277	 require(to != address(0), "to");
278	 {
279	 uint128 baseLiquidity = _liquidityForShares(baseLower, baseUpper, shares);
280	 uint128 limitLiquidity = _liquidityForShares(limitLower, limitUpper, shares);
281	 (uint256 base0, uint256 base1) = _burnLiquidity(baseLower, baseUpper, baseLiquidity, to, false);
282	 (uint256 limit0, uint256 limit1) = _burnLiquidity(limitLower, limitUpper, limitLiquidity, to, false);
283	 uint256 unused0 = _withdrawUnused(token0, shares, to);
284	 uint256 unused1 = _withdrawUnused(token1, shares, to);
285	 amount0 = base0.add(limit0).add(unused0);
286	 amount1 = base1.add(limit1).add(unused1);
287	 }
288	 require(from == msg.sender || IUniversalVault(from).owner() == msg.sender, "Sender must own the tokens");
289	 _burn(from, shares);
290	 emit Withdraw(from, to, shares, amount0, amount1);
291	 }
292	 function rebalance(int24 _baseLower, int24 _baseUpper, int24 _limitLower, int24 _limitUpper, address feeRecipient) external override nonReentrant onlyOwner {
293	 assert(_baseLower != _limitLower || _baseUpper != _limitUpper);
294	 int24 mid = _mid();
295	 uint128 basePosition = _position(baseLower, baseUpper);
296	 uint128 limitPosition = _position(limitLower, limitUpper);
297	 (uint256 feesLimit0, uint256 feesLimit1) = getLimitFees();
298	 (uint256 feesBase0, uint256 feesBase1) = getBaseFees();
299	 uint256 fees0 = feesBase0.add(feesLimit0);
300	 uint256 fees1 = feesBase1.add(feesLimit1);
301	 _burnLiquidity(baseLower, baseUpper, basePosition, address(this), true);
302	 _burnLiquidity(limitLower, limitUpper, limitPosition, address(this), true);
303	 if(fees0 > 0) token0.transfer(feeRecipient, fees0.div(10));
304	 if(fees1 > 0) token1.transfer(feeRecipient, fees1.div(10));
305	 uint256 balance0 = token0.balanceOf(address(this));
306	 uint256 balance1 = token1.balanceOf(address(this));
307	 emit Rebalance(mid, balance0, balance1, fees0, fees1, totalSupply());
308	 baseLower = _baseLower;
309	 baseUpper = _baseUpper;
310	 uint128 baseLiquidity = _maxDepositable(baseLower, baseUpper);
311	 _mintLiquidity(baseLower, baseUpper, baseLiquidity, address(this));
312	 limitLower = _limitLower;
313	 limitUpper = _limitUpper;
314	 uint128 limitLiquidity = _maxDepositable(limitLower, limitUpper);
315	 _mintLiquidity(limitLower, limitUpper, limitLiquidity, address(this));
316	 }
317	 function _mintLiquidity( int24 tickLower, int24 tickUpper, uint128 liquidity, address payer ) internal returns (uint256 amount0, uint256 amount1) {
318	 if (liquidity > 0) {
319	 (amount0, amount1) = pool.mint( address(this), tickLower, tickUpper, liquidity, abi.encode(payer) );
320	 }
321	 }
322	 function _burnLiquidity( int24 tickLower, int24 tickUpper, uint128 liquidity, address to, bool collectAll ) internal returns (uint256 amount0, uint256 amount1) {
323	 if (liquidity > 0) {
324	 (uint256 owed0, uint256 owed1) = pool.burn(tickLower, tickUpper, liquidity);
325	 uint128 collect0 = collectAll ? type(uint128).max : _uint128Safe(owed0);
326	 uint128 collect1 = collectAll ? type(uint128).max : _uint128Safe(owed1);
327	 if (collect0 > 0 || collect1 > 0) {
328	 (amount0, amount1) = pool.collect(to, tickLower, tickUpper, collect0, collect1);
329	 }
330	 }
331	 }
332	 function _depositUnused(IERC20 token, uint256 shares) internal returns (uint256 amount) {
333	 uint256 balance = token.balanceOf(address(this));
334	 if (balance >= DUST_THRESHOLD) {
335	 amount = balance.mul(shares).div(totalSupply()).add(1);
336	 token.safeTransferFrom(msg.sender, address(this), amount);
337	 }
338	 }
339	 function _withdrawUnused( IERC20 token, uint256 shares, address to ) internal returns (uint256 amount) {
340	 uint256 balance = token.balanceOf(address(this));
341	 if (balance >= DUST_THRESHOLD) {
342	 amount = balance.mul(shares).div(totalSupply());
343	 token.safeTransfer(to, amount);
344	 }
345	 }
346	 function _liquidityForShares( int24 tickLower, int24 tickUpper, uint256 shares ) internal view returns (uint128) {
347	 uint256 position = uint256(_position(tickLower, tickUpper));
348	 return _uint128Safe(position.mul(shares).div(totalSupply()));
349	 }
350	 function _position(int24 tickLower, int24 tickUpper) internal view returns (uint128 liquidity) {
351	 bytes32 positionKey = keccak256(abi.encodePacked(address(this), tickLower, tickUpper));
352	 (liquidity, , , , ) = pool.positions(positionKey);
353	 }
354	 function _maxDepositable(int24 tickLower, int24 tickUpper) internal view returns (uint128) {
355	 uint256 balance0 = token0.balanceOf(address(this));
356	 uint256 balance1 = token1.balanceOf(address(this));
357	 return _liquidityForAmounts(tickLower, tickUpper, balance0, balance1);
358	 }
359	 function uniswapV3MintCallback( uint256 amount0, uint256 amount1, bytes calldata data ) external override {
360	 require(msg.sender == address(pool));
361	 address payer = abi.decode(data, (address));
362	 if (payer == address(this)) {
363	 if (amount0 > 0) token0.safeTransfer(msg.sender, amount0);
364	 if (amount1 > 0) token1.safeTransfer(msg.sender, amount1);
365	 }
366	 else {
367	 if (amount0 > 0) token0.safeTransferFrom(payer, msg.sender, amount0);
368	 if (amount1 > 0) token1.safeTransferFrom(payer, msg.sender, amount1);
369	 }
370	 }
371	 function uniswapV3SwapCallback( int256 amount0Delta, int256 amount1Delta, bytes calldata data ) external override {
372	 require(msg.sender == address(pool));
373	 address payer = abi.decode(data, (address));
374	 if (amount0Delta > 0) {
375	 if(payer == address(this)) {
376	 token0.transfer(msg.sender, uint256(amount0Delta));
377	 }
378	 else{
379	 token0.safeTransferFrom(payer, msg.sender, uint256(amount0Delta));
380	 }
381	 }
382	 else if (amount1Delta > 0) {
383	 if(payer == address(this)) {
384	 token1.transfer(msg.sender, uint256(amount1Delta));
385	 }
386	 else{
387	 token1.safeTransferFrom(payer, msg.sender, uint256(amount1Delta));
388	 }
389	 }
390	 }
391	 function getTotalAmounts() public view override returns (uint256 total0, uint256 total1) {
392	 (, uint256 base0, uint256 base1) = getBasePosition();
393	 (, uint256 limit0, uint256 limit1) = getLimitPosition();
394	 total0 = token0.balanceOf(address(this)).add(base0).add(limit0);
395	 total1 = token1.balanceOf(address(this)).add(base1).add(limit1);
396	 }
397	 function getBasePosition() public view returns ( uint128 liquidity, uint256 amount0, uint256 amount1 ) {
398	 liquidity = _position(baseLower, baseUpper);
399	 (amount0, amount1) = _amountsForLiquidity(baseLower, baseUpper, liquidity);
400	 }
401	 function getBaseFees() public view returns ( uint256 fees0, uint256 fees1 ) {
402	 bytes32 positionKey = keccak256(abi.encodePacked(address(this), baseLower, baseUpper));
403	 (, , , fees0, fees1) = pool.positions(positionKey);
404	 }
405	 function getLimitFees() public view returns ( uint256 fees0, uint256 fees1 ) {
406	 bytes32 positionKey = keccak256(abi.encodePacked(address(this), limitLower, limitUpper));
407	 (, , , fees0, fees1) = pool.positions(positionKey);
408	 }
409	 function getLimitPosition() public view returns ( uint128 liquidity, uint256 amount0, uint256 amount1 ) {
410	 liquidity = _position(limitLower, limitUpper);
411	 (amount0, amount1) = _amountsForLiquidity(limitLower, limitUpper, liquidity);
412	 }
413	 function _amountsForLiquidity( int24 tickLower, int24 tickUpper, uint128 liquidity ) internal view returns (uint256, uint256) {
414	 (uint160 sqrtRatioX96, , , , , , ) = pool.slot0();
415	 return LiquidityAmounts.getAmountsForLiquidity( sqrtRatioX96, TickMath.getSqrtRatioAtTick(tickLower), TickMath.getSqrtRatioAtTick(tickUpper), liquidity );
416	 }
417	 function _liquidityForAmounts( int24 tickLower, int24 tickUpper, uint256 amount0, uint256 amount1 ) internal view returns (uint128) {
418	 (uint160 sqrtRatioX96, , , , , , ) = pool.slot0();
419	 return LiquidityAmounts.getLiquidityForAmounts( sqrtRatioX96, TickMath.getSqrtRatioAtTick(tickLower), TickMath.getSqrtRatioAtTick(tickUpper), amount0, amount1 );
420	 }
421	 function _mid() internal view returns (int24 mid) {
422	 (, mid, , , , , ) = pool.slot0();
423	 }
424	 function _uint128Safe(uint256 x) internal pure returns (uint128) {
425	 assert(x <= type(uint128).max);
426	 return uint128(x);
427	 }
428	 function setMaxTotalSupply(uint256 _maxTotalSupply) external onlyOwner {
429	 maxTotalSupply = _maxTotalSupply;
430	 }
431	 modifier onlyOwner {
432	 require(msg.sender == owner, "only owner");
433	 _;
434	 }
435	 }
436	 pragma solidity >=0.6.0 <0.8.0;
437	 library SafeMath {
438	 function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
439	 uint256 c = a + b;
440	 if (c < a) return (false, 0);
441	 return (true, c);
442	 }
443	 function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
444	 if (b > a) return (false, 0);
445	 return (true, a - b);
446	 }
447	 function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
448	 if (a == 0) return (true, 0);
449	 uint256 c = a * b;
450	 if (c / a != b) return (false, 0);
451	 return (true, c);
452	 }
453	 function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
454	 if (b == 0) return (false, 0);
455	 return (true, a / b);
456	 }
457	 function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
458	 if (b == 0) return (false, 0);
459	 return (true, a % b);
460	 }
461	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
462	 uint256 c = a + b;
463	 require(c >= a, "SafeMath: addition overflow");
464	 return c;
465	 }
466	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
467	 require(b <= a, "SafeMath: subtraction overflow");
468	 return a - b;
469	 }
470	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
471	 if (a == 0) return 0;
472	 uint256 c = a * b;
473	 require(c / a == b, "SafeMath: multiplication overflow");
474	 return c;
475	 }
476	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
477	 require(b > 0, "SafeMath: division by zero");
478	 return a / b;
479	 }
480	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
481	 require(b > 0, "SafeMath: modulo by zero");
482	 return a % b;
483	 }
484	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
485	 require(b <= a, errorMessage);
486	 return a - b;
487	 }
488	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
489	 require(b > 0, errorMessage);
490	 return a / b;
491	 }
492	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
493	 require(b > 0, errorMessage);
494	 return a % b;
495	 }
496	 }
497	 pragma solidity >=0.6.0 <0.8.0;
498	 library SignedSafeMath {
499	 int256 constant private _INT256_MIN = -2**255;
500	 function mul(int256 a, int256 b) internal pure returns (int256) {
501	 if (a == 0) {
502	 return 0;
503	 }
504	 require(!(a == -1 && b == _INT256_MIN), "SignedSafeMath: multiplication overflow");
505	 int256 c = a * b;
506	 require(c / a == b, "SignedSafeMath: multiplication overflow");
507	 return c;
508	 }
509	 function div(int256 a, int256 b) internal pure returns (int256) {
510	 require(b != 0, "SignedSafeMath: division by zero");
511	 require(!(b == -1 && a == _INT256_MIN), "SignedSafeMath: division overflow");
512	 int256 c = a / b;
513	 return c;
514	 }
515	 function sub(int256 a, int256 b) internal pure returns (int256) {
516	 int256 c = a - b;
517	 require((b >= 0 && c <= a) || (b < 0 && c > a), "SignedSafeMath: subtraction overflow");
518	 return c;
519	 }
520	 function add(int256 a, int256 b) internal pure returns (int256) {
521	 int256 c = a + b;
522	 require((b >= 0 && c >= a) || (b < 0 && c < a), "SignedSafeMath: addition overflow");
523	 return c;
524	 }
525	 }
526	 pragma solidity >=0.6.0 <0.8.0;
527	 library SafeERC20 {
528	 using SafeMath for uint256;
529	 using Address for address;
530	 function safeTransfer(IERC20 token, address to, uint256 value) internal {
531	 _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
532	 }
533	 function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
534	 _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
535	 }
536	 function safeApprove(IERC20 token, address spender, uint256 value) internal {
537	 require((value == 0) || (token.allowance(address(this), spender) == 0), "SafeERC20: approve from non-zero to non-zero allowance" );
538	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
539	 }
540	 function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
541	 uint256 newAllowance = token.allowance(address(this), spender).add(value);
542	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
543	 }
544	 function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
545	 uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
546	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
547	 }
548	 function _callOptionalReturn(IERC20 token, bytes memory data) private {
549	 bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
550	 if (returndata.length > 0) {
551	 require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
552	 }
553	 }
554	 }
555	 pragma solidity >=0.5.0;
556	 interface IUniswapV3Pool is IUniswapV3PoolImmutables, IUniswapV3PoolState, IUniswapV3PoolDerivedState, IUniswapV3PoolActions, IUniswapV3PoolOwnerActions, IUniswapV3PoolEvents {
557	 }
558	 pragma solidity >=0.5.0;
559	 library TickMath {
560	 int24 internal constant MIN_TICK = -887272;
561	 int24 internal constant MAX_TICK = -MIN_TICK;
562	 uint160 internal constant MIN_SQRT_RATIO = 4295128739;
563	 uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;
564	 function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {
565	 uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));
566	 require(absTick <= uint256(MAX_TICK), 'T');
567	 uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;
568	 if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;
569	 if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;
570	 if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;
571	 if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;
572	 if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;
573	 if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;
574	 if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;
575	 if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;
576	 if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;
577	 if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;
578	 if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;
579	 if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;
580	 if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;
581	 if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;
582	 if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;
583	 if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;
584	 if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;
585	 if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;
586	 if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;
587	 if (tick > 0) ratio = type(uint256).max / ratio;
588	 sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));
589	 }
590	 function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {
591	 require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');
592	 uint256 ratio = uint256(sqrtPriceX96) << 32;
593	 uint256 r = ratio;
594	 uint256 msb = 0;
595	 assembly {
596	 let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) msb := or(msb, f) r := shr(f, r) }
597	 assembly {
598	 let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF)) msb := or(msb, f) r := shr(f, r) }
599	 assembly {
600	 let f := shl(5, gt(r, 0xFFFFFFFF)) msb := or(msb, f) r := shr(f, r) }
601	 assembly {
602	 let f := shl(4, gt(r, 0xFFFF)) msb := or(msb, f) r := shr(f, r) }
603	 assembly {
604	 let f := shl(3, gt(r, 0xFF)) msb := or(msb, f) r := shr(f, r) }
605	 assembly {
606	 let f := shl(2, gt(r, 0xF)) msb := or(msb, f) r := shr(f, r) }
607	 assembly {
608	 let f := shl(1, gt(r, 0x3)) msb := or(msb, f) r := shr(f, r) }
609	 assembly {
610	 let f := gt(r, 0x1) msb := or(msb, f) }
611	 if (msb >= 128) r = ratio >> (msb - 127);
612	 else r = ratio << (127 - msb);
613	 int256 log_2 = (int256(msb) - 128) << 64;
614	 assembly {
615	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(63, f)) r := shr(f, r) }
616	 assembly {
617	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(62, f)) r := shr(f, r) }
618	 assembly {
619	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(61, f)) r := shr(f, r) }
620	 assembly {
621	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(60, f)) r := shr(f, r) }
622	 assembly {
623	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(59, f)) r := shr(f, r) }
624	 assembly {
625	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(58, f)) r := shr(f, r) }
626	 assembly {
627	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(57, f)) r := shr(f, r) }
628	 assembly {
629	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(56, f)) r := shr(f, r) }
630	 assembly {
631	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(55, f)) r := shr(f, r) }
632	 assembly {
633	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(54, f)) r := shr(f, r) }
634	 assembly {
635	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(53, f)) r := shr(f, r) }
636	 assembly {
637	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(52, f)) r := shr(f, r) }
638	 assembly {
639	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(51, f)) r := shr(f, r) }
640	 assembly {
641	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(50, f)) }
642	 int256 log_sqrt10001 = log_2 * 255738958999603826347141;
643	 int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);
644	 int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);
645	 tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;
646	 }
647	 }
648	 pragma solidity >=0.4.0;
649	 library FullMath {
650	 function mulDiv( uint256 a, uint256 b, uint256 denominator ) internal pure returns (uint256 result) {
651	 uint256 prod0;
652	 uint256 prod1;
653	 assembly {
654	 let mm := mulmod(a, b, not(0)) prod0 := mul(a, b) prod1 := sub(sub(mm, prod0), lt(mm, prod0)) }
655	 if (prod1 == 0) {
656	 require(denominator > 0);
657	 assembly {
658	 result := div(prod0, denominator) }
659	 return result;
660	 }
661	 require(denominator > prod1);
662	 uint256 remainder;
663	 assembly {
664	 remainder := mulmod(a, b, denominator) }
665	 assembly {
666	 prod1 := sub(prod1, gt(remainder, prod0)) prod0 := sub(prod0, remainder) }
667	 uint256 twos = -denominator & denominator;
668	 assembly {
669	 denominator := div(denominator, twos) }
670	 assembly {
671	 prod0 := div(prod0, twos) }
672	 assembly {
673	 twos := add(div(sub(0, twos), twos), 1) }
674	 prod0 |= prod1 * twos;
675	 uint256 inv = (3 * denominator) ^ 2;
676	 inv *= 2 - denominator * inv;
677	 inv *= 2 - denominator * inv;
678	 inv *= 2 - denominator * inv;
679	 inv *= 2 - denominator * inv;
680	 inv *= 2 - denominator * inv;
681	 inv *= 2 - denominator * inv;
682	 result = prod0 * inv;
683	 return result;
684	 }
685	 function mulDivRoundingUp( uint256 a, uint256 b, uint256 denominator ) internal pure returns (uint256 result) {
686	 result = mulDiv(a, b, denominator);
687	 if (mulmod(a, b, denominator) > 0) {
688	 require(result < type(uint256).max);
689	 result++;
690	 }
691	 }
692	 }
693	 pragma solidity >=0.5.0;
694	 library LiquidityAmounts {
695	 function toUint128(uint256 x) private pure returns (uint128 y) {
696	 require((y = uint128(x)) == x);
697	 }
698	 function getLiquidityForAmount0( uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint256 amount0 ) internal pure returns (uint128 liquidity) {
699	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
700	 uint256 intermediate = FullMath.mulDiv(sqrtRatioAX96, sqrtRatioBX96, FixedPoint96.Q96);
701	 return toUint128(FullMath.mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));
702	 }
703	 function getLiquidityForAmount1( uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint256 amount1 ) internal pure returns (uint128 liquidity) {
704	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
705	 return toUint128(FullMath.mulDiv(amount1, FixedPoint96.Q96, sqrtRatioBX96 - sqrtRatioAX96));
706	 }
707	 function getLiquidityForAmounts( uint160 sqrtRatioX96, uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint256 amount0, uint256 amount1 ) internal pure returns (uint128 liquidity) {
708	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
709	 if (sqrtRatioX96 <= sqrtRatioAX96) {
710	 liquidity = getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);
711	 }
712	 else if (sqrtRatioX96 < sqrtRatioBX96) {
713	 uint128 liquidity0 = getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);
714	 uint128 liquidity1 = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);
715	 liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;
716	 }
717	 else {
718	 liquidity = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);
719	 }
720	 }
721	 function getAmount0ForLiquidity( uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity ) internal pure returns (uint256 amount0) {
722	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
723	 return FullMath.mulDiv( uint256(liquidity) << FixedPoint96.RESOLUTION, sqrtRatioBX96 - sqrtRatioAX96, sqrtRatioBX96 ) / sqrtRatioAX96;
724	 }
725	 function getAmount1ForLiquidity( uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity ) internal pure returns (uint256 amount1) {
726	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
727	 return FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);
728	 }
729	 function getAmountsForLiquidity( uint160 sqrtRatioX96, uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity ) internal pure returns (uint256 amount0, uint256 amount1) {
730	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
731	 if (sqrtRatioX96 <= sqrtRatioAX96) {
732	 amount0 = getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);
733	 }
734	 else if (sqrtRatioX96 < sqrtRatioBX96) {
735	 amount0 = getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);
736	 amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);
737	 }
738	 else {
739	 amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);
740	 }
741	 }
742	 }
743	 pragma solidity 0.7.6;
744	 interface IUniversalVault {
745	 event Locked(address delegate, address token, uint256 amount);
746	 event Unlocked(address delegate, address token, uint256 amount);
747	 event RageQuit(address delegate, address token, bool notified, string reason);
748	 struct LockData {
749	 address delegate;
750	 address token;
751	 uint256 balance;
752	 }
753	 function initialize() external;
754	 function lock( address token, uint256 amount, bytes calldata permission ) external;
755	 function unlock( address token, uint256 amount, bytes calldata permission ) external;
756	 function rageQuit(address delegate, address token) external returns (bool notified, string memory error);
757	 function transferERC20( address token, address to, uint256 amount ) external;
758	 function transferETH(address to, uint256 amount) external payable;
759	 function calculateLockID(address delegate, address token) external pure returns (bytes32 lockID);
760	 function getPermissionHash( bytes32 eip712TypeHash, address delegate, address token, uint256 amount, uint256 nonce ) external view returns (bytes32 permissionHash);
761	 function getNonce() external view returns (uint256 nonce);
762	 function owner() external view returns (address ownerAddress);
763	 function getLockSetCount() external view returns (uint256 count);
764	 function getLockAt(uint256 index) external view returns (LockData memory lockData);
765	 function getBalanceDelegated(address token, address delegate) external view returns (uint256 balance);
766	 function getBalanceLocked(address token) external view returns (uint256 balance);
767	 function checkBalances() external view returns (bool validity);
768	 }
769	 pragma solidity >=0.6.2 <0.8.0;
770	 library Address {
771	 function isContract(address account) internal view returns (bool) {
772	 uint256 size;
773	 assembly {
774	 size := extcodesize(account) }
775	 return size > 0;
776	 }
777	 function sendValue(address payable recipient, uint256 amount) internal {
778	 require(address(this).balance >= amount, "Address: insufficient balance");
779	 (bool success, ) = recipient.call{
780	 value: amount }
781	 ("");
782	 require(success, "Address: unable to send value, recipient may have reverted");
783	 }
784	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
785	 return functionCall(target, data, "Address: low-level call failed");
786	 }
787	 function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
788	 return functionCallWithValue(target, data, 0, errorMessage);
789	 }
790	 function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
791	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
792	 }
793	 function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
794	 require(address(this).balance >= value, "Address: insufficient balance for call");
795	 require(isContract(target), "Address: call to non-contract");
796	 (bool success, bytes memory returndata) = target.call{
797	 value: value }
798	 (data);
799	 return _verifyCallResult(success, returndata, errorMessage);
800	 }
801	 function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
802	 return functionStaticCall(target, data, "Address: low-level static call failed");
803	 }
804	 function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
805	 require(isContract(target), "Address: static call to non-contract");
806	 (bool success, bytes memory returndata) = target.staticcall(data);
807	 return _verifyCallResult(success, returndata, errorMessage);
808	 }
809	 function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
810	 return functionDelegateCall(target, data, "Address: low-level delegate call failed");
811	 }
812	 function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
813	 require(isContract(target), "Address: delegate call to non-contract");
814	 (bool success, bytes memory returndata) = target.delegatecall(data);
815	 return _verifyCallResult(success, returndata, errorMessage);
816	 }
817	 function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
818	 if (success) {
819	 return returndata;
820	 }
821	 else {
822	 if (returndata.length > 0) {
823	 assembly {
824	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
825	 }
826	 else {
827	 revert(errorMessage);
828	 }
829	 }
830	 }
831	 }
832	 pragma solidity >=0.4.0;
833	 library FixedPoint96 {
834	 uint8 internal constant RESOLUTION = 96;
835	 uint256 internal constant Q96 = 0x1000000000000000000000000;
836	 }
