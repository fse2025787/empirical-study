row number 
1	  pragma experimental ABIEncoderV2;
2	 pragma solidity >=0.6.10 <0.8.0;
3	 interface IStableSwapCore {
4	 function getQuoteOut(uint256 baseIn) external view returns (uint256 quoteOut);
5	 function getQuoteIn(uint256 baseOut) external view returns (uint256 quoteIn);
6	 function getBaseOut(uint256 quoteIn) external view returns (uint256 baseOut);
7	 function getBaseIn(uint256 quoteOut) external view returns (uint256 baseIn);
8	 function buy( uint256 version, uint256 baseOut, address recipient, bytes calldata data ) external returns (uint256 realBaseOut);
9	 function sell( uint256 version, uint256 quoteOut, address recipient, bytes calldata data ) external returns (uint256 realQuoteOut);
10	 }
11	 pragma solidity >=0.6.0 <0.8.0;
12	 abstract contract Context {
13	 function _msgSender() internal view virtual returns (address payable) {
14	 return msg.sender;
15	 }
16	 function _msgData() internal view virtual returns (bytes memory) {
17	 this;
18	 return msg.data;
19	 }
20	 }
21	 pragma solidity >=0.6.0 <0.8.0;
22	 abstract contract Ownable is Context {
23	 address private _owner;
24	 event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
25	 constructor () internal {
26	 address msgSender = _msgSender();
27	 _owner = msgSender;
28	 emit OwnershipTransferred(address(0), msgSender);
29	 }
30	 function owner() public view virtual returns (address) {
31	 return _owner;
32	 }
33	 modifier onlyOwner() {
34	 require(owner() == _msgSender(), "Ownable: caller is not the owner");
35	 _;
36	 }
37	 function renounceOwnership() public virtual onlyOwner {
38	 emit OwnershipTransferred(_owner, address(0));
39	 _owner = address(0);
40	 }
41	 function transferOwnership(address newOwner) public virtual onlyOwner {
42	 require(newOwner != address(0), "Ownable: new owner is the zero address");
43	 emit OwnershipTransferred(_owner, newOwner);
44	 _owner = newOwner;
45	 }
46	 }
47	 pragma solidity >=0.6.0 <0.8.0;
48	 abstract contract ReentrancyGuard {
49	 uint256 private constant _NOT_ENTERED = 1;
50	 uint256 private constant _ENTERED = 2;
51	 uint256 private _status;
52	 constructor () internal {
53	 _status = _NOT_ENTERED;
54	 }
55	 modifier nonReentrant() {
56	 require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
57	 _status = _ENTERED;
58	 _;
59	 _status = _NOT_ENTERED;
60	 }
61	 }
62	 interface IStableSwap is IStableSwapCore {
63	 function fund() external view returns (IFundV3);
64	 function baseTranche() external view returns (uint256);
65	 function baseAddress() external view returns (address);
66	 function quoteAddress() external view returns (address);
67	 function allBalances() external view returns (uint256, uint256);
68	 function getOraclePrice() external view returns (uint256);
69	 function getCurrentD() external view returns (uint256);
70	 function getCurrentPriceOverOracle() external view returns (uint256);
71	 function getCurrentPrice() external view returns (uint256);
72	 function getPriceOverOracleIntegral() external view returns (uint256);
73	 function addLiquidity(uint256 version, address recipient) external returns (uint256);
74	 function removeLiquidity( uint256 version, uint256 lpIn, uint256 minBaseOut, uint256 minQuoteOut ) external returns (uint256 baseOut, uint256 quoteOut);
75	 function removeLiquidityUnwrap( uint256 version, uint256 lpIn, uint256 minBaseOut, uint256 minQuoteOut ) external returns (uint256 baseOut, uint256 quoteOut);
76	 function removeBaseLiquidity( uint256 version, uint256 lpIn, uint256 minBaseOut ) external returns (uint256 baseOut);
77	 function removeQuoteLiquidity( uint256 version, uint256 lpIn, uint256 minQuoteOut ) external returns (uint256 quoteOut);
78	 function removeQuoteLiquidityUnwrap( uint256 version, uint256 lpIn, uint256 minQuoteOut ) external returns (uint256 quoteOut);
79	 }
80	 pragma solidity >=0.6.0 <0.8.0;
81	 abstract contract ManagedPausable {
82	 event Paused(address account);
83	 event Unpaused(address account);
84	 event PauserRoleTransferred(address indexed previousPauser, address indexed newPauser);
85	 uint256 private constant FALSE = 0;
86	 uint256 private constant TRUE = 1;
87	 uint256 private _initialized;
88	 uint256 private _paused;
89	 address private _pauser;
90	 function _initializeManagedPausable(address pauser_) internal {
91	 require(_initialized == FALSE);
92	 _initialized = TRUE;
93	 _paused = FALSE;
94	 _pauser = pauser_;
95	 }
96	 function paused() public view returns (bool) {
97	 return _paused != FALSE;
98	 }
99	 function pauser() public view returns (address) {
100	 return _pauser;
101	 }
102	 function renouncePauserRole() external onlyPauser {
103	 emit PauserRoleTransferred(_pauser, address(0));
104	 _pauser = address(0);
105	 }
106	 function transferPauserRole(address newPauser) external onlyPauser {
107	 require(newPauser != address(0));
108	 emit PauserRoleTransferred(_pauser, newPauser);
109	 _pauser = newPauser;
110	 }
111	 modifier onlyPauser() {
112	 require(_pauser == msg.sender, "Pausable: only pauser");
113	 _;
114	 }
115	 modifier whenNotPaused() {
116	 require(_paused == FALSE, "Pausable: paused");
117	 _;
118	 }
119	 modifier whenPaused() {
120	 require(_paused != FALSE, "Pausable: not paused");
121	 _;
122	 }
123	 function pause() external onlyPauser whenNotPaused {
124	 _paused = TRUE;
125	 emit Paused(msg.sender);
126	 }
127	 function unpause() external onlyPauser whenPaused {
128	 _paused = FALSE;
129	 emit Unpaused(msg.sender);
130	 }
131	 }
132	 pragma solidity >=0.6.10 <0.8.0;
133	 abstract contract ITrancheIndexV2 {
134	 uint256 internal constant TRANCHE_Q = 0;
135	 uint256 internal constant TRANCHE_B = 1;
136	 uint256 internal constant TRANCHE_R = 2;
137	 uint256 internal constant TRANCHE_COUNT = 3;
138	 }
139	 pragma solidity >=0.6.10 <0.8.0;
140	 abstract contract StableSwapV2 is IStableSwap, Ownable, ReentrancyGuard, ManagedPausable {
141	 using SafeMath for uint256;
142	 using SafeDecimalMath for uint256;
143	 using SafeERC20 for IERC20;
144	 event LiquidityAdded( address indexed sender, address indexed recipient, uint256 baseIn, uint256 quoteIn, uint256 lpOut, uint256 fee, uint256 adminFee, uint256 oraclePrice );
145	 event LiquidityRemoved( address indexed account, uint256 lpIn, uint256 baseOut, uint256 quotOut, uint256 fee, uint256 adminFee, uint256 oraclePrice );
146	 event Swap( address indexed sender, address indexed recipient, uint256 baseIn, uint256 quoteIn, uint256 baseOut, uint256 quoteOut, uint256 fee, uint256 adminFee, uint256 oraclePrice );
147	 event Sync(uint256 base, uint256 quote, uint256 oraclePrice);
148	 event AmplRampUpdated(uint256 start, uint256 end, uint256 startTimestamp, uint256 endTimestamp);
149	 event FeeCollectorUpdated(address newFeeCollector);
150	 event FeeRateUpdated(uint256 newFeeRate);
151	 event AdminFeeRateUpdated(uint256 newAdminFeeRate);
152	 uint256 private constant AMPL_MAX_VALUE = 1e6;
153	 uint256 private constant AMPL_RAMP_MIN_TIME = 86400;
154	 uint256 private constant AMPL_RAMP_MAX_CHANGE = 10;
155	 uint256 private constant MAX_FEE_RATE = 0.5e18;
156	 uint256 private constant MAX_ADMIN_FEE_RATE = 1e18;
157	 uint256 private constant MAX_ITERATION = 255;
158	 uint256 private constant MINIMUM_LIQUIDITY = 1e3;
159	 address public immutable lpToken;
160	 IFundV3 public immutable override fund;
161	 uint256 public immutable override baseTranche;
162	 address public immutable override quoteAddress;
163	 uint256 internal immutable _quoteDecimalMultiplier;
164	 uint256 public baseBalance;
165	 uint256 public quoteBalance;
166	 uint256 private _priceOverOracleIntegral;
167	 uint256 private _priceOverOracleTimestamp;
168	 uint256 public amplRampStart;
169	 uint256 public amplRampEnd;
170	 uint256 public amplRampStartTimestamp;
171	 uint256 public amplRampEndTimestamp;
172	 address public feeCollector;
173	 uint256 public feeRate;
174	 uint256 public adminFeeRate;
175	 uint256 public totalAdminFee;
176	 constructor( address lpToken_, address fund_, uint256 baseTranche_, address quoteAddress_, uint256 quoteDecimals_, uint256 ampl_, address feeCollector_, uint256 feeRate_, uint256 adminFeeRate_ ) public {
177	 lpToken = lpToken_;
178	 fund = IFundV3(fund_);
179	 baseTranche = baseTranche_;
180	 quoteAddress = quoteAddress_;
181	 require(quoteDecimals_ <= 18, "Quote asset decimals larger than 18");
182	 _quoteDecimalMultiplier = 10**(18 - quoteDecimals_);
183	 require(ampl_ > 0 && ampl_ < AMPL_MAX_VALUE, "Invalid A");
184	 amplRampEnd = ampl_;
185	 emit AmplRampUpdated(ampl_, ampl_, 0, 0);
186	 _updateFeeCollector(feeCollector_);
187	 _updateFeeRate(feeRate_);
188	 _updateAdminFeeRate(adminFeeRate_);
189	 _initializeManagedPausable(msg.sender);
190	 }
191	 receive() external payable {
192	 }
193	 function baseAddress() external view override returns (address) {
194	 return fund.tokenShare(baseTranche);
195	 }
196	 function allBalances() external view override returns (uint256, uint256) {
197	 (uint256 base, uint256 quote, , , , , ) = _getRebalanceResult(fund.getRebalanceSize());
198	 return (base, quote);
199	 }
200	 function getAmpl() public view returns (uint256) {
201	 uint256 endTimestamp = amplRampEndTimestamp;
202	 if (block.timestamp < endTimestamp) {
203	 uint256 startTimestamp = amplRampStartTimestamp;
204	 uint256 start = amplRampStart;
205	 uint256 end = amplRampEnd;
206	 if (end > start) {
207	 return start + ((end - start) * (block.timestamp - startTimestamp)) / (endTimestamp - startTimestamp);
208	 }
209	 else {
210	 return start - ((start - end) * (block.timestamp - startTimestamp)) / (endTimestamp - startTimestamp);
211	 }
212	 }
213	 else {
214	 return amplRampEnd;
215	 }
216	 }
217	 function getCurrentD() external view override returns (uint256) {
218	 (uint256 base, uint256 quote, , , , , ) = _getRebalanceResult(fund.getRebalanceSize());
219	 return _getD(base, quote, getAmpl(), getOraclePrice());
220	 }
221	 function getCurrentPriceOverOracle() public view override returns (uint256) {
222	 (uint256 base, uint256 quote, , , , , ) = _getRebalanceResult(fund.getRebalanceSize());
223	 if (base == 0 || quote == 0) {
224	 return 1e18;
225	 }
226	 uint256 ampl = getAmpl();
227	 uint256 oraclePrice = getOraclePrice();
228	 uint256 d = _getD(base, quote, ampl, oraclePrice);
229	 return _getPriceOverOracle(base, quote, ampl, oraclePrice, d);
230	 }
231	 function getCurrentPrice() external view override returns (uint256) {
232	 (uint256 base, uint256 quote, , , , , ) = _getRebalanceResult(fund.getRebalanceSize());
233	 uint256 oraclePrice = getOraclePrice();
234	 if (base == 0 || quote == 0) {
235	 return oraclePrice;
236	 }
237	 uint256 ampl = getAmpl();
238	 uint256 d = _getD(base, quote, ampl, oraclePrice);
239	 return _getPriceOverOracle(base, quote, ampl, oraclePrice, d).multiplyDecimal(oraclePrice);
240	 }
241	 function getPriceOverOracleIntegral() external view override returns (uint256) {
242	 return _priceOverOracleIntegral + getCurrentPriceOverOracle() * (block.timestamp - _priceOverOracleTimestamp);
243	 }
244	 function getQuoteOut(uint256 baseIn) external view override returns (uint256 quoteOut) {
245	 (uint256 oldBase, uint256 oldQuote, , , , , ) = _getRebalanceResult(fund.getRebalanceSize());
246	 uint256 newBase = oldBase.add(baseIn);
247	 uint256 ampl = getAmpl();
248	 uint256 oraclePrice = getOraclePrice();
249	 uint256 d = _getD(oldBase, oldQuote, ampl, oraclePrice) + 1;
250	 uint256 newQuote = _getQuote(ampl, newBase, oraclePrice, d) + 1;
251	 quoteOut = oldQuote.sub(newQuote);
252	 quoteOut = quoteOut.multiplyDecimal(1e18 - feeRate);
253	 }
254	 function getQuoteIn(uint256 baseOut) external view override returns (uint256 quoteIn) {
255	 (uint256 oldBase, uint256 oldQuote, , , , , ) = _getRebalanceResult(fund.getRebalanceSize());
256	 uint256 newBase = oldBase.sub(baseOut);
257	 uint256 ampl = getAmpl();
258	 uint256 oraclePrice = getOraclePrice();
259	 uint256 d = _getD(oldBase, oldQuote, ampl, oraclePrice) + 1;
260	 uint256 newQuote = _getQuote(ampl, newBase, oraclePrice, d) + 1;
261	 quoteIn = newQuote.sub(oldQuote);
262	 uint256 feeRate_ = feeRate;
263	 quoteIn = quoteIn.mul(1e18).add(1e18 - feeRate_ - 1) / (1e18 - feeRate_);
264	 }
265	 function getBaseOut(uint256 quoteIn) external view override returns (uint256 baseOut) {
266	 (uint256 oldBase, uint256 oldQuote, , , , , ) = _getRebalanceResult(fund.getRebalanceSize());
267	 uint256 quoteInAfterFee = quoteIn.multiplyDecimal(1e18 - feeRate);
268	 uint256 newQuote = oldQuote.add(quoteInAfterFee);
269	 uint256 ampl = getAmpl();
270	 uint256 oraclePrice = getOraclePrice();
271	 uint256 d = _getD(oldBase, oldQuote, ampl, oraclePrice) + 1;
272	 uint256 newBase = _getBase(ampl, newQuote, oraclePrice, d) + 1;
273	 baseOut = oldBase.sub(newBase);
274	 }
275	 function getBaseIn(uint256 quoteOut) external view override returns (uint256 baseIn) {
276	 (uint256 oldBase, uint256 oldQuote, , , , , ) = _getRebalanceResult(fund.getRebalanceSize());
277	 uint256 feeRate_ = feeRate;
278	 uint256 quoteOutBeforeFee = quoteOut.mul(1e18).add(1e18 - feeRate_ - 1) / (1e18 - feeRate_);
279	 uint256 newQuote = oldQuote.sub(quoteOutBeforeFee);
280	 uint256 ampl = getAmpl();
281	 uint256 oraclePrice = getOraclePrice();
282	 uint256 d = _getD(oldBase, oldQuote, ampl, oraclePrice) + 1;
283	 uint256 newBase = _getBase(ampl, newQuote, oraclePrice, d) + 1;
284	 baseIn = newBase.sub(oldBase);
285	 }
286	 function buy( uint256 version, uint256 baseOut, address recipient, bytes calldata data ) external override nonReentrant checkVersion(version) whenNotPaused returns (uint256 realBaseOut) {
287	 require(baseOut > 0, "Zero output");
288	 realBaseOut = baseOut;
289	 (uint256 oldBase, uint256 oldQuote) = _handleRebalance(version);
290	 require(baseOut < oldBase, "Insufficient liquidity");
291	 fund.trancheTransfer(baseTranche, recipient, baseOut, version);
292	 if (data.length > 0) {
293	 ITranchessSwapCallee(msg.sender).tranchessSwapCallback(baseOut, 0, data);
294	 _checkVersion(version);
295	 }
296	 uint256 newQuote = _getNewQuoteBalance();
297	 uint256 quoteIn = newQuote.sub(oldQuote);
298	 uint256 fee = quoteIn.multiplyDecimal(feeRate);
299	 uint256 oraclePrice = getOraclePrice();
300	 {
301	 uint256 ampl = getAmpl();
302	 uint256 oldD = _getD(oldBase, oldQuote, ampl, oraclePrice);
303	 _updatePriceOverOracleIntegral(oldBase, oldQuote, ampl, oraclePrice, oldD);
304	 uint256 newD = _getD(oldBase - baseOut, newQuote.sub(fee), ampl, oraclePrice);
305	 require(newD >= oldD, "Invariant mismatch");
306	 }
307	 uint256 adminFee = fee.multiplyDecimal(adminFeeRate);
308	 baseBalance = oldBase - baseOut;
309	 quoteBalance = newQuote.sub(adminFee);
310	 totalAdminFee = totalAdminFee.add(adminFee);
311	 uint256 baseOut_ = baseOut;
312	 emit Swap(msg.sender, recipient, 0, quoteIn, baseOut_, 0, fee, adminFee, oraclePrice);
313	 }
314	 function sell( uint256 version, uint256 quoteOut, address recipient, bytes calldata data ) external override nonReentrant checkVersion(version) whenNotPaused returns (uint256 realQuoteOut) {
315	 require(quoteOut > 0, "Zero output");
316	 realQuoteOut = quoteOut;
317	 (uint256 oldBase, uint256 oldQuote) = _handleRebalance(version);
318	 IERC20(quoteAddress).safeTransfer(recipient, quoteOut);
319	 if (data.length > 0) {
320	 ITranchessSwapCallee(msg.sender).tranchessSwapCallback(0, quoteOut, data);
321	 _checkVersion(version);
322	 }
323	 uint256 newBase = fund.trancheBalanceOf(baseTranche, address(this));
324	 uint256 baseIn = newBase.sub(oldBase);
325	 uint256 fee;
326	 {
327	 uint256 feeRate_ = feeRate;
328	 fee = quoteOut.mul(feeRate_).div(1e18 - feeRate_);
329	 }
330	 require(quoteOut.add(fee) < oldQuote, "Insufficient liquidity");
331	 uint256 oraclePrice = getOraclePrice();
332	 {
333	 uint256 newQuote = oldQuote - quoteOut;
334	 uint256 ampl = getAmpl();
335	 uint256 oldD = _getD(oldBase, oldQuote, ampl, oraclePrice);
336	 _updatePriceOverOracleIntegral(oldBase, oldQuote, ampl, oraclePrice, oldD);
337	 uint256 newD = _getD(newBase, newQuote - fee, ampl, oraclePrice);
338	 require(newD >= oldD, "Invariant mismatch");
339	 }
340	 uint256 adminFee = fee.multiplyDecimal(adminFeeRate);
341	 baseBalance = newBase;
342	 quoteBalance = oldQuote - quoteOut - adminFee;
343	 totalAdminFee = totalAdminFee.add(adminFee);
344	 uint256 quoteOut_ = quoteOut;
345	 emit Swap(msg.sender, recipient, baseIn, 0, 0, quoteOut_, fee, adminFee, oraclePrice);
346	 }
347	 function addLiquidity(uint256 version, address recipient) external override nonReentrant checkVersion(version) whenNotPaused returns (uint256 lpOut) {
348	 (uint256 oldBase, uint256 oldQuote) = _handleRebalance(version);
349	 uint256 newBase = fund.trancheBalanceOf(baseTranche, address(this));
350	 uint256 newQuote = _getNewQuoteBalance();
351	 uint256 ampl = getAmpl();
352	 uint256 oraclePrice = getOraclePrice();
353	 uint256 lpSupply = IERC20(lpToken).totalSupply();
354	 if (lpSupply == 0) {
355	 require(newBase > 0 && newQuote > 0, "Zero initial balance");
356	 baseBalance = newBase;
357	 quoteBalance = newQuote;
358	 _priceOverOracleIntegral += 1e18 * (block.timestamp - _priceOverOracleTimestamp);
359	 _priceOverOracleTimestamp = block.timestamp;
360	 uint256 d1 = _getD(newBase, newQuote, ampl, oraclePrice);
361	 ILiquidityGauge(lpToken).mint(address(this), MINIMUM_LIQUIDITY);
362	 ILiquidityGauge(lpToken).mint(recipient, d1.sub(MINIMUM_LIQUIDITY));
363	 emit LiquidityAdded(msg.sender, recipient, newBase, newQuote, d1, 0, 0, oraclePrice);
364	 return d1;
365	 }
366	 uint256 fee;
367	 uint256 adminFee;
368	 {
369	 uint256 d0 = _getD(oldBase, oldQuote, ampl, oraclePrice);
370	 _updatePriceOverOracleIntegral(oldBase, oldQuote, ampl, oraclePrice, d0);
371	 {
372	 uint256 d1 = _getD(newBase, newQuote, ampl, oraclePrice);
373	 uint256 idealQuote = d1.mul(oldQuote) / d0;
374	 uint256 difference = idealQuote > newQuote ? idealQuote - newQuote : newQuote - idealQuote;
375	 fee = difference.multiplyDecimal(feeRate);
376	 }
377	 adminFee = fee.multiplyDecimal(adminFeeRate);
378	 totalAdminFee = totalAdminFee.add(adminFee);
379	 baseBalance = newBase;
380	 quoteBalance = newQuote.sub(adminFee);
381	 uint256 d2 = _getD(newBase, newQuote.sub(fee), ampl, oraclePrice);
382	 require(d2 > d0, "No liquidity is added");
383	 lpOut = lpSupply.mul(d2.sub(d0)).div(d0);
384	 }
385	 ILiquidityGauge(lpToken).mint(recipient, lpOut);
386	 emit LiquidityAdded( msg.sender, recipient, newBase - oldBase, newQuote - oldQuote, lpOut, fee, adminFee, oraclePrice );
387	 }
388	 function removeLiquidity( uint256 version, uint256 lpIn, uint256 minBaseOut, uint256 minQuoteOut ) external override nonReentrant checkVersion(version) returns (uint256 baseOut, uint256 quoteOut) {
389	 (baseOut, quoteOut) = _removeLiquidity(version, lpIn, minBaseOut, minQuoteOut);
390	 IERC20(quoteAddress).safeTransfer(msg.sender, quoteOut);
391	 }
392	 function removeLiquidityUnwrap( uint256 version, uint256 lpIn, uint256 minBaseOut, uint256 minQuoteOut ) external override nonReentrant checkVersion(version) returns (uint256 baseOut, uint256 quoteOut) {
393	 (baseOut, quoteOut) = _removeLiquidity(version, lpIn, minBaseOut, minQuoteOut);
394	 IWrappedERC20(quoteAddress).withdraw(quoteOut);
395	 (bool success, ) = msg.sender.call{
396	 value: quoteOut}
397	 ("");
398	 require(success, "Transfer failed");
399	 }
400	 function _removeLiquidity( uint256 version, uint256 lpIn, uint256 minBaseOut, uint256 minQuoteOut ) private returns (uint256 baseOut, uint256 quoteOut) {
401	 uint256 lpSupply = IERC20(lpToken).totalSupply();
402	 (uint256 oldBase, uint256 oldQuote) = _handleRebalance(version);
403	 baseOut = oldBase.mul(lpIn).div(lpSupply);
404	 quoteOut = oldQuote.mul(lpIn).div(lpSupply);
405	 require(baseOut >= minBaseOut, "Insufficient output");
406	 require(quoteOut >= minQuoteOut, "Insufficient output");
407	 baseBalance = oldBase.sub(baseOut);
408	 quoteBalance = oldQuote.sub(quoteOut);
409	 ILiquidityGauge(lpToken).burnFrom(msg.sender, lpIn);
410	 fund.trancheTransfer(baseTranche, msg.sender, baseOut, version);
411	 emit LiquidityRemoved(msg.sender, lpIn, baseOut, quoteOut, 0, 0, 0);
412	 }
413	 function removeBaseLiquidity( uint256 version, uint256 lpIn, uint256 minBaseOut ) external override nonReentrant checkVersion(version) whenNotPaused returns (uint256 baseOut) {
414	 (uint256 oldBase, uint256 oldQuote) = _handleRebalance(version);
415	 uint256 lpSupply = IERC20(lpToken).totalSupply();
416	 uint256 ampl = getAmpl();
417	 uint256 oraclePrice = getOraclePrice();
418	 uint256 d1;
419	 {
420	 uint256 d0 = _getD(oldBase, oldQuote, ampl, oraclePrice);
421	 _updatePriceOverOracleIntegral(oldBase, oldQuote, ampl, oraclePrice, d0);
422	 d1 = d0.sub(d0.mul(lpIn).div(lpSupply));
423	 }
424	 {
425	 uint256 fee = oldQuote.mul(lpIn).div(lpSupply).multiplyDecimal(feeRate);
426	 uint256 newBase = _getBase(ampl, oldQuote.sub(fee), oraclePrice, d1) + 1;
427	 baseOut = oldBase.sub(newBase);
428	 require(baseOut >= minBaseOut, "Insufficient output");
429	 ILiquidityGauge(lpToken).burnFrom(msg.sender, lpIn);
430	 baseBalance = newBase;
431	 uint256 adminFee = fee.multiplyDecimal(adminFeeRate);
432	 totalAdminFee = totalAdminFee.add(adminFee);
433	 quoteBalance = oldQuote.sub(adminFee);
434	 emit LiquidityRemoved(msg.sender, lpIn, baseOut, 0, fee, adminFee, oraclePrice);
435	 }
436	 fund.trancheTransfer(baseTranche, msg.sender, baseOut, version);
437	 }
438	 function removeQuoteLiquidity( uint256 version, uint256 lpIn, uint256 minQuoteOut ) external override nonReentrant checkVersion(version) whenNotPaused returns (uint256 quoteOut) {
439	 quoteOut = _removeQuoteLiquidity(version, lpIn, minQuoteOut);
440	 IERC20(quoteAddress).safeTransfer(msg.sender, quoteOut);
441	 }
442	 function removeQuoteLiquidityUnwrap( uint256 version, uint256 lpIn, uint256 minQuoteOut ) external override nonReentrant checkVersion(version) whenNotPaused returns (uint256 quoteOut) {
443	 quoteOut = _removeQuoteLiquidity(version, lpIn, minQuoteOut);
444	 IWrappedERC20(quoteAddress).withdraw(quoteOut);
445	 (bool success, ) = msg.sender.call{
446	 value: quoteOut}
447	 ("");
448	 require(success, "Transfer failed");
449	 }
450	 function _removeQuoteLiquidity( uint256 version, uint256 lpIn, uint256 minQuoteOut ) private returns (uint256 quoteOut) {
451	 (uint256 oldBase, uint256 oldQuote) = _handleRebalance(version);
452	 uint256 lpSupply = IERC20(lpToken).totalSupply();
453	 uint256 ampl = getAmpl();
454	 uint256 oraclePrice = getOraclePrice();
455	 uint256 d1;
456	 {
457	 uint256 d0 = _getD(oldBase, oldQuote, ampl, oraclePrice);
458	 _updatePriceOverOracleIntegral(oldBase, oldQuote, ampl, oraclePrice, d0);
459	 d1 = d0.sub(d0.mul(lpIn).div(lpSupply));
460	 }
461	 uint256 idealQuote = oldQuote.mul(lpSupply.sub(lpIn)).div(lpSupply);
462	 uint256 newQuote = _getQuote(ampl, oldBase, oraclePrice, d1) + 1;
463	 uint256 fee = idealQuote.sub(newQuote).multiplyDecimal(feeRate);
464	 quoteOut = oldQuote.sub(newQuote).sub(fee);
465	 require(quoteOut >= minQuoteOut, "Insufficient output");
466	 ILiquidityGauge(lpToken).burnFrom(msg.sender, lpIn);
467	 uint256 adminFee = fee.multiplyDecimal(adminFeeRate);
468	 totalAdminFee = totalAdminFee.add(adminFee);
469	 quoteBalance = newQuote.add(fee).sub(adminFee);
470	 emit LiquidityRemoved(msg.sender, lpIn, 0, quoteOut, fee, adminFee, oraclePrice);
471	 }
472	 function sync() external nonReentrant {
473	 (uint256 oldBase, uint256 oldQuote) = _handleRebalance(fund.getRebalanceSize());
474	 uint256 ampl = getAmpl();
475	 uint256 oraclePrice = getOraclePrice();
476	 uint256 d = _getD(oldBase, oldQuote, ampl, oraclePrice);
477	 _updatePriceOverOracleIntegral(oldBase, oldQuote, ampl, oraclePrice, d);
478	 uint256 newBase = fund.trancheBalanceOf(baseTranche, address(this));
479	 uint256 newQuote = _getNewQuoteBalance();
480	 baseBalance = newBase;
481	 quoteBalance = newQuote;
482	 emit Sync(newBase, newQuote, oraclePrice);
483	 }
484	 function collectFee() external {
485	 uint256 totalAdminFee_ = totalAdminFee;
486	 delete totalAdminFee;
487	 IERC20(quoteAddress).safeTransfer(feeCollector, totalAdminFee_);
488	 }
489	 function _getNewQuoteBalance() private view returns (uint256) {
490	 return IERC20(quoteAddress).balanceOf(address(this)).sub(totalAdminFee);
491	 }
492	 function _updatePriceOverOracleIntegral( uint256 base, uint256 quote, uint256 ampl, uint256 oraclePrice, uint256 d ) private {
493	 _priceOverOracleIntegral += _getPriceOverOracle(base, quote, ampl, oraclePrice, d) * (block.timestamp - _priceOverOracleTimestamp);
494	 _priceOverOracleTimestamp = block.timestamp;
495	 }
496	 function _getD( uint256 base, uint256 quote, uint256 ampl, uint256 oraclePrice ) private view returns (uint256) {
497	 uint256 normalizedQuote = quote.mul(_quoteDecimalMultiplier);
498	 uint256 baseValue = base.multiplyDecimal(oraclePrice);
499	 uint256 sum = baseValue.add(normalizedQuote);
500	 if (sum == 0) return 0;
501	 uint256 prev = 0;
502	 uint256 d = sum;
503	 for (uint256 i = 0; i < MAX_ITERATION; i++) {
504	 prev = d;
505	 uint256 d3 = d.mul(d).div(baseValue).mul(d) / normalizedQuote / 4;
506	 d = (sum.mul(4 * ampl) + 2 * d3).mul(d) / d.mul(4 * ampl - 1).add(3 * d3);
507	 if (d <= prev + 1 && prev <= d + 1) {
508	 break;
509	 }
510	 }
511	 return d;
512	 }
513	 function _getPriceOverOracle( uint256 base, uint256 quote, uint256 ampl, uint256 oraclePrice, uint256 d ) private view returns (uint256) {
514	 uint256 commonExp = d.multiplyDecimal(4e18 - 1e18 / ampl);
515	 uint256 baseValue = base.multiplyDecimal(oraclePrice);
516	 uint256 normalizedQuote = quote.mul(_quoteDecimalMultiplier);
517	 return (baseValue.mul(8).add(normalizedQuote.mul(4)).sub(commonExp)) .multiplyDecimal(normalizedQuote) .divideDecimal(normalizedQuote.mul(8).add(baseValue.mul(4)).sub(commonExp)) .divideDecimal(baseValue);
518	 }
519	 function _getBase( uint256 ampl, uint256 quote, uint256 oraclePrice, uint256 d ) private view returns (uint256 base) {
520	 uint256 normalizedQuote = quote.mul(_quoteDecimalMultiplier);
521	 uint256 d3 = d.mul(d).div(normalizedQuote).mul(d) / (16 * ampl);
522	 uint256 prev = 0;
523	 uint256 baseValue = d;
524	 for (uint256 i = 0; i < MAX_ITERATION; i++) {
525	 prev = baseValue;
526	 baseValue = baseValue.mul(baseValue).add(d3) / (2 * baseValue).add(normalizedQuote).add(d / (4 * ampl)).sub(d);
527	 if (baseValue <= prev + 1 && prev <= baseValue + 1) {
528	 break;
529	 }
530	 }
531	 base = baseValue.divideDecimal(oraclePrice);
532	 }
533	 function _getQuote( uint256 ampl, uint256 base, uint256 oraclePrice, uint256 d ) private view returns (uint256 quote) {
534	 uint256 baseValue = base.multiplyDecimal(oraclePrice);
535	 uint256 d3 = d.mul(d).div(baseValue).mul(d) / (16 * ampl);
536	 uint256 prev = 0;
537	 uint256 normalizedQuote = d;
538	 for (uint256 i = 0; i < MAX_ITERATION; i++) {
539	 prev = normalizedQuote;
540	 normalizedQuote = normalizedQuote.mul(normalizedQuote).add(d3) / (2 * normalizedQuote).add(baseValue).add(d / (4 * ampl)).sub(d);
541	 if (normalizedQuote <= prev + 1 && prev <= normalizedQuote + 1) {
542	 break;
543	 }
544	 }
545	 quote = normalizedQuote / _quoteDecimalMultiplier;
546	 }
547	 function updateAmplRamp(uint256 endAmpl, uint256 endTimestamp) external onlyOwner {
548	 require(endAmpl > 0 && endAmpl < AMPL_MAX_VALUE, "Invalid A");
549	 require(endTimestamp >= block.timestamp + AMPL_RAMP_MIN_TIME, "A ramp time too short");
550	 uint256 ampl = getAmpl();
551	 require( (endAmpl >= ampl && endAmpl <= ampl * AMPL_RAMP_MAX_CHANGE) || (endAmpl < ampl && endAmpl * AMPL_RAMP_MAX_CHANGE >= ampl), "A ramp change too large" );
552	 amplRampStart = ampl;
553	 amplRampEnd = endAmpl;
554	 amplRampStartTimestamp = block.timestamp;
555	 amplRampEndTimestamp = endTimestamp;
556	 emit AmplRampUpdated(ampl, endAmpl, block.timestamp, endTimestamp);
557	 }
558	 function _updateFeeCollector(address newFeeCollector) private {
559	 feeCollector = newFeeCollector;
560	 emit FeeCollectorUpdated(newFeeCollector);
561	 }
562	 function updateFeeCollector(address newFeeCollector) external onlyOwner {
563	 _updateFeeCollector(newFeeCollector);
564	 }
565	 function _updateFeeRate(uint256 newFeeRate) private {
566	 require(newFeeRate <= MAX_FEE_RATE, "Exceed max fee rate");
567	 feeRate = newFeeRate;
568	 emit FeeRateUpdated(newFeeRate);
569	 }
570	 function updateFeeRate(uint256 newFeeRate) external onlyOwner {
571	 _updateFeeRate(newFeeRate);
572	 }
573	 function _updateAdminFeeRate(uint256 newAdminFeeRate) private {
574	 require(newAdminFeeRate <= MAX_ADMIN_FEE_RATE, "Exceed max admin fee rate");
575	 adminFeeRate = newAdminFeeRate;
576	 emit AdminFeeRateUpdated(newAdminFeeRate);
577	 }
578	 function updateAdminFeeRate(uint256 newAdminFeeRate) external onlyOwner {
579	 _updateAdminFeeRate(newAdminFeeRate);
580	 }
581	 modifier checkVersion(uint256 version) {
582	 _checkVersion(version);
583	 _;
584	 }
585	 function _checkVersion(uint256 version) internal view virtual {
586	 }
587	 function _getRebalanceResult(uint256 latestVersion) internal view virtual returns ( uint256 newBase, uint256 newQuote, uint256 excessiveQ, uint256 excessiveB, uint256 excessiveR, uint256 excessiveQuote, bool isRebalanced );
588	 function _handleRebalance(uint256 latestVersion) internal virtual returns (uint256 newBase, uint256 newQuote);
589	 function getOraclePrice() public view virtual override returns (uint256);
590	 }
591	 pragma solidity >=0.6.0 <0.8.0;
592	 interface IERC20 {
593	 function totalSupply() external view returns (uint256);
594	 function balanceOf(address account) external view returns (uint256);
595	 function transfer(address recipient, uint256 amount) external returns (bool);
596	 function allowance(address owner, address spender) external view returns (uint256);
597	 function approve(address spender, uint256 amount) external returns (bool);
598	 function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
599	 event Transfer(address indexed from, address indexed to, uint256 value);
600	 event Approval(address indexed owner, address indexed spender, uint256 value);
601	 }
602	 pragma solidity >=0.6.10 <0.8.0;
603	 interface ITwapOracle {
604	 enum UpdateType {
605	 PRIMARY, SECONDARY, OWNER, CHAINLINK, UNISWAP_V2}
606	 function getTwap(uint256 timestamp) external view returns (uint256);
607	 }
608	 pragma solidity >=0.6.10 <0.8.0;
609	 contract BishopStableSwapV2 is StableSwapV2, ITrancheIndexV2 {
610	 event Rebalanced(uint256 base, uint256 quote, uint256 version);
611	 uint256 public immutable tradingCurbThreshold;
612	 uint256 public currentVersion;
613	 constructor( address lpToken_, address fund_, address quoteAddress_, uint256 quoteDecimals_, uint256 ampl_, address feeCollector_, uint256 feeRate_, uint256 adminFeeRate_, uint256 tradingCurbThreshold_ ) public StableSwapV2( lpToken_, fund_, TRANCHE_B, quoteAddress_, quoteDecimals_, ampl_, feeCollector_, feeRate_, adminFeeRate_ ) {
614	 tradingCurbThreshold = tradingCurbThreshold_;
615	 currentVersion = IFundV3(fund_).getRebalanceSize();
616	 }
617	 function _checkVersion(uint256 version) internal view override {
618	 require(version == fund.getRebalanceSize(), "Obsolete rebalance version");
619	 }
620	 function _getRebalanceResult(uint256 latestVersion) internal view override returns ( uint256 newBase, uint256 newQuote, uint256 excessiveQ, uint256 excessiveB, uint256 excessiveR, uint256 excessiveQuote, bool isRebalanced ) {
621	 if (latestVersion == currentVersion) {
622	 return (baseBalance, quoteBalance, 0, 0, 0, 0, false);
623	 }
624	 isRebalanced = true;
625	 uint256 oldBaseBalance = baseBalance;
626	 uint256 oldQuoteBalance = quoteBalance;
627	 (excessiveQ, newBase, ) = fund.batchRebalance( 0, oldBaseBalance, 0, currentVersion, latestVersion );
628	 if (newBase < oldBaseBalance) {
629	 excessiveR = IPrimaryMarketV3(fund.primaryMarket()).getSplit(excessiveQ);
630	 newBase = newBase.add(excessiveR);
631	 }
632	 if (newBase < oldBaseBalance) {
633	 newQuote = oldQuoteBalance.mul(newBase).div(oldBaseBalance);
634	 excessiveQuote = oldQuoteBalance - newQuote;
635	 }
636	 else {
637	 newQuote = oldQuoteBalance;
638	 excessiveB = newBase - oldBaseBalance;
639	 newBase = oldBaseBalance;
640	 }
641	 }
642	 function _handleRebalance(uint256 latestVersion) internal override returns (uint256 newBase, uint256 newQuote) {
643	 uint256 excessiveQ;
644	 uint256 excessiveB;
645	 uint256 excessiveR;
646	 uint256 excessiveQuote;
647	 bool isRebalanced;
648	 ( newBase, newQuote, excessiveQ, excessiveB, excessiveR, excessiveQuote, isRebalanced ) = _getRebalanceResult(latestVersion);
649	 if (isRebalanced) {
650	 baseBalance = newBase;
651	 quoteBalance = newQuote;
652	 currentVersion = latestVersion;
653	 emit Rebalanced(newBase, newQuote, latestVersion);
654	 if (excessiveQ > 0) {
655	 if (excessiveR > 0) {
656	 IPrimaryMarketV3(fund.primaryMarket()).split( address(this), excessiveQ, latestVersion );
657	 excessiveQ = 0;
658	 }
659	 else {
660	 fund.trancheTransfer(TRANCHE_Q, lpToken, excessiveQ, latestVersion);
661	 }
662	 }
663	 if (excessiveB > 0) {
664	 fund.trancheTransfer(TRANCHE_B, lpToken, excessiveB, latestVersion);
665	 }
666	 if (excessiveR > 0) {
667	 fund.trancheTransfer(TRANCHE_R, lpToken, excessiveR, latestVersion);
668	 }
669	 if (excessiveQuote > 0) {
670	 IERC20(quoteAddress).safeTransfer(lpToken, excessiveQuote);
671	 }
672	 ILiquidityGauge(lpToken).distribute( excessiveQ, excessiveB, excessiveR, excessiveQuote, latestVersion );
673	 }
674	 }
675	 function getOraclePrice() public view override returns (uint256) {
676	 uint256 price = fund.twapOracle().getLatest();
677	 (, uint256 navB, uint256 navR) = fund.extrapolateNav(price);
678	 require(navR >= navB.multiplyDecimal(tradingCurbThreshold), "Trading curb");
679	 return navB;
680	 }
681	 }
682	 pragma solidity ^0.6.0;
683	 interface AggregatorV3Interface {
684	 function decimals() external view returns ( uint8 );
685	 function description() external view returns ( string memory );
686	 function version() external view returns ( uint256 );
687	 function getRoundData( uint80 _roundId ) external view returns ( uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound );
688	 function latestRoundData() external view returns ( uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound );
689	 }
690	 pragma solidity >=0.6.10 <0.8.0;
691	 interface IPrimaryMarketV3 {
692	 function fund() external view returns (address);
693	 function getCreation(uint256 underlying) external view returns (uint256 outQ);
694	 function getCreationForQ(uint256 minOutQ) external view returns (uint256 underlying);
695	 function getRedemption(uint256 inQ) external view returns (uint256 underlying, uint256 fee);
696	 function getRedemptionForUnderlying(uint256 minUnderlying) external view returns (uint256 inQ);
697	 function getSplit(uint256 inQ) external view returns (uint256 outB);
698	 function getSplitForB(uint256 minOutB) external view returns (uint256 inQ);
699	 function getMerge(uint256 inB) external view returns (uint256 outQ, uint256 feeQ);
700	 function getMergeForQ(uint256 minOutQ) external view returns (uint256 inB);
701	 function canBeRemovedFromFund() external view returns (bool);
702	 function create( address recipient, uint256 minOutQ, uint256 version ) external returns (uint256 outQ);
703	 function redeem( address recipient, uint256 inQ, uint256 minUnderlying, uint256 version ) external returns (uint256 underlying);
704	 function redeemAndUnwrap( address recipient, uint256 inQ, uint256 minUnderlying, uint256 version ) external returns (uint256 underlying);
705	 function queueRedemption( address recipient, uint256 inQ, uint256 minUnderlying, uint256 version ) external returns (uint256 underlying, uint256 index);
706	 function claimRedemptions(address account, uint256[] calldata indices) external returns (uint256 underlying);
707	 function claimRedemptionsAndUnwrap(address account, uint256[] calldata indices) external returns (uint256 underlying);
708	 function split( address recipient, uint256 inQ, uint256 version ) external returns (uint256 outB);
709	 function merge( address recipient, uint256 inB, uint256 version ) external returns (uint256 outQ);
710	 function settle(uint256 day) external;
711	 }
712	 pragma solidity >=0.6.0 <0.8.0;
713	 library SafeERC20 {
714	 using SafeMath for uint256;
715	 using Address for address;
716	 function safeTransfer(IERC20 token, address to, uint256 value) internal {
717	 _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
718	 }
719	 function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
720	 _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
721	 }
722	 function safeApprove(IERC20 token, address spender, uint256 value) internal {
723	 require((value == 0) || (token.allowance(address(this), spender) == 0), "SafeERC20: approve from non-zero to non-zero allowance" );
724	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
725	 }
726	 function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
727	 uint256 newAllowance = token.allowance(address(this), spender).add(value);
728	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
729	 }
730	 function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
731	 uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
732	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
733	 }
734	 function _callOptionalReturn(IERC20 token, bytes memory data) private {
735	 bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
736	 if (returndata.length > 0) {
737	 require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
738	 }
739	 }
740	 }
741	 pragma solidity >=0.6.0 <0.8.0;
742	 library SafeMath {
743	 function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
744	 uint256 c = a + b;
745	 if (c < a) return (false, 0);
746	 return (true, c);
747	 }
748	 function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
749	 if (b > a) return (false, 0);
750	 return (true, a - b);
751	 }
752	 function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
753	 if (a == 0) return (true, 0);
754	 uint256 c = a * b;
755	 if (c / a != b) return (false, 0);
756	 return (true, c);
757	 }
758	 function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
759	 if (b == 0) return (false, 0);
760	 return (true, a / b);
761	 }
762	 function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
763	 if (b == 0) return (false, 0);
764	 return (true, a % b);
765	 }
766	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
767	 uint256 c = a + b;
768	 require(c >= a, "SafeMath: addition overflow");
769	 return c;
770	 }
771	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
772	 require(b <= a, "SafeMath: subtraction overflow");
773	 return a - b;
774	 }
775	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
776	 if (a == 0) return 0;
777	 uint256 c = a * b;
778	 require(c / a == b, "SafeMath: multiplication overflow");
779	 return c;
780	 }
781	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
782	 require(b > 0, "SafeMath: division by zero");
783	 return a / b;
784	 }
785	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
786	 require(b > 0, "SafeMath: modulo by zero");
787	 return a % b;
788	 }
789	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
790	 require(b <= a, errorMessage);
791	 return a - b;
792	 }
793	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
794	 require(b > 0, errorMessage);
795	 return a / b;
796	 }
797	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
798	 require(b > 0, errorMessage);
799	 return a % b;
800	 }
801	 }
802	 pragma solidity >=0.6.10 <0.8.0;
803	 interface ILiquidityGauge is IERC20 {
804	 function mint(address account, uint256 amount) external;
805	 function burnFrom(address account, uint256 amount) external;
806	 function workingSupply() external view returns (uint256);
807	 function workingBalanceOf(address account) external view returns (uint256);
808	 function claimableRewards(address account) external returns ( uint256 chessAmount, uint256 bonusAmount, uint256 amountQ, uint256 amountB, uint256 amountR, uint256 quoteAmount );
809	 function claimRewards(address account) external;
810	 function distribute( uint256 amountQ, uint256 amountB, uint256 amountR, uint256 quoteAmount, uint256 version ) external;
811	 }
812	 pragma solidity >=0.6.10 <0.8.0;
813	 interface ITranchessSwapCallee {
814	 function tranchessSwapCallback( uint256 baseDeltaOut, uint256 quoteDeltaOut, bytes calldata data ) external;
815	 }
816	 pragma solidity >=0.6.10 <0.8.0;
817	 interface IWrappedERC20 is IERC20 {
818	 function deposit() external payable;
819	 function withdraw(uint256 wad) external;
820	 }
821	 pragma solidity >=0.6.10 <0.8.0;
822	 library SafeDecimalMath {
823	 using SafeMath for uint256;
824	 uint256 private constant decimals = 18;
825	 uint256 private constant highPrecisionDecimals = 27;
826	 uint256 private constant UNIT = 10**uint256(decimals);
827	 uint256 private constant PRECISE_UNIT = 10**uint256(highPrecisionDecimals);
828	 uint256 private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10**uint256(highPrecisionDecimals - decimals);
829	 function multiplyDecimal(uint256 x, uint256 y) internal pure returns (uint256) {
830	 return x.mul(y).div(UNIT);
831	 }
832	 function multiplyDecimalPrecise(uint256 x, uint256 y) internal pure returns (uint256) {
833	 return x.mul(y).div(PRECISE_UNIT);
834	 }
835	 function divideDecimal(uint256 x, uint256 y) internal pure returns (uint256) {
836	 return x.mul(UNIT).div(y);
837	 }
838	 function divideDecimalPrecise(uint256 x, uint256 y) internal pure returns (uint256) {
839	 return x.mul(PRECISE_UNIT).div(y);
840	 }
841	 function decimalToPreciseDecimal(uint256 i) internal pure returns (uint256) {
842	 return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);
843	 }
844	 function preciseDecimalToDecimal(uint256 i) internal pure returns (uint256) {
845	 uint256 quotientTimesTen = i.mul(10).div(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);
846	 if (quotientTimesTen % 10 >= 5) {
847	 quotientTimesTen = quotientTimesTen.add(10);
848	 }
849	 return quotientTimesTen.div(10);
850	 }
851	 function saturatingMul(uint256 a, uint256 b) internal pure returns (uint256) {
852	 if (a == 0) {
853	 return 0;
854	 }
855	 uint256 c = a * b;
856	 return c / a != b ? type(uint256).max : c;
857	 }
858	 function saturatingMultiplyDecimal(uint256 x, uint256 y) internal pure returns (uint256) {
859	 return saturatingMul(x, y).div(UNIT);
860	 }
861	 }
862	 pragma solidity >=0.6.10 <0.8.0;
863	 library AdvancedMath {
864	 function sqrt(uint256 s) internal pure returns (uint256) {
865	 if (s == 0) return 0;
866	 uint256 t = s;
867	 uint256 x0 = 2;
868	 if (t >= 1 << 128) {
869	 t >>= 128;
870	 x0 <<= 64;
871	 }
872	 if (t >= 1 << 64) {
873	 t >>= 64;
874	 x0 <<= 32;
875	 }
876	 if (t >= 1 << 32) {
877	 t >>= 32;
878	 x0 <<= 16;
879	 }
880	 if (t >= 1 << 16) {
881	 t >>= 16;
882	 x0 <<= 8;
883	 }
884	 if (t >= 1 << 8) {
885	 t >>= 8;
886	 x0 <<= 4;
887	 }
888	 if (t >= 1 << 4) {
889	 t >>= 4;
890	 x0 <<= 2;
891	 }
892	 if (t >= 1 << 2) {
893	 x0 <<= 1;
894	 }
895	 uint256 x1 = (x0 + s / x0) >> 1;
896	 while (x1 < x0) {
897	 x0 = x1;
898	 x1 = (x0 + s / x0) >> 1;
899	 }
900	 return x0;
901	 }
902	 function cbrt(uint256 s) internal pure returns (uint256) {
903	 if (s == 0) return 0;
904	 uint256 t = s;
905	 uint256 x0 = 2;
906	 if (t >= 1 << 192) {
907	 t >>= 192;
908	 x0 <<= 64;
909	 }
910	 if (t >= 1 << 96) {
911	 t >>= 96;
912	 x0 <<= 32;
913	 }
914	 if (t >= 1 << 48) {
915	 t >>= 48;
916	 x0 <<= 16;
917	 }
918	 if (t >= 1 << 24) {
919	 t >>= 24;
920	 x0 <<= 8;
921	 }
922	 if (t >= 1 << 12) {
923	 t >>= 12;
924	 x0 <<= 4;
925	 }
926	 if (t >= 1 << 6) {
927	 t >>= 6;
928	 x0 <<= 2;
929	 }
930	 if (t >= 1 << 3) {
931	 x0 <<= 1;
932	 }
933	 uint256 x1 = (2 * x0 + s / x0 / x0) / 3;
934	 while (x1 < x0) {
935	 x0 = x1;
936	 x1 = (2 * x0 + s / x0 / x0) / 3;
937	 }
938	 return x0;
939	 }
940	 }
941	 pragma solidity >=0.6.2 <0.8.0;
942	 library Address {
943	 function isContract(address account) internal view returns (bool) {
944	 uint256 size;
945	 assembly {
946	 size := extcodesize(account) }
947	 return size > 0;
948	 }
949	 function sendValue(address payable recipient, uint256 amount) internal {
950	 require(address(this).balance >= amount, "Address: insufficient balance");
951	 (bool success, ) = recipient.call{
952	 value: amount }
953	 ("");
954	 require(success, "Address: unable to send value, recipient may have reverted");
955	 }
956	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
957	 return functionCall(target, data, "Address: low-level call failed");
958	 }
959	 function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
960	 return functionCallWithValue(target, data, 0, errorMessage);
961	 }
962	 function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
963	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
964	 }
965	 function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
966	 require(address(this).balance >= value, "Address: insufficient balance for call");
967	 require(isContract(target), "Address: call to non-contract");
968	 (bool success, bytes memory returndata) = target.call{
969	 value: value }
970	 (data);
971	 return _verifyCallResult(success, returndata, errorMessage);
972	 }
973	 function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
974	 return functionStaticCall(target, data, "Address: low-level static call failed");
975	 }
976	 function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
977	 require(isContract(target), "Address: static call to non-contract");
978	 (bool success, bytes memory returndata) = target.staticcall(data);
979	 return _verifyCallResult(success, returndata, errorMessage);
980	 }
981	 function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
982	 return functionDelegateCall(target, data, "Address: low-level delegate call failed");
983	 }
984	 function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
985	 require(isContract(target), "Address: delegate call to non-contract");
986	 (bool success, bytes memory returndata) = target.delegatecall(data);
987	 return _verifyCallResult(success, returndata, errorMessage);
988	 }
989	 function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
990	 if (success) {
991	 return returndata;
992	 }
993	 else {
994	 if (returndata.length > 0) {
995	 assembly {
996	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
997	 }
998	 else {
999	 revert(errorMessage);
1000	 }
1001	 }
1002	 }
1003	 }
1004	 pragma solidity >=0.6.10 <0.8.0;
1005	 interface IFundV3 {
1006	 struct Rebalance {
1007	 uint256 ratioB2Q;
1008	 uint256 ratioR2Q;
1009	 uint256 ratioBR;
1010	 uint256 timestamp;
1011	 }
1012	 function tokenUnderlying() external view returns (address);
1013	 function tokenQ() external view returns (address);
1014	 function tokenB() external view returns (address);
1015	 function tokenR() external view returns (address);
1016	 function tokenShare(uint256 tranche) external view returns (address);
1017	 function primaryMarket() external view returns (address);
1018	 function primaryMarketUpdateProposal() external view returns (address, uint256);
1019	 function strategy() external view returns (address);
1020	 function strategyUpdateProposal() external view returns (address, uint256);
1021	 function underlyingDecimalMultiplier() external view returns (uint256);
1022	 function twapOracle() external view returns (ITwapOracleV2);
1023	 function feeCollector() external view returns (address);
1024	 function endOfDay(uint256 timestamp) external pure returns (uint256);
1025	 function trancheTotalSupply(uint256 tranche) external view returns (uint256);
1026	 function trancheBalanceOf(uint256 tranche, address account) external view returns (uint256);
1027	 function trancheAllBalanceOf(address account) external view returns ( uint256, uint256, uint256 );
1028	 function trancheBalanceVersion(address account) external view returns (uint256);
1029	 function trancheAllowance( uint256 tranche, address owner, address spender ) external view returns (uint256);
1030	 function trancheAllowanceVersion(address owner, address spender) external view returns (uint256);
1031	 function trancheTransfer( uint256 tranche, address recipient, uint256 amount, uint256 version ) external;
1032	 function trancheTransferFrom( uint256 tranche, address sender, address recipient, uint256 amount, uint256 version ) external;
1033	 function trancheApprove( uint256 tranche, address spender, uint256 amount, uint256 version ) external;
1034	 function getRebalanceSize() external view returns (uint256);
1035	 function getRebalance(uint256 index) external view returns (Rebalance memory);
1036	 function getRebalanceTimestamp(uint256 index) external view returns (uint256);
1037	 function currentDay() external view returns (uint256);
1038	 function splitRatio() external view returns (uint256);
1039	 function historicalSplitRatio(uint256 version) external view returns (uint256);
1040	 function fundActivityStartTime() external view returns (uint256);
1041	 function isFundActive(uint256 timestamp) external view returns (bool);
1042	 function getEquivalentTotalB() external view returns (uint256);
1043	 function getEquivalentTotalQ() external view returns (uint256);
1044	 function historicalEquivalentTotalB(uint256 timestamp) external view returns (uint256);
1045	 function historicalNavs(uint256 timestamp) external view returns (uint256 navB, uint256 navR);
1046	 function extrapolateNav(uint256 price) external view returns ( uint256, uint256, uint256 );
1047	 function doRebalance( uint256 amountQ, uint256 amountB, uint256 amountR, uint256 index ) external view returns ( uint256 newAmountQ, uint256 newAmountB, uint256 newAmountR );
1048	 function batchRebalance( uint256 amountQ, uint256 amountB, uint256 amountR, uint256 fromIndex, uint256 toIndex ) external view returns ( uint256 newAmountQ, uint256 newAmountB, uint256 newAmountR );
1049	 function refreshBalance(address account, uint256 targetVersion) external;
1050	 function refreshAllowance( address owner, address spender, uint256 targetVersion ) external;
1051	 function shareTransfer( address sender, address recipient, uint256 amount ) external;
1052	 function shareTransferFrom( address spender, address sender, address recipient, uint256 amount ) external returns (uint256 newAllowance);
1053	 function shareIncreaseAllowance( address sender, address spender, uint256 addedValue ) external returns (uint256 newAllowance);
1054	 function shareDecreaseAllowance( address sender, address spender, uint256 subtractedValue ) external returns (uint256 newAllowance);
1055	 function shareApprove( address owner, address spender, uint256 amount ) external;
1056	 function historicalUnderlying(uint256 timestamp) external view returns (uint256);
1057	 function getTotalUnderlying() external view returns (uint256);
1058	 function getStrategyUnderlying() external view returns (uint256);
1059	 function getTotalDebt() external view returns (uint256);
1060	 event RebalanceTriggered( uint256 indexed index, uint256 indexed day, uint256 navSum, uint256 navB, uint256 navROrZero, uint256 ratioB2Q, uint256 ratioR2Q, uint256 ratioBR );
1061	 event Settled(uint256 indexed day, uint256 navB, uint256 navR, uint256 interestRate);
1062	 event InterestRateUpdated(uint256 baseInterestRate, uint256 floatingInterestRate);
1063	 event BalancesRebalanced( address indexed account, uint256 version, uint256 balanceQ, uint256 balanceB, uint256 balanceR );
1064	 event AllowancesRebalanced( address indexed owner, address indexed spender, uint256 version, uint256 allowanceQ, uint256 allowanceB, uint256 allowanceR );
1065	 }
1066	 pragma solidity >=0.6.10 <0.8.0;
1067	 interface ITwapOracleV2 is ITwapOracle {
1068	 function getLatest() external view returns (uint256);
1069	 }
