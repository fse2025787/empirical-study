row number 
1	  pragma abicoder v2;
2	 pragma experimental ABIEncoderV2;
3	 pragma solidity >=0.4.24 <0.8.0;
4	 abstract contract Initializable {
5	 bool private _initialized;
6	 bool private _initializing;
7	 modifier initializer() {
8	 require(_initializing || _isConstructor() || !_initialized, "Initializable: contract is already initialized");
9	 bool isTopLevelCall = !_initializing;
10	 if (isTopLevelCall) {
11	 _initializing = true;
12	 _initialized = true;
13	 }
14	 _;
15	 if (isTopLevelCall) {
16	 _initializing = false;
17	 }
18	 }
19	 function _isConstructor() private view returns (bool) {
20	 return !AddressUpgradeable.isContract(address(this));
21	 }
22	 }
23	 pragma solidity >=0.6.0 <0.8.0;
24	 interface IERC165Upgradeable {
25	 function supportsInterface(bytes4 interfaceId) external view returns (bool);
26	 }
27	 pragma solidity >=0.6.0 <0.8.0;
28	 interface IERC1155ReceiverUpgradeable is IERC165Upgradeable {
29	 function onERC1155Received( address operator, address from, uint256 id, uint256 value, bytes calldata data ) external returns(bytes4);
30	 function onERC1155BatchReceived( address operator, address from, uint256[] calldata ids, uint256[] calldata values, bytes calldata data ) external returns(bytes4);
31	 }
32	 pragma solidity >=0.6.0 <0.8.0;
33	 abstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {
34	 bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;
35	 mapping(bytes4 => bool) private _supportedInterfaces;
36	 function __ERC165_init() internal initializer {
37	 __ERC165_init_unchained();
38	 }
39	 function __ERC165_init_unchained() internal initializer {
40	 _registerInterface(_INTERFACE_ID_ERC165);
41	 }
42	 function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
43	 return _supportedInterfaces[interfaceId];
44	 }
45	 function _registerInterface(bytes4 interfaceId) internal virtual {
46	 require(interfaceId != 0xffffffff, "ERC165: invalid interface id");
47	 _supportedInterfaces[interfaceId] = true;
48	 }
49	 uint256[49] private __gap;
50	 }
51	 pragma solidity >=0.6.0 <0.8.0;
52	 interface IERC20Upgradeable {
53	 function totalSupply() external view returns (uint256);
54	 function balanceOf(address account) external view returns (uint256);
55	 function transfer(address recipient, uint256 amount) external returns (bool);
56	 function allowance(address owner, address spender) external view returns (uint256);
57	 function approve(address spender, uint256 amount) external returns (bool);
58	 function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
59	 event Transfer(address indexed from, address indexed to, uint256 value);
60	 event Approval(address indexed owner, address indexed spender, uint256 value);
61	 }
62	 pragma solidity >=0.6.0 <0.8.0;
63	 abstract contract ContextUpgradeable is Initializable {
64	 function __Context_init() internal initializer {
65	 __Context_init_unchained();
66	 }
67	 function __Context_init_unchained() internal initializer {
68	 }
69	 function _msgSender() internal view virtual returns (address payable) {
70	 return msg.sender;
71	 }
72	 function _msgData() internal view virtual returns (bytes memory) {
73	 this;
74	 return msg.data;
75	 }
76	 uint256[50] private __gap;
77	 }
78	 pragma solidity >=0.6.0 <0.8.0;
79	 abstract contract ERC1155ReceiverUpgradeable is Initializable, ERC165Upgradeable, IERC1155ReceiverUpgradeable {
80	 function __ERC1155Receiver_init() internal initializer {
81	 __ERC165_init_unchained();
82	 __ERC1155Receiver_init_unchained();
83	 }
84	 function __ERC1155Receiver_init_unchained() internal initializer {
85	 _registerInterface( ERC1155ReceiverUpgradeable(address(0)).onERC1155Received.selector ^ ERC1155ReceiverUpgradeable(address(0)).onERC1155BatchReceived.selector );
86	 }
87	 uint256[50] private __gap;
88	 }
89	 pragma solidity >=0.6.0 <0.8.0;
90	 abstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {
91	 address private _owner;
92	 event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
93	 function __Ownable_init() internal initializer {
94	 __Context_init_unchained();
95	 __Ownable_init_unchained();
96	 }
97	 function __Ownable_init_unchained() internal initializer {
98	 address msgSender = _msgSender();
99	 _owner = msgSender;
100	 emit OwnershipTransferred(address(0), msgSender);
101	 }
102	 function owner() public view virtual returns (address) {
103	 return _owner;
104	 }
105	 modifier onlyOwner() {
106	 require(owner() == _msgSender(), "Ownable: caller is not the owner");
107	 _;
108	 }
109	 function renounceOwnership() public virtual onlyOwner {
110	 emit OwnershipTransferred(_owner, address(0));
111	 _owner = address(0);
112	 }
113	 function transferOwnership(address newOwner) public virtual onlyOwner {
114	 require(newOwner != address(0), "Ownable: new owner is the zero address");
115	 emit OwnershipTransferred(_owner, newOwner);
116	 _owner = newOwner;
117	 }
118	 uint256[49] private __gap;
119	 }
120	 pragma solidity >=0.6.0 <0.8.0;
121	 contract ERC1155HolderUpgradeable is Initializable, ERC1155ReceiverUpgradeable {
122	 function __ERC1155Holder_init() internal initializer {
123	 __ERC165_init_unchained();
124	 __ERC1155Receiver_init_unchained();
125	 __ERC1155Holder_init_unchained();
126	 }
127	 function __ERC1155Holder_init_unchained() internal initializer {
128	 }
129	 function onERC1155Received(address, address, uint256, uint256, bytes memory) public virtual override returns (bytes4) {
130	 return this.onERC1155Received.selector;
131	 }
132	 function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) public virtual override returns (bytes4) {
133	 return this.onERC1155BatchReceived.selector;
134	 }
135	 uint256[50] private __gap;
136	 }
137	 pragma solidity 0.7.6;
138	 interface IERC1155 is IERC165Upgradeable {
139	 event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);
140	 event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);
141	 event ApprovalForAll(address indexed account, address indexed operator, bool approved);
142	 event URI(string value, uint256 indexed id);
143	 function balanceOf(address account, uint256 id) external view returns (uint256);
144	 function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);
145	 function setApprovalForAll(address operator, bool approved) external;
146	 function isApprovedForAll(address account, address operator) external view returns (bool);
147	 function safeTransferFrom( address from, address to, uint256 id, uint256 amount, bytes calldata data ) external;
148	 function safeBatchTransferFrom( address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data ) external;
149	 function grantRole(bytes32 role, address account) external;
150	 function MINTER_ROLE() external view returns (bytes32);
151	 function mint( address to, uint64 _ammId, uint64 _periodIndex, uint32 _pairId, uint256 amount, bytes memory data ) external returns (uint256 id);
152	 function burnFrom( address account, uint256 id, uint256 value ) external;
153	 }
154	 pragma solidity 0.7.6;
155	 interface IERC20 is IERC20Upgradeable {
156	 function name() external returns (string memory);
157	 function symbol() external returns (string memory);
158	 function decimals() external view returns (uint8);
159	 function increaseAllowance(address spender, uint256 addedValue) external returns (bool);
160	 function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);
161	 }
162	 pragma solidity 0.7.6;
163	 contract MasterChef is OwnableUpgradeable, ERC1155HolderUpgradeable {
164	 using SafeMathUpgradeable for uint256;
165	 using SafeERC20Upgradeable for IERC20Upgradeable;
166	 using SafeERC20Upgradeable for ILPToken;
167	 using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;
168	 using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;
169	 struct UserInfo {
170	 uint256 amount;
171	 uint256 rewardDebt;
172	 uint256 periodId;
173	 }
174	 struct PoolInfo {
175	 uint256 allocPoint;
176	 uint256 accAPWPerShare;
177	 uint256 lastRewardBlock;
178	 uint256 ammId;
179	 uint256 pairId;
180	 }
181	 EnumerableSetUpgradeable.UintSet internal activePools;
182	 mapping(uint256 => mapping(uint256 => uint256)) internal poolToPeriodId;
183	 mapping(uint256 => mapping(uint256 => mapping(address => UserInfo))) public userInfo;
184	 mapping(uint256 => address) public lpIDToFutureAddress;
185	 mapping(uint256 => uint256) public nextUpgradeAllocPoint;
186	 mapping(uint256 => IRewarder) public rewarders;
187	 uint256 private constant TOKEN_PRECISION = 1e12;
188	 IERC20Upgradeable public apw;
189	 ILPToken public lpToken;
190	 uint256 public apwPerBlock;
191	 mapping(uint256 => PoolInfo) public poolInfo;
192	 bytes4 public constant ERC1155_ERC165 = 0xd9b67a26;
193	 mapping(address => EnumerableSetUpgradeable.UintSet) internal userLpTokensIds;
194	 uint256 public totalAllocPoint;
195	 uint256 public startBlock;
196	 modifier validPool(uint256 _lpTokenId) {
197	 uint64 ammId = lpToken.getAMMId(_lpTokenId);
198	 uint256 pairId = lpToken.getPairId(_lpTokenId);
199	 require(poolToPeriodId[ammId][pairId] != 0, "MasterChef: invalid pool id");
200	 _;
201	 }
202	 event Deposit(address indexed user, uint256 indexed lpTokenId, uint256 amount);
203	 event Withdraw(address indexed user, uint256 indexed lpTokenId, uint256 amount);
204	 event EmergencyWithdraw(address indexed user, uint256 indexed lpTokenId, uint256 amount);
205	 event NextAllocPointSet(uint256 indexed previousLpTokenId, uint256 nextAllocPoint);
206	 event Harvest(address indexed user, uint256 indexed lpTokenId, uint256 amount);
207	 function initialize( address _apw, address _lpToken, uint256 _apwPerBlock, uint256 _startBlock ) external initializer {
208	 require(_apw != address(0), "MasterChef: Invalid APW address provided");
209	 require(_lpToken != address(0), "MasterChef: Invalid LPToken address provided");
210	 require(_apwPerBlock > 0, "MasterChef: !apwPerBlock-0");
211	 apw = IERC20Upgradeable(_apw);
212	 lpToken = ILPToken(_lpToken);
213	 apwPerBlock = _apwPerBlock;
214	 startBlock = _startBlock;
215	 totalAllocPoint = 0;
216	 __Ownable_init();
217	 _registerInterface(ERC1155_ERC165);
218	 }
219	 function add( uint256 _allocPoint, uint256 _lpTokenId, IRewarder _rewarder, bool _withUpdate ) external onlyOwner {
220	 _add(_allocPoint, _lpTokenId, _rewarder, _withUpdate);
221	 }
222	 function _add( uint256 _allocPoint, uint256 _lpTokenId, IRewarder _rewarder, bool _withUpdate ) internal {
223	 uint64 ammId = lpToken.getAMMId(_lpTokenId);
224	 uint256 pairId = lpToken.getPairId(_lpTokenId);
225	 uint64 periodId = lpToken.getPeriodIndex(_lpTokenId);
226	 address ammAddress = lpToken.amms(ammId);
227	 require(ammAddress != address(0), "MasterChef: LPTokenId Invalid");
228	 require(poolToPeriodId[ammId][pairId] != periodId, "MasterChef: LP Token already added");
229	 address futureAddress = IAMM(ammAddress).getFutureAddress();
230	 uint256 lastPeriodId = IFutureVault(futureAddress).getCurrentPeriodIndex();
231	 require(periodId == lastPeriodId, "MasterChef: Invalid period ID for LP Token");
232	 lpIDToFutureAddress[_lpTokenId] = futureAddress;
233	 rewarders[_lpTokenId] = _rewarder;
234	 if (_withUpdate) {
235	 massUpdatePools();
236	 }
237	 uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock;
238	 totalAllocPoint = totalAllocPoint.add(_allocPoint);
239	 poolInfo[_lpTokenId] = PoolInfo({
240	 allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, accAPWPerShare: 0, ammId: ammId, pairId: pairId }
241	 );
242	 activePools.add(_lpTokenId);
243	 poolToPeriodId[ammId][pairId] = periodId;
244	 }
245	 function set( uint256 _lpTokenId, uint256 _allocPoint, IRewarder _rewarder, bool overwrite, bool _withUpdate ) external onlyOwner {
246	 _set(_lpTokenId, _allocPoint, _rewarder, overwrite, _withUpdate);
247	 }
248	 function _set( uint256 _lpTokenId, uint256 _allocPoint, IRewarder _rewarder, bool overwrite, bool _withUpdate ) internal validPool(_lpTokenId) {
249	 if (_withUpdate) {
250	 massUpdatePools();
251	 }
252	 totalAllocPoint = totalAllocPoint.sub(poolInfo[_lpTokenId].allocPoint).add(_allocPoint);
253	 poolInfo[_lpTokenId].allocPoint = _allocPoint;
254	 if (overwrite) {
255	 rewarders[_lpTokenId] = _rewarder;
256	 }
257	 }
258	 function pendingAPW(uint256 _lpTokenId, address _user) external view validPool(_lpTokenId) returns (uint256) {
259	 uint64 ammId = lpToken.getAMMId(_lpTokenId);
260	 uint256 pairId = lpToken.getPairId(_lpTokenId);
261	 UserInfo storage user = userInfo[ammId][pairId][_user];
262	 PoolInfo storage pool = poolInfo[_lpTokenId];
263	 uint256 accAPWPerShare = pool.accAPWPerShare;
264	 uint256 lpSupply = lpToken.balanceOf(address(this), _lpTokenId);
265	 if (block.number > pool.lastRewardBlock && lpSupply != 0 && totalAllocPoint != 0) {
266	 uint256 apwReward = (block.number.sub(pool.lastRewardBlock)).mul(apwPerBlock).mul(pool.allocPoint).div(totalAllocPoint);
267	 accAPWPerShare = accAPWPerShare.add(apwReward.mul(TOKEN_PRECISION).div(lpSupply));
268	 }
269	 return user.amount.mul(accAPWPerShare).div(TOKEN_PRECISION).sub(user.rewardDebt);
270	 }
271	 function massUpdatePools() public {
272	 uint256 length = activePools.length();
273	 for (uint256 i = 0; i < length; ++i) {
274	 updatePool(activePools.at(i));
275	 }
276	 }
277	 function updatePool(uint256 _lpTokenId) public validPool(_lpTokenId) {
278	 PoolInfo storage pool = poolInfo[_lpTokenId];
279	 if (block.number <= pool.lastRewardBlock) {
280	 return;
281	 }
282	 uint256 lpSupply = lpToken.balanceOf(address(this), _lpTokenId);
283	 if (lpSupply == 0) {
284	 pool.lastRewardBlock = block.number;
285	 return;
286	 }
287	 uint256 apwReward = totalAllocPoint == 0 ? 0 : (block.number.sub(pool.lastRewardBlock)).mul(apwPerBlock).mul(pool.allocPoint).div(totalAllocPoint);
288	 pool.accAPWPerShare = pool.accAPWPerShare.add(apwReward.mul(TOKEN_PRECISION).div(lpSupply));
289	 pool.lastRewardBlock = block.number;
290	 }
291	 function _upgradePoolRewardsIfNeeded(uint64 _ammId, uint256 _pairId) internal returns (bool) {
292	 address ammAddress = lpToken.amms(_ammId);
293	 uint256 lastPeriodId = IFutureVault(IAMM(ammAddress).getFutureAddress()).getCurrentPeriodIndex();
294	 uint256 previousPeriodId = poolToPeriodId[_ammId][_pairId];
295	 uint previousLpTokenId = IAMM(ammAddress).getLPTokenId(_ammId, previousPeriodId, _pairId);
296	 if (lastPeriodId > previousPeriodId) {
297	 _set(previousLpTokenId, 0, IRewarder(0x0), false, false);
298	 uint256 newLpTokenId = IAMM(ammAddress).getLPTokenId(_ammId, lastPeriodId, _pairId);
299	 activePools.remove(previousLpTokenId);
300	 IRewarder rewarder = rewarders[previousLpTokenId];
301	 _add(nextUpgradeAllocPoint[previousLpTokenId], newLpTokenId, rewarder, false);
302	 if (address(rewarder) != address(0x0)) rewarder.renewPool(previousLpTokenId, newLpTokenId);
303	 return true;
304	 }
305	 else {
306	 return false;
307	 }
308	 }
309	 function deposit(uint256 _lpTokenId, uint256 _amount) external validPool(_lpTokenId) {
310	 uint64 ammId = lpToken.getAMMId(_lpTokenId);
311	 uint256 pairId = lpToken.getPairId(_lpTokenId);
312	 _upgradePoolRewardsIfNeeded(ammId, pairId);
313	 uint256 periodOfToken = lpToken.getPeriodIndex(_lpTokenId);
314	 uint256 lastPeriodId = IFutureVault(lpIDToFutureAddress[_lpTokenId]).getCurrentPeriodIndex();
315	 require(periodOfToken == lastPeriodId, "Masterchef: Invalid period Id for Token");
316	 updatePool(_lpTokenId);
317	 PoolInfo storage pool = poolInfo[_lpTokenId];
318	 UserInfo storage user = userInfo[ammId][pairId][msg.sender];
319	 if (user.amount > 0) {
320	 uint256 lastUserLpTokenId = IAMM(lpToken.amms(ammId)).getLPTokenId(ammId, user.periodId, pairId);
321	 uint256 accAPWPerShare = (user.periodId != 0 && user.periodId < periodOfToken) ? poolInfo[lastUserLpTokenId].accAPWPerShare : pool.accAPWPerShare;
322	 uint256 pending = user.amount.mul(accAPWPerShare).div(TOKEN_PRECISION).sub(user.rewardDebt);
323	 if (pending > 0) require(safeAPWTransfer(msg.sender, pending), "Masterchef: SafeTransfer APW failed");
324	 }
325	 if (user.periodId != periodOfToken) {
326	 userLpTokensIds[msg.sender].remove(IAMM(lpToken.amms(ammId)).getLPTokenId(ammId, pairId, user.periodId));
327	 user.amount = 0;
328	 user.rewardDebt = 0;
329	 user.periodId = periodOfToken;
330	 }
331	 if (_amount > 0) lpToken.safeTransferFrom(address(msg.sender), address(this), _lpTokenId, _amount, "");
332	 user.amount = user.amount.add(_amount);
333	 userLpTokensIds[msg.sender].add(_lpTokenId);
334	 user.rewardDebt = user.amount.mul(pool.accAPWPerShare).div(TOKEN_PRECISION);
335	 IRewarder _rewarder = rewarders[_lpTokenId];
336	 if (address(_rewarder) != address(0)) {
337	 _rewarder.onAPWReward(_lpTokenId, msg.sender, msg.sender, user.amount);
338	 }
339	 emit Deposit(msg.sender, _lpTokenId, _amount);
340	 }
341	 function withdraw(uint256 _lpTokenId, uint256 _amount) external validPool(_lpTokenId) {
342	 PoolInfo storage pool = poolInfo[_lpTokenId];
343	 uint64 ammId = lpToken.getAMMId(_lpTokenId);
344	 uint256 pairId = lpToken.getPairId(_lpTokenId);
345	 UserInfo storage user = userInfo[ammId][pairId][msg.sender];
346	 if (totalAllocPoint != 0) updatePool(_lpTokenId);
347	 require(user.amount >= _amount, "withdraw: not good");
348	 uint256 pending = user.amount.mul(pool.accAPWPerShare).div(TOKEN_PRECISION).sub(user.rewardDebt);
349	 if (pending > 0) require(safeAPWTransfer(msg.sender, pending), "Masterchef: SafeTransfer APW failed");
350	 user.amount = user.amount.sub(_amount);
351	 if (user.amount == 0) userLpTokensIds[msg.sender].remove(_lpTokenId);
352	 user.rewardDebt = user.amount.mul(pool.accAPWPerShare).div(TOKEN_PRECISION);
353	 IRewarder _rewarder = rewarders[_lpTokenId];
354	 if (address(_rewarder) != address(0)) {
355	 _rewarder.onAPWReward(_lpTokenId, msg.sender, msg.sender, user.amount);
356	 }
357	 if (_amount > 0) lpToken.safeTransferFrom(address(this), address(msg.sender), _lpTokenId, _amount, "");
358	 emit Withdraw(msg.sender, _lpTokenId, _amount);
359	 }
360	 function harvest(uint256 _lpTokenId, address to) public {
361	 uint64 ammId = lpToken.getAMMId(_lpTokenId);
362	 uint256 pairId = lpToken.getPairId(_lpTokenId);
363	 UserInfo storage user = userInfo[ammId][pairId][msg.sender];
364	 require(user.amount != 0, "Masterchef: invalid lp address");
365	 uint256 accumulatedAPW = uint256(user.amount.mul(poolInfo[_lpTokenId].accAPWPerShare) / TOKEN_PRECISION);
366	 uint256 _pendingAPW = accumulatedAPW.sub(user.rewardDebt);
367	 user.rewardDebt = accumulatedAPW;
368	 if (_pendingAPW != 0) {
369	 safeAPWTransfer(to, _pendingAPW);
370	 }
371	 IRewarder _rewarder = rewarders[_lpTokenId];
372	 if (address(_rewarder) != address(0)) {
373	 _rewarder.onAPWReward(_lpTokenId, msg.sender, to, user.amount);
374	 }
375	 emit Harvest(msg.sender, _lpTokenId, _pendingAPW);
376	 }
377	 function emergencyWithdraw(uint256 _lpTokenId) external validPool(_lpTokenId) {
378	 uint64 ammId = lpToken.getAMMId(_lpTokenId);
379	 uint256 pairId = lpToken.getPairId(_lpTokenId);
380	 UserInfo storage user = userInfo[ammId][pairId][msg.sender];
381	 uint256 userAmount = user.amount;
382	 if (userAmount > 0) lpToken.safeTransferFrom(address(this), address(msg.sender), _lpTokenId, userAmount, "");
383	 user.amount = 0;
384	 user.rewardDebt = 0;
385	 IRewarder _rewarder = rewarders[_lpTokenId];
386	 if (address(_rewarder) != address(0)) {
387	 _rewarder.onAPWReward(_lpTokenId, msg.sender, msg.sender, 0);
388	 }
389	 userLpTokensIds[msg.sender].remove(_lpTokenId);
390	 emit EmergencyWithdraw(msg.sender, _lpTokenId, userAmount);
391	 }
392	 function safeAPWTransfer(address _to, uint256 _amount) internal returns (bool success) {
393	 uint256 apwBal = apw.balanceOf(address(this));
394	 uint256 transferAmount = (_amount > apwBal) ? apwBal : _amount;
395	 success = apw.transfer(_to, transferAmount);
396	 }
397	 function setAPWPerBlock(uint256 _apwPerBlock) external onlyOwner {
398	 massUpdatePools();
399	 require(_apwPerBlock > 0, "!apwPerBlock-0");
400	 apwPerBlock = _apwPerBlock;
401	 }
402	 function withdrawAPW(address _recipient, uint256 _amount) external onlyOwner {
403	 if (_amount > 0) apw.transfer(_recipient, _amount);
404	 }
405	 function setNextUpgradeAllocPoint(uint256 _lpTokenId, uint256 _nextAllocPoint) external validPool(_lpTokenId) onlyOwner {
406	 uint64 ammId = lpToken.getAMMId(_lpTokenId);
407	 uint256 pairId = lpToken.getPairId(_lpTokenId);
408	 uint256 periodId = lpToken.getPeriodIndex(_lpTokenId);
409	 require(periodId == poolToPeriodId[ammId][pairId], "Masterchef: pool already upgraded");
410	 nextUpgradeAllocPoint[_lpTokenId] = _nextAllocPoint;
411	 emit NextAllocPointSet(_lpTokenId, _nextAllocPoint);
412	 }
413	 function isRegisteredPoolId(uint256 _poolId) external view returns (bool) {
414	 return activePools.contains(_poolId);
415	 }
416	 function poolIdsLength() external view returns (uint256) {
417	 return activePools.length();
418	 }
419	 function poolIdAt(uint256 _id) external view returns (uint256) {
420	 return activePools.at(_id);
421	 }
422	 function getUserLpTokenIdList(address _user) external view returns (uint256[] memory) {
423	 uint256 length = userLpTokensIds[_user].length();
424	 uint256[] memory _userLpTokenIds = new uint256[](length);
425	 for (uint256 i = 0; i < length; i++) {
426	 _userLpTokenIds[i] = userLpTokensIds[_user].at(i);
427	 }
428	 return _userLpTokenIds;
429	 }
430	 }
431	 pragma solidity >=0.6.0 <0.8.0;
432	 library SafeERC20Upgradeable {
433	 using SafeMathUpgradeable for uint256;
434	 using AddressUpgradeable for address;
435	 function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {
436	 _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
437	 }
438	 function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {
439	 _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
440	 }
441	 function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {
442	 require((value == 0) || (token.allowance(address(this), spender) == 0), "SafeERC20: approve from non-zero to non-zero allowance" );
443	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
444	 }
445	 function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {
446	 uint256 newAllowance = token.allowance(address(this), spender).add(value);
447	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
448	 }
449	 function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {
450	 uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
451	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
452	 }
453	 function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {
454	 bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
455	 if (returndata.length > 0) {
456	 require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
457	 }
458	 }
459	 }
460	 pragma solidity >=0.6.0 <0.8.0;
461	 library EnumerableSetUpgradeable {
462	 struct Set {
463	 bytes32[] _values;
464	 mapping (bytes32 => uint256) _indexes;
465	 }
466	 function _add(Set storage set, bytes32 value) private returns (bool) {
467	 if (!_contains(set, value)) {
468	 set._values.push(value);
469	 set._indexes[value] = set._values.length;
470	 return true;
471	 }
472	 else {
473	 return false;
474	 }
475	 }
476	 function _remove(Set storage set, bytes32 value) private returns (bool) {
477	 uint256 valueIndex = set._indexes[value];
478	 if (valueIndex != 0) {
479	 uint256 toDeleteIndex = valueIndex - 1;
480	 uint256 lastIndex = set._values.length - 1;
481	 bytes32 lastvalue = set._values[lastIndex];
482	 set._values[toDeleteIndex] = lastvalue;
483	 set._indexes[lastvalue] = toDeleteIndex + 1;
484	 set._values.pop();
485	 delete set._indexes[value];
486	 return true;
487	 }
488	 else {
489	 return false;
490	 }
491	 }
492	 function _contains(Set storage set, bytes32 value) private view returns (bool) {
493	 return set._indexes[value] != 0;
494	 }
495	 function _length(Set storage set) private view returns (uint256) {
496	 return set._values.length;
497	 }
498	 function _at(Set storage set, uint256 index) private view returns (bytes32) {
499	 require(set._values.length > index, "EnumerableSet: index out of bounds");
500	 return set._values[index];
501	 }
502	 struct Bytes32Set {
503	 Set _inner;
504	 }
505	 function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {
506	 return _add(set._inner, value);
507	 }
508	 function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {
509	 return _remove(set._inner, value);
510	 }
511	 function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {
512	 return _contains(set._inner, value);
513	 }
514	 function length(Bytes32Set storage set) internal view returns (uint256) {
515	 return _length(set._inner);
516	 }
517	 function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {
518	 return _at(set._inner, index);
519	 }
520	 struct AddressSet {
521	 Set _inner;
522	 }
523	 function add(AddressSet storage set, address value) internal returns (bool) {
524	 return _add(set._inner, bytes32(uint256(uint160(value))));
525	 }
526	 function remove(AddressSet storage set, address value) internal returns (bool) {
527	 return _remove(set._inner, bytes32(uint256(uint160(value))));
528	 }
529	 function contains(AddressSet storage set, address value) internal view returns (bool) {
530	 return _contains(set._inner, bytes32(uint256(uint160(value))));
531	 }
532	 function length(AddressSet storage set) internal view returns (uint256) {
533	 return _length(set._inner);
534	 }
535	 function at(AddressSet storage set, uint256 index) internal view returns (address) {
536	 return address(uint160(uint256(_at(set._inner, index))));
537	 }
538	 struct UintSet {
539	 Set _inner;
540	 }
541	 function add(UintSet storage set, uint256 value) internal returns (bool) {
542	 return _add(set._inner, bytes32(value));
543	 }
544	 function remove(UintSet storage set, uint256 value) internal returns (bool) {
545	 return _remove(set._inner, bytes32(value));
546	 }
547	 function contains(UintSet storage set, uint256 value) internal view returns (bool) {
548	 return _contains(set._inner, bytes32(value));
549	 }
550	 function length(UintSet storage set) internal view returns (uint256) {
551	 return _length(set._inner);
552	 }
553	 function at(UintSet storage set, uint256 index) internal view returns (uint256) {
554	 return uint256(_at(set._inner, index));
555	 }
556	 }
557	 pragma solidity >=0.6.0 <0.8.0;
558	 library SafeMathUpgradeable {
559	 function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
560	 uint256 c = a + b;
561	 if (c < a) return (false, 0);
562	 return (true, c);
563	 }
564	 function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
565	 if (b > a) return (false, 0);
566	 return (true, a - b);
567	 }
568	 function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
569	 if (a == 0) return (true, 0);
570	 uint256 c = a * b;
571	 if (c / a != b) return (false, 0);
572	 return (true, c);
573	 }
574	 function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
575	 if (b == 0) return (false, 0);
576	 return (true, a / b);
577	 }
578	 function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
579	 if (b == 0) return (false, 0);
580	 return (true, a % b);
581	 }
582	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
583	 uint256 c = a + b;
584	 require(c >= a, "SafeMath: addition overflow");
585	 return c;
586	 }
587	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
588	 require(b <= a, "SafeMath: subtraction overflow");
589	 return a - b;
590	 }
591	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
592	 if (a == 0) return 0;
593	 uint256 c = a * b;
594	 require(c / a == b, "SafeMath: multiplication overflow");
595	 return c;
596	 }
597	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
598	 require(b > 0, "SafeMath: division by zero");
599	 return a / b;
600	 }
601	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
602	 require(b > 0, "SafeMath: modulo by zero");
603	 return a % b;
604	 }
605	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
606	 require(b <= a, errorMessage);
607	 return a - b;
608	 }
609	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
610	 require(b > 0, errorMessage);
611	 return a / b;
612	 }
613	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
614	 require(b > 0, errorMessage);
615	 return a % b;
616	 }
617	 }
618	 pragma solidity 0.7.6;
619	 interface IAMM {
620	 struct Pair {
621	 address tokenAddress;
622	 uint256[2] weights;
623	 uint256[2] balances;
624	 bool liquidityIsInitialized;
625	 }
626	 function finalize() external;
627	 function switchPeriod() external;
628	 function togglePauseAmm() external;
629	 function withdrawExpiredToken(address _user, uint256 _lpTokenId) external;
630	 function getExpiredTokensInfo(address _user, uint256 _lpTokenId) external view returns ( uint256, uint256, uint256 );
631	 function swapExactAmountIn( uint256 _pairID, uint256 _tokenIn, uint256 _tokenAmountIn, uint256 _tokenOut, uint256 _minAmountOut, address _to ) external returns (uint256 tokenAmountOut, uint256 spotPriceAfter);
632	 function swapExactAmountOut( uint256 _pairID, uint256 _tokenIn, uint256 _maxAmountIn, uint256 _tokenOut, uint256 _tokenAmountOut, address _to ) external returns (uint256 tokenAmountIn, uint256 spotPriceAfter);
633	 function createLiquidity(uint256 _pairID, uint256[2] memory _tokenAmounts) external;
634	 function addLiquidity( uint256 _pairID, uint256 _poolAmountOut, uint256[2] memory _maxAmountsIn ) external;
635	 function removeLiquidity( uint256 _pairID, uint256 _poolAmountIn, uint256[2] memory _minAmountsOut ) external;
636	 function joinSwapExternAmountIn( uint256 _pairID, uint256 _tokenIn, uint256 _tokenAmountIn, uint256 _minPoolAmountOut ) external returns (uint256 poolAmountOut);
637	 function joinSwapPoolAmountOut( uint256 _pairID, uint256 _tokenIn, uint256 _poolAmountOut, uint256 _maxAmountIn ) external returns (uint256 tokenAmountIn);
638	 function exitSwapPoolAmountIn( uint256 _pairID, uint256 _tokenOut, uint256 _poolAmountIn, uint256 _minAmountOut ) external returns (uint256 tokenAmountOut);
639	 function exitSwapExternAmountOut( uint256 _pairID, uint256 _tokenOut, uint256 _tokenAmountOut, uint256 _maxPoolAmountIn ) external returns (uint256 poolAmountIn);
640	 function setSwappingFees(uint256 _swapFee) external;
641	 function calcOutAndSpotGivenIn( uint256 _pairID, uint256 _tokenIn, uint256 _tokenAmountIn, uint256 _tokenOut, uint256 _minAmountOut ) external view returns (uint256 tokenAmountOut, uint256 spotPriceAfter);
642	 function calcInAndSpotGivenOut( uint256 _pairID, uint256 _tokenIn, uint256 _maxAmountIn, uint256 _tokenOut, uint256 _tokenAmountOut ) external view returns (uint256 tokenAmountIn, uint256 spotPriceAfter);
643	 function getSpotPrice( uint256 _pairID, uint256 _tokenIn, uint256 _tokenOut ) external view returns (uint256);
644	 function getFutureAddress() external view returns (address);
645	 function getPTAddress() external view returns (address);
646	 function getUnderlyingOfIBTAddress() external view returns (address);
647	 function getFYTAddress() external view returns (address);
648	 function getPTWeightInPair() external view returns (uint256);
649	 function getPairWithID(uint256 _pairID) external view returns (Pair memory);
650	 function getLPTokenId( uint256 _ammId, uint256 _periodIndex, uint256 _pairID ) external pure returns (uint256);
651	 function ammId() external returns (uint64);
652	 }
653	 pragma solidity ^0.7.6;
654	 interface ILPToken is IERC1155 {
655	 function amms(uint64 _ammId) external view returns (address);
656	 function getAMMId(uint256 _id) external pure returns (uint64);
657	 function getPeriodIndex(uint256 _id) external pure returns (uint64);
658	 function getPairId(uint256 _id) external pure returns (uint32);
659	 }
660	 pragma solidity 0.7.6;
661	 interface IFutureVault {
662	 event NewPeriodStarted(uint256 _newPeriodIndex);
663	 event FutureWalletSet(address _futureWallet);
664	 event RegistrySet(IRegistry _registry);
665	 event FundsDeposited(address _user, uint256 _amount);
666	 event FundsWithdrawn(address _user, uint256 _amount);
667	 event PTSet(IPT _pt);
668	 event LiquidityTransfersPaused();
669	 event LiquidityTransfersResumed();
670	 event DelegationCreated(address _delegator, address _receiver, uint256 _amount);
671	 event DelegationRemoved(address _delegator, address _receiver, uint256 _amount);
672	 function PERIOD_DURATION() external view returns (uint256);
673	 function PLATFORM_NAME() external view returns (string memory);
674	 function startNewPeriod() external;
675	 function updateUserState(address _user) external;
676	 function claimFYT(address _user, uint256 _amount) external;
677	 function deposit(address _user, uint256 _amount) external;
678	 function withdraw(address _user, uint256 _amount) external;
679	 function createFYTDelegationTo( address _delegator, address _receiver, uint256 _amount ) external;
680	 function withdrawFYTDelegationFrom( address _delegator, address _receiver, uint256 _amount ) external;
681	 function getTotalDelegated(address _delegator) external view returns (uint256 totalDelegated);
682	 function getNextPeriodIndex() external view returns (uint256);
683	 function getCurrentPeriodIndex() external view returns (uint256);
684	 function getClaimablePT(address _user) external view returns (uint256);
685	 function getUserEarlyUnlockablePremium(address _user) external view returns (uint256 premiumLocked, uint256 amountRequired);
686	 function getUnlockableFunds(address _user) external view returns (uint256);
687	 function getClaimableFYTForPeriod(address _user, uint256 _periodIndex) external view returns (uint256);
688	 function getUnrealisedYieldPerPT() external view returns (uint256);
689	 function getPTPerAmountDeposited(uint256 _amount) external view returns (uint256);
690	 function getPremiumPerUnderlyingDeposited(uint256 _amount) external view returns (uint256);
691	 function getTotalUnderlyingDeposited() external view returns (uint256);
692	 function getYieldOfPeriod(uint256 _periodID) external view returns (uint256);
693	 function getControllerAddress() external view returns (address);
694	 function getFutureWalletAddress() external view returns (address);
695	 function getIBTAddress() external view returns (address);
696	 function getPTAddress() external view returns (address);
697	 function getFYTofPeriod(uint256 _periodIndex) external view returns (address);
698	 function isTerminated() external view returns (bool);
699	 function getPerformanceFeeFactor() external view returns (uint256);
700	 function harvestRewards() external;
701	 function redeemAllVaultRewards() external;
702	 function redeemVaultRewards(address _rewardToken) external;
703	 function addRewardsToken(address _token) external;
704	 function isRewardToken(address _token) external view returns (bool);
705	 function getRewardTokenAt(uint256 _index) external view returns (address);
706	 function getRewardTokensCount() external view returns (uint256);
707	 function getRewardsRecipient() external view returns (address);
708	 function setRewardRecipient(address _recipient) external;
709	 function setFutureWallet(IFutureWallet _futureWallet) external;
710	 function setRegistry(IRegistry _registry) external;
711	 function pauseLiquidityTransfers() external;
712	 function resumeLiquidityTransfers() external;
713	 function convertIBTToUnderlying(uint256 _amount) external view returns (uint256);
714	 function convertUnderlyingtoIBT(uint256 _amount) external view returns (uint256);
715	 }
716	 pragma solidity 0.7.6;
717	 interface IRewarder {
718	 function onAPWReward( uint256 pid, address user, address recipient, uint256 apwAmount ) external;
719	 function pendingTokens(uint256 pid, address user) external view returns (IERC20[] memory, uint256[] memory);
720	 function renewPool(uint256 _oldPid, uint256 _newPid) external;
721	 }
722	 pragma solidity >=0.6.2 <0.8.0;
723	 library AddressUpgradeable {
724	 function isContract(address account) internal view returns (bool) {
725	 uint256 size;
726	 assembly {
727	 size := extcodesize(account) }
728	 return size > 0;
729	 }
730	 function sendValue(address payable recipient, uint256 amount) internal {
731	 require(address(this).balance >= amount, "Address: insufficient balance");
732	 (bool success, ) = recipient.call{
733	 value: amount }
734	 ("");
735	 require(success, "Address: unable to send value, recipient may have reverted");
736	 }
737	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
738	 return functionCall(target, data, "Address: low-level call failed");
739	 }
740	 function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
741	 return functionCallWithValue(target, data, 0, errorMessage);
742	 }
743	 function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
744	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
745	 }
746	 function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
747	 require(address(this).balance >= value, "Address: insufficient balance for call");
748	 require(isContract(target), "Address: call to non-contract");
749	 (bool success, bytes memory returndata) = target.call{
750	 value: value }
751	 (data);
752	 return _verifyCallResult(success, returndata, errorMessage);
753	 }
754	 function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
755	 return functionStaticCall(target, data, "Address: low-level static call failed");
756	 }
757	 function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
758	 require(isContract(target), "Address: static call to non-contract");
759	 (bool success, bytes memory returndata) = target.staticcall(data);
760	 return _verifyCallResult(success, returndata, errorMessage);
761	 }
762	 function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
763	 if (success) {
764	 return returndata;
765	 }
766	 else {
767	 if (returndata.length > 0) {
768	 assembly {
769	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
770	 }
771	 else {
772	 revert(errorMessage);
773	 }
774	 }
775	 }
776	 }
777	 pragma solidity 0.7.6;
778	 interface IPT is IERC20 {
779	 function burn(uint256 amount) external;
780	 function mint(address to, uint256 amount) external;
781	 function burnFrom(address account, uint256 amount) external;
782	 function pause() external;
783	 function unpause() external;
784	 function recordedBalanceOf(address account) external view returns (uint256);
785	 function balanceOf(address account) external view override returns (uint256);
786	 function futureVault() external view returns (address);
787	 }
788	 pragma solidity 0.7.6;
789	 interface IRegistry {
790	 function initialize(address _admin) external;
791	 function setTreasury(address _newTreasury) external;
792	 function setController(address _newController) external;
793	 function setAPW(address _newAPW) external;
794	 function setProxyFactory(address _proxyFactory) external;
795	 function setPTLogic(address _PTLogic) external;
796	 function setFYTLogic(address _FYTLogic) external;
797	 function setMathsUtils(address _mathsUtils) external;
798	 function setNamingUtils(address _namingUtils) external;
799	 function getControllerAddress() external view returns (address);
800	 function getTreasuryAddress() external view returns (address);
801	 function getTokensFactoryAddress() external view returns (address);
802	 function getDAOAddress() external returns (address);
803	 function getAPWAddress() external view returns (address);
804	 function getAMMFactoryAddress() external view returns (address);
805	 function getTokenFactoryAddress() external view returns (address);
806	 function getProxyFactoryAddress() external view returns (address);
807	 function getPTLogicAddress() external view returns (address);
808	 function getFYTLogicAddress() external view returns (address);
809	 function getAMMLogicAddress() external view returns (address);
810	 function getAMMLPTokenLogicAddress() external view returns (address);
811	 function getMathsUtils() external view returns (address);
812	 function getNamingUtils() external view returns (address);
813	 function addFuture(address _future) external;
814	 function removeFuture(address _future) external;
815	 function isRegisteredFuture(address _future) external view returns (bool);
816	 function isRegisteredAMM(address _ammAddress) external view returns (bool);
817	 function getFutureAt(uint256 _index) external view returns (address);
818	 function futureCount() external view returns (uint256);
819	 }
820	 pragma solidity 0.7.6;
821	 interface IFutureWallet {
822	 function initialize(address _futureAddress, address _adminAddress) external;
823	 function registerExpiredFuture(uint256 _amount) external;
824	 function redeemYield(uint256 _periodIndex) external;
825	 function getRedeemableYield(uint256 _periodIndex, address _tokenHolder) external view returns (uint256);
826	 function getFutureAddress() external view returns (address);
827	 function getIBTAddress() external view returns (address);
828	 }
