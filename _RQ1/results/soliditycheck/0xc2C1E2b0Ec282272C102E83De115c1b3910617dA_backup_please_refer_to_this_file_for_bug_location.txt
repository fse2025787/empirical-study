row number 
1	  pragma experimental ABIEncoderV2;
2	 pragma solidity ^0.6.12;
3	 interface IPowerPoke {
4	 function authorizeReporter(uint256 userId_, address pokerKey_) external view;
5	 function authorizeNonReporter(uint256 userId_, address pokerKey_) external view;
6	 function authorizeNonReporterWithDeposit( uint256 userId_, address pokerKey_, uint256 overrideMinDeposit_ ) external view;
7	 function authorizePoker(uint256 userId_, address pokerKey_) external view;
8	 function authorizePokerWithDeposit( uint256 userId_, address pokerKey_, uint256 overrideMinStake_ ) external view;
9	 function slashReporter(uint256 slasherId_, uint256 times_) external;
10	 function reward( uint256 userId_, uint256 gasUsed_, uint256 compensationPlan_, bytes calldata pokeOptions_ ) external;
11	 function transferClientOwnership(address client_, address to_) external;
12	 function addCredit(address client_, uint256 amount_) external;
13	 function withdrawCredit( address client_, address to_, uint256 amount_ ) external;
14	 function setReportIntervals( address client_, uint256 minReportInterval_, uint256 maxReportInterval_ ) external;
15	 function setSlasherHeartbeat(address client_, uint256 slasherHeartbeat_) external;
16	 function setGasPriceLimit(address client_, uint256 gasPriceLimit_) external;
17	 function setFixedCompensations( address client_, uint256 eth_, uint256 cvp_ ) external;
18	 function setBonusPlan( address client_, uint256 planId_, bool active_, uint64 bonusNominator_, uint64 bonusDenominator_, uint64 perGas_ ) external;
19	 function setMinimalDeposit(address client_, uint256 defaultMinDeposit_) external;
20	 function withdrawRewards(uint256 userId_, address to_) external;
21	 function setPokerKeyRewardWithdrawAllowance(uint256 userId_, bool allow_) external;
22	 function addClient( address client_, address owner_, bool canSlash_, uint256 gasPriceLimit_, uint256 minReportInterval_, uint256 maxReportInterval_ ) external;
23	 function setClientActiveFlag(address client_, bool active_) external;
24	 function setCanSlashFlag(address client_, bool canSlash) external;
25	 function setOracle(address oracle_) external;
26	 function pause() external;
27	 function unpause() external;
28	 function creditOf(address client_) external view returns (uint256);
29	 function ownerOf(address client_) external view returns (address);
30	 function getMinMaxReportIntervals(address client_) external view returns (uint256 min, uint256 max);
31	 function getSlasherHeartbeat(address client_) external view returns (uint256);
32	 function getGasPriceLimit(address client_) external view returns (uint256);
33	 function getPokerBonus( address client_, uint256 bonusPlanId_, uint256 gasUsed_, uint256 userDeposit_ ) external view returns (uint256);
34	 function getGasPriceFor(address client_) external view returns (uint256);
35	 }
36	 pragma solidity >=0.4.24 <0.7.0;
37	 contract Initializable {
38	 bool private initialized;
39	 bool private initializing;
40	 modifier initializer() {
41	 require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");
42	 bool isTopLevelCall = !initializing;
43	 if (isTopLevelCall) {
44	 initializing = true;
45	 initialized = true;
46	 }
47	 _;
48	 if (isTopLevelCall) {
49	 initializing = false;
50	 }
51	 }
52	 function isConstructor() private view returns (bool) {
53	 address self = address(this);
54	 uint256 cs;
55	 assembly {
56	 cs := extcodesize(self) }
57	 return cs == 0;
58	 }
59	 uint256[50] private ______gap;
60	 }
61	 pragma solidity ^0.6.0;
62	 contract ContextUpgradeSafe is Initializable {
63	 function __Context_init() internal initializer {
64	 __Context_init_unchained();
65	 }
66	 function __Context_init_unchained() internal initializer {
67	 }
68	 function _msgSender() internal view virtual returns (address payable) {
69	 return msg.sender;
70	 }
71	 function _msgData() internal view virtual returns (bytes memory) {
72	 this;
73	 return msg.data;
74	 }
75	 uint256[50] private __gap;
76	 }
77	 pragma solidity ^0.6.0;
78	 contract OwnableUpgradeSafe is Initializable, ContextUpgradeSafe {
79	 address private _owner;
80	 event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
81	 function __Ownable_init() internal initializer {
82	 __Context_init_unchained();
83	 __Ownable_init_unchained();
84	 }
85	 function __Ownable_init_unchained() internal initializer {
86	 address msgSender = _msgSender();
87	 _owner = msgSender;
88	 emit OwnershipTransferred(address(0), msgSender);
89	 }
90	 function owner() public view returns (address) {
91	 return _owner;
92	 }
93	 modifier onlyOwner() {
94	 require(_owner == _msgSender(), "Ownable: caller is not the owner");
95	 _;
96	 }
97	 function renounceOwnership() public virtual onlyOwner {
98	 emit OwnershipTransferred(_owner, address(0));
99	 _owner = address(0);
100	 }
101	 function transferOwnership(address newOwner) public virtual onlyOwner {
102	 require(newOwner != address(0), "Ownable: new owner is the zero address");
103	 emit OwnershipTransferred(_owner, newOwner);
104	 _owner = newOwner;
105	 }
106	 uint256[49] private __gap;
107	 }
108	 pragma solidity 0.6.12;
109	 interface IPowerOracle {
110	 function assetPrices(address _token) external view returns (uint256);
111	 }
112	 pragma solidity >=0.6.0 <0.8.0;
113	 interface IERC20 {
114	 function totalSupply() external view returns (uint256);
115	 function balanceOf(address account) external view returns (uint256);
116	 function transfer(address recipient, uint256 amount) external returns (bool);
117	 function allowance(address owner, address spender) external view returns (uint256);
118	 function approve(address spender, uint256 amount) external returns (bool);
119	 function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
120	 event Transfer(address indexed from, address indexed to, uint256 value);
121	 event Approval(address indexed owner, address indexed spender, uint256 value);
122	 }
123	 pragma solidity >=0.6.0 <0.8.0;
124	 library SafeMath {
125	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
126	 uint256 c = a + b;
127	 require(c >= a, "SafeMath: addition overflow");
128	 return c;
129	 }
130	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
131	 return sub(a, b, "SafeMath: subtraction overflow");
132	 }
133	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
134	 require(b <= a, errorMessage);
135	 uint256 c = a - b;
136	 return c;
137	 }
138	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
139	 if (a == 0) {
140	 return 0;
141	 }
142	 uint256 c = a * b;
143	 require(c / a == b, "SafeMath: multiplication overflow");
144	 return c;
145	 }
146	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
147	 return div(a, b, "SafeMath: division by zero");
148	 }
149	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
150	 require(b > 0, errorMessage);
151	 uint256 c = a / b;
152	 return c;
153	 }
154	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
155	 return mod(a, b, "SafeMath: modulo by zero");
156	 }
157	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
158	 require(b != 0, errorMessage);
159	 return a % b;
160	 }
161	 }
162	 pragma solidity >=0.6.2 <0.8.0;
163	 library Address {
164	 function isContract(address account) internal view returns (bool) {
165	 uint256 size;
166	 assembly {
167	 size := extcodesize(account) }
168	 return size > 0;
169	 }
170	 function sendValue(address payable recipient, uint256 amount) internal {
171	 require(address(this).balance >= amount, "Address: insufficient balance");
172	 (bool success, ) = recipient.call{
173	 value: amount }
174	 ("");
175	 require(success, "Address: unable to send value, recipient may have reverted");
176	 }
177	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
178	 return functionCall(target, data, "Address: low-level call failed");
179	 }
180	 function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
181	 return functionCallWithValue(target, data, 0, errorMessage);
182	 }
183	 function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
184	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
185	 }
186	 function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
187	 require(address(this).balance >= value, "Address: insufficient balance for call");
188	 require(isContract(target), "Address: call to non-contract");
189	 (bool success, bytes memory returndata) = target.call{
190	 value: value }
191	 (data);
192	 return _verifyCallResult(success, returndata, errorMessage);
193	 }
194	 function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
195	 return functionStaticCall(target, data, "Address: low-level static call failed");
196	 }
197	 function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
198	 require(isContract(target), "Address: static call to non-contract");
199	 (bool success, bytes memory returndata) = target.staticcall(data);
200	 return _verifyCallResult(success, returndata, errorMessage);
201	 }
202	 function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
203	 if (success) {
204	 return returndata;
205	 }
206	 else {
207	 if (returndata.length > 0) {
208	 assembly {
209	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
210	 }
211	 else {
212	 revert(errorMessage);
213	 }
214	 }
215	 }
216	 }
217	 pragma solidity >=0.6.0 <0.8.0;
218	 library SafeERC20 {
219	 using SafeMath for uint256;
220	 using Address for address;
221	 function safeTransfer(IERC20 token, address to, uint256 value) internal {
222	 _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
223	 }
224	 function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
225	 _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
226	 }
227	 function safeApprove(IERC20 token, address spender, uint256 value) internal {
228	 require((value == 0) || (token.allowance(address(this), spender) == 0), "SafeERC20: approve from non-zero to non-zero allowance" );
229	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
230	 }
231	 function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
232	 uint256 newAllowance = token.allowance(address(this), spender).add(value);
233	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
234	 }
235	 function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
236	 uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
237	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
238	 }
239	 function _callOptionalReturn(IERC20 token, bytes memory data) private {
240	 bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
241	 if (returndata.length > 0) {
242	 require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
243	 }
244	 }
245	 }
246	 pragma solidity >=0.6.0 <0.8.0;
247	 abstract contract Context {
248	 function _msgSender() internal view virtual returns (address payable) {
249	 return msg.sender;
250	 }
251	 function _msgData() internal view virtual returns (bytes memory) {
252	 this;
253	 return msg.data;
254	 }
255	 }
256	 pragma solidity >=0.6.0 <0.8.0;
257	 abstract contract Ownable is Context {
258	 address private _owner;
259	 event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
260	 constructor () internal {
261	 address msgSender = _msgSender();
262	 _owner = msgSender;
263	 emit OwnershipTransferred(address(0), msgSender);
264	 }
265	 function owner() public view returns (address) {
266	 return _owner;
267	 }
268	 modifier onlyOwner() {
269	 require(_owner == _msgSender(), "Ownable: caller is not the owner");
270	 _;
271	 }
272	 function renounceOwnership() public virtual onlyOwner {
273	 emit OwnershipTransferred(_owner, address(0));
274	 _owner = address(0);
275	 }
276	 function transferOwnership(address newOwner) public virtual onlyOwner {
277	 require(newOwner != address(0), "Ownable: new owner is the zero address");
278	 emit OwnershipTransferred(_owner, newOwner);
279	 _owner = newOwner;
280	 }
281	 }
282	 pragma solidity 0.6.12;
283	 interface BMathInterface {
284	 function calcInGivenOut( uint256 tokenBalanceIn, uint256 tokenWeightIn, uint256 tokenBalanceOut, uint256 tokenWeightOut, uint256 tokenAmountOut, uint256 swapFee ) external pure returns (uint256 tokenAmountIn);
285	 function calcSingleInGivenPoolOut( uint256 tokenBalanceIn, uint256 tokenWeightIn, uint256 poolSupply, uint256 totalWeight, uint256 poolAmountOut, uint256 swapFee ) external pure returns (uint256 tokenAmountIn);
286	 }
287	 pragma solidity 0.6.12;
288	 interface BPoolInterface is IERC20, BMathInterface {
289	 function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn) external;
290	 function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut) external;
291	 function swapExactAmountIn( address, uint256, address, uint256, uint256 ) external returns (uint256, uint256);
292	 function swapExactAmountOut( address, uint256, address, uint256, uint256 ) external returns (uint256, uint256);
293	 function joinswapExternAmountIn( address, uint256, uint256 ) external returns (uint256);
294	 function joinswapPoolAmountOut( address, uint256, uint256 ) external returns (uint256);
295	 function exitswapPoolAmountIn( address, uint256, uint256 ) external returns (uint256);
296	 function exitswapExternAmountOut( address, uint256, uint256 ) external returns (uint256);
297	 function getDenormalizedWeight(address) external view returns (uint256);
298	 function getBalance(address) external view returns (uint256);
299	 function getSwapFee() external view returns (uint256);
300	 function getTotalDenormalizedWeight() external view returns (uint256);
301	 function getCommunityFee() external view returns ( uint256, uint256, uint256, address );
302	 function calcAmountWithCommunityFee( uint256, uint256, address ) external view returns (uint256, uint256);
303	 function getRestrictions() external view returns (address);
304	 function isPublicSwap() external view returns (bool);
305	 function isFinalized() external view returns (bool);
306	 function isBound(address t) external view returns (bool);
307	 function getCurrentTokens() external view returns (address[] memory tokens);
308	 function getFinalTokens() external view returns (address[] memory tokens);
309	 function setSwapFee(uint256) external;
310	 function setCommunityFeeAndReceiver( uint256, uint256, uint256, address ) external;
311	 function setController(address) external;
312	 function setPublicSwap(bool) external;
313	 function finalize() external;
314	 function bind( address, uint256, uint256 ) external;
315	 function rebind( address, uint256, uint256 ) external;
316	 function unbind(address) external;
317	 function gulp(address) external;
318	 function callVoting( address voting, bytes4 signature, bytes calldata args, uint256 value ) external;
319	 function getMinWeight() external view returns (uint256);
320	 function getMaxBoundTokens() external view returns (uint256);
321	 }
322	 pragma solidity 0.6.12;
323	 interface PowerIndexPoolInterface is BPoolInterface {
324	 function initialize( string calldata name, string calldata symbol, uint256 minWeightPerSecond, uint256 maxWeightPerSecond ) external;
325	 function bind( address, uint256, uint256, uint256, uint256 ) external;
326	 function setDynamicWeight( address token, uint256 targetDenorm, uint256 fromTimestamp, uint256 targetTimestamp ) external;
327	 function getDynamicWeightSettings(address token) external view returns ( uint256 fromTimestamp, uint256 targetTimestamp, uint256 fromDenorm, uint256 targetDenorm );
328	 function getMinWeight() external view override returns (uint256);
329	 function getWeightPerSecondBounds() external view returns (uint256, uint256);
330	 function setWeightPerSecondBounds(uint256, uint256) external;
331	 function setWrapper(address, bool) external;
332	 function getWrapperMode() external view returns (bool);
333	 }
334	 pragma solidity 0.6.12;
335	 interface IPoolRestrictions {
336	 function getMaxTotalSupply(address _pool) external view returns (uint256);
337	 function isVotingSignatureAllowed(address _votingAddress, bytes4 _signature) external view returns (bool);
338	 function isVotingSenderAllowed(address _votingAddress, address _sender) external view returns (bool);
339	 function isWithoutFee(address _addr) external view returns (bool);
340	 }
341	 pragma solidity 0.6.12;
342	 contract PowerIndexAbstractController is Ownable {
343	 using SafeMath for uint256;
344	 bytes4 public constant CALL_VOTING_SIG = bytes4(keccak256(bytes("callVoting(address,bytes4,bytes,uint256)")));
345	 event CallPool(bool indexed success, bytes4 indexed inputSig, bytes inputData, bytes outputData);
346	 PowerIndexPoolInterface public immutable pool;
347	 constructor(address _pool) public {
348	 pool = PowerIndexPoolInterface(_pool);
349	 }
350	 function callPool(bytes4 signature, bytes calldata args) external onlyOwner {
351	 _checkSignature(signature);
352	 (bool success, bytes memory data) = address(pool).call(abi.encodePacked(signature, args));
353	 require(success, "NOT_SUCCESS");
354	 emit CallPool(success, signature, args, data);
355	 }
356	 function callVotingByPool( address voting, bytes4 signature, bytes calldata args, uint256 value ) external {
357	 require(_restrictions().isVotingSenderAllowed(voting, msg.sender), "SENDER_NOT_ALLOWED");
358	 pool.callVoting(voting, signature, args, value);
359	 }
360	 function migrateController(address newController, address[] calldata addressesToMigrate) external onlyOwner {
361	 uint256 len = addressesToMigrate.length;
362	 for (uint256 i = 0; i < len; i++) {
363	 PowerIndexPoolInterface(addressesToMigrate[i]).setController(newController);
364	 }
365	 }
366	 function _restrictions() internal view returns (IPoolRestrictions) {
367	 return IPoolRestrictions(pool.getRestrictions());
368	 }
369	 function _checkSignature(bytes4 signature) internal pure virtual {
370	 require(signature != CALL_VOTING_SIG, "SIGNATURE_NOT_ALLOWED");
371	 }
372	 }
373	 pragma solidity 0.6.12;
374	 interface PowerIndexWrapperInterface {
375	 function getFinalTokens() external view returns (address[] memory tokens);
376	 function getCurrentTokens() external view returns (address[] memory tokens);
377	 function getBalance(address _token) external view returns (uint256);
378	 function setPiTokenForUnderlyingsMultiple(address[] calldata _underlyingTokens, address[] calldata _piTokens) external;
379	 function setPiTokenForUnderlying(address _underlyingTokens, address _piToken) external;
380	 function updatePiTokenEthFees(address[] calldata _underlyingTokens) external;
381	 function withdrawOddEthFee(address payable _recipient) external;
382	 function calcEthFeeForTokens(address[] memory tokens) external view returns (uint256 feeSum);
383	 function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn) external payable;
384	 function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut) external payable;
385	 function swapExactAmountIn( address, uint256, address, uint256, uint256 ) external payable returns (uint256, uint256);
386	 function swapExactAmountOut( address, uint256, address, uint256, uint256 ) external payable returns (uint256, uint256);
387	 function joinswapExternAmountIn( address, uint256, uint256 ) external payable returns (uint256);
388	 function joinswapPoolAmountOut( address, uint256, uint256 ) external payable returns (uint256);
389	 function exitswapPoolAmountIn( address, uint256, uint256 ) external payable returns (uint256);
390	 function exitswapExternAmountOut( address, uint256, uint256 ) external payable returns (uint256);
391	 }
392	 pragma solidity 0.6.12;
393	 interface WrappedPiErc20Interface is IERC20 {
394	 function deposit(uint256 _amount) external payable returns (uint256);
395	 function withdraw(uint256 _amount) external payable returns (uint256);
396	 function changeRouter(address _newRouter) external;
397	 function setEthFee(uint256 _newEthFee) external;
398	 function approveUnderlying(address _to, uint256 _amount) external;
399	 function callExternal( address voting, bytes4 signature, bytes calldata args, uint256 value ) external;
400	 struct ExternalCallData {
401	 address destination;
402	 bytes4 signature;
403	 bytes args;
404	 uint256 value;
405	 }
406	 function callExternalMultiple(ExternalCallData[] calldata calls) external;
407	 function getUnderlyingBalance() external view returns (uint256);
408	 }
409	 pragma solidity 0.6.12;
410	 interface WrappedPiErc20FactoryInterface {
411	 event NewWrappedPiErc20(address indexed token, address indexed wrappedToken, address indexed creator);
412	 function build( address _token, address _router, string calldata _name, string calldata _symbol ) external returns (WrappedPiErc20Interface);
413	 }
414	 pragma solidity 0.6.12;
415	 interface IPiRouterFactory {
416	 function buildRouter(address _piToken, bytes calldata _args) external returns (address);
417	 }
418	 pragma solidity 0.6.12;
419	 contract PowerIndexWrappedController is PowerIndexAbstractController {
420	 event ReplacePoolTokenWithPiToken( address indexed underlyingToken, address indexed piToken, uint256 balance, uint256 denormalizedWeight );
421	 event ReplacePoolTokenWithNewVersion( address indexed oldToken, address indexed newToken, address indexed migrator, uint256 balance, uint256 denormalizedWeight );
422	 event ReplacePoolTokenFinish();
423	 event SetPoolWrapper(address indexed poolWrapper);
424	 event SetPiTokenFactory(address indexed piTokenFactory);
425	 event CreatePiToken(address indexed underlyingToken, address indexed piToken, address indexed router);
426	 PowerIndexWrapperInterface public poolWrapper;
427	 WrappedPiErc20FactoryInterface public piTokenFactory;
428	 constructor( address _pool, address _poolWrapper, address _piTokenFactory ) public PowerIndexAbstractController(_pool) {
429	 poolWrapper = PowerIndexWrapperInterface(_poolWrapper);
430	 piTokenFactory = WrappedPiErc20FactoryInterface(_piTokenFactory);
431	 }
432	 function setPoolWrapper(address _poolWrapper) external onlyOwner {
433	 poolWrapper = PowerIndexWrapperInterface(_poolWrapper);
434	 emit SetPoolWrapper(_poolWrapper);
435	 }
436	 function setPiTokenFactory(address _piTokenFactory) external onlyOwner {
437	 piTokenFactory = WrappedPiErc20FactoryInterface(_piTokenFactory);
438	 emit SetPiTokenFactory(_piTokenFactory);
439	 }
440	 function createPiToken( address _underlyingToken, address _routerFactory, bytes memory _routerArgs, string calldata _name, string calldata _symbol ) external onlyOwner {
441	 _createPiToken(_underlyingToken, _routerFactory, _routerArgs, _name, _symbol);
442	 }
443	 function replacePoolTokenWithNewPiToken( address _underlyingToken, address _routerFactory, bytes calldata _routerArgs, string calldata _name, string calldata _symbol ) external payable onlyOwner {
444	 WrappedPiErc20Interface piToken = _createPiToken(_underlyingToken, _routerFactory, _routerArgs, _name, _symbol);
445	 _replacePoolTokenWithPiToken(_underlyingToken, piToken);
446	 }
447	 function replacePoolTokenWithExistingPiToken(address _underlyingToken, WrappedPiErc20Interface _piToken) external payable onlyOwner {
448	 _replacePoolTokenWithPiToken(_underlyingToken, _piToken);
449	 }
450	 function replacePoolTokenWithNewVersion( address _oldToken, address _newToken, address _migrator, bytes calldata _migratorData ) external onlyOwner {
451	 uint256 denormalizedWeight = pool.getDenormalizedWeight(_oldToken);
452	 uint256 balance = pool.getBalance(_oldToken);
453	 pool.unbind(_oldToken);
454	 IERC20(_oldToken).approve(_migrator, balance);
455	 (bool success, ) = _migrator.call(_migratorData);
456	 require(success, "NOT_SUCCESS");
457	 require( IERC20(_newToken).balanceOf(address(this)) >= balance, "PiBPoolController:newVersion: insufficient newToken balance" );
458	 IERC20(_newToken).approve(address(pool), balance);
459	 _bindNewToken(_newToken, balance, denormalizedWeight);
460	 emit ReplacePoolTokenWithNewVersion(_oldToken, _newToken, _migrator, balance, denormalizedWeight);
461	 }
462	 function _replacePoolTokenWithPiToken(address _underlyingToken, WrappedPiErc20Interface _piToken) internal {
463	 uint256 denormalizedWeight = pool.getDenormalizedWeight(_underlyingToken);
464	 uint256 balance = pool.getBalance(_underlyingToken);
465	 pool.unbind(_underlyingToken);
466	 IERC20(_underlyingToken).approve(address(_piToken), balance);
467	 _piToken.deposit{
468	 value: msg.value }
469	 (balance);
470	 _piToken.approve(address(pool), balance);
471	 _bindNewToken(address(_piToken), balance, denormalizedWeight);
472	 if (address(poolWrapper) != address(0)) {
473	 poolWrapper.setPiTokenForUnderlying(_underlyingToken, address(_piToken));
474	 }
475	 emit ReplacePoolTokenWithPiToken(_underlyingToken, address(_piToken), balance, denormalizedWeight);
476	 }
477	 function _bindNewToken( address _piToken, uint256 _balance, uint256 _denormalizedWeight ) internal virtual {
478	 pool.bind(_piToken, _balance, _denormalizedWeight);
479	 }
480	 function _createPiToken( address _underlyingToken, address _routerFactory, bytes memory _routerArgs, string calldata _name, string calldata _symbol ) internal returns (WrappedPiErc20Interface) {
481	 WrappedPiErc20Interface piToken = piTokenFactory.build(_underlyingToken, address(this), _name, _symbol);
482	 address router = IPiRouterFactory(_routerFactory).buildRouter(address(piToken), _routerArgs);
483	 Ownable(router).transferOwnership(msg.sender);
484	 piToken.changeRouter(router);
485	 emit CreatePiToken(_underlyingToken, address(piToken), router);
486	 return piToken;
487	 }
488	 }
489	 pragma solidity 0.6.12;
490	 contract PowerIndexPoolController is PowerIndexWrappedController {
491	 using SafeERC20 for IERC20;
492	 bytes4 public constant BIND_SIG = bytes4(keccak256(bytes("bind(address,uint256,uint256,uint256,uint256)")));
493	 bytes4 public constant UNBIND_SIG = bytes4(keccak256(bytes("unbind(address)")));
494	 struct DynamicWeightInput {
495	 address token;
496	 uint256 targetDenorm;
497	 uint256 fromTimestamp;
498	 uint256 targetTimestamp;
499	 }
500	 event SetWeightsStrategy(address indexed weightsStrategy);
501	 address public weightsStrategy;
502	 modifier onlyWeightsStrategy() {
503	 require(msg.sender == weightsStrategy, "ONLY_WEIGHTS_STRATEGY");
504	 _;
505	 }
506	 constructor( address _pool, address _poolWrapper, address _wrapperFactory, address _weightsStrategy ) public PowerIndexWrappedController(_pool, _poolWrapper, _wrapperFactory) {
507	 weightsStrategy = _weightsStrategy;
508	 }
509	 function bind( address token, uint256 balance, uint256 targetDenorm, uint256 fromTimestamp, uint256 targetTimestamp ) external onlyOwner {
510	 _validateNewTokenBind();
511	 IERC20(token).safeTransferFrom(msg.sender, address(this), balance);
512	 IERC20(token).approve(address(pool), balance);
513	 pool.bind(token, balance, targetDenorm, fromTimestamp, targetTimestamp);
514	 }
515	 function replaceTokenWithNew( address oldToken, address newToken, uint256 balance, uint256 fromTimestamp, uint256 targetTimestamp ) external onlyOwner {
516	 _replaceTokenWithNew(oldToken, newToken, balance, fromTimestamp, targetTimestamp);
517	 }
518	 function replaceTokenWithNewFromNow( address oldToken, address newToken, uint256 balance, uint256 durationFromNow ) external onlyOwner {
519	 uint256 now = block.timestamp.add(1);
520	 _replaceTokenWithNew(oldToken, newToken, balance, now, now.add(durationFromNow));
521	 }
522	 function setDynamicWeightList(DynamicWeightInput[] memory _dynamicWeights) external onlyOwner {
523	 uint256 len = _dynamicWeights.length;
524	 for (uint256 i = 0; i < len; i++) {
525	 pool.setDynamicWeight( _dynamicWeights[i].token, _dynamicWeights[i].targetDenorm, _dynamicWeights[i].fromTimestamp, _dynamicWeights[i].targetTimestamp );
526	 }
527	 }
528	 function setWeightsStrategy(address _weightsStrategy) external onlyOwner {
529	 weightsStrategy = _weightsStrategy;
530	 emit SetWeightsStrategy(_weightsStrategy);
531	 }
532	 function setDynamicWeightListByStrategy(DynamicWeightInput[] memory _dynamicWeights) external onlyWeightsStrategy {
533	 uint256 len = _dynamicWeights.length;
534	 for (uint256 i = 0; i < len; i++) {
535	 pool.setDynamicWeight( _dynamicWeights[i].token, _dynamicWeights[i].targetDenorm, _dynamicWeights[i].fromTimestamp, _dynamicWeights[i].targetTimestamp );
536	 }
537	 }
538	 function unbindNotActualToken(address _token) external {
539	 require(pool.getDenormalizedWeight(_token) == pool.getMinWeight(), "DENORM_MIN");
540	 (, uint256 targetTimestamp, , ) = pool.getDynamicWeightSettings(_token);
541	 require(block.timestamp > targetTimestamp, "TIMESTAMP_MORE_THEN_TARGET");
542	 uint256 tokenBalance = pool.getBalance(_token);
543	 pool.unbind(_token);
544	 (, , , address communityWallet) = pool.getCommunityFee();
545	 IERC20(_token).safeTransfer(communityWallet, tokenBalance);
546	 }
547	 function _checkSignature(bytes4 signature) internal pure override {
548	 require(signature != BIND_SIG && signature != UNBIND_SIG && signature != CALL_VOTING_SIG, "SIGNATURE_NOT_ALLOWED");
549	 }
550	 function _replaceTokenWithNew( address oldToken, address newToken, uint256 balance, uint256 fromTimestamp, uint256 targetTimestamp ) internal {
551	 uint256 minWeight = pool.getMinWeight();
552	 (, , , uint256 targetDenorm) = pool.getDynamicWeightSettings(oldToken);
553	 pool.setDynamicWeight(oldToken, minWeight, fromTimestamp, targetTimestamp);
554	 IERC20(newToken).safeTransferFrom(msg.sender, address(this), balance);
555	 IERC20(newToken).approve(address(pool), balance);
556	 pool.bind(newToken, balance, targetDenorm.sub(minWeight), fromTimestamp, targetTimestamp);
557	 }
558	 function _validateNewTokenBind() internal {
559	 address[] memory tokens = pool.getCurrentTokens();
560	 uint256 tokensLen = tokens.length;
561	 uint256 minWeight = pool.getMinWeight();
562	 if (tokensLen == pool.getMaxBoundTokens() - 1) {
563	 for (uint256 i = 0; i < tokensLen; i++) {
564	 (, , , uint256 targetDenorm) = pool.getDynamicWeightSettings(tokens[i]);
565	 if (targetDenorm == minWeight) {
566	 return;
567	 }
568	 }
569	 revert("NEW_TOKEN_NOT_ALLOWED");
570	 }
571	 }
572	 }
573	 pragma solidity 0.6.12;
574	 contract BConst {
575	 uint public constant BONE = 10**18;
576	 uint public constant MIN_BOUND_TOKENS = 2;
577	 uint public constant MAX_BOUND_TOKENS = 9;
578	 uint public constant MIN_FEE = BONE / 10**6;
579	 uint public constant MAX_FEE = BONE / 10;
580	 uint public constant MIN_WEIGHT = 1000000000;
581	 uint public constant MAX_WEIGHT = BONE * 50;
582	 uint public constant MAX_TOTAL_WEIGHT = BONE * 50;
583	 uint public constant MIN_BALANCE = BONE / 10**12;
584	 uint public constant INIT_POOL_SUPPLY = BONE * 100;
585	 uint public constant MIN_BPOW_BASE = 1 wei;
586	 uint public constant MAX_BPOW_BASE = (2 * BONE) - 1 wei;
587	 uint public constant BPOW_PRECISION = BONE / 10**10;
588	 uint public constant MAX_IN_RATIO = BONE / 2;
589	 uint public constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;
590	 }
591	 pragma solidity 0.6.12;
592	 contract BNum is BConst {
593	 function btoi(uint a) internal pure returns (uint) {
594	 return a / BONE;
595	 }
596	 function bfloor(uint a) internal pure returns (uint) {
597	 return btoi(a) * BONE;
598	 }
599	 function badd(uint a, uint b) internal pure returns (uint) {
600	 uint c = a + b;
601	 require(c >= a, "ERR_ADD_OVERFLOW");
602	 return c;
603	 }
604	 function bsub(uint a, uint b) internal pure returns (uint) {
605	 (uint c, bool flag) = bsubSign(a, b);
606	 require(!flag, "ERR_SUB_UNDERFLOW");
607	 return c;
608	 }
609	 function bsubSign(uint a, uint b) internal pure returns (uint, bool) {
610	 if (a >= b) {
611	 return (a - b, false);
612	 }
613	 else {
614	 return (b - a, true);
615	 }
616	 }
617	 function bmul(uint a, uint b) internal pure returns (uint) {
618	 uint c0 = a * b;
619	 require(a == 0 || c0 / a == b, "ERR_MUL_OVERFLOW");
620	 uint c1 = c0 + (BONE / 2);
621	 require(c1 >= c0, "ERR_MUL_OVERFLOW");
622	 uint c2 = c1 / BONE;
623	 return c2;
624	 }
625	 function bdiv(uint a, uint b) internal pure returns (uint) {
626	 require(b != 0, "ERR_DIV_ZERO");
627	 uint c0 = a * BONE;
628	 require(a == 0 || c0 / a == BONE, "ERR_DIV_INTERNAL");
629	 uint c1 = c0 + (b / 2);
630	 require(c1 >= c0, "ERR_DIV_INTERNAL");
631	 uint c2 = c1 / b;
632	 return c2;
633	 }
634	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
635	 require(b > 0, "ERR_DIV_ZERO");
636	 return a / b;
637	 }
638	 function bpowi(uint a, uint n) internal pure returns (uint) {
639	 uint z = n % 2 != 0 ? a : BONE;
640	 for (n /= 2; n != 0; n /= 2) {
641	 a = bmul(a, a);
642	 if (n % 2 != 0) {
643	 z = bmul(z, a);
644	 }
645	 }
646	 return z;
647	 }
648	 function bpow(uint base, uint exp) internal pure returns (uint) {
649	 require(base >= MIN_BPOW_BASE, "ERR_BPOW_BASE_TOO_LOW");
650	 require(base <= MAX_BPOW_BASE, "ERR_BPOW_BASE_TOO_HIGH");
651	 uint whole = bfloor(exp);
652	 uint remain = bsub(exp, whole);
653	 uint wholePow = bpowi(base, btoi(whole));
654	 if (remain == 0) {
655	 return wholePow;
656	 }
657	 uint partialResult = bpowApprox(base, remain, BPOW_PRECISION);
658	 return bmul(wholePow, partialResult);
659	 }
660	 function bpowApprox(uint base, uint exp, uint precision) internal pure returns (uint) {
661	 uint a = exp;
662	 (uint x, bool xneg) = bsubSign(base, BONE);
663	 uint term = BONE;
664	 uint sum = term;
665	 bool negative = false;
666	 for (uint i = 1; term >= precision; i++) {
667	 uint bigK = i * BONE;
668	 (uint c, bool cneg) = bsubSign(a, bsub(bigK, BONE));
669	 term = bmul(term, bmul(c, x));
670	 term = bdiv(term, bigK);
671	 if (term == 0) break;
672	 if (xneg) negative = !negative;
673	 if (cneg) negative = !negative;
674	 if (negative) {
675	 sum = bsub(sum, term);
676	 }
677	 else {
678	 sum = badd(sum, term);
679	 }
680	 }
681	 return sum;
682	 }
683	 }
684	 pragma solidity 0.6.12;
685	 contract MCapWeightAbstract is BNum, OwnableUpgradeSafe {
686	 event SetExcludeTokenBalances(address indexed token, address[] excludeTokenBalances);
687	 event FetchTokenMCap(address indexed pool, address indexed token, uint256 mCap);
688	 event UpdatePoolWeights( address indexed pool, uint256 indexed timestamp, address[] tokens, uint256[3][] weightsChange, uint256[] newMCaps );
689	 struct TokenConfigItem {
690	 address token;
691	 address[] excludeTokenBalances;
692	 }
693	 IPowerOracle public oracle;
694	 mapping(address => address[]) public excludeTokenBalances;
695	 constructor(address _oracle) public OwnableUpgradeSafe() {
696	 if (_oracle != address(0)) {
697	 __Ownable_init();
698	 oracle = IPowerOracle(_oracle);
699	 }
700	 }
701	 function setExcludeTokenBalances(address _token, address[] calldata _excludeTokenBalances) external onlyOwner {
702	 excludeTokenBalances[_token] = _excludeTokenBalances;
703	 emit SetExcludeTokenBalances(_token, _excludeTokenBalances);
704	 }
705	 function setExcludeTokenBalancesList(TokenConfigItem[] calldata _tokenConfigItems) external onlyOwner {
706	 uint256 len = _tokenConfigItems.length;
707	 for (uint256 i = 0; i < len; i++) {
708	 excludeTokenBalances[_tokenConfigItems[i].token] = _tokenConfigItems[i].excludeTokenBalances;
709	 emit SetExcludeTokenBalances(_tokenConfigItems[i].token, _tokenConfigItems[i].excludeTokenBalances);
710	 }
711	 }
712	 function getTokenMarketCap(address _token) public view returns (uint256) {
713	 uint256 totalSupply = IERC20(_token).totalSupply();
714	 uint256 len = excludeTokenBalances[_token].length;
715	 for (uint256 i = 0; i < len; i++) {
716	 totalSupply = bsub(totalSupply, IERC20(_token).balanceOf(excludeTokenBalances[_token][i]));
717	 }
718	 return bdiv(bmul(totalSupply, oracle.assetPrices(_token)), 1 ether);
719	 }
720	 function getExcludeTokenBalancesLength(address _token) external view returns (uint256) {
721	 return excludeTokenBalances[_token].length;
722	 }
723	 function getExcludeTokenBalancesList(address _token) external view returns (address[] memory) {
724	 return excludeTokenBalances[_token];
725	 }
726	 function _computeWeightsChangeWithEvent( PowerIndexPoolInterface _pool, address[] memory _tokens, uint256 _minWPS, uint256 _maxWPS, uint256 fromTimestamp, uint256 toTimestamp ) internal returns (uint256[3][] memory weightsChange, uint256 lenToPush) {
727	 uint256[] memory newMCaps;
728	 (weightsChange, lenToPush, newMCaps) = computeWeightsChange( _pool, _tokens, _minWPS, _maxWPS, fromTimestamp, toTimestamp );
729	 emit UpdatePoolWeights(address(_pool), block.timestamp, _tokens, weightsChange, newMCaps);
730	 }
731	 function computeWeightsChange( PowerIndexPoolInterface _pool, address[] memory _tokens, uint256 _minWPS, uint256 _maxWPS, uint256 fromTimestamp, uint256 toTimestamp ) public view returns ( uint256[3][] memory weightsChange, uint256 lenToPush, uint256[] memory newMCaps ) {
732	 uint256 len = _tokens.length;
733	 newMCaps = new uint256[](len);
734	 uint256 newMarketCapSum;
735	 for (uint256 i = 0; i < len; i++) {
736	 newMCaps[i] = getTokenMarketCap(_tokens[i]);
737	 newMarketCapSum = badd(newMarketCapSum, newMCaps[i]);
738	 }
739	 weightsChange = new uint256[3][](len);
740	 for (uint256 i = 0; i < len; i++) {
741	 (, , , uint256 oldWeight) = _pool.getDynamicWeightSettings(_tokens[i]);
742	 uint256 newWeight = bmul(bdiv(newMCaps[i], newMarketCapSum), 25 * BONE);
743	 weightsChange[i] = [i, oldWeight, newWeight];
744	 }
745	 for (uint256 i = 0; i < len; i++) {
746	 uint256 wps = getWeightPerSecond(weightsChange[i][1], weightsChange[i][2], fromTimestamp, toTimestamp);
747	 if (wps >= _minWPS) {
748	 lenToPush++;
749	 }
750	 }
751	 if (lenToPush > 1) {
752	 _sort(weightsChange);
753	 }
754	 }
755	 function getWeightPerSecond( uint256 fromDenorm, uint256 targetDenorm, uint256 fromTimestamp, uint256 targetTimestamp ) public pure returns (uint256) {
756	 uint256 delta = targetDenorm > fromDenorm ? bsub(targetDenorm, fromDenorm) : bsub(fromDenorm, targetDenorm);
757	 return div(delta, bsub(targetTimestamp, fromTimestamp));
758	 }
759	 function _quickSort( uint256[3][] memory wightsChange, int256 left, int256 right ) internal pure {
760	 int256 i = left;
761	 int256 j = right;
762	 if (i == j) return;
763	 uint256[3] memory pivot = wightsChange[uint256(left + (right - left) / 2)];
764	 int256 pDiff = int256(pivot[2]) - int256(pivot[1]);
765	 while (i <= j) {
766	 while (int256(wightsChange[uint256(i)][2]) - int256(wightsChange[uint256(i)][1]) < pDiff) i++;
767	 while (pDiff < int256(wightsChange[uint256(j)][2]) - int256(wightsChange[uint256(j)][1])) j--;
768	 if (i <= j) {
769	 (wightsChange[uint256(i)], wightsChange[uint256(j)]) = (wightsChange[uint256(j)], wightsChange[uint256(i)]);
770	 i++;
771	 j--;
772	 }
773	 }
774	 if (left < j) _quickSort(wightsChange, left, j);
775	 if (i < right) _quickSort(wightsChange, i, right);
776	 }
777	 function _sort(uint256[3][] memory weightsChange) internal pure {
778	 _quickSort(weightsChange, int256(0), int256(weightsChange.length - 1));
779	 }
780	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
781	 if (a == 0) {
782	 return 0;
783	 }
784	 uint256 c = a * b;
785	 require(c / a == b, "SafeMath: multiplication overflow");
786	 return c;
787	 }
788	 }
789	 pragma solidity 0.6.12;
790	 contract MCapWeightStrategy is MCapWeightAbstract {
791	 event AddPool(address indexed pool, address indexed poolController);
792	 event SetPool(address indexed pool, address indexed poolController, bool indexed active);
793	 event SetWeightsChangeDuration(uint256 weightsChangeDuration);
794	 struct PokeVars {
795	 PowerIndexPoolInterface pool;
796	 uint256 minWPS;
797	 uint256 maxWPS;
798	 address[] tokens;
799	 address[] piTokens;
800	 uint256 tokensLen;
801	 uint256 fromTimestamp;
802	 uint256 iToPush;
803	 }
804	 struct Pool {
805	 PowerIndexPoolController controller;
806	 PowerIndexWrapperInterface wrapper;
807	 uint256 lastWeightsUpdate;
808	 bool active;
809	 }
810	 uint256 internal constant COMPENSATION_PLAN_1_ID = 1;
811	 address[] public pools;
812	 mapping(address => Pool) public poolsData;
813	 uint256 weightsChangeDuration;
814	 IPowerPoke public powerPoke;
815	 modifier onlyReporter(uint256 _reporterId, bytes calldata _rewardOpts) {
816	 uint256 gasStart = gasleft();
817	 powerPoke.authorizeReporter(_reporterId, msg.sender);
818	 _;
819	 _reward(_reporterId, gasStart, COMPENSATION_PLAN_1_ID, _rewardOpts);
820	 }
821	 modifier onlyNonReporter(uint256 _reporterId, bytes calldata _rewardOpts) {
822	 uint256 gasStart = gasleft();
823	 powerPoke.authorizeNonReporter(_reporterId, msg.sender);
824	 _;
825	 _reward(_reporterId, gasStart, COMPENSATION_PLAN_1_ID, _rewardOpts);
826	 }
827	 modifier denyContract() {
828	 require(msg.sender == tx.origin, "CONTRACT_CALL");
829	 _;
830	 }
831	 constructor() public MCapWeightAbstract(address(0)) {
832	 }
833	 function initialize( address _oracle, address _powerPoke, uint256 _weightsChangeDuration ) external initializer {
834	 __Ownable_init();
835	 oracle = IPowerOracle(_oracle);
836	 powerPoke = IPowerPoke(_powerPoke);
837	 weightsChangeDuration = _weightsChangeDuration;
838	 }
839	 function setWeightsChangeDuration(uint256 _weightsChangeDuration) external onlyOwner {
840	 weightsChangeDuration = _weightsChangeDuration;
841	 emit SetWeightsChangeDuration(_weightsChangeDuration);
842	 }
843	 function addPool( address _poolAddress, address _controller, address _wrapper ) external onlyOwner {
844	 require(address(poolsData[_poolAddress].controller) == address(0), "ALREADY_EXIST");
845	 require(_controller != address(0), "CONTROLLER_CANT_BE_NULL");
846	 pools.push(_poolAddress);
847	 poolsData[_poolAddress].controller = PowerIndexPoolController(_controller);
848	 poolsData[_poolAddress].wrapper = PowerIndexWrapperInterface(_wrapper);
849	 poolsData[_poolAddress].active = true;
850	 emit AddPool(_poolAddress, _controller);
851	 }
852	 function setPool( address _poolAddress, address _controller, address _wrapper, bool _active ) external onlyOwner {
853	 require(_controller != address(0), "CONTROLLER_CANT_BE_NULL");
854	 poolsData[_poolAddress].controller = PowerIndexPoolController(_controller);
855	 poolsData[_poolAddress].wrapper = PowerIndexWrapperInterface(_wrapper);
856	 poolsData[_poolAddress].active = _active;
857	 emit SetPool(_poolAddress, _controller, _active);
858	 }
859	 function pausePool(address _poolAddress) external onlyOwner {
860	 poolsData[_poolAddress].active = false;
861	 PowerIndexPoolInterface pool = PowerIndexPoolInterface(_poolAddress);
862	 address[] memory tokens = pool.getCurrentTokens();
863	 uint256 len = tokens.length;
864	 PowerIndexPoolController.DynamicWeightInput[] memory dws;
865	 dws = new PowerIndexPoolController.DynamicWeightInput[](len);
866	 for (uint256 i = 0; i < len; i++) {
867	 dws[i].token = tokens[i];
868	 dws[i].fromTimestamp = block.timestamp + 1;
869	 dws[i].targetTimestamp = block.timestamp + 2;
870	 dws[i].targetDenorm = pool.getDenormalizedWeight(tokens[i]);
871	 }
872	 poolsData[_poolAddress].controller.setDynamicWeightListByStrategy(dws);
873	 }
874	 function pokeFromReporter( uint256 _reporterId, address[] memory _pools, bytes calldata _rewardOpts ) external onlyReporter(_reporterId, _rewardOpts) denyContract {
875	 _poke(_pools, false);
876	 }
877	 function pokeFromSlasher( uint256 _reporterId, address[] memory _pools, bytes calldata _rewardOpts ) external onlyNonReporter(_reporterId, _rewardOpts) denyContract {
878	 _poke(_pools, true);
879	 }
880	 function getPoolsList() external view returns (address[] memory) {
881	 return pools;
882	 }
883	 function getPoolsLength() external view returns (uint256) {
884	 return pools.length;
885	 }
886	 function getActivePoolsList() external view returns (address[] memory output) {
887	 uint256 len = pools.length;
888	 uint256 activeLen = 0;
889	 for (uint256 i; i < len; i++) {
890	 if (poolsData[pools[i]].active) {
891	 activeLen++;
892	 }
893	 }
894	 output = new address[](activeLen);
895	 uint256 ai;
896	 for (uint256 i; i < len; i++) {
897	 if (poolsData[pools[i]].active) {
898	 output[ai++] = pools[i];
899	 }
900	 }
901	 }
902	 function _poke(address[] memory _pools, bool _bySlasher) internal {
903	 (uint256 minInterval, uint256 maxInterval) = _getMinMaxReportInterval();
904	 for (uint256 pi = 0; pi < _pools.length; pi++) {
905	 PokeVars memory pv;
906	 pv.pool = PowerIndexPoolInterface(_pools[pi]);
907	 Pool storage pd = poolsData[address(pv.pool)];
908	 require(pd.active, "NOT_ACTIVE");
909	 require(pd.lastWeightsUpdate + minInterval < block.timestamp, "MIN_INTERVAL_NOT_REACHED");
910	 if (_bySlasher) {
911	 require(pd.lastWeightsUpdate + maxInterval < block.timestamp, "MAX_INTERVAL_NOT_REACHED");
912	 }
913	 (pv.minWPS, pv.maxWPS) = pv.pool.getWeightPerSecondBounds();
914	 if (address(pd.wrapper) == address(0)) {
915	 pv.tokens = pv.pool.getCurrentTokens();
916	 }
917	 else {
918	 pv.tokens = pd.wrapper.getCurrentTokens();
919	 pv.piTokens = pv.pool.getCurrentTokens();
920	 }
921	 pv.tokensLen = pv.tokens.length;
922	 pv.fromTimestamp = block.timestamp + 1;
923	 (uint256[3][] memory weightsChange, uint256 lenToPush) = _computeWeightsChangeWithEvent( pv.pool, pv.tokens, pv.minWPS, pv.maxWPS, pv.fromTimestamp, pv.fromTimestamp + weightsChangeDuration );
924	 PowerIndexPoolController.DynamicWeightInput[] memory dws;
925	 dws = new PowerIndexPoolController.DynamicWeightInput[](lenToPush);
926	 for (uint256 i = 0; i < pv.tokensLen; i++) {
927	 uint256 wps = getWeightPerSecond( weightsChange[i][1], weightsChange[i][2], pv.fromTimestamp, pv.fromTimestamp + weightsChangeDuration );
928	 if (wps > pv.maxWPS) {
929	 if (weightsChange[i][1] > weightsChange[i][2]) {
930	 weightsChange[i][2] = bsub(weightsChange[i][1], mul(weightsChangeDuration, pv.maxWPS));
931	 }
932	 else {
933	 weightsChange[i][2] = badd(weightsChange[i][1], mul(weightsChangeDuration, pv.maxWPS));
934	 }
935	 }
936	 if (wps >= pv.minWPS) {
937	 if (address(pd.wrapper) == address(0)) {
938	 dws[pv.iToPush].token = pv.tokens[weightsChange[i][0]];
939	 }
940	 else {
941	 dws[pv.iToPush].token = pv.piTokens[weightsChange[i][0]];
942	 }
943	 dws[pv.iToPush].fromTimestamp = pv.fromTimestamp;
944	 dws[pv.iToPush].targetTimestamp = pv.fromTimestamp + weightsChangeDuration;
945	 dws[pv.iToPush].targetDenorm = weightsChange[i][2];
946	 pv.iToPush++;
947	 }
948	 }
949	 if (dws.length > 0) {
950	 pd.controller.setDynamicWeightListByStrategy(dws);
951	 }
952	 pd.lastWeightsUpdate = block.timestamp;
953	 }
954	 }
955	 function _reward( uint256 _reporterId, uint256 _gasStart, uint256 _compensationPlan, bytes calldata _rewardOpts ) internal {
956	 powerPoke.reward(_reporterId, bsub(_gasStart, gasleft()), _compensationPlan, _rewardOpts);
957	 }
958	 function _getMinMaxReportInterval() internal view returns (uint256 min, uint256 max) {
959	 return powerPoke.getMinMaxReportIntervals(address(this));
960	 }
961	 }
