row number 
1	  pragma abicoder v2;
2	 pragma solidity >=0.6.0 <0.8.0;
3	 interface IERC165Upgradeable {
4	 function supportsInterface(bytes4 interfaceId) external view returns (bool);
5	 }
6	 pragma solidity >=0.4.24 <0.8.0;
7	 abstract contract Initializable {
8	 bool private _initialized;
9	 bool private _initializing;
10	 modifier initializer() {
11	 require(_initializing || _isConstructor() || !_initialized, "Initializable: contract is already initialized");
12	 bool isTopLevelCall = !_initializing;
13	 if (isTopLevelCall) {
14	 _initializing = true;
15	 _initialized = true;
16	 }
17	 _;
18	 if (isTopLevelCall) {
19	 _initializing = false;
20	 }
21	 }
22	 function _isConstructor() private view returns (bool) {
23	 return !AddressUpgradeable.isContract(address(this));
24	 }
25	 }
26	 pragma solidity >=0.6.2 <0.8.0;
27	 interface IERC721Upgradeable is IERC165Upgradeable {
28	 event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
29	 event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
30	 event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
31	 function balanceOf(address owner) external view returns (uint256 balance);
32	 function ownerOf(uint256 tokenId) external view returns (address owner);
33	 function safeTransferFrom(address from, address to, uint256 tokenId) external;
34	 function transferFrom(address from, address to, uint256 tokenId) external;
35	 function approve(address to, uint256 tokenId) external;
36	 function getApproved(uint256 tokenId) external view returns (address operator);
37	 function setApprovalForAll(address operator, bool _approved) external;
38	 function isApprovedForAll(address owner, address operator) external view returns (bool);
39	 function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;
40	 }
41	 pragma solidity >=0.6.0 <0.8.0;
42	 abstract contract EIP712Upgradeable is Initializable {
43	 bytes32 private _HASHED_NAME;
44	 bytes32 private _HASHED_VERSION;
45	 bytes32 private constant _TYPE_HASH = keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");
46	 function __EIP712_init(string memory name, string memory version) internal initializer {
47	 __EIP712_init_unchained(name, version);
48	 }
49	 function __EIP712_init_unchained(string memory name, string memory version) internal initializer {
50	 bytes32 hashedName = keccak256(bytes(name));
51	 bytes32 hashedVersion = keccak256(bytes(version));
52	 _HASHED_NAME = hashedName;
53	 _HASHED_VERSION = hashedVersion;
54	 }
55	 function _domainSeparatorV4() internal view returns (bytes32) {
56	 return _buildDomainSeparator(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash());
57	 }
58	 function _buildDomainSeparator(bytes32 typeHash, bytes32 name, bytes32 version) private view returns (bytes32) {
59	 return keccak256( abi.encode( typeHash, name, version, _getChainId(), address(this) ) );
60	 }
61	 function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {
62	 return keccak256(abi.encodePacked("\x19\x01", _domainSeparatorV4(), structHash));
63	 }
64	 function _getChainId() private view returns (uint256 chainId) {
65	 this;
66	 assembly {
67	 chainId := chainid() }
68	 }
69	 function _EIP712NameHash() internal virtual view returns (bytes32) {
70	 return _HASHED_NAME;
71	 }
72	 function _EIP712VersionHash() internal virtual view returns (bytes32) {
73	 return _HASHED_VERSION;
74	 }
75	 uint256[50] private __gap;
76	 }
77	 pragma solidity >=0.6.0 <0.8.0;
78	 abstract contract ContextUpgradeable is Initializable {
79	 function __Context_init() internal initializer {
80	 __Context_init_unchained();
81	 }
82	 function __Context_init_unchained() internal initializer {
83	 }
84	 function _msgSender() internal view virtual returns (address payable) {
85	 return msg.sender;
86	 }
87	 function _msgData() internal view virtual returns (bytes memory) {
88	 this;
89	 return msg.data;
90	 }
91	 uint256[50] private __gap;
92	 }
93	 pragma solidity >=0.6.0 <0.8.0;
94	 abstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {
95	 bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;
96	 mapping(bytes4 => bool) private _supportedInterfaces;
97	 function __ERC165_init() internal initializer {
98	 __ERC165_init_unchained();
99	 }
100	 function __ERC165_init_unchained() internal initializer {
101	 _registerInterface(_INTERFACE_ID_ERC165);
102	 }
103	 function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
104	 return _supportedInterfaces[interfaceId];
105	 }
106	 function _registerInterface(bytes4 interfaceId) internal virtual {
107	 require(interfaceId != 0xffffffff, "ERC165: invalid interface id");
108	 _supportedInterfaces[interfaceId] = true;
109	 }
110	 uint256[49] private __gap;
111	 }
112	 pragma solidity 0.7.6;
113	 abstract contract ERC1271Validator is EIP712Upgradeable {
114	 using AddressUpgradeable for address;
115	 using ECDSAUpgradeable for bytes32;
116	 string constant SIGNATURE_ERROR = "signature verification error";
117	 bytes4 constant internal MAGICVALUE = 0x1626ba7e;
118	 function validate1271(address signer, bytes32 structHash, bytes memory signature) internal view {
119	 bytes32 hash = _hashTypedDataV4(structHash);
120	 if (signer.isContract()) {
121	 require( ERC1271(signer).isValidSignature(hash, signature) == MAGICVALUE, SIGNATURE_ERROR );
122	 }
123	 else {
124	 require( hash.recover(signature) == signer, SIGNATURE_ERROR );
125	 }
126	 }
127	 uint256[50] private __gap;
128	 }
129	 pragma solidity >=0.6.2 <0.8.0;
130	 interface IERC721EnumerableUpgradeable is IERC721Upgradeable {
131	 function totalSupply() external view returns (uint256);
132	 function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);
133	 function tokenByIndex(uint256 index) external view returns (uint256);
134	 }
135	 pragma solidity >=0.6.2 <0.8.0;
136	 interface IERC721MetadataUpgradeable is IERC721Upgradeable {
137	 function name() external view returns (string memory);
138	 function symbol() external view returns (string memory);
139	 function tokenURI(uint256 tokenId) external view returns (string memory);
140	 }
141	 pragma solidity >=0.6.2 <0.8.0;
142	 interface RoyaltiesV2 {
143	 event RoyaltiesSet(uint256 tokenId, LibPart.Part[] royalties);
144	 function getRaribleV2Royalties(uint256 id) external view returns (LibPart.Part[] memory);
145	 }
146	 pragma solidity >=0.6.2 <0.8.0;
147	 abstract contract AbstractRoyalties {
148	 mapping (uint256 => LibPart.Part[]) internal royalties;
149	 function _saveRoyalties(uint256 id, LibPart.Part[] memory _royalties) internal {
150	 uint256 totalValue;
151	 for (uint i = 0; i < _royalties.length; i++) {
152	 require(_royalties[i].account != address(0x0), "Recipient should be present");
153	 require(_royalties[i].value != 0, "Royalty value should be positive");
154	 totalValue += _royalties[i].value;
155	 royalties[id].push(_royalties[i]);
156	 }
157	 require(totalValue < 10000, "Royalty total value should be < 10000");
158	 _onRoyaltiesSet(id, _royalties);
159	 }
160	 function _updateAccount(uint256 _id, address _from, address _to) internal {
161	 uint length = royalties[_id].length;
162	 for(uint i = 0; i < length; i++) {
163	 if (royalties[_id][i].account == _from) {
164	 royalties[_id][i].account = address(uint160(_to));
165	 }
166	 }
167	 }
168	 function _onRoyaltiesSet(uint256 id, LibPart.Part[] memory _royalties) virtual internal;
169	 }
170	 pragma solidity 0.7.6;
171	 contract Mint721Validator is ERC1271Validator {
172	 function __Mint721Validator_init_unchained() internal initializer {
173	 __EIP712_init_unchained("Mint721", "1");
174	 }
175	 function validate(address account, bytes32 hash, bytes memory signature) internal view {
176	 validate1271(account, hash, signature);
177	 }
178	 uint256[50] private __gap;
179	 }
180	 pragma solidity >=0.6.0 <0.8.0;
181	 contract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable, IERC721EnumerableUpgradeable {
182	 using SafeMathUpgradeable for uint256;
183	 using AddressUpgradeable for address;
184	 using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;
185	 using EnumerableMapUpgradeable for EnumerableMapUpgradeable.UintToAddressMap;
186	 using StringsUpgradeable for uint256;
187	 bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;
188	 mapping (address => EnumerableSetUpgradeable.UintSet) private _holderTokens;
189	 EnumerableMapUpgradeable.UintToAddressMap private _tokenOwners;
190	 mapping (uint256 => address) private _tokenApprovals;
191	 mapping (address => mapping (address => bool)) private _operatorApprovals;
192	 string private _name;
193	 string private _symbol;
194	 mapping (uint256 => string) private _tokenURIs;
195	 string private _baseURI;
196	 bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;
197	 bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;
198	 bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;
199	 function __ERC721_init(string memory name_, string memory symbol_) internal initializer {
200	 __Context_init_unchained();
201	 __ERC165_init_unchained();
202	 __ERC721_init_unchained(name_, symbol_);
203	 }
204	 function __ERC721_init_unchained(string memory name_, string memory symbol_) internal initializer {
205	 _name = name_;
206	 _symbol = symbol_;
207	 _registerInterface(_INTERFACE_ID_ERC721);
208	 _registerInterface(_INTERFACE_ID_ERC721_METADATA);
209	 _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);
210	 }
211	 function balanceOf(address owner) public view virtual override returns (uint256) {
212	 require(owner != address(0), "ERC721: balance query for the zero address");
213	 return _holderTokens[owner].length();
214	 }
215	 function ownerOf(uint256 tokenId) public view virtual override returns (address) {
216	 return _tokenOwners.get(tokenId, "ERC721: owner query for nonexistent token");
217	 }
218	 function name() public view virtual override returns (string memory) {
219	 return _name;
220	 }
221	 function symbol() public view virtual override returns (string memory) {
222	 return _symbol;
223	 }
224	 function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
225	 require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
226	 string memory _tokenURI = _tokenURIs[tokenId];
227	 string memory base = baseURI();
228	 if (bytes(base).length == 0) {
229	 return _tokenURI;
230	 }
231	 if (bytes(_tokenURI).length > 0) {
232	 return string(abi.encodePacked(base, _tokenURI));
233	 }
234	 return string(abi.encodePacked(base, tokenId.toString()));
235	 }
236	 function baseURI() public view virtual returns (string memory) {
237	 return _baseURI;
238	 }
239	 function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {
240	 return _holderTokens[owner].at(index);
241	 }
242	 function totalSupply() public view virtual override returns (uint256) {
243	 return _tokenOwners.length();
244	 }
245	 function tokenByIndex(uint256 index) public view virtual override returns (uint256) {
246	 (uint256 tokenId, ) = _tokenOwners.at(index);
247	 return tokenId;
248	 }
249	 function approve(address to, uint256 tokenId) public virtual override {
250	 address owner = ERC721Upgradeable.ownerOf(tokenId);
251	 require(to != owner, "ERC721: approval to current owner");
252	 require(_msgSender() == owner || ERC721Upgradeable.isApprovedForAll(owner, _msgSender()), "ERC721: approve caller is not owner nor approved for all" );
253	 _approve(to, tokenId);
254	 }
255	 function getApproved(uint256 tokenId) public view virtual override returns (address) {
256	 require(_exists(tokenId), "ERC721: approved query for nonexistent token");
257	 return _tokenApprovals[tokenId];
258	 }
259	 function setApprovalForAll(address operator, bool approved) public virtual override {
260	 require(operator != _msgSender(), "ERC721: approve to caller");
261	 _operatorApprovals[_msgSender()][operator] = approved;
262	 emit ApprovalForAll(_msgSender(), operator, approved);
263	 }
264	 function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
265	 return _operatorApprovals[owner][operator];
266	 }
267	 function transferFrom(address from, address to, uint256 tokenId) public virtual override {
268	 require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");
269	 _transfer(from, to, tokenId);
270	 }
271	 function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {
272	 safeTransferFrom(from, to, tokenId, "");
273	 }
274	 function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {
275	 require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");
276	 _safeTransfer(from, to, tokenId, _data);
277	 }
278	 function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {
279	 _transfer(from, to, tokenId);
280	 require(_checkOnERC721Received(from, to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");
281	 }
282	 function _exists(uint256 tokenId) internal view virtual returns (bool) {
283	 return _tokenOwners.contains(tokenId);
284	 }
285	 function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {
286	 require(_exists(tokenId), "ERC721: operator query for nonexistent token");
287	 address owner = ERC721Upgradeable.ownerOf(tokenId);
288	 return (spender == owner || getApproved(tokenId) == spender || ERC721Upgradeable.isApprovedForAll(owner, spender));
289	 }
290	 function _safeMint(address to, uint256 tokenId) internal virtual {
291	 _safeMint(to, tokenId, "");
292	 }
293	 function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {
294	 _mint(to, tokenId);
295	 require(_checkOnERC721Received(address(0), to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");
296	 }
297	 function _mint(address to, uint256 tokenId) internal virtual {
298	 require(to != address(0), "ERC721: mint to the zero address");
299	 require(!_exists(tokenId), "ERC721: token already minted");
300	 _beforeTokenTransfer(address(0), to, tokenId);
301	 _holderTokens[to].add(tokenId);
302	 _tokenOwners.set(tokenId, to);
303	 emit Transfer(address(0), to, tokenId);
304	 }
305	 function _burn(uint256 tokenId) internal virtual {
306	 address owner = ERC721Upgradeable.ownerOf(tokenId);
307	 _beforeTokenTransfer(owner, address(0), tokenId);
308	 _approve(address(0), tokenId);
309	 if (bytes(_tokenURIs[tokenId]).length != 0) {
310	 delete _tokenURIs[tokenId];
311	 }
312	 _holderTokens[owner].remove(tokenId);
313	 _tokenOwners.remove(tokenId);
314	 emit Transfer(owner, address(0), tokenId);
315	 }
316	 function _transfer(address from, address to, uint256 tokenId) internal virtual {
317	 require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer of token that is not own");
318	 require(to != address(0), "ERC721: transfer to the zero address");
319	 _beforeTokenTransfer(from, to, tokenId);
320	 _approve(address(0), tokenId);
321	 _holderTokens[from].remove(tokenId);
322	 _holderTokens[to].add(tokenId);
323	 _tokenOwners.set(tokenId, to);
324	 emit Transfer(from, to, tokenId);
325	 }
326	 function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {
327	 require(_exists(tokenId), "ERC721Metadata: URI set of nonexistent token");
328	 _tokenURIs[tokenId] = _tokenURI;
329	 }
330	 function _setBaseURI(string memory baseURI_) internal virtual {
331	 _baseURI = baseURI_;
332	 }
333	 function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data) private returns (bool) {
334	 if (!to.isContract()) {
335	 return true;
336	 }
337	 bytes memory returndata = to.functionCall(abi.encodeWithSelector( IERC721ReceiverUpgradeable(to).onERC721Received.selector, _msgSender(), from, tokenId, _data ), "ERC721: transfer to non ERC721Receiver implementer");
338	 bytes4 retval = abi.decode(returndata, (bytes4));
339	 return (retval == _ERC721_RECEIVED);
340	 }
341	 function _approve(address to, uint256 tokenId) private {
342	 _tokenApprovals[tokenId] = to;
343	 emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);
344	 }
345	 function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual {
346	 }
347	 uint256[41] private __gap;
348	 }
349	 pragma solidity >=0.6.2 <0.8.0;
350	 interface IERC721LazyMint is IERC721Upgradeable {
351	 event Creators( uint256 tokenId, LibPart.Part[] creators );
352	 function mintAndTransfer( LibERC721LazyMint.Mint721Data memory data, address to ) external;
353	 function transferFromOrMint( LibERC721LazyMint.Mint721Data memory data, address from, address to ) external;
354	 }
355	 pragma solidity >=0.6.2 <0.8.0;
356	 abstract contract RoyaltiesV2Upgradeable is ERC165Upgradeable, RoyaltiesV2 {
357	 function __RoyaltiesV2Upgradeable_init_unchained() internal initializer {
358	 _registerInterface(LibRoyaltiesV2._INTERFACE_ID_ROYALTIES);
359	 }
360	 }
361	 pragma solidity >=0.6.2 <0.8.0;
362	 contract RoyaltiesV2Impl is AbstractRoyalties, RoyaltiesV2 {
363	 function getRaribleV2Royalties(uint256 id) override external view returns (LibPart.Part[] memory) {
364	 return royalties[id];
365	 }
366	 function _onRoyaltiesSet(uint256 id, LibPart.Part[] memory _royalties) override internal {
367	 emit RoyaltiesSet(id, _royalties);
368	 }
369	 }
370	 pragma solidity 0.7.6;
371	 abstract contract HasContractURI is ERC165Upgradeable {
372	 string public contractURI;
373	 bytes4 private constant _INTERFACE_ID_CONTRACT_URI = 0xe8a3d485;
374	 function __HasContractURI_init_unchained(string memory _contractURI) internal initializer {
375	 contractURI = _contractURI;
376	 _registerInterface(_INTERFACE_ID_CONTRACT_URI);
377	 }
378	 function _setContractURI(string memory _contractURI) internal {
379	 contractURI = _contractURI;
380	 }
381	 uint256[49] private __gap;
382	 }
383	 pragma solidity 0.7.6;
384	 abstract contract ERC721DefaultApproval is ERC721Upgradeable {
385	 mapping(address => bool) private defaultApprovals;
386	 event DefaultApproval(address indexed operator, bool hasApproval);
387	 function _setDefaultApproval(address operator, bool hasApproval) internal {
388	 defaultApprovals[operator] = hasApproval;
389	 emit DefaultApproval(operator, hasApproval);
390	 }
391	 function _isApprovedOrOwner(address spender, uint256 tokenId) internal virtual override view returns (bool) {
392	 return defaultApprovals[spender] || super._isApprovedOrOwner(spender, tokenId);
393	 }
394	 function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
395	 return defaultApprovals[operator] || super.isApprovedForAll(owner, operator);
396	 }
397	 uint256[50] private __gap;
398	 }
399	 pragma solidity 0.7.6;
400	 abstract contract ERC721Lazy is IERC721LazyMint, ERC721Upgradeable, Mint721Validator, RoyaltiesV2Upgradeable, RoyaltiesV2Impl {
401	 using SafeMathUpgradeable for uint;
402	 bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;
403	 bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;
404	 bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;
405	 bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;
406	 mapping(uint256 => LibPart.Part[]) private creators;
407	 function __ERC721Lazy_init_unchained() internal initializer {
408	 }
409	 function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165Upgradeable, ERC165Upgradeable) returns (bool) {
410	 return interfaceId == LibERC721LazyMint._INTERFACE_ID_MINT_AND_TRANSFER || interfaceId == LibRoyaltiesV2._INTERFACE_ID_ROYALTIES || interfaceId == _INTERFACE_ID_ERC165 || interfaceId == _INTERFACE_ID_ERC721 || interfaceId == _INTERFACE_ID_ERC721_METADATA || interfaceId == _INTERFACE_ID_ERC721_ENUMERABLE;
411	 }
412	 function transferFromOrMint( LibERC721LazyMint.Mint721Data memory data, address from, address to ) override external {
413	 if (_exists(data.tokenId)) {
414	 safeTransferFrom(from, to, data.tokenId);
415	 }
416	 else {
417	 mintAndTransfer(data, to);
418	 }
419	 }
420	 function mintAndTransfer(LibERC721LazyMint.Mint721Data memory data, address to) public override virtual {
421	 address minter = address(data.tokenId >> 96);
422	 address sender = _msgSender();
423	 require(minter == data.creators[0].account, "tokenId incorrect");
424	 require(data.creators.length == data.signatures.length);
425	 require(minter == sender || isApprovedForAll(minter, sender), "ERC721: transfer caller is not owner nor approved");
426	 bytes32 hash = LibERC721LazyMint.hash(data);
427	 for (uint i = 0; i < data.creators.length; i++) {
428	 address creator = data.creators[i].account;
429	 if (creator != sender) {
430	 validate(creator, hash, data.signatures[i]);
431	 }
432	 }
433	 _safeMint(to, data.tokenId);
434	 _saveRoyalties(data.tokenId, data.royalties);
435	 _saveCreators(data.tokenId, data.creators);
436	 _setTokenURI(data.tokenId, data.tokenURI);
437	 }
438	 function _saveCreators(uint tokenId, LibPart.Part[] memory _creators) internal {
439	 LibPart.Part[] storage creatorsOfToken = creators[tokenId];
440	 uint total = 0;
441	 for (uint i = 0; i < _creators.length; i++) {
442	 require(_creators[i].account != address(0x0), "Account should be present");
443	 require(_creators[i].value != 0, "Creator share should be positive");
444	 creatorsOfToken.push(_creators[i]);
445	 total = total.add(_creators[i].value);
446	 }
447	 require(total == 10000, "total amount of creators share should be 10000");
448	 emit Creators(tokenId, _creators);
449	 }
450	 function updateAccount(uint256 _id, address _from, address _to) external {
451	 require(_msgSender() == _from, "not allowed");
452	 super._updateAccount(_id, _from, _to);
453	 }
454	 function getCreators(uint256 _id) external view returns (LibPart.Part[] memory) {
455	 return creators[_id];
456	 }
457	 uint256[50] private __gap;
458	 }
459	 pragma solidity >=0.6.0 <0.8.0;
460	 abstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {
461	 address private _owner;
462	 event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
463	 function __Ownable_init() internal initializer {
464	 __Context_init_unchained();
465	 __Ownable_init_unchained();
466	 }
467	 function __Ownable_init_unchained() internal initializer {
468	 address msgSender = _msgSender();
469	 _owner = msgSender;
470	 emit OwnershipTransferred(address(0), msgSender);
471	 }
472	 function owner() public view virtual returns (address) {
473	 return _owner;
474	 }
475	 modifier onlyOwner() {
476	 require(owner() == _msgSender(), "Ownable: caller is not the owner");
477	 _;
478	 }
479	 function renounceOwnership() public virtual onlyOwner {
480	 emit OwnershipTransferred(_owner, address(0));
481	 _owner = address(0);
482	 }
483	 function transferOwnership(address newOwner) public virtual onlyOwner {
484	 require(newOwner != address(0), "Ownable: new owner is the zero address");
485	 emit OwnershipTransferred(_owner, newOwner);
486	 _owner = newOwner;
487	 }
488	 uint256[49] private __gap;
489	 }
490	 pragma solidity >=0.6.0 <0.8.0;
491	 abstract contract ERC721BurnableUpgradeable is Initializable, ContextUpgradeable, ERC721Upgradeable {
492	 function __ERC721Burnable_init() internal initializer {
493	 __Context_init_unchained();
494	 __ERC165_init_unchained();
495	 __ERC721Burnable_init_unchained();
496	 }
497	 function __ERC721Burnable_init_unchained() internal initializer {
498	 }
499	 function burn(uint256 tokenId) public virtual {
500	 require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721Burnable: caller is not owner nor approved");
501	 _burn(tokenId);
502	 }
503	 uint256[50] private __gap;
504	 }
505	 pragma solidity >=0.6.0 <0.8.0;
506	 abstract contract Context {
507	 function _msgSender() internal view virtual returns (address payable) {
508	 return msg.sender;
509	 }
510	 function _msgData() internal view virtual returns (bytes memory) {
511	 this;
512	 return msg.data;
513	 }
514	 }
515	 pragma solidity 0.7.6;
516	 abstract contract ERC721Base is OwnableUpgradeable, ERC721DefaultApproval, ERC721BurnableUpgradeable, ERC721Lazy, HasContractURI {
517	 function setDefaultApproval(address operator, bool hasApproval) external onlyOwner {
518	 _setDefaultApproval(operator, hasApproval);
519	 }
520	 function _isApprovedOrOwner(address spender, uint256 tokenId) internal virtual override(ERC721Upgradeable, ERC721DefaultApproval) view returns (bool) {
521	 return ERC721DefaultApproval._isApprovedOrOwner(spender, tokenId);
522	 }
523	 function isApprovedForAll(address owner, address operator) public view virtual override(ERC721DefaultApproval, ERC721Upgradeable, IERC721Upgradeable) returns (bool) {
524	 return ERC721DefaultApproval.isApprovedForAll(owner, operator);
525	 }
526	 function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, ERC721Lazy) returns (bool) {
527	 return super.supportsInterface(interfaceId);
528	 }
529	 uint256[50] private __gap;
530	 }
531	 pragma solidity >=0.6.0 <0.8.0;
532	 abstract contract Ownable is Context {
533	 address private _owner;
534	 event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
535	 constructor () internal {
536	 address msgSender = _msgSender();
537	 _owner = msgSender;
538	 emit OwnershipTransferred(address(0), msgSender);
539	 }
540	 function owner() public view virtual returns (address) {
541	 return _owner;
542	 }
543	 modifier onlyOwner() {
544	 require(owner() == _msgSender(), "Ownable: caller is not the owner");
545	 _;
546	 }
547	 function renounceOwnership() public virtual onlyOwner {
548	 emit OwnershipTransferred(_owner, address(0));
549	 _owner = address(0);
550	 }
551	 function transferOwnership(address newOwner) public virtual onlyOwner {
552	 require(newOwner != address(0), "Ownable: new owner is the zero address");
553	 emit OwnershipTransferred(_owner, newOwner);
554	 _owner = newOwner;
555	 }
556	 }
557	 pragma solidity >=0.6.0 <0.8.0;
558	 abstract contract Proxy {
559	 function _delegate(address implementation) internal virtual {
560	 assembly {
561	 calldatacopy(0, 0, calldatasize()) let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0) returndatacopy(0, 0, returndatasize()) switch result case 0 {
562	 revert(0, returndatasize()) }
563	 default {
564	 return(0, returndatasize()) }
565	 }
566	 }
567	 function _implementation() internal view virtual returns (address);
568	 function _fallback() internal virtual {
569	 _beforeFallback();
570	 _delegate(_implementation());
571	 }
572	 fallback () external payable virtual {
573	 _fallback();
574	 }
575	 receive () external payable virtual {
576	 _fallback();
577	 }
578	 function _beforeFallback() internal virtual {
579	 }
580	 }
581	 pragma solidity 0.7.6;
582	 abstract contract ERC1271 {
583	 bytes4 constant public ERC1271_INTERFACE_ID = 0xfb855dc9;
584	 bytes4 constant public ERC1271_RETURN_VALID_SIGNATURE = 0x1626ba7e;
585	 bytes4 constant public ERC1271_RETURN_INVALID_SIGNATURE = 0x00000000;
586	 function isValidSignature(bytes32 _hash, bytes memory _signature) public virtual view returns (bytes4);
587	 function returnIsValidSignatureMagicNumber(bool isValid) internal pure returns (bytes4) {
588	 return isValid ? ERC1271_RETURN_VALID_SIGNATURE : ERC1271_RETURN_INVALID_SIGNATURE;
589	 }
590	 }
591	 pragma solidity 0.7.6;
592	 contract ERC721Rarible is ERC721Base {
593	 event CreateERC721Rarible(address owner, string name, string symbol);
594	 function __ERC721Rarible_init(string memory _name, string memory _symbol, string memory baseURI, string memory contractURI) external initializer {
595	 _setBaseURI(baseURI);
596	 __ERC721Lazy_init_unchained();
597	 __RoyaltiesV2Upgradeable_init_unchained();
598	 __Context_init_unchained();
599	 __ERC165_init_unchained();
600	 __Ownable_init_unchained();
601	 __ERC721Burnable_init_unchained();
602	 __Mint721Validator_init_unchained();
603	 __HasContractURI_init_unchained(contractURI);
604	 __ERC721_init_unchained(_name, _symbol);
605	 emit CreateERC721Rarible(_msgSender(), _name, _symbol);
606	 }
607	 uint256[50] private __gap;
608	 }
609	 pragma solidity >=0.6.2 <0.8.0;
610	 contract ERC721RaribleFactory is Ownable {
611	 IBeacon public beacon;
612	 address transferProxy;
613	 address lazyTransferProxy;
614	 event Create721RaribleProxy(BeaconProxy proxy);
615	 constructor(IBeacon _beacon, address _transferProxy, address _lazyTransferProxy) {
616	 beacon = _beacon;
617	 transferProxy = _transferProxy;
618	 lazyTransferProxy = _lazyTransferProxy;
619	 }
620	 function createToken(string memory _name, string memory _symbol, string memory baseURI, string memory contractURI) external {
621	 bytes memory data = abi.encodeWithSelector(ERC721Rarible(0).__ERC721Rarible_init.selector, _name, _symbol, baseURI, contractURI);
622	 BeaconProxy beaconProxy = new BeaconProxy(address(beacon), data);
623	 ERC721Rarible token = ERC721Rarible(address(beaconProxy));
624	 token.setDefaultApproval(transferProxy, true);
625	 token.setDefaultApproval(lazyTransferProxy, true);
626	 token.transferOwnership(_msgSender());
627	 emit Create721RaribleProxy(beaconProxy);
628	 }
629	 }
630	 pragma solidity >=0.6.0 <0.8.0;
631	 library ECDSAUpgradeable {
632	 function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {
633	 if (signature.length != 65) {
634	 revert("ECDSA: invalid signature length");
635	 }
636	 bytes32 r;
637	 bytes32 s;
638	 uint8 v;
639	 assembly {
640	 r := mload(add(signature, 0x20)) s := mload(add(signature, 0x40)) v := byte(0, mload(add(signature, 0x60))) }
641	 return recover(hash, v, r, s);
642	 }
643	 function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {
644	 require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, "ECDSA: invalid signature 's' value");
645	 require(v == 27 || v == 28, "ECDSA: invalid signature 'v' value");
646	 address signer = ecrecover(hash, v, r, s);
647	 require(signer != address(0), "ECDSA: invalid signature");
648	 return signer;
649	 }
650	 function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {
651	 return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
652	 }
653	 }
654	 pragma solidity >=0.6.0 <0.8.0;
655	 library SafeMathUpgradeable {
656	 function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
657	 uint256 c = a + b;
658	 if (c < a) return (false, 0);
659	 return (true, c);
660	 }
661	 function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
662	 if (b > a) return (false, 0);
663	 return (true, a - b);
664	 }
665	 function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
666	 if (a == 0) return (true, 0);
667	 uint256 c = a * b;
668	 if (c / a != b) return (false, 0);
669	 return (true, c);
670	 }
671	 function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
672	 if (b == 0) return (false, 0);
673	 return (true, a / b);
674	 }
675	 function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
676	 if (b == 0) return (false, 0);
677	 return (true, a % b);
678	 }
679	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
680	 uint256 c = a + b;
681	 require(c >= a, "SafeMath: addition overflow");
682	 return c;
683	 }
684	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
685	 require(b <= a, "SafeMath: subtraction overflow");
686	 return a - b;
687	 }
688	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
689	 if (a == 0) return 0;
690	 uint256 c = a * b;
691	 require(c / a == b, "SafeMath: multiplication overflow");
692	 return c;
693	 }
694	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
695	 require(b > 0, "SafeMath: division by zero");
696	 return a / b;
697	 }
698	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
699	 require(b > 0, "SafeMath: modulo by zero");
700	 return a % b;
701	 }
702	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
703	 require(b <= a, errorMessage);
704	 return a - b;
705	 }
706	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
707	 require(b > 0, errorMessage);
708	 return a / b;
709	 }
710	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
711	 require(b > 0, errorMessage);
712	 return a % b;
713	 }
714	 }
715	 pragma solidity >=0.6.0 <0.8.0;
716	 interface IERC721ReceiverUpgradeable {
717	 function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);
718	 }
719	 pragma solidity >=0.6.2 <0.8.0;
720	 library AddressUpgradeable {
721	 function isContract(address account) internal view returns (bool) {
722	 uint256 size;
723	 assembly {
724	 size := extcodesize(account) }
725	 return size > 0;
726	 }
727	 function sendValue(address payable recipient, uint256 amount) internal {
728	 require(address(this).balance >= amount, "Address: insufficient balance");
729	 (bool success, ) = recipient.call{
730	 value: amount }
731	 ("");
732	 require(success, "Address: unable to send value, recipient may have reverted");
733	 }
734	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
735	 return functionCall(target, data, "Address: low-level call failed");
736	 }
737	 function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
738	 return functionCallWithValue(target, data, 0, errorMessage);
739	 }
740	 function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
741	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
742	 }
743	 function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
744	 require(address(this).balance >= value, "Address: insufficient balance for call");
745	 require(isContract(target), "Address: call to non-contract");
746	 (bool success, bytes memory returndata) = target.call{
747	 value: value }
748	 (data);
749	 return _verifyCallResult(success, returndata, errorMessage);
750	 }
751	 function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
752	 return functionStaticCall(target, data, "Address: low-level static call failed");
753	 }
754	 function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
755	 require(isContract(target), "Address: static call to non-contract");
756	 (bool success, bytes memory returndata) = target.staticcall(data);
757	 return _verifyCallResult(success, returndata, errorMessage);
758	 }
759	 function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
760	 if (success) {
761	 return returndata;
762	 }
763	 else {
764	 if (returndata.length > 0) {
765	 assembly {
766	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
767	 }
768	 else {
769	 revert(errorMessage);
770	 }
771	 }
772	 }
773	 }
774	 pragma solidity >=0.6.0 <0.8.0;
775	 library EnumerableMapUpgradeable {
776	 struct MapEntry {
777	 bytes32 _key;
778	 bytes32 _value;
779	 }
780	 struct Map {
781	 MapEntry[] _entries;
782	 mapping (bytes32 => uint256) _indexes;
783	 }
784	 function _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {
785	 uint256 keyIndex = map._indexes[key];
786	 if (keyIndex == 0) {
787	 map._entries.push(MapEntry({
788	 _key: key, _value: value }
789	 ));
790	 map._indexes[key] = map._entries.length;
791	 return true;
792	 }
793	 else {
794	 map._entries[keyIndex - 1]._value = value;
795	 return false;
796	 }
797	 }
798	 function _remove(Map storage map, bytes32 key) private returns (bool) {
799	 uint256 keyIndex = map._indexes[key];
800	 if (keyIndex != 0) {
801	 uint256 toDeleteIndex = keyIndex - 1;
802	 uint256 lastIndex = map._entries.length - 1;
803	 MapEntry storage lastEntry = map._entries[lastIndex];
804	 map._entries[toDeleteIndex] = lastEntry;
805	 map._indexes[lastEntry._key] = toDeleteIndex + 1;
806	 map._entries.pop();
807	 delete map._indexes[key];
808	 return true;
809	 }
810	 else {
811	 return false;
812	 }
813	 }
814	 function _contains(Map storage map, bytes32 key) private view returns (bool) {
815	 return map._indexes[key] != 0;
816	 }
817	 function _length(Map storage map) private view returns (uint256) {
818	 return map._entries.length;
819	 }
820	 function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {
821	 require(map._entries.length > index, "EnumerableMap: index out of bounds");
822	 MapEntry storage entry = map._entries[index];
823	 return (entry._key, entry._value);
824	 }
825	 function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {
826	 uint256 keyIndex = map._indexes[key];
827	 if (keyIndex == 0) return (false, 0);
828	 return (true, map._entries[keyIndex - 1]._value);
829	 }
830	 function _get(Map storage map, bytes32 key) private view returns (bytes32) {
831	 uint256 keyIndex = map._indexes[key];
832	 require(keyIndex != 0, "EnumerableMap: nonexistent key");
833	 return map._entries[keyIndex - 1]._value;
834	 }
835	 function _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {
836	 uint256 keyIndex = map._indexes[key];
837	 require(keyIndex != 0, errorMessage);
838	 return map._entries[keyIndex - 1]._value;
839	 }
840	 struct UintToAddressMap {
841	 Map _inner;
842	 }
843	 function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {
844	 return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));
845	 }
846	 function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {
847	 return _remove(map._inner, bytes32(key));
848	 }
849	 function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {
850	 return _contains(map._inner, bytes32(key));
851	 }
852	 function length(UintToAddressMap storage map) internal view returns (uint256) {
853	 return _length(map._inner);
854	 }
855	 function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {
856	 (bytes32 key, bytes32 value) = _at(map._inner, index);
857	 return (uint256(key), address(uint160(uint256(value))));
858	 }
859	 function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {
860	 (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));
861	 return (success, address(uint160(uint256(value))));
862	 }
863	 function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {
864	 return address(uint160(uint256(_get(map._inner, bytes32(key)))));
865	 }
866	 function get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {
867	 return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));
868	 }
869	 }
870	 pragma solidity >=0.6.0 <0.8.0;
871	 library EnumerableSetUpgradeable {
872	 struct Set {
873	 bytes32[] _values;
874	 mapping (bytes32 => uint256) _indexes;
875	 }
876	 function _add(Set storage set, bytes32 value) private returns (bool) {
877	 if (!_contains(set, value)) {
878	 set._values.push(value);
879	 set._indexes[value] = set._values.length;
880	 return true;
881	 }
882	 else {
883	 return false;
884	 }
885	 }
886	 function _remove(Set storage set, bytes32 value) private returns (bool) {
887	 uint256 valueIndex = set._indexes[value];
888	 if (valueIndex != 0) {
889	 uint256 toDeleteIndex = valueIndex - 1;
890	 uint256 lastIndex = set._values.length - 1;
891	 bytes32 lastvalue = set._values[lastIndex];
892	 set._values[toDeleteIndex] = lastvalue;
893	 set._indexes[lastvalue] = toDeleteIndex + 1;
894	 set._values.pop();
895	 delete set._indexes[value];
896	 return true;
897	 }
898	 else {
899	 return false;
900	 }
901	 }
902	 function _contains(Set storage set, bytes32 value) private view returns (bool) {
903	 return set._indexes[value] != 0;
904	 }
905	 function _length(Set storage set) private view returns (uint256) {
906	 return set._values.length;
907	 }
908	 function _at(Set storage set, uint256 index) private view returns (bytes32) {
909	 require(set._values.length > index, "EnumerableSet: index out of bounds");
910	 return set._values[index];
911	 }
912	 struct Bytes32Set {
913	 Set _inner;
914	 }
915	 function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {
916	 return _add(set._inner, value);
917	 }
918	 function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {
919	 return _remove(set._inner, value);
920	 }
921	 function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {
922	 return _contains(set._inner, value);
923	 }
924	 function length(Bytes32Set storage set) internal view returns (uint256) {
925	 return _length(set._inner);
926	 }
927	 function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {
928	 return _at(set._inner, index);
929	 }
930	 struct AddressSet {
931	 Set _inner;
932	 }
933	 function add(AddressSet storage set, address value) internal returns (bool) {
934	 return _add(set._inner, bytes32(uint256(uint160(value))));
935	 }
936	 function remove(AddressSet storage set, address value) internal returns (bool) {
937	 return _remove(set._inner, bytes32(uint256(uint160(value))));
938	 }
939	 function contains(AddressSet storage set, address value) internal view returns (bool) {
940	 return _contains(set._inner, bytes32(uint256(uint160(value))));
941	 }
942	 function length(AddressSet storage set) internal view returns (uint256) {
943	 return _length(set._inner);
944	 }
945	 function at(AddressSet storage set, uint256 index) internal view returns (address) {
946	 return address(uint160(uint256(_at(set._inner, index))));
947	 }
948	 struct UintSet {
949	 Set _inner;
950	 }
951	 function add(UintSet storage set, uint256 value) internal returns (bool) {
952	 return _add(set._inner, bytes32(value));
953	 }
954	 function remove(UintSet storage set, uint256 value) internal returns (bool) {
955	 return _remove(set._inner, bytes32(value));
956	 }
957	 function contains(UintSet storage set, uint256 value) internal view returns (bool) {
958	 return _contains(set._inner, bytes32(value));
959	 }
960	 function length(UintSet storage set) internal view returns (uint256) {
961	 return _length(set._inner);
962	 }
963	 function at(UintSet storage set, uint256 index) internal view returns (uint256) {
964	 return uint256(_at(set._inner, index));
965	 }
966	 }
967	 pragma solidity >=0.6.0 <0.8.0;
968	 library StringsUpgradeable {
969	 function toString(uint256 value) internal pure returns (string memory) {
970	 if (value == 0) {
971	 return "0";
972	 }
973	 uint256 temp = value;
974	 uint256 digits;
975	 while (temp != 0) {
976	 digits++;
977	 temp /= 10;
978	 }
979	 bytes memory buffer = new bytes(digits);
980	 uint256 index = digits - 1;
981	 temp = value;
982	 while (temp != 0) {
983	 buffer[index--] = bytes1(uint8(48 + temp % 10));
984	 temp /= 10;
985	 }
986	 return string(buffer);
987	 }
988	 }
989	 pragma solidity >=0.6.0 <0.8.0;
990	 contract BeaconProxy is Proxy {
991	 bytes32 private constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;
992	 constructor(address beacon, bytes memory data) public payable {
993	 assert(_BEACON_SLOT == bytes32(uint256(keccak256("eip1967.proxy.beacon")) - 1));
994	 _setBeacon(beacon, data);
995	 }
996	 function _beacon() internal view virtual returns (address beacon) {
997	 bytes32 slot = _BEACON_SLOT;
998	 assembly {
999	 beacon := sload(slot) }
1000	 }
1001	 function _implementation() internal view virtual override returns (address) {
1002	 return IBeacon(_beacon()).implementation();
1003	 }
1004	 function _setBeacon(address beacon, bytes memory data) internal virtual {
1005	 require( Address.isContract(beacon), "BeaconProxy: beacon is not a contract" );
1006	 require( Address.isContract(IBeacon(beacon).implementation()), "BeaconProxy: beacon implementation is not a contract" );
1007	 bytes32 slot = _BEACON_SLOT;
1008	 assembly {
1009	 sstore(slot, beacon) }
1010	 if (data.length > 0) {
1011	 Address.functionDelegateCall(_implementation(), data, "BeaconProxy: function call failed");
1012	 }
1013	 }
1014	 }
1015	 pragma solidity >=0.6.0 <0.8.0;
1016	 interface IBeacon {
1017	 function implementation() external view returns (address);
1018	 }
1019	 pragma solidity >=0.6.2 <0.8.0;
1020	 library Address {
1021	 function isContract(address account) internal view returns (bool) {
1022	 uint256 size;
1023	 assembly {
1024	 size := extcodesize(account) }
1025	 return size > 0;
1026	 }
1027	 function sendValue(address payable recipient, uint256 amount) internal {
1028	 require(address(this).balance >= amount, "Address: insufficient balance");
1029	 (bool success, ) = recipient.call{
1030	 value: amount }
1031	 ("");
1032	 require(success, "Address: unable to send value, recipient may have reverted");
1033	 }
1034	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
1035	 return functionCall(target, data, "Address: low-level call failed");
1036	 }
1037	 function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
1038	 return functionCallWithValue(target, data, 0, errorMessage);
1039	 }
1040	 function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
1041	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
1042	 }
1043	 function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
1044	 require(address(this).balance >= value, "Address: insufficient balance for call");
1045	 require(isContract(target), "Address: call to non-contract");
1046	 (bool success, bytes memory returndata) = target.call{
1047	 value: value }
1048	 (data);
1049	 return _verifyCallResult(success, returndata, errorMessage);
1050	 }
1051	 function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
1052	 return functionStaticCall(target, data, "Address: low-level static call failed");
1053	 }
1054	 function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
1055	 require(isContract(target), "Address: static call to non-contract");
1056	 (bool success, bytes memory returndata) = target.staticcall(data);
1057	 return _verifyCallResult(success, returndata, errorMessage);
1058	 }
1059	 function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
1060	 return functionDelegateCall(target, data, "Address: low-level delegate call failed");
1061	 }
1062	 function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
1063	 require(isContract(target), "Address: delegate call to non-contract");
1064	 (bool success, bytes memory returndata) = target.delegatecall(data);
1065	 return _verifyCallResult(success, returndata, errorMessage);
1066	 }
1067	 function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
1068	 if (success) {
1069	 return returndata;
1070	 }
1071	 else {
1072	 if (returndata.length > 0) {
1073	 assembly {
1074	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
1075	 }
1076	 else {
1077	 revert(errorMessage);
1078	 }
1079	 }
1080	 }
1081	 }
1082	 pragma solidity >=0.6.2 <0.8.0;
1083	 library LibERC721LazyMint {
1084	 bytes4 constant public ERC721_LAZY_ASSET_CLASS = bytes4(keccak256("ERC721_LAZY"));
1085	 bytes4 constant _INTERFACE_ID_MINT_AND_TRANSFER = 0x8486f69f;
1086	 struct Mint721Data {
1087	 uint tokenId;
1088	 string tokenURI;
1089	 LibPart.Part[] creators;
1090	 LibPart.Part[] royalties;
1091	 bytes[] signatures;
1092	 }
1093	 bytes32 public constant MINT_AND_TRANSFER_TYPEHASH = keccak256("Mint721(uint256 tokenId,string tokenURI,Part[] creators,Part[] royalties)Part(address account,uint96 value)");
1094	 function hash(Mint721Data memory data) internal pure returns (bytes32) {
1095	 bytes32[] memory royaltiesBytes = new bytes32[](data.royalties.length);
1096	 for (uint i = 0; i < data.royalties.length; i++) {
1097	 royaltiesBytes[i] = LibPart.hash(data.royalties[i]);
1098	 }
1099	 bytes32[] memory creatorsBytes = new bytes32[](data.creators.length);
1100	 for (uint i = 0; i < data.creators.length; i++) {
1101	 creatorsBytes[i] = LibPart.hash(data.creators[i]);
1102	 }
1103	 return keccak256(abi.encode( MINT_AND_TRANSFER_TYPEHASH, data.tokenId, keccak256(bytes(data.tokenURI)), keccak256(abi.encodePacked(creatorsBytes)), keccak256(abi.encodePacked(royaltiesBytes)) ));
1104	 }
1105	 }
1106	 pragma solidity >=0.6.2 <0.8.0;
1107	 library LibPart {
1108	 bytes32 public constant TYPE_HASH = keccak256("Part(address account,uint96 value)");
1109	 struct Part {
1110	 address payable account;
1111	 uint96 value;
1112	 }
1113	 function hash(Part memory part) internal pure returns (bytes32) {
1114	 return keccak256(abi.encode(TYPE_HASH, part.account, part.value));
1115	 }
1116	 }
1117	 pragma solidity >=0.6.2 <0.8.0;
1118	 library LibRoyaltiesV2 {
1119	 bytes4 constant _INTERFACE_ID_ROYALTIES = 0xcad96cca;
1120	 }
