row number 
1	  pragma experimental ABIEncoderV2;
2	 pragma solidity >=0.4.24 <0.8.0;
3	 abstract contract Initializable {
4	 bool private _initialized;
5	 bool private _initializing;
6	 modifier initializer() {
7	 require(_initializing || _isConstructor() || !_initialized, "Initializable: contract is already initialized");
8	 bool isTopLevelCall = !_initializing;
9	 if (isTopLevelCall) {
10	 _initializing = true;
11	 _initialized = true;
12	 }
13	 _;
14	 if (isTopLevelCall) {
15	 _initializing = false;
16	 }
17	 }
18	 function _isConstructor() private view returns (bool) {
19	 return !AddressUpgradeable.isContract(address(this));
20	 }
21	 }
22	 pragma solidity >=0.6.0 <0.8.0;
23	 abstract contract ContextUpgradeable is Initializable {
24	 function __Context_init() internal initializer {
25	 __Context_init_unchained();
26	 }
27	 function __Context_init_unchained() internal initializer {
28	 }
29	 function _msgSender() internal view virtual returns (address payable) {
30	 return msg.sender;
31	 }
32	 function _msgData() internal view virtual returns (bytes memory) {
33	 this;
34	 return msg.data;
35	 }
36	 uint256[50] private __gap;
37	 }
38	 pragma solidity >=0.6.0 <0.8.0;
39	 abstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable {
40	 function __AccessControl_init() internal initializer {
41	 __Context_init_unchained();
42	 __AccessControl_init_unchained();
43	 }
44	 function __AccessControl_init_unchained() internal initializer {
45	 }
46	 using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;
47	 using AddressUpgradeable for address;
48	 struct RoleData {
49	 EnumerableSetUpgradeable.AddressSet members;
50	 bytes32 adminRole;
51	 }
52	 mapping (bytes32 => RoleData) private _roles;
53	 bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;
54	 event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
55	 event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
56	 event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
57	 function hasRole(bytes32 role, address account) public view returns (bool) {
58	 return _roles[role].members.contains(account);
59	 }
60	 function getRoleMemberCount(bytes32 role) public view returns (uint256) {
61	 return _roles[role].members.length();
62	 }
63	 function getRoleMember(bytes32 role, uint256 index) public view returns (address) {
64	 return _roles[role].members.at(index);
65	 }
66	 function getRoleAdmin(bytes32 role) public view returns (bytes32) {
67	 return _roles[role].adminRole;
68	 }
69	 function grantRole(bytes32 role, address account) public virtual {
70	 require(hasRole(_roles[role].adminRole, _msgSender()), "AccessControl: sender must be an admin to grant");
71	 _grantRole(role, account);
72	 }
73	 function revokeRole(bytes32 role, address account) public virtual {
74	 require(hasRole(_roles[role].adminRole, _msgSender()), "AccessControl: sender must be an admin to revoke");
75	 _revokeRole(role, account);
76	 }
77	 function renounceRole(bytes32 role, address account) public virtual {
78	 require(account == _msgSender(), "AccessControl: can only renounce roles for self");
79	 _revokeRole(role, account);
80	 }
81	 function _setupRole(bytes32 role, address account) internal virtual {
82	 _grantRole(role, account);
83	 }
84	 function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
85	 emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);
86	 _roles[role].adminRole = adminRole;
87	 }
88	 function _grantRole(bytes32 role, address account) private {
89	 if (_roles[role].members.add(account)) {
90	 emit RoleGranted(role, account, _msgSender());
91	 }
92	 }
93	 function _revokeRole(bytes32 role, address account) private {
94	 if (_roles[role].members.remove(account)) {
95	 emit RoleRevoked(role, account, _msgSender());
96	 }
97	 }
98	 uint256[49] private __gap;
99	 }
100	 pragma solidity 0.7.6;
101	 contract RoleCheckable is AccessControlUpgradeable {
102	 bytes32 internal constant ADMIN_ROLE = 0x1effbbff9c66c5e59634f24fe842750c60d18891155c32dd155fc2d661a4c86d;
103	 bytes32 internal constant CONTROLLER_ROLE = 0x7b765e0e932d348852a6f810bfa1ab891e259123f02db8cdcde614c570223357;
104	 bytes32 internal constant START_FUTURE = 0xeb5092aab714e6356486bc97f25dd7a5c1dc5c7436a9d30e8d4a527fba24de1c;
105	 bytes32 internal constant FUTURE_ROLE = 0x52d2dbc4d362e84c42bdfb9941433968ba41423559d7559b32db1183b22b148f;
106	 bytes32 internal constant HARVEST_REWARDS = 0xf2683e58e5a2a04c1ed32509bfdbf1e9ebc725c63f4c95425d2afd482bfdb0f8;
107	 modifier onlyAdmin() {
108	 require(hasRole(ADMIN_ROLE, msg.sender), "RoleCheckable: Caller should be ADMIN");
109	 _;
110	 }
111	 modifier onlyStartFuture() {
112	 require(hasRole(START_FUTURE, msg.sender), "RoleCheckable: Caller should have START FUTURE Role");
113	 _;
114	 }
115	 modifier onlyHarvestReward() {
116	 require(hasRole(HARVEST_REWARDS, msg.sender), "RoleCheckable: Caller should have HARVEST REWARDS Role");
117	 _;
118	 }
119	 modifier onlyController() {
120	 require(hasRole(CONTROLLER_ROLE, msg.sender), "RoleCheckable: Caller should be CONTROLLER");
121	 _;
122	 }
123	 }
124	 pragma solidity >=0.6.0 <0.8.0;
125	 abstract contract ReentrancyGuardUpgradeable is Initializable {
126	 uint256 private constant _NOT_ENTERED = 1;
127	 uint256 private constant _ENTERED = 2;
128	 uint256 private _status;
129	 function __ReentrancyGuard_init() internal initializer {
130	 __ReentrancyGuard_init_unchained();
131	 }
132	 function __ReentrancyGuard_init_unchained() internal initializer {
133	 _status = _NOT_ENTERED;
134	 }
135	 modifier nonReentrant() {
136	 require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
137	 _status = _ENTERED;
138	 _;
139	 _status = _NOT_ENTERED;
140	 }
141	 uint256[49] private __gap;
142	 }
143	 pragma solidity 0.7.6;
144	 contract RegistryStorage is RoleCheckable {
145	 IRegistry internal registry;
146	 event RegistryChanged(IRegistry _registry);
147	 function setRegistry(IRegistry _registry) external onlyAdmin {
148	 registry = _registry;
149	 emit RegistryChanged(_registry);
150	 }
151	 }
152	 pragma solidity 0.7.6;
153	 abstract contract FutureVault is Initializable, RegistryStorage, ReentrancyGuardUpgradeable {
154	 using SafeMathUpgradeable for uint256;
155	 using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;
156	 using SafeERC20Upgradeable for IERC20;
157	 mapping(uint256 => uint256) internal collectedFYTSByPeriod;
158	 mapping(uint256 => uint256) internal premiumsTotal;
159	 mapping(address => uint256) internal lastPeriodClaimed;
160	 mapping(address => uint256) internal premiumToBeRedeemed;
161	 mapping(address => uint256) internal FYTsOfUserPremium;
162	 mapping(address => uint256) internal claimableFYTByUser;
163	 mapping(uint256 => uint256) internal yieldOfPeriod;
164	 uint256 internal totalUnderlyingDeposited;
165	 bool private terminated;
166	 uint256 internal performanceFeeFactor;
167	 IFutureYieldToken[] internal fyts;
168	 struct Delegation {
169	 address receiver;
170	 uint256 delegatedAmount;
171	 }
172	 mapping(address => Delegation[]) internal delegationsByDelegator;
173	 mapping(address => uint256) internal totalDelegationsReceived;
174	 IFutureWallet internal futureWallet;
175	 IERC20 internal ibt;
176	 IPT internal pt;
177	 IController internal controller;
178	 uint256 public PERIOD_DURATION;
179	 string public PLATFORM_NAME;
180	 uint256 internal IBT_UNIT;
181	 uint256 internal IBT_UNITS_MULTIPLIED_VALUE;
182	 uint256 constant UNIT = 10**18;
183	 event NewPeriodStarted(uint256 _newPeriodIndex);
184	 event FutureWalletSet(IFutureWallet _futureWallet);
185	 event FundsDeposited(address _user, uint256 _amount);
186	 event FundsWithdrawn(address _user, uint256 _amount);
187	 event PTSet(IPT _pt);
188	 event LiquidityTransfersPaused();
189	 event LiquidityTransfersResumed();
190	 event DelegationCreated(address _delegator, address _receiver, uint256 _amount);
191	 event DelegationRemoved(address _delegator, address _receiver, uint256 _amount);
192	 modifier nextPeriodAvailable() {
193	 uint256 controllerDelay = controller.STARTING_DELAY();
194	 require( controller.getNextPeriodStart(PERIOD_DURATION) < block.timestamp.add(controllerDelay), "FutureVault: ERR_PERIOD_RANGE" );
195	 _;
196	 }
197	 modifier periodsActive() {
198	 require(!terminated, "PERIOD_TERMINATED");
199	 _;
200	 }
201	 modifier withdrawalsEnabled() {
202	 require(!controller.isWithdrawalsPaused(address(this)), "FutureVault: WITHDRAWALS_DISABLED");
203	 _;
204	 }
205	 modifier depositsEnabled() {
206	 require( !controller.isDepositsPaused(address(this)) && getCurrentPeriodIndex() != 0, "FutureVault: DEPOSITS_DISABLED" );
207	 _;
208	 }
209	 function initialize( IController _controller, IERC20 _ibt, uint256 _periodDuration, string memory _platformName, address _admin ) public virtual initializer {
210	 controller = _controller;
211	 ibt = _ibt;
212	 IBT_UNIT = 10**ibt.decimals();
213	 IBT_UNITS_MULTIPLIED_VALUE = UNIT * IBT_UNIT;
214	 PERIOD_DURATION = _periodDuration;
215	 PLATFORM_NAME = _platformName;
216	 _setupRole(DEFAULT_ADMIN_ROLE, _admin);
217	 _setupRole(ADMIN_ROLE, _admin);
218	 _setupRole(CONTROLLER_ROLE, address(_controller));
219	 fyts.push();
220	 registry = IRegistry(controller.getRegistryAddress());
221	 pt = IPT( ITokensFactory(IRegistry(controller.getRegistryAddress()).getTokensFactoryAddress()).deployPT( ibt.symbol(), ibt.decimals(), PLATFORM_NAME, PERIOD_DURATION ) );
222	 emit PTSet(pt);
223	 }
224	 function startNewPeriod() public virtual;
225	 function _switchPeriod() internal periodsActive {
226	 uint256 nextPeriodID = getNextPeriodIndex();
227	 uint256 yield = getUnrealisedYieldPerPT().mul(totalUnderlyingDeposited) / IBT_UNIT;
228	 uint256 reinvestedYield;
229	 if (yield > 0) {
230	 uint256 currentPeriodIndex = getCurrentPeriodIndex();
231	 uint256 premiums = convertUnderlyingtoIBT(premiumsTotal[currentPeriodIndex]);
232	 uint256 performanceFee = (yield.mul(performanceFeeFactor) / UNIT).sub(premiums);
233	 uint256 remainingYield = yield.sub(performanceFee);
234	 yieldOfPeriod[currentPeriodIndex] = convertIBTToUnderlying( remainingYield.mul(IBT_UNIT).div(totalUnderlyingDeposited) );
235	 uint256 collectedYield = remainingYield.mul(collectedFYTSByPeriod[currentPeriodIndex]).div( totalUnderlyingDeposited );
236	 reinvestedYield = remainingYield.sub(collectedYield);
237	 futureWallet.registerExpiredFuture(collectedYield);
238	 if (performanceFee > 0) ibt.safeTransfer(registry.getTreasuryAddress(), performanceFee);
239	 if (remainingYield > 0) ibt.safeTransfer(address(futureWallet), collectedYield);
240	 }
241	 else {
242	 futureWallet.registerExpiredFuture(0);
243	 }
244	 totalUnderlyingDeposited = totalUnderlyingDeposited.add(convertIBTToUnderlying(reinvestedYield));
245	 if (!controller.isFutureSetToBeTerminated(address(this))) {
246	 _deployNewFutureYieldToken(nextPeriodID);
247	 emit NewPeriodStarted(nextPeriodID);
248	 }
249	 else {
250	 terminated = true;
251	 }
252	 uint256 nextPerformanceFeeFactor = controller.getNextPerformanceFeeFactor(address(this));
253	 if (nextPerformanceFeeFactor != performanceFeeFactor) performanceFeeFactor = nextPerformanceFeeFactor;
254	 }
255	 function updateUserState(address _user) public {
256	 uint256 currentPeriodIndex = getCurrentPeriodIndex();
257	 uint256 lastPeriodClaimedOfUser = lastPeriodClaimed[_user];
258	 if (lastPeriodClaimedOfUser < currentPeriodIndex && lastPeriodClaimedOfUser != 0) {
259	 pt.mint(_user, _preparePTClaim(_user));
260	 }
261	 if (lastPeriodClaimedOfUser != currentPeriodIndex) lastPeriodClaimed[_user] = currentPeriodIndex;
262	 }
263	 function _preparePTClaim(address _user) internal virtual returns (uint256 claimablePT) {
264	 uint256 currentPeriodIndex = getCurrentPeriodIndex();
265	 if (lastPeriodClaimed[_user] < currentPeriodIndex) {
266	 claimablePT = getClaimablePT(_user);
267	 delete premiumToBeRedeemed[_user];
268	 delete FYTsOfUserPremium[_user];
269	 claimableFYTByUser[_user] = pt.balanceOf(_user).add(totalDelegationsReceived[_user]).sub( getTotalDelegated(_user) );
270	 lastPeriodClaimed[_user] = currentPeriodIndex;
271	 }
272	 }
273	 function deposit(address _user, uint256 _amount) external virtual periodsActive depositsEnabled onlyController {
274	 require((_amount > 0) && (_amount <= ibt.balanceOf(_user)), "FutureVault: ERR_AMOUNT");
275	 _deposit(_user, _amount);
276	 emit FundsDeposited(_user, _amount);
277	 }
278	 function _deposit(address _user, uint256 _amount) internal {
279	 uint256 underlyingDeposited = getPTPerAmountDeposited(_amount);
280	 uint256 ptToMint = _preparePTClaim(_user).add(underlyingDeposited);
281	 uint256 currentPeriodIndex = getCurrentPeriodIndex();
282	 uint256 redeemable = getPremiumPerUnderlyingDeposited(underlyingDeposited);
283	 premiumToBeRedeemed[_user] = premiumToBeRedeemed[_user].add(redeemable);
284	 FYTsOfUserPremium[_user] = FYTsOfUserPremium[_user].add(ptToMint);
285	 premiumsTotal[currentPeriodIndex] = premiumsTotal[currentPeriodIndex].add(redeemable);
286	 totalUnderlyingDeposited = totalUnderlyingDeposited.add(underlyingDeposited);
287	 claimableFYTByUser[_user] = claimableFYTByUser[_user].add(ptToMint);
288	 pt.mint(_user, ptToMint);
289	 }
290	 function withdraw(address _user, uint256 _amount) external virtual nonReentrant withdrawalsEnabled onlyController {
291	 require((_amount > 0) && (_amount <= pt.balanceOf(_user)), "FutureVault: ERR_AMOUNT");
292	 require(_amount <= fyts[getCurrentPeriodIndex()].balanceOf(_user), "FutureVault: ERR_FYT_AMOUNT");
293	 _withdraw(_user, _amount);
294	 uint256 FYTsToBurn;
295	 uint256 currentPeriodIndex = getCurrentPeriodIndex();
296	 uint256 FYTSMinted = fyts[currentPeriodIndex].recordedBalanceOf(_user);
297	 if (_amount > FYTSMinted) {
298	 FYTsToBurn = FYTSMinted;
299	 uint256 ClaimableFYTsToBurn = _amount - FYTsToBurn;
300	 claimableFYTByUser[_user] = claimableFYTByUser[_user].sub(ClaimableFYTsToBurn, "FutureVault: ERR_AMOUNT");
301	 collectedFYTSByPeriod[currentPeriodIndex] = collectedFYTSByPeriod[currentPeriodIndex].add(ClaimableFYTsToBurn);
302	 }
303	 else {
304	 FYTsToBurn = _amount;
305	 }
306	 if (FYTsToBurn > 0) fyts[currentPeriodIndex].burnFrom(_user, FYTsToBurn);
307	 emit FundsWithdrawn(_user, _amount);
308	 }
309	 function _withdraw(address _user, uint256 _amount) internal virtual {
310	 updateUserState(_user);
311	 uint256 fundsToBeUnlocked = _amount.mul(getUnlockableFunds(_user)).div(pt.balanceOf(_user));
312	 uint256 yieldToBeUnlocked = _amount.mul(getUnrealisedYieldPerPT()) / IBT_UNIT;
313	 uint256 premiumToBeUnlocked = _prepareUserEarlyPremiumUnlock(_user, _amount);
314	 require( pt.balanceOf(_user) >= _amount.add(getTotalDelegated(_user)), "FutureVault: transfer amount exceeds transferrable balance" );
315	 uint256 treasuryFee = (yieldToBeUnlocked.mul(performanceFeeFactor) / UNIT).sub(premiumToBeUnlocked);
316	 uint256 yieldToBeRedeemed = yieldToBeUnlocked - treasuryFee;
317	 ibt.safeTransfer(_user, fundsToBeUnlocked.add(yieldToBeRedeemed).add(premiumToBeUnlocked));
318	 if (treasuryFee > 0) {
319	 ibt.safeTransfer(registry.getTreasuryAddress(), treasuryFee);
320	 }
321	 totalUnderlyingDeposited = totalUnderlyingDeposited.sub(_amount);
322	 pt.burnFrom(_user, _amount);
323	 }
324	 function _prepareUserEarlyPremiumUnlock(address _user, uint256 _ptShares) internal returns (uint256 premiumToBeUnlocked) {
325	 uint256 unlockablePremium = premiumToBeRedeemed[_user];
326	 uint256 userFYTsInPremium = FYTsOfUserPremium[_user];
327	 if (unlockablePremium > 0) {
328	 if (_ptShares > userFYTsInPremium) {
329	 premiumToBeUnlocked = convertUnderlyingtoIBT(unlockablePremium);
330	 delete premiumToBeRedeemed[_user];
331	 delete FYTsOfUserPremium[_user];
332	 }
333	 else {
334	 uint256 premiumForAmount = unlockablePremium.mul(_ptShares).div(userFYTsInPremium);
335	 premiumToBeUnlocked = convertUnderlyingtoIBT(premiumForAmount);
336	 premiumToBeRedeemed[_user] = unlockablePremium - premiumForAmount;
337	 FYTsOfUserPremium[_user] = userFYTsInPremium - _ptShares;
338	 }
339	 premiumsTotal[getCurrentPeriodIndex()] = premiumsTotal[getCurrentPeriodIndex()].sub(premiumToBeUnlocked);
340	 }
341	 }
342	 function getUserEarlyUnlockablePremium(address _user) public view returns (uint256 premiumLocked, uint256 amountRequired) {
343	 premiumLocked = premiumToBeRedeemed[_user];
344	 amountRequired = FYTsOfUserPremium[_user];
345	 }
346	 function createFYTDelegationTo( address _delegator, address _receiver, uint256 _amount ) public nonReentrant periodsActive {
347	 require(hasRole(CONTROLLER_ROLE, msg.sender), "ERR_CALLER");
348	 updateUserState(_delegator);
349	 updateUserState(_receiver);
350	 uint256 totalDelegated = getTotalDelegated(_delegator);
351	 uint256 numberOfDelegations = delegationsByDelegator[_delegator].length;
352	 require(_amount > 0 && _amount <= pt.balanceOf(_delegator).sub(totalDelegated), "FutureVault: ERR_AMOUNT");
353	 bool delegated;
354	 for (uint256 i = 0; i < numberOfDelegations; i++) {
355	 if (delegationsByDelegator[_delegator][i].receiver == _receiver) {
356	 delegationsByDelegator[_delegator][i].delegatedAmount = delegationsByDelegator[_delegator][i] .delegatedAmount .add(_amount);
357	 delegated = true;
358	 break;
359	 }
360	 }
361	 if (!delegated) {
362	 delegationsByDelegator[_delegator].push(Delegation({
363	 receiver: _receiver, delegatedAmount: _amount }
364	 ));
365	 }
366	 totalDelegationsReceived[_receiver] = totalDelegationsReceived[_receiver].add(_amount);
367	 emit DelegationCreated(_delegator, _receiver, _amount);
368	 }
369	 function withdrawFYTDelegationFrom( address _delegator, address _receiver, uint256 _amount ) public {
370	 require(hasRole(CONTROLLER_ROLE, msg.sender), "ERR_CALLER");
371	 updateUserState(_delegator);
372	 updateUserState(_receiver);
373	 uint256 numberOfDelegations = delegationsByDelegator[_delegator].length;
374	 bool removed;
375	 for (uint256 i = 0; i < numberOfDelegations; i++) {
376	 if (delegationsByDelegator[_delegator][i].receiver == _receiver) {
377	 delegationsByDelegator[_delegator][i].delegatedAmount = delegationsByDelegator[_delegator][i] .delegatedAmount .sub(_amount, "ERR_AMOUNT");
378	 removed = true;
379	 break;
380	 }
381	 }
382	 require(_amount > 0 && removed, "FutureVault: ERR_AMOUNT");
383	 totalDelegationsReceived[_receiver] = totalDelegationsReceived[_receiver].sub(_amount);
384	 emit DelegationRemoved(_delegator, _receiver, _amount);
385	 }
386	 function getTotalDelegated(address _delegator) public view returns (uint256 totalDelegated) {
387	 uint256 numberOfDelegations = delegationsByDelegator[_delegator].length;
388	 for (uint256 i = 0; i < numberOfDelegations; i++) {
389	 totalDelegated = totalDelegated.add(delegationsByDelegator[_delegator][i].delegatedAmount);
390	 }
391	 }
392	 function claimFYT(address _user, uint256 _amount) external virtual nonReentrant {
393	 require(msg.sender == address(fyts[getCurrentPeriodIndex()]), "FutureVault: ERR_CALLER");
394	 updateUserState(_user);
395	 _claimFYT(_user, _amount);
396	 }
397	 function _claimFYT(address _user, uint256 _amount) internal virtual {
398	 uint256 currentPeriodIndex = getCurrentPeriodIndex();
399	 claimableFYTByUser[_user] = claimableFYTByUser[_user].sub(_amount, "ERR_CLAIMED_FYT_AMOUNT");
400	 fyts[currentPeriodIndex].mint(_user, _amount);
401	 collectedFYTSByPeriod[currentPeriodIndex] = collectedFYTSByPeriod[currentPeriodIndex].add(_amount);
402	 }
403	 function exitTerminatedFuture(address _user) external nonReentrant onlyController {
404	 require(terminated, "FutureVault: ERR_NOT_TERMINATED");
405	 uint256 amount = pt.balanceOf(_user);
406	 require(amount > 0, "FutureVault: ERR_PT_BALANCE");
407	 _withdraw(_user, amount);
408	 emit FundsWithdrawn(_user, amount);
409	 }
410	 function convertIBTToUnderlying(uint256 _amount) public view virtual returns (uint256);
411	 function convertUnderlyingtoIBT(uint256 _amount) public view virtual returns (uint256);
412	 function _deployNewFutureYieldToken(uint256 newPeriodIndex) internal {
413	 IFutureYieldToken newToken = IFutureYieldToken( ITokensFactory(registry.getTokensFactoryAddress()).deployNextFutureYieldToken(newPeriodIndex) );
414	 fyts.push(newToken);
415	 }
416	 function getClaimablePT(address _user) public view virtual returns (uint256) {
417	 uint256 currentPeriodIndex = getCurrentPeriodIndex();
418	 if (lastPeriodClaimed[_user] < currentPeriodIndex) {
419	 uint256 recordedBalance = pt.recordedBalanceOf(_user);
420	 uint256 mintablePT = (recordedBalance).add(premiumToBeRedeemed[_user]);
421	 mintablePT = mintablePT.add(totalDelegationsReceived[_user]).sub(getTotalDelegated(_user));
422	 uint256 userStackingGrowthFactor = yieldOfPeriod[lastPeriodClaimed[_user]];
423	 if (userStackingGrowthFactor > 0) {
424	 mintablePT = mintablePT.add(claimableFYTByUser[_user].mul(userStackingGrowthFactor) / IBT_UNIT);
425	 }
426	 for (uint256 i = lastPeriodClaimed[_user] + 1; i < currentPeriodIndex; i++) {
427	 mintablePT = mintablePT.add(yieldOfPeriod[i].mul(mintablePT) / IBT_UNIT);
428	 }
429	 return mintablePT.add(getTotalDelegated(_user)).sub(recordedBalance).sub(totalDelegationsReceived[_user]);
430	 }
431	 else {
432	 return 0;
433	 }
434	 }
435	 function getUnlockableFunds(address _user) public view virtual returns (uint256) {
436	 return pt.balanceOf(_user);
437	 }
438	 function getClaimableFYTForPeriod(address _user, uint256 _periodIndex) external view virtual returns (uint256) {
439	 uint256 currentPeriodIndex = getCurrentPeriodIndex();
440	 if (_periodIndex != currentPeriodIndex || _user == address(this)) {
441	 return 0;
442	 }
443	 else if (_periodIndex == currentPeriodIndex && lastPeriodClaimed[_user] == currentPeriodIndex) {
444	 return claimableFYTByUser[_user];
445	 }
446	 else {
447	 return pt.balanceOf(_user).add(totalDelegationsReceived[_user]).sub(getTotalDelegated(_user));
448	 }
449	 }
450	 function getUnrealisedYieldPerPT() public view virtual returns (uint256);
451	 function getPTPerAmountDeposited(uint256 _amount) public view virtual returns (uint256);
452	 function getPremiumPerUnderlyingDeposited(uint256 _amount) public view virtual returns (uint256) {
453	 if (totalUnderlyingDeposited == 0) {
454	 return 0;
455	 }
456	 uint256 yieldPerFYT = getUnrealisedYieldPerPT();
457	 uint256 premiumToRefundInIBT = _amount.mul(yieldPerFYT).mul(performanceFeeFactor) / IBT_UNITS_MULTIPLIED_VALUE;
458	 return convertIBTToUnderlying(premiumToRefundInIBT);
459	 }
460	 function getUnlockablePremium(address _user) public view returns (uint256) {
461	 if (lastPeriodClaimed[_user] != getCurrentPeriodIndex()) {
462	 return 0;
463	 }
464	 else {
465	 return premiumToBeRedeemed[_user];
466	 }
467	 }
468	 function getYieldOfPeriod(uint256 _periodID) external view returns (uint256) {
469	 require(getCurrentPeriodIndex() > _periodID, "FutureVault: Invalid period ID");
470	 return yieldOfPeriod[_periodID];
471	 }
472	 function getNextPeriodIndex() public view virtual returns (uint256) {
473	 return fyts.length;
474	 }
475	 function getCurrentPeriodIndex() public view virtual returns (uint256) {
476	 return fyts.length - 1;
477	 }
478	 function getTotalUnderlyingDeposited() external view returns (uint256) {
479	 return totalUnderlyingDeposited;
480	 }
481	 function getControllerAddress() public view returns (address) {
482	 return address(controller);
483	 }
484	 function getFutureWalletAddress() public view returns (address) {
485	 return address(futureWallet);
486	 }
487	 function getIBTAddress() public view returns (address) {
488	 return address(ibt);
489	 }
490	 function getPTAddress() public view returns (address) {
491	 return address(pt);
492	 }
493	 function getFYTofPeriod(uint256 _periodIndex) public view returns (address) {
494	 return address(fyts[_periodIndex]);
495	 }
496	 function isTerminated() public view returns (bool) {
497	 return terminated;
498	 }
499	 function getPerformanceFeeFactor() external view returns (uint256) {
500	 return performanceFeeFactor;
501	 }
502	 function setFutureWallet(IFutureWallet _futureWallet) external onlyAdmin {
503	 futureWallet = _futureWallet;
504	 emit FutureWalletSet(_futureWallet);
505	 }
506	 function pauseLiquidityTransfers() public {
507	 require(hasRole(ADMIN_ROLE, msg.sender), "ERR_CALLER");
508	 pt.pause();
509	 emit LiquidityTransfersPaused();
510	 }
511	 function resumeLiquidityTransfers() public {
512	 require(hasRole(ADMIN_ROLE, msg.sender), "ERR_CALLER");
513	 pt.unpause();
514	 emit LiquidityTransfersResumed();
515	 }
516	 }
517	 pragma solidity 0.7.6;
518	 abstract contract RewardsFutureVault is FutureVault {
519	 using SafeERC20Upgradeable for IERC20;
520	 using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;
521	 EnumerableSetUpgradeable.AddressSet internal rewardTokens;
522	 address internal rewardsRecipient;
523	 event RewardsHarvested();
524	 event RewardTokenAdded(address _token);
525	 event RewardTokenRedeemed(IERC20 _token, uint256 _amount);
526	 event RewardsRecipientUpdated(address _recipient);
527	 function harvestRewards() public virtual {
528	 require(hasRole(CONTROLLER_ROLE, msg.sender), "ERR_CALLER");
529	 _harvestRewards();
530	 emit RewardsHarvested();
531	 }
532	 function _harvestRewards() internal virtual {
533	 }
534	 function redeemAllVaultRewards() external virtual onlyController {
535	 require(rewardsRecipient != address(0), "RewardsFutureVault: ERR_RECIPIENT");
536	 uint256 numberOfRewardTokens = rewardTokens.length();
537	 for (uint256 i; i < numberOfRewardTokens; i++) {
538	 IERC20 rewardToken = IERC20(rewardTokens.at(i));
539	 uint256 rewardTokenBalance = rewardToken.balanceOf(address(this));
540	 rewardToken.safeTransfer(rewardsRecipient, rewardTokenBalance);
541	 emit RewardTokenRedeemed(rewardToken, rewardTokenBalance);
542	 }
543	 }
544	 function redeemVaultRewards(IERC20 _rewardToken) external virtual onlyController {
545	 require(rewardsRecipient != address(0), "RewardsFutureVault: ERR_RECIPIENT");
546	 require(rewardTokens.contains(address(_rewardToken)), "RewardsFutureVault: ERR_TOKEN_ADDRESS");
547	 uint256 rewardTokenBalance = _rewardToken.balanceOf(address(this));
548	 _rewardToken.safeTransfer(rewardsRecipient, rewardTokenBalance);
549	 emit RewardTokenRedeemed(_rewardToken, rewardTokenBalance);
550	 }
551	 function addRewardsToken(address _token) external onlyAdmin {
552	 require(_token != address(ibt), "RewardsFutureVault: ERR_TOKEN_ADDRESS");
553	 rewardTokens.add(_token);
554	 emit RewardTokenAdded(_token);
555	 }
556	 function setRewardRecipient(address _recipient) external {
557	 require(hasRole(ADMIN_ROLE, msg.sender), "ERR_CALLER");
558	 rewardsRecipient = _recipient;
559	 emit RewardsRecipientUpdated(_recipient);
560	 }
561	 function isRewardToken(IERC20 _token) external view returns (bool) {
562	 return rewardTokens.contains(address(_token));
563	 }
564	 function getRewardTokenAt(uint256 _index) external view returns (address) {
565	 return rewardTokens.at(_index);
566	 }
567	 function getRewardTokensCount() external view returns (uint256) {
568	 return rewardTokens.length();
569	 }
570	 function getRewardsRecipient() external view returns (address) {
571	 return rewardsRecipient;
572	 }
573	 }
574	 pragma solidity 0.7.6;
575	 abstract contract RateFutureVault is RewardsFutureVault {
576	 using SafeMathUpgradeable for uint256;
577	 mapping(uint256 => uint256) internal IBTRates;
578	 function initialize( IController _controller, IERC20 _ibt, uint256 _periodDuration, string memory _platformName, address _admin ) public virtual override initializer {
579	 super.initialize(_controller, _ibt, _periodDuration, _platformName, _admin);
580	 IBTRates[getCurrentPeriodIndex()] = getIBTRate();
581	 }
582	 function startNewPeriod() public virtual override nextPeriodAvailable periodsActive nonReentrant {
583	 require(hasRole(CONTROLLER_ROLE, msg.sender), "ERR_CALLER");
584	 _switchPeriod();
585	 IBTRates[getCurrentPeriodIndex()] = getIBTRate();
586	 }
587	 function convertIBTToUnderlying(uint256 _amount) public view virtual override returns (uint256) {
588	 return _convertIBTToUnderlyingAtRate(_amount, getIBTRate());
589	 }
590	 function _convertIBTToUnderlyingAtRate(uint256 _amount, uint256 _rate) internal view virtual returns (uint256) {
591	 return (_amount.mul(_rate) / IBT_UNIT);
592	 }
593	 function convertUnderlyingtoIBT(uint256 _amount) public view virtual override returns (uint256) {
594	 return _convertUnderlyingtoIBTAtRate(_amount, getIBTRate());
595	 }
596	 function _convertUnderlyingtoIBTAtRate(uint256 _amount, uint256 _rate) internal view virtual returns (uint256) {
597	 return _amount.mul(IBT_UNIT).div(_rate);
598	 }
599	 function getUnlockableFunds(address _user) public view virtual override returns (uint256) {
600	 return convertUnderlyingtoIBT(super.getUnlockableFunds(_user));
601	 }
602	 function getUnrealisedYieldPerPT() public view virtual override returns (uint256) {
603	 uint256 currRate = getIBTRate();
604	 uint256 currPeriodStartRate = IBTRates[getCurrentPeriodIndex()];
605	 if (currRate == currPeriodStartRate) return 0;
606	 uint256 amountOfIBTsAtStart = _convertUnderlyingtoIBTAtRate(IBT_UNIT, currPeriodStartRate);
607	 uint256 amountOfIBTsNow = _convertUnderlyingtoIBTAtRate(IBT_UNIT, currRate);
608	 return amountOfIBTsAtStart.sub(amountOfIBTsNow);
609	 }
610	 function getIBTRate() public view virtual returns (uint256);
611	 function getPTPerAmountDeposited(uint256 _amount) public view virtual override returns (uint256) {
612	 return _convertIBTToUnderlyingAtRate(_amount, IBTRates[getCurrentPeriodIndex()]);
613	 }
614	 }
615	 pragma solidity >=0.6.0 <0.8.0;
616	 interface IERC20Upgradeable {
617	 function totalSupply() external view returns (uint256);
618	 function balanceOf(address account) external view returns (uint256);
619	 function transfer(address recipient, uint256 amount) external returns (bool);
620	 function allowance(address owner, address spender) external view returns (uint256);
621	 function approve(address spender, uint256 amount) external returns (bool);
622	 function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
623	 event Transfer(address indexed from, address indexed to, uint256 value);
624	 event Approval(address indexed owner, address indexed spender, uint256 value);
625	 }
626	 pragma solidity 0.7.6;
627	 abstract contract HybridFutureVault is RateFutureVault {
628	 using SafeMathUpgradeable for uint256;
629	 mapping(uint256 => uint256) internal scaledTotals;
630	 function deposit(address _user, uint256 _amount) external virtual override periodsActive depositsEnabled onlyController {
631	 require((_amount > 0) && (_amount <= ibt.balanceOf(_user)), "HybridFutureVault: ERR_AMOUNT");
632	 _deposit(_user, _amount);
633	 emit FundsDeposited(_user, _amount);
634	 }
635	 function _withdraw(address _user, uint256 _amount) internal virtual override {
636	 super._withdraw(_user, _amount);
637	 }
638	 function startNewPeriod() public virtual override nextPeriodAvailable periodsActive nonReentrant {
639	 require(hasRole(CONTROLLER_ROLE, msg.sender), "ERR_CALLER");
640	 _switchPeriod();
641	 IBTRates[getCurrentPeriodIndex()] = getIBTRate();
642	 }
643	 function getUnrealisedYieldPerPT() public view override returns (uint256) {
644	 uint256 totalUnderlyingAtStart = totalUnderlyingDeposited;
645	 if (totalUnderlyingAtStart == 0) return 0;
646	 uint256 totalUnderlyingNow = convertIBTToUnderlying(ibt.balanceOf(address(this)));
647	 uint256 yieldForAllPT = convertUnderlyingtoIBT(totalUnderlyingNow.sub(totalUnderlyingAtStart));
648	 return yieldForAllPT.mul(IBT_UNIT).div(totalUnderlyingAtStart);
649	 }
650	 function getPTPerAmountDeposited(uint256 _amount) public view override returns (uint256) {
651	 uint256 underlyingAmountOfDeposit = convertIBTToUnderlying(_amount);
652	 uint256 underlyingYieldPerPT = convertIBTToUnderlying(getUnrealisedYieldPerPT());
653	 return underlyingAmountOfDeposit.mul(IBT_UNIT).div(IBT_UNIT.add(underlyingYieldPerPT));
654	 }
655	 }
656	 pragma solidity 0.7.6;
657	 interface IERC20 is IERC20Upgradeable {
658	 function name() external returns (string memory);
659	 function symbol() external returns (string memory);
660	 function decimals() external view returns (uint8);
661	 function increaseAllowance(address spender, uint256 addedValue) external returns (bool);
662	 function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);
663	 }
664	 pragma solidity 0.7.6;
665	 contract yTokenFutureVault is HybridFutureVault {
666	 function getIBTRate() public view override returns (uint256) {
667	 return IyToken(address(ibt)).pricePerShare();
668	 }
669	 }
670	 pragma solidity 0.7.6;
671	 interface IyToken is IERC20 {
672	 function pricePerShare() external view returns (uint256);
673	 }
674	 pragma solidity >=0.6.0 <0.8.0;
675	 library SafeMathUpgradeable {
676	 function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
677	 uint256 c = a + b;
678	 if (c < a) return (false, 0);
679	 return (true, c);
680	 }
681	 function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
682	 if (b > a) return (false, 0);
683	 return (true, a - b);
684	 }
685	 function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
686	 if (a == 0) return (true, 0);
687	 uint256 c = a * b;
688	 if (c / a != b) return (false, 0);
689	 return (true, c);
690	 }
691	 function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
692	 if (b == 0) return (false, 0);
693	 return (true, a / b);
694	 }
695	 function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
696	 if (b == 0) return (false, 0);
697	 return (true, a % b);
698	 }
699	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
700	 uint256 c = a + b;
701	 require(c >= a, "SafeMath: addition overflow");
702	 return c;
703	 }
704	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
705	 require(b <= a, "SafeMath: subtraction overflow");
706	 return a - b;
707	 }
708	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
709	 if (a == 0) return 0;
710	 uint256 c = a * b;
711	 require(c / a == b, "SafeMath: multiplication overflow");
712	 return c;
713	 }
714	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
715	 require(b > 0, "SafeMath: division by zero");
716	 return a / b;
717	 }
718	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
719	 require(b > 0, "SafeMath: modulo by zero");
720	 return a % b;
721	 }
722	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
723	 require(b <= a, errorMessage);
724	 return a - b;
725	 }
726	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
727	 require(b > 0, errorMessage);
728	 return a / b;
729	 }
730	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
731	 require(b > 0, errorMessage);
732	 return a % b;
733	 }
734	 }
735	 pragma solidity >=0.6.0 <0.8.0;
736	 library SafeERC20Upgradeable {
737	 using SafeMathUpgradeable for uint256;
738	 using AddressUpgradeable for address;
739	 function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {
740	 _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
741	 }
742	 function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {
743	 _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
744	 }
745	 function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {
746	 require((value == 0) || (token.allowance(address(this), spender) == 0), "SafeERC20: approve from non-zero to non-zero allowance" );
747	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
748	 }
749	 function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {
750	 uint256 newAllowance = token.allowance(address(this), spender).add(value);
751	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
752	 }
753	 function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {
754	 uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
755	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
756	 }
757	 function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {
758	 bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
759	 if (returndata.length > 0) {
760	 require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
761	 }
762	 }
763	 }
764	 pragma solidity 0.7.6;
765	 interface IFutureYieldToken is IERC20 {
766	 function burn(uint256 amount) external;
767	 function burnFrom(address account, uint256 amount) external;
768	 function mint(address to, uint256 amount) external;
769	 function recordedBalanceOf(address account) external view returns (uint256);
770	 function balanceOf(address account) external view override returns (uint256);
771	 function futureVault() external view returns (address);
772	 function internalPeriodID() external view returns (uint256);
773	 }
774	 pragma solidity 0.7.6;
775	 interface IPT is IERC20 {
776	 function burn(uint256 amount) external;
777	 function mint(address to, uint256 amount) external;
778	 function burnFrom(address account, uint256 amount) external;
779	 function pause() external;
780	 function unpause() external;
781	 function recordedBalanceOf(address account) external view returns (uint256);
782	 function balanceOf(address account) external view override returns (uint256);
783	 function futureVault() external view returns (address);
784	 }
785	 pragma solidity 0.7.6;
786	 interface IFutureWallet {
787	 event YieldRedeemed(address _user, uint256 _periodIndex);
788	 event WithdrawalsPaused();
789	 event WithdrawalsResumed();
790	 function registerExpiredFuture(uint256 _amount) external;
791	 function redeemYield(uint256 _periodIndex) external;
792	 function getRedeemableYield(uint256 _periodIndex, address _user) external view returns (uint256);
793	 function getFutureVaultAddress() external view returns (address);
794	 function getIBTAddress() external view returns (address);
795	 function harvestRewards() external;
796	 function redeemAllWalletRewards() external;
797	 function redeemWalletRewards(address _rewardToken) external;
798	 function getRewardsRecipient() external view returns (address);
799	 function setRewardRecipient(address _recipient) external;
800	 }
801	 pragma solidity 0.7.6;
802	 interface IController {
803	 event NextPeriodSwitchSet(uint256 _periodDuration, uint256 _nextSwitchTimestamp);
804	 event NewPeriodDurationIndexSet(uint256 _periodIndex);
805	 event FutureRegistered(IFutureVault _futureVault);
806	 event FutureUnregistered(IFutureVault _futureVault);
807	 event StartingDelaySet(uint256 _startingDelay);
808	 event NewPerformanceFeeFactor(IFutureVault _futureVault, uint256 _feeFactor);
809	 event FutureTerminated(IFutureVault _futureVault);
810	 event DepositsPaused(IFutureVault _futureVault);
811	 event DepositsResumed(IFutureVault _futureVault);
812	 event WithdrawalsPaused(IFutureVault _futureVault);
813	 event WithdrawalsResumed(IFutureVault _futureVault);
814	 event RegistryChanged(IRegistry _registry);
815	 event FutureSetToBeTerminated(IFutureVault _futureVault);
816	 function STARTING_DELAY() external view returns (uint256);
817	 function deposit(address _futureVault, uint256 _amount) external;
818	 function withdraw(address _futureVault, uint256 _amount) external;
819	 function exitTerminatedFuture(address _futureVault, address _user) external;
820	 function createFYTDelegationTo( address _futureVault, address _receiver, uint256 _amount ) external;
821	 function withdrawFYTDelegationFrom( address _futureVault, address _receiver, uint256 _amount ) external;
822	 function getRegistryAddress() external view returns (address);
823	 function getPeriodIndex(uint256 _periodDuration) external view returns (uint256);
824	 function getNextPeriodStart(uint256 _periodDuration) external view returns (uint256);
825	 function getNextPerformanceFeeFactor(address _futureVault) external view returns (uint256);
826	 function getCurrentPerformanceFeeFactor(address _futureVault) external view returns (uint256);
827	 function getDurations() external view returns (uint256[] memory durationsList);
828	 function getFuturesWithDuration(uint256 _periodDuration) external view returns (address[] memory filteredFutures);
829	 function isFutureTerminated(address _futureVault) external view returns (bool);
830	 function isFutureSetToBeTerminated(address _futureVault) external view returns (bool);
831	 function isWithdrawalsPaused(address _futureVault) external view returns (bool);
832	 function isDepositsPaused(address _futureVault) external view returns (bool);
833	 }
834	 pragma solidity 0.7.6;
835	 interface IRegistry {
836	 function setTreasury(address _newTreasury) external;
837	 function setController(address _newController) external;
838	 function setPTLogic(address _PTLogic) external;
839	 function setFYTLogic(address _FYTLogic) external;
840	 function getControllerAddress() external view returns (address);
841	 function getTreasuryAddress() external view returns (address);
842	 function getTokensFactoryAddress() external view returns (address);
843	 function getPTLogicAddress() external view returns (address);
844	 function getFYTLogicAddress() external view returns (address);
845	 function addFutureVault(address _future) external;
846	 function removeFutureVault(address _future) external;
847	 function isRegisteredFutureVault(address _future) external view returns (bool);
848	 function getFutureVaultAt(uint256 _index) external view returns (address);
849	 function futureVaultCount() external view returns (uint256);
850	 }
851	 pragma solidity 0.7.6;
852	 interface ITokensFactory {
853	 function deployNextFutureYieldToken(uint256 nextPeriodIndex) external returns (address newToken);
854	 function deployPT( string memory _ibtSymbol, uint256 _ibtDecimals, string memory _platformName, uint256 _perioDuration ) external returns (address newToken);
855	 }
856	 pragma solidity 0.7.6;
857	 library APWineMaths {
858	 using SafeMathUpgradeable for uint256;
859	 function getScaledInput( uint256 _actualValue, uint256 _initialSum, uint256 _actualSum ) internal pure returns (uint256) {
860	 if (_initialSum == 0 || _actualSum == 0) return _actualValue;
861	 return (_actualValue.mul(_initialSum)).div(_actualSum);
862	 }
863	 function getActualOutput( uint256 _scaledOutput, uint256 _initialSum, uint256 _actualSum ) internal pure returns (uint256) {
864	 if (_initialSum == 0 || _actualSum == 0) return 0;
865	 return (_scaledOutput.mul(_actualSum)).div(_initialSum);
866	 }
867	 }
868	 pragma solidity >=0.6.0 <0.8.0;
869	 library EnumerableSetUpgradeable {
870	 struct Set {
871	 bytes32[] _values;
872	 mapping (bytes32 => uint256) _indexes;
873	 }
874	 function _add(Set storage set, bytes32 value) private returns (bool) {
875	 if (!_contains(set, value)) {
876	 set._values.push(value);
877	 set._indexes[value] = set._values.length;
878	 return true;
879	 }
880	 else {
881	 return false;
882	 }
883	 }
884	 function _remove(Set storage set, bytes32 value) private returns (bool) {
885	 uint256 valueIndex = set._indexes[value];
886	 if (valueIndex != 0) {
887	 uint256 toDeleteIndex = valueIndex - 1;
888	 uint256 lastIndex = set._values.length - 1;
889	 bytes32 lastvalue = set._values[lastIndex];
890	 set._values[toDeleteIndex] = lastvalue;
891	 set._indexes[lastvalue] = toDeleteIndex + 1;
892	 set._values.pop();
893	 delete set._indexes[value];
894	 return true;
895	 }
896	 else {
897	 return false;
898	 }
899	 }
900	 function _contains(Set storage set, bytes32 value) private view returns (bool) {
901	 return set._indexes[value] != 0;
902	 }
903	 function _length(Set storage set) private view returns (uint256) {
904	 return set._values.length;
905	 }
906	 function _at(Set storage set, uint256 index) private view returns (bytes32) {
907	 require(set._values.length > index, "EnumerableSet: index out of bounds");
908	 return set._values[index];
909	 }
910	 struct Bytes32Set {
911	 Set _inner;
912	 }
913	 function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {
914	 return _add(set._inner, value);
915	 }
916	 function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {
917	 return _remove(set._inner, value);
918	 }
919	 function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {
920	 return _contains(set._inner, value);
921	 }
922	 function length(Bytes32Set storage set) internal view returns (uint256) {
923	 return _length(set._inner);
924	 }
925	 function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {
926	 return _at(set._inner, index);
927	 }
928	 struct AddressSet {
929	 Set _inner;
930	 }
931	 function add(AddressSet storage set, address value) internal returns (bool) {
932	 return _add(set._inner, bytes32(uint256(uint160(value))));
933	 }
934	 function remove(AddressSet storage set, address value) internal returns (bool) {
935	 return _remove(set._inner, bytes32(uint256(uint160(value))));
936	 }
937	 function contains(AddressSet storage set, address value) internal view returns (bool) {
938	 return _contains(set._inner, bytes32(uint256(uint160(value))));
939	 }
940	 function length(AddressSet storage set) internal view returns (uint256) {
941	 return _length(set._inner);
942	 }
943	 function at(AddressSet storage set, uint256 index) internal view returns (address) {
944	 return address(uint160(uint256(_at(set._inner, index))));
945	 }
946	 struct UintSet {
947	 Set _inner;
948	 }
949	 function add(UintSet storage set, uint256 value) internal returns (bool) {
950	 return _add(set._inner, bytes32(value));
951	 }
952	 function remove(UintSet storage set, uint256 value) internal returns (bool) {
953	 return _remove(set._inner, bytes32(value));
954	 }
955	 function contains(UintSet storage set, uint256 value) internal view returns (bool) {
956	 return _contains(set._inner, bytes32(value));
957	 }
958	 function length(UintSet storage set) internal view returns (uint256) {
959	 return _length(set._inner);
960	 }
961	 function at(UintSet storage set, uint256 index) internal view returns (uint256) {
962	 return uint256(_at(set._inner, index));
963	 }
964	 }
965	 pragma solidity >=0.6.2 <0.8.0;
966	 library AddressUpgradeable {
967	 function isContract(address account) internal view returns (bool) {
968	 uint256 size;
969	 assembly {
970	 size := extcodesize(account) }
971	 return size > 0;
972	 }
973	 function sendValue(address payable recipient, uint256 amount) internal {
974	 require(address(this).balance >= amount, "Address: insufficient balance");
975	 (bool success, ) = recipient.call{
976	 value: amount }
977	 ("");
978	 require(success, "Address: unable to send value, recipient may have reverted");
979	 }
980	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
981	 return functionCall(target, data, "Address: low-level call failed");
982	 }
983	 function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
984	 return functionCallWithValue(target, data, 0, errorMessage);
985	 }
986	 function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
987	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
988	 }
989	 function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
990	 require(address(this).balance >= value, "Address: insufficient balance for call");
991	 require(isContract(target), "Address: call to non-contract");
992	 (bool success, bytes memory returndata) = target.call{
993	 value: value }
994	 (data);
995	 return _verifyCallResult(success, returndata, errorMessage);
996	 }
997	 function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
998	 return functionStaticCall(target, data, "Address: low-level static call failed");
999	 }
1000	 function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
1001	 require(isContract(target), "Address: static call to non-contract");
1002	 (bool success, bytes memory returndata) = target.staticcall(data);
1003	 return _verifyCallResult(success, returndata, errorMessage);
1004	 }
1005	 function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
1006	 if (success) {
1007	 return returndata;
1008	 }
1009	 else {
1010	 if (returndata.length > 0) {
1011	 assembly {
1012	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
1013	 }
1014	 else {
1015	 revert(errorMessage);
1016	 }
1017	 }
1018	 }
1019	 }
1020	 pragma solidity 0.7.6;
1021	 interface IFutureVault {
1022	 event NewPeriodStarted(uint256 _newPeriodIndex);
1023	 event FutureWalletSet(address _futureWallet);
1024	 event RegistrySet(IRegistry _registry);
1025	 event FundsDeposited(address _user, uint256 _amount);
1026	 event FundsWithdrawn(address _user, uint256 _amount);
1027	 event PTSet(IPT _pt);
1028	 event LiquidityTransfersPaused();
1029	 event LiquidityTransfersResumed();
1030	 event DelegationCreated(address _delegator, address _receiver, uint256 _amount);
1031	 event DelegationRemoved(address _delegator, address _receiver, uint256 _amount);
1032	 function PERIOD_DURATION() external view returns (uint256);
1033	 function PLATFORM_NAME() external view returns (string memory);
1034	 function startNewPeriod() external;
1035	 function exitTerminatedFuture(address _user) external;
1036	 function updateUserState(address _user) external;
1037	 function claimFYT(address _user, uint256 _amount) external;
1038	 function deposit(address _user, uint256 _amount) external;
1039	 function withdraw(address _user, uint256 _amount) external;
1040	 function createFYTDelegationTo( address _delegator, address _receiver, uint256 _amount ) external;
1041	 function withdrawFYTDelegationFrom( address _delegator, address _receiver, uint256 _amount ) external;
1042	 function getTotalDelegated(address _delegator) external view returns (uint256 totalDelegated);
1043	 function getNextPeriodIndex() external view returns (uint256);
1044	 function getCurrentPeriodIndex() external view returns (uint256);
1045	 function getClaimablePT(address _user) external view returns (uint256);
1046	 function getUserEarlyUnlockablePremium(address _user) external view returns (uint256 premiumLocked, uint256 amountRequired);
1047	 function getUnlockableFunds(address _user) external view returns (uint256);
1048	 function getClaimableFYTForPeriod(address _user, uint256 _periodIndex) external view returns (uint256);
1049	 function getUnrealisedYieldPerPT() external view returns (uint256);
1050	 function getPTPerAmountDeposited(uint256 _amount) external view returns (uint256);
1051	 function getPremiumPerUnderlyingDeposited(uint256 _amount) external view returns (uint256);
1052	 function getTotalUnderlyingDeposited() external view returns (uint256);
1053	 function getYieldOfPeriod(uint256 _periodID) external view returns (uint256);
1054	 function getControllerAddress() external view returns (address);
1055	 function getFutureWalletAddress() external view returns (address);
1056	 function getIBTAddress() external view returns (address);
1057	 function getPTAddress() external view returns (address);
1058	 function getFYTofPeriod(uint256 _periodIndex) external view returns (address);
1059	 function isTerminated() external view returns (bool);
1060	 function getPerformanceFeeFactor() external view returns (uint256);
1061	 function harvestRewards() external;
1062	 function redeemAllVaultRewards() external;
1063	 function redeemVaultRewards(address _rewardToken) external;
1064	 function addRewardsToken(address _token) external;
1065	 function isRewardToken(address _token) external view returns (bool);
1066	 function getRewardTokenAt(uint256 _index) external view returns (address);
1067	 function getRewardTokensCount() external view returns (uint256);
1068	 function getRewardsRecipient() external view returns (address);
1069	 function setRewardRecipient(address _recipient) external;
1070	 function setFutureWallet(IFutureWallet _futureWallet) external;
1071	 function setRegistry(IRegistry _registry) external;
1072	 function pauseLiquidityTransfers() external;
1073	 function resumeLiquidityTransfers() external;
1074	 function convertIBTToUnderlying(uint256 _amount) external view returns (uint256);
1075	 function convertUnderlyingtoIBT(uint256 _amount) external view returns (uint256);
1076	 }
