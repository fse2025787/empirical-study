row number 
1	  pragma abicoder v2;
2	 pragma experimental ABIEncoderV2;
3	 pragma solidity >=0.6.0 <0.8.0;
4	 abstract contract Context {
5	 function _msgSender() internal view virtual returns (address payable) {
6	 return msg.sender;
7	 }
8	 function _msgData() internal view virtual returns (bytes memory) {
9	 this;
10	 return msg.data;
11	 }
12	 }
13	 pragma solidity >=0.6.0 <0.8.0;
14	 abstract contract Pausable is Context {
15	 event Paused(address account);
16	 event Unpaused(address account);
17	 bool private _paused;
18	 constructor () internal {
19	 _paused = false;
20	 }
21	 function paused() public view virtual returns (bool) {
22	 return _paused;
23	 }
24	 modifier whenNotPaused() {
25	 require(!paused(), "Pausable: paused");
26	 _;
27	 }
28	 modifier whenPaused() {
29	 require(paused(), "Pausable: not paused");
30	 _;
31	 }
32	 function _pause() internal virtual whenNotPaused {
33	 _paused = true;
34	 emit Paused(_msgSender());
35	 }
36	 function _unpause() internal virtual whenPaused {
37	 _paused = false;
38	 emit Unpaused(_msgSender());
39	 }
40	 }
41	 pragma solidity >=0.6.2;
42	 interface IUniswapV2Router01 {
43	 function factory() external view returns (address);
44	 function WETH() external view returns (address);
45	 function addLiquidity( address tokenA, address tokenB, uint256 amountADesired, uint256 amountBDesired, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline ) external returns ( uint256 amountA, uint256 amountB, uint256 liquidity );
46	 function addLiquidityETH( address token, uint256 amountTokenDesired, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline ) external payable returns ( uint256 amountToken, uint256 amountETH, uint256 liquidity );
47	 function removeLiquidity( address tokenA, address tokenB, uint256 liquidity, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline ) external returns (uint256 amountA, uint256 amountB);
48	 function removeLiquidityETH( address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline ) external returns (uint256 amountToken, uint256 amountETH);
49	 function removeLiquidityWithPermit( address tokenA, address tokenB, uint256 liquidity, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s ) external returns (uint256 amountA, uint256 amountB);
50	 function removeLiquidityETHWithPermit( address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s ) external returns (uint256 amountToken, uint256 amountETH);
51	 function swapExactTokensForTokens( uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline ) external returns (uint256[] memory amounts);
52	 function swapTokensForExactTokens( uint256 amountOut, uint256 amountInMax, address[] calldata path, address to, uint256 deadline ) external returns (uint256[] memory amounts);
53	 function swapExactETHForTokens( uint256 amountOutMin, address[] calldata path, address to, uint256 deadline ) external payable returns (uint256[] memory amounts);
54	 function swapTokensForExactETH( uint256 amountOut, uint256 amountInMax, address[] calldata path, address to, uint256 deadline ) external returns (uint256[] memory amounts);
55	 function swapExactTokensForETH( uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline ) external returns (uint256[] memory amounts);
56	 function swapETHForExactTokens( uint256 amountOut, address[] calldata path, address to, uint256 deadline ) external payable returns (uint256[] memory amounts);
57	 function quote( uint256 amountA, uint256 reserveA, uint256 reserveB ) external view returns (uint256 amountB);
58	 function getAmountOut( uint256 amountIn, uint256 reserveIn, uint256 reserveOut ) external view returns (uint256 amountOut);
59	 function getAmountIn( uint256 amountOut, uint256 reserveIn, uint256 reserveOut ) external view returns (uint256 amountIn);
60	 function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);
61	 function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);
62	 }
63	 pragma solidity ^0.7.4;
64	 interface IAppAddressProvider {
65	 function getDataCompressor() external view returns (address);
66	 function getGearToken() external view returns (address);
67	 function getWethToken() external view returns (address);
68	 function getWETHGateway() external view returns (address);
69	 function getPriceOracle() external view returns (address);
70	 function getLeveragedActions() external view returns (address);
71	 }
72	 pragma solidity >=0.6.0 <0.8.0;
73	 abstract contract Ownable is Context {
74	 address private _owner;
75	 event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
76	 constructor () internal {
77	 address msgSender = _msgSender();
78	 _owner = msgSender;
79	 emit OwnershipTransferred(address(0), msgSender);
80	 }
81	 function owner() public view virtual returns (address) {
82	 return _owner;
83	 }
84	 modifier onlyOwner() {
85	 require(owner() == _msgSender(), "Ownable: caller is not the owner");
86	 _;
87	 }
88	 function renounceOwnership() public virtual onlyOwner {
89	 emit OwnershipTransferred(_owner, address(0));
90	 _owner = address(0);
91	 }
92	 function transferOwnership(address newOwner) public virtual onlyOwner {
93	 require(newOwner != address(0), "Ownable: new owner is the zero address");
94	 emit OwnershipTransferred(_owner, newOwner);
95	 _owner = newOwner;
96	 }
97	 }
98	 pragma solidity ^0.7.4;
99	 abstract contract ACLTrait is Pausable {
100	 ACL private _acl;
101	 constructor(address addressProvider) {
102	 require( addressProvider != address(0), Errors.ZERO_ADDRESS_IS_NOT_ALLOWED );
103	 _acl = ACL(AddressProvider(addressProvider).getACL());
104	 }
105	 modifier configuratorOnly() {
106	 require( _acl.isConfigurator(msg.sender), Errors.ACL_CALLER_NOT_CONFIGURATOR );
107	 _;
108	 }
109	 function pause() external {
110	 require( _acl.isPausableAdmin(msg.sender), Errors.ACL_CALLER_NOT_PAUSABLE_ADMIN );
111	 _pause();
112	 }
113	 function unpause() external {
114	 require( _acl.isUnpausableAdmin(msg.sender), Errors.ACL_CALLER_NOT_PAUSABLE_ADMIN );
115	 _unpause();
116	 }
117	 }
118	 pragma solidity ^0.7.4;
119	 interface IAppCreditManager {
120	 function openCreditAccount( uint256 amount, address onBehalfOf, uint256 leverageFactor, uint256 referralCode ) external;
121	 function closeCreditAccount(address to, DataTypes.Exchange[] calldata paths) external;
122	 function repayCreditAccount(address to) external;
123	 function increaseBorrowedAmount(uint256 amount) external;
124	 function addCollateral( address onBehalfOf, address token, uint256 amount ) external;
125	 function calcRepayAmount(address borrower, bool isLiquidated) external view returns (uint256);
126	 function getCreditAccountOrRevert(address borrower) external view returns (address);
127	 function hasOpenedCreditAccount(address borrower) external view returns (bool);
128	 function defaultSwapContract() external view returns (address);
129	 }
130	 pragma solidity ^0.7.4;
131	 interface IPriceOracle {
132	 event NewPriceFeed(address indexed token, address indexed priceFeed);
133	 function addPriceFeed(address token, address priceFeedToken) external;
134	 function convert( uint256 amount, address tokenFrom, address tokenTo ) external view returns (uint256);
135	 function getLastPrice(address tokenFrom, address tokenTo) external view returns (uint256);
136	 }
137	 pragma solidity >=0.6.0 <0.8.0;
138	 interface IERC20 {
139	 function totalSupply() external view returns (uint256);
140	 function balanceOf(address account) external view returns (uint256);
141	 function transfer(address recipient, uint256 amount) external returns (bool);
142	 function allowance(address owner, address spender) external view returns (uint256);
143	 function approve(address spender, uint256 amount) external returns (bool);
144	 function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
145	 event Transfer(address indexed from, address indexed to, uint256 value);
146	 event Approval(address indexed owner, address indexed spender, uint256 value);
147	 }
148	 pragma solidity ^0.7.4;
149	 contract PathFinder {
150	 using SafeMath for uint256;
151	 using BytesLib for bytes;
152	 AddressProvider public addressProvider;
153	 ContractsRegister public immutable contractsRegister;
154	 PriceOracle public priceOracle;
155	 address public wethToken;
156	 address public constant ethToUsdPriceFeed = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;
157	 uint256 public constant version = 1;
158	 struct TradePath {
159	 address[] path;
160	 uint256 rate;
161	 uint256 expectedAmount;
162	 }
163	 modifier registeredCreditManagerOnly(address creditManager) {
164	 require( contractsRegister.isCreditManager(creditManager), Errors.REGISTERED_CREDIT_ACCOUNT_MANAGERS_ONLY );
165	 _;
166	 }
167	 constructor(address _addressProvider) {
168	 addressProvider = AddressProvider(_addressProvider);
169	 contractsRegister = ContractsRegister( addressProvider.getContractsRegister() );
170	 priceOracle = PriceOracle(addressProvider.getPriceOracle());
171	 wethToken = addressProvider.getWethToken();
172	 }
173	 function bestUniPath( uint256 swapInterface, address router, uint256 swapType, address from, address to, uint256 amount, address[] memory tokens ) public returns (TradePath memory) {
174	 if (amount == 0) {
175	 return TradePath({
176	 path: new address[](3), rate: 0, expectedAmount: 0}
177	 );
178	 }
179	 address[] memory path = new address[](2);
180	 path[0] = from;
181	 path[1] = to;
182	 (uint256 bestAmount, bool best) = _getAmountsUni( swapInterface, router, swapType, path, amount, swapType == Constants.EXACT_INPUT ? 0 : Constants.MAX_INT );
183	 address[] memory bestPath;
184	 uint256 expectedAmount;
185	 if (best) {
186	 bestPath = path;
187	 }
188	 for (uint256 i = 0; i < tokens.length; i++) {
189	 path = new address[](3);
190	 path[0] = from;
191	 path[2] = to;
192	 if (tokens[i] != from && tokens[i] != to) {
193	 path[1] = tokens[i];
194	 (expectedAmount, best) = _getAmountsUni( swapInterface, router, swapType, path, amount, bestAmount );
195	 if (best) {
196	 bestAmount = expectedAmount;
197	 bestPath = path;
198	 }
199	 }
200	 }
201	 uint256 bestRate = 0;
202	 if (bestAmount == Constants.MAX_INT) {
203	 bestAmount = 0;
204	 }
205	 if (bestAmount != 0 && amount != 0) {
206	 bestRate = swapType == Constants.EXACT_INPUT ? Constants.WAD.mul(amount).div(bestAmount) : Constants.WAD.mul(bestAmount).div(amount);
207	 }
208	 return TradePath({
209	 rate: bestRate, path: bestPath, expectedAmount: bestAmount }
210	 );
211	 }
212	 function _getAmountsUni( uint256 swapInterface, address router, uint256 swapType, address[] memory path, uint256 amount, uint256 bestAmount ) internal returns (uint256, bool) {
213	 return swapInterface == Constants.UNISWAP_V2 ? _getAmountsV2( IUniswapV2Router02(router), swapType, path, amount, bestAmount ) : _getAmountsV3( IQuoter(router), swapType, path, amount, bestAmount );
214	 }
215	 function _getAmountsV2( IUniswapV2Router02 router, uint256 swapType, address[] memory path, uint256 amount, uint256 bestAmount ) internal view returns (uint256, bool) {
216	 uint256 expectedAmount;
217	 if (swapType == Constants.EXACT_INPUT) {
218	 try router.getAmountsOut(amount, path) returns ( uint256[] memory amountsOut ) {
219	 expectedAmount = amountsOut[path.length - 1];
220	 }
221	 catch {
222	 return (bestAmount, false);
223	 }
224	 }
225	 else if (swapType == Constants.EXACT_OUTPUT) {
226	 try router.getAmountsIn(amount, path) returns ( uint256[] memory amountsIn ) {
227	 expectedAmount = amountsIn[0];
228	 }
229	 catch {
230	 return (bestAmount, false);
231	 }
232	 }
233	 else {
234	 revert("Unknown swap type");
235	 }
236	 if ( (swapType == Constants.EXACT_INPUT && expectedAmount > bestAmount) || (swapType == Constants.EXACT_OUTPUT && expectedAmount < bestAmount) ) {
237	 return (expectedAmount, true);
238	 }
239	 return (bestAmount, false);
240	 }
241	 function _getAmountsV3( IQuoter quoter, uint256 swapType, address[] memory path, uint256 amount, uint256 bestAmount ) internal returns (uint256, bool) {
242	 uint256 expectedAmount;
243	 if (swapType == Constants.EXACT_INPUT) {
244	 try quoter.quoteExactInput( convertPathToPathV3(path, swapType), amount ) returns (uint256 amountOut) {
245	 expectedAmount = amountOut;
246	 }
247	 catch {
248	 return (bestAmount, false);
249	 }
250	 }
251	 else if (swapType == Constants.EXACT_OUTPUT) {
252	 try quoter.quoteExactOutput( convertPathToPathV3(path, swapType), amount ) returns (uint256 amountIn) {
253	 expectedAmount = amountIn;
254	 }
255	 catch {
256	 return (bestAmount, false);
257	 }
258	 }
259	 else {
260	 revert("Unknown swap type");
261	 }
262	 if ( (swapType == Constants.EXACT_INPUT && expectedAmount > bestAmount) || (swapType == Constants.EXACT_OUTPUT && expectedAmount < bestAmount) ) {
263	 return (expectedAmount, true);
264	 }
265	 return (bestAmount, false);
266	 }
267	 function convertPathToPathV3(address[] memory path, uint256 swapType) public pure returns (bytes memory result) {
268	 uint24 fee = 3000;
269	 if (swapType == Constants.EXACT_INPUT) {
270	 for (uint256 i = 0; i < path.length.sub(1); i++) {
271	 result = result.concat(abi.encodePacked(path[i], fee));
272	 }
273	 result = result.concat(abi.encodePacked(path[path.length - 1]));
274	 }
275	 else {
276	 for (uint256 i = path.length.sub(1); i > 0; i--) {
277	 result = result.concat(abi.encodePacked(path[i], fee));
278	 }
279	 result = result.concat(abi.encodePacked(path[0]));
280	 }
281	 }
282	 function getClosurePaths( address router, address _creditManager, address borrower, address[] memory connectorTokens ) external registeredCreditManagerOnly(_creditManager) returns (TradePath[] memory result) {
283	 ICreditFilter creditFilter = ICreditFilter( ICreditManager(_creditManager).creditFilter() );
284	 result = new TradePath[](creditFilter.allowedTokensCount());
285	 address creditAccount = ICreditManager(_creditManager) .getCreditAccountOrRevert(borrower);
286	 address underlyingToken = creditFilter.underlyingToken();
287	 for (uint256 i = 0; i < creditFilter.allowedTokensCount(); i++) {
288	 (address token, uint256 balance, , ) = creditFilter .getCreditAccountTokenById(creditAccount, i);
289	 if (i == 0) {
290	 result[0] = TradePath({
291	 path: new address[](3), rate: Constants.WAD, expectedAmount: balance }
292	 );
293	 }
294	 else {
295	 result[i] = bestUniPath( Constants.UNISWAP_V2, router, Constants.EXACT_INPUT, token, underlyingToken, balance, connectorTokens );
296	 }
297	 }
298	 }
299	 function getPrices(address[] calldata tokens) external view returns (uint256[] memory prices) {
300	 ( , int256 ethPrice, , , ) = AggregatorV3Interface(ethToUsdPriceFeed).latestRoundData();
301	 prices = new uint256[](tokens.length);
302	 for (uint256 i = 0; i < tokens.length; i++) {
303	 uint256 decimals = ERC20(tokens[i]).decimals();
304	 prices[i] = priceOracle .convert(10**decimals, tokens[i], wethToken) .mul(uint256(ethPrice)) .div(Constants.WAD);
305	 }
306	 }
307	 }
308	 pragma solidity >=0.6.0;
309	 interface AggregatorV3Interface {
310	 function decimals() external view returns (uint8);
311	 function description() external view returns (string memory);
312	 function version() external view returns (uint256);
313	 function getRoundData(uint80 _roundId) external view returns ( uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound );
314	 function latestRoundData() external view returns ( uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound );
315	 }
316	 pragma solidity >=0.6.0 <0.8.0;
317	 library SafeMath {
318	 function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
319	 uint256 c = a + b;
320	 if (c < a) return (false, 0);
321	 return (true, c);
322	 }
323	 function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
324	 if (b > a) return (false, 0);
325	 return (true, a - b);
326	 }
327	 function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
328	 if (a == 0) return (true, 0);
329	 uint256 c = a * b;
330	 if (c / a != b) return (false, 0);
331	 return (true, c);
332	 }
333	 function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
334	 if (b == 0) return (false, 0);
335	 return (true, a / b);
336	 }
337	 function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
338	 if (b == 0) return (false, 0);
339	 return (true, a % b);
340	 }
341	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
342	 uint256 c = a + b;
343	 require(c >= a, "SafeMath: addition overflow");
344	 return c;
345	 }
346	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
347	 require(b <= a, "SafeMath: subtraction overflow");
348	 return a - b;
349	 }
350	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
351	 if (a == 0) return 0;
352	 uint256 c = a * b;
353	 require(c / a == b, "SafeMath: multiplication overflow");
354	 return c;
355	 }
356	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
357	 require(b > 0, "SafeMath: division by zero");
358	 return a / b;
359	 }
360	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
361	 require(b > 0, "SafeMath: modulo by zero");
362	 return a % b;
363	 }
364	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
365	 require(b <= a, errorMessage);
366	 return a - b;
367	 }
368	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
369	 require(b > 0, errorMessage);
370	 return a / b;
371	 }
372	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
373	 require(b > 0, errorMessage);
374	 return a % b;
375	 }
376	 }
377	 pragma solidity >=0.7.5;
378	 interface ISwapRouter {
379	 struct ExactInputSingleParams {
380	 address tokenIn;
381	 address tokenOut;
382	 uint24 fee;
383	 address recipient;
384	 uint256 deadline;
385	 uint256 amountIn;
386	 uint256 amountOutMinimum;
387	 uint160 sqrtPriceLimitX96;
388	 }
389	 function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);
390	 struct ExactInputParams {
391	 bytes path;
392	 address recipient;
393	 uint256 deadline;
394	 uint256 amountIn;
395	 uint256 amountOutMinimum;
396	 }
397	 function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);
398	 struct ExactOutputSingleParams {
399	 address tokenIn;
400	 address tokenOut;
401	 uint24 fee;
402	 address recipient;
403	 uint256 deadline;
404	 uint256 amountOut;
405	 uint256 amountInMaximum;
406	 uint160 sqrtPriceLimitX96;
407	 }
408	 function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);
409	 struct ExactOutputParams {
410	 bytes path;
411	 address recipient;
412	 uint256 deadline;
413	 uint256 amountOut;
414	 uint256 amountInMaximum;
415	 }
416	 function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);
417	 }
418	 pragma solidity >=0.6.2;
419	 interface IUniswapV2Router02 is IUniswapV2Router01 {
420	 function removeLiquidityETHSupportingFeeOnTransferTokens( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) external returns (uint amountETH);
421	 function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s ) external returns (uint amountETH);
422	 function swapExactTokensForTokensSupportingFeeOnTransferTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external;
423	 function swapExactETHForTokensSupportingFeeOnTransferTokens( uint amountOutMin, address[] calldata path, address to, uint deadline ) external payable;
424	 function swapExactTokensForETHSupportingFeeOnTransferTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external;
425	 function factory() external override view returns (address);
426	 function WETH() external override view returns (address);
427	 function addLiquidity( address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline ) external override returns (uint amountA, uint amountB, uint liquidity);
428	 function addLiquidityETH( address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) external override payable returns (uint amountToken, uint amountETH, uint liquidity);
429	 function removeLiquidity( address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline ) external override returns (uint amountA, uint amountB);
430	 function removeLiquidityETH( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) external override returns (uint amountToken, uint amountETH);
431	 function removeLiquidityWithPermit( address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s ) external override returns (uint amountA, uint amountB);
432	 function removeLiquidityETHWithPermit( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s ) external override returns (uint amountToken, uint amountETH);
433	 function swapExactTokensForTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external override returns (uint[] memory amounts);
434	 function swapTokensForExactTokens( uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline ) external override returns (uint[] memory amounts);
435	 function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external override payable returns (uint[] memory amounts);
436	 function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external override returns (uint[] memory amounts);
437	 function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external override returns (uint[] memory amounts);
438	 function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) external override payable returns (uint[] memory amounts);
439	 function quote(uint amountA, uint reserveA, uint reserveB) external override view returns (uint amountB);
440	 function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external override view returns (uint amountOut);
441	 function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external override view returns (uint amountIn);
442	 function getAmountsOut(uint amountIn, address[] calldata path) external override view returns (uint[] memory amounts);
443	 function getAmountsIn(uint amountOut, address[] calldata path) external override view returns (uint[] memory amounts);
444	 }
445	 pragma solidity >=0.5.0 <0.8.0;
446	 library BytesLib {
447	 function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {
448	 bytes memory tempBytes;
449	 assembly {
450	 tempBytes := mload(0x40) let length := mload(_preBytes) mstore(tempBytes, length) let mc := add(tempBytes, 0x20) let end := add(mc, length) for {
451	 let cc := add(_preBytes, 0x20) }
452	 lt(mc, end) {
453	 mc := add(mc, 0x20) cc := add(cc, 0x20) }
454	 {
455	 mstore(mc, mload(cc)) }
456	 length := mload(_postBytes) mstore(tempBytes, add(length, mload(tempBytes))) mc := end end := add(mc, length) for {
457	 let cc := add(_postBytes, 0x20) }
458	 lt(mc, end) {
459	 mc := add(mc, 0x20) cc := add(cc, 0x20) }
460	 {
461	 mstore(mc, mload(cc)) }
462	 mstore( 0x40, and( add(add(end, iszero(add(length, mload(_preBytes)))), 31), not(31) ) ) }
463	 return tempBytes;
464	 }
465	 function slice( bytes memory _bytes, uint256 _start, uint256 _length ) internal pure returns (bytes memory) {
466	 require(_length + 31 >= _length, "slice_overflow");
467	 require(_start + _length >= _start, "slice_overflow");
468	 require(_bytes.length >= _start + _length, "slice_outOfBounds");
469	 bytes memory tempBytes;
470	 assembly {
471	 switch iszero(_length) case 0 {
472	 tempBytes := mload(0x40) let lengthmod := and(_length, 31) let mc := add( add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)) ) let end := add(mc, _length) for {
473	 let cc := add( add( add(_bytes, lengthmod), mul(0x20, iszero(lengthmod)) ), _start ) }
474	 lt(mc, end) {
475	 mc := add(mc, 0x20) cc := add(cc, 0x20) }
476	 {
477	 mstore(mc, mload(cc)) }
478	 mstore(tempBytes, _length) mstore(0x40, and(add(mc, 31), not(31))) }
479	 default {
480	 tempBytes := mload(0x40) mstore(tempBytes, 0) mstore(0x40, add(tempBytes, 0x20)) }
481	 }
482	 return tempBytes;
483	 }
484	 function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {
485	 require(_start + 20 >= _start, "toAddress_overflow");
486	 require(_bytes.length >= _start + 20, "toAddress_outOfBounds");
487	 address tempAddress;
488	 assembly {
489	 tempAddress := div( mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000 ) }
490	 return tempAddress;
491	 }
492	 function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {
493	 require(_start + 3 >= _start, "toUint24_overflow");
494	 require(_bytes.length >= _start + 3, "toUint24_outOfBounds");
495	 uint24 tempUint;
496	 assembly {
497	 tempUint := mload(add(add(_bytes, 0x3), _start)) }
498	 return tempUint;
499	 }
500	 }
501	 pragma solidity ^0.7.4;
502	 interface ICurvePool {
503	 function coins(uint256) external view returns (address);
504	 function exchange( int128 i, int128 j, uint256 dx, uint256 min_dy ) external;
505	 function exchange_underlying( int128 i, int128 j, uint256 dx, uint256 min_dy ) external;
506	 function get_dy_underlying( int128 i, int128 j, uint256 dx ) external view returns (uint256);
507	 function get_dy( int128 i, int128 j, uint256 dx ) external view returns (uint256);
508	 function get_virtual_price() external view returns (uint256);
509	 }
510	 pragma solidity ^0.7.4;
511	 library Constants {
512	 uint256 constant MAX_INT = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;
513	 uint256 constant MAX_INT_4 = 0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;
514	 uint256 constant ACCOUNT_CREATION_REWARD = 1e5;
515	 uint256 constant DEPLOYMENT_COST = 1e17;
516	 uint256 constant FEE_INTEREST = 1000;
517	 uint256 constant FEE_LIQUIDATION = 200;
518	 uint256 constant LIQUIDATION_DISCOUNTED_SUM = 9500;
519	 uint256 constant UNDERLYING_TOKEN_LIQUIDATION_THRESHOLD = LIQUIDATION_DISCOUNTED_SUM - FEE_LIQUIDATION;
520	 uint256 constant SECONDS_PER_YEAR = 365 days;
521	 uint256 constant SECONDS_PER_ONE_AND_HALF_YEAR = SECONDS_PER_YEAR * 3 /2;
522	 uint256 constant RAY = 1e27;
523	 uint256 constant WAD = 1e18;
524	 uint8 constant OPERATION_CLOSURE = 1;
525	 uint8 constant OPERATION_REPAY = 2;
526	 uint8 constant OPERATION_LIQUIDATION = 3;
527	 uint8 constant LEVERAGE_DECIMALS = 100;
528	 uint8 constant MAX_WITHDRAW_FEE = 100;
529	 uint256 constant CHI_THRESHOLD = 9950;
530	 uint256 constant HF_CHECK_INTERVAL_DEFAULT = 4;
531	 uint256 constant NO_SWAP = 0;
532	 uint256 constant UNISWAP_V2 = 1;
533	 uint256 constant UNISWAP_V3 = 2;
534	 uint256 constant CURVE_V1 = 3;
535	 uint256 constant LP_YEARN = 4;
536	 uint256 constant EXACT_INPUT = 1;
537	 uint256 constant EXACT_OUTPUT = 2;
538	 }
539	 pragma solidity ^0.7.4;
540	 library Errors {
541	 string public constant ZERO_ADDRESS_IS_NOT_ALLOWED = "Z0";
542	 string public constant NOT_IMPLEMENTED = "NI";
543	 string public constant INCORRECT_PATH_LENGTH = "PL";
544	 string public constant INCORRECT_ARRAY_LENGTH = "CR";
545	 string public constant REGISTERED_CREDIT_ACCOUNT_MANAGERS_ONLY = "CP";
546	 string public constant REGISTERED_POOLS_ONLY = "RP";
547	 string public constant INCORRECT_PARAMETER = "IP";
548	 string public constant MATH_MULTIPLICATION_OVERFLOW = "M1";
549	 string public constant MATH_ADDITION_OVERFLOW = "M2";
550	 string public constant MATH_DIVISION_BY_ZERO = "M3";
551	 string public constant POOL_CONNECTED_CREDIT_MANAGERS_ONLY = "PS0";
552	 string public constant POOL_INCOMPATIBLE_CREDIT_ACCOUNT_MANAGER = "PS1";
553	 string public constant POOL_MORE_THAN_EXPECTED_LIQUIDITY_LIMIT = "PS2";
554	 string public constant POOL_INCORRECT_WITHDRAW_FEE = "PS3";
555	 string public constant POOL_CANT_ADD_CREDIT_MANAGER_TWICE = "PS4";
556	 string public constant CM_NO_OPEN_ACCOUNT = "CM1";
557	 string public constant CM_ZERO_ADDRESS_OR_USER_HAVE_ALREADY_OPEN_CREDIT_ACCOUNT = "CM2";
558	 string public constant CM_INCORRECT_AMOUNT = "CM3";
559	 string public constant CM_CAN_LIQUIDATE_WITH_SUCH_HEALTH_FACTOR = "CM4";
560	 string public constant CM_CAN_UPDATE_WITH_SUCH_HEALTH_FACTOR = "CM5";
561	 string public constant CM_WETH_GATEWAY_ONLY = "CM6";
562	 string public constant CM_INCORRECT_PARAMS = "CM7";
563	 string public constant CM_INCORRECT_FEES = "CM8";
564	 string public constant CM_MAX_LEVERAGE_IS_TOO_HIGH = "CM9";
565	 string public constant CM_CANT_CLOSE_WITH_LOSS = "CMA";
566	 string public constant CM_TARGET_CONTRACT_iS_NOT_ALLOWED = "CMB";
567	 string public constant CM_TRANSFER_FAILED = "CMC";
568	 string public constant CM_INCORRECT_NEW_OWNER = "CME";
569	 string public constant AF_CANT_CLOSE_CREDIT_ACCOUNT_IN_THE_SAME_BLOCK = "AF1";
570	 string public constant AF_MINING_IS_FINISHED = "AF2";
571	 string public constant AF_CREDIT_ACCOUNT_NOT_IN_STOCK = "AF3";
572	 string public constant AF_EXTERNAL_ACCOUNTS_ARE_FORBIDDEN = "AF4";
573	 string public constant AS_ADDRESS_NOT_FOUND = "AP1";
574	 string public constant CR_POOL_ALREADY_ADDED = "CR1";
575	 string public constant CR_CREDIT_MANAGER_ALREADY_ADDED = "CR2";
576	 string public constant CF_UNDERLYING_TOKEN_FILTER_CONFLICT = "CF0";
577	 string public constant CF_INCORRECT_LIQUIDATION_THRESHOLD = "CF1";
578	 string public constant CF_TOKEN_IS_NOT_ALLOWED = "CF2";
579	 string public constant CF_CREDIT_MANAGERS_ONLY = "CF3";
580	 string public constant CF_ADAPTERS_ONLY = "CF4";
581	 string public constant CF_OPERATION_LOW_HEALTH_FACTOR = "CF5";
582	 string public constant CF_TOO_MUCH_ALLOWED_TOKENS = "CF6";
583	 string public constant CF_INCORRECT_CHI_THRESHOLD = "CF7";
584	 string public constant CF_INCORRECT_FAST_CHECK = "CF8";
585	 string public constant CF_NON_TOKEN_CONTRACT = "CF9";
586	 string public constant CF_CONTRACT_IS_NOT_IN_ALLOWED_LIST = "CFA";
587	 string public constant CF_FAST_CHECK_NOT_COVERED_COLLATERAL_DROP = "CFB";
588	 string public constant CF_SOME_LIQUIDATION_THRESHOLD_MORE_THAN_NEW_ONE = "CFC";
589	 string public constant CF_ADAPTER_CAN_BE_USED_ONLY_ONCE = "CFD";
590	 string public constant CF_INCORRECT_PRICEFEED = "CFE";
591	 string public constant CF_TRANSFER_IS_NOT_ALLOWED = "CFF";
592	 string public constant CF_CREDIT_MANAGER_IS_ALREADY_SET = "CFG";
593	 string public constant CA_CONNECTED_CREDIT_MANAGER_ONLY = "CA1";
594	 string public constant CA_FACTORY_ONLY = "CA2";
595	 string public constant PO_PRICE_FEED_DOESNT_EXIST = "PO0";
596	 string public constant PO_TOKENS_WITH_DECIMALS_MORE_18_ISNT_ALLOWED = "PO1";
597	 string public constant PO_AGGREGATOR_DECIMALS_SHOULD_BE_18 = "PO2";
598	 string public constant ACL_CALLER_NOT_PAUSABLE_ADMIN = "ACL1";
599	 string public constant ACL_CALLER_NOT_CONFIGURATOR = "ACL2";
600	 string public constant WG_DESTINATION_IS_NOT_WETH_COMPATIBLE = "WG1";
601	 string public constant WG_RECEIVE_IS_NOT_ALLOWED = "WG2";
602	 string public constant WG_NOT_ENOUGH_FUNDS = "WG3";
603	 string public constant LA_INCORRECT_VALUE = "LA1";
604	 string public constant LA_HAS_VALUE_WITH_TOKEN_TRANSFER = "LA2";
605	 string public constant LA_UNKNOWN_SWAP_INTERFACE = "LA3";
606	 string public constant LA_UNKNOWN_LP_INTERFACE = "LA4";
607	 string public constant LA_LOWER_THAN_AMOUNT_MIN = "LA5";
608	 string public constant LA_TOKEN_OUT_IS_NOT_COLLATERAL = "LA6";
609	 string public constant YPF_PRICE_PER_SHARE_OUT_OF_RANGE = "YP1";
610	 string public constant YPF_INCORRECT_LIMITER_PARAMETERS = "YP2";
611	 string public constant TD_WALLET_IS_ALREADY_CONNECTED_TO_VC = "TD1";
612	 string public constant TD_INCORRECT_WEIGHTS = "TD2";
613	 string public constant TD_NON_ZERO_BALANCE_AFTER_DISTRIBUTION = "TD3";
614	 string public constant TD_CONTRIBUTOR_IS_NOT_REGISTERED = "TD4";
615	 }
616	 pragma solidity >=0.7.5;
617	 interface IQuoter {
618	 function quoteExactInput(bytes memory path, uint256 amountIn) external returns (uint256 amountOut);
619	 function quoteExactInputSingle( address tokenIn, address tokenOut, uint24 fee, uint256 amountIn, uint160 sqrtPriceLimitX96 ) external returns (uint256 amountOut);
620	 function quoteExactOutput(bytes memory path, uint256 amountOut) external returns (uint256 amountIn);
621	 function quoteExactOutputSingle( address tokenIn, address tokenOut, uint24 fee, uint256 amountOut, uint160 sqrtPriceLimitX96 ) external returns (uint256 amountIn);
622	 }
623	 pragma solidity ^0.7.4;
624	 contract AddressProvider is Ownable, IAppAddressProvider {
625	 mapping(bytes32 => address) public addresses;
626	 event AddressSet(bytes32 indexed service, address indexed newAddress);
627	 event Claimed(uint256 user_id, address account, uint256 amount, bytes32 leaf);
628	 bytes32 public constant CONTRACTS_REGISTER = "CONTRACTS_REGISTER";
629	 bytes32 public constant ACL = "ACL";
630	 bytes32 public constant PRICE_ORACLE = "PRICE_ORACLE";
631	 bytes32 public constant ACCOUNT_FACTORY = "ACCOUNT_FACTORY";
632	 bytes32 public constant DATA_COMPRESSOR = "DATA_COMPRESSOR";
633	 bytes32 public constant TREASURY_CONTRACT = "TREASURY_CONTRACT";
634	 bytes32 public constant GEAR_TOKEN = "GEAR_TOKEN";
635	 bytes32 public constant WETH_TOKEN = "WETH_TOKEN";
636	 bytes32 public constant WETH_GATEWAY = "WETH_GATEWAY";
637	 bytes32 public constant LEVERAGED_ACTIONS = "LEVERAGED_ACTIONS";
638	 uint256 public constant version = 1;
639	 constructor() {
640	 emit AddressSet("ADDRESS_PROVIDER", address(this));
641	 }
642	 function getACL() external view returns (address) {
643	 return _getAddress(ACL);
644	 }
645	 function setACL(address _address) external onlyOwner {
646	 _setAddress(ACL, _address);
647	 }
648	 function getContractsRegister() external view returns (address) {
649	 return _getAddress(CONTRACTS_REGISTER);
650	 }
651	 function setContractsRegister(address _address) external onlyOwner {
652	 _setAddress(CONTRACTS_REGISTER, _address);
653	 }
654	 function getPriceOracle() external view override returns (address) {
655	 return _getAddress(PRICE_ORACLE);
656	 }
657	 function setPriceOracle(address _address) external onlyOwner {
658	 _setAddress(PRICE_ORACLE, _address);
659	 }
660	 function getAccountFactory() external view returns (address) {
661	 return _getAddress(ACCOUNT_FACTORY);
662	 }
663	 function setAccountFactory(address _address) external onlyOwner {
664	 _setAddress(ACCOUNT_FACTORY, _address);
665	 }
666	 function getDataCompressor() external view override returns (address) {
667	 return _getAddress(DATA_COMPRESSOR);
668	 }
669	 function setDataCompressor(address _address) external onlyOwner {
670	 _setAddress(DATA_COMPRESSOR, _address);
671	 }
672	 function getTreasuryContract() external view returns (address) {
673	 return _getAddress(TREASURY_CONTRACT);
674	 }
675	 function setTreasuryContract(address _address) external onlyOwner {
676	 _setAddress(TREASURY_CONTRACT, _address);
677	 }
678	 function getGearToken() external view override returns (address) {
679	 return _getAddress(GEAR_TOKEN);
680	 }
681	 function setGearToken(address _address) external onlyOwner {
682	 _setAddress(GEAR_TOKEN, _address);
683	 }
684	 function getWethToken() external view override returns (address) {
685	 return _getAddress(WETH_TOKEN);
686	 }
687	 function setWethToken(address _address) external onlyOwner {
688	 _setAddress(WETH_TOKEN, _address);
689	 }
690	 function getWETHGateway() external view override returns (address) {
691	 return _getAddress(WETH_GATEWAY);
692	 }
693	 function setWETHGateway(address _address) external onlyOwner {
694	 _setAddress(WETH_GATEWAY, _address);
695	 }
696	 function getLeveragedActions() external view override returns (address) {
697	 return _getAddress(LEVERAGED_ACTIONS);
698	 }
699	 function setLeveragedActions(address _address) external onlyOwner {
700	 _setAddress(LEVERAGED_ACTIONS, _address);
701	 }
702	 function _getAddress(bytes32 key) internal view returns (address) {
703	 address result = addresses[key];
704	 require(result != address(0), Errors.AS_ADDRESS_NOT_FOUND);
705	 return result;
706	 }
707	 function _setAddress(bytes32 key, address value) internal {
708	 addresses[key] = value;
709	 emit AddressSet(key, value);
710	 }
711	 }
712	 pragma solidity ^0.7.4;
713	 contract ContractsRegister is ACLTrait {
714	 address[] public pools;
715	 mapping(address => bool) public isPool;
716	 address[] public creditManagers;
717	 mapping(address => bool) public isCreditManager;
718	 uint256 public constant version = 1;
719	 event NewPoolAdded(address indexed pool);
720	 event NewCreditManagerAdded(address indexed creditManager);
721	 constructor(address addressProvider) ACLTrait(addressProvider) {
722	 }
723	 function addPool(address newPoolAddress) external configuratorOnly {
724	 require( newPoolAddress != address(0), Errors.ZERO_ADDRESS_IS_NOT_ALLOWED );
725	 require(!isPool[newPoolAddress], Errors.CR_POOL_ALREADY_ADDED);
726	 pools.push(newPoolAddress);
727	 isPool[newPoolAddress] = true;
728	 emit NewPoolAdded(newPoolAddress);
729	 }
730	 function getPools() external view returns (address[] memory) {
731	 return pools;
732	 }
733	 function getPoolsCount() external view returns (uint256) {
734	 return pools.length;
735	 }
736	 function addCreditManager(address newCreditManager) external configuratorOnly {
737	 require( newCreditManager != address(0), Errors.ZERO_ADDRESS_IS_NOT_ALLOWED );
738	 require( !isCreditManager[newCreditManager], Errors.CR_CREDIT_MANAGER_ALREADY_ADDED );
739	 creditManagers.push(newCreditManager);
740	 isCreditManager[newCreditManager] = true;
741	 emit NewCreditManagerAdded(newCreditManager);
742	 }
743	 function getCreditManagers() external view returns (address[] memory) {
744	 return creditManagers;
745	 }
746	 function getCreditManagersCount() external view returns (uint256) {
747	 return creditManagers.length;
748	 }
749	 }
750	 pragma solidity ^0.7.4;
751	 interface ICreditManager is IAppCreditManager {
752	 event OpenCreditAccount( address indexed sender, address indexed onBehalfOf, address indexed creditAccount, uint256 amount, uint256 borrowAmount, uint256 referralCode );
753	 event CloseCreditAccount( address indexed owner, address indexed to, uint256 remainingFunds );
754	 event LiquidateCreditAccount( address indexed owner, address indexed liquidator, uint256 remainingFunds );
755	 event IncreaseBorrowedAmount(address indexed borrower, uint256 amount);
756	 event AddCollateral( address indexed onBehalfOf, address indexed token, uint256 value );
757	 event RepayCreditAccount(address indexed owner, address indexed to);
758	 event ExecuteOrder(address indexed borrower, address indexed target);
759	 event NewParameters( uint256 minAmount, uint256 maxAmount, uint256 maxLeverage, uint256 feeInterest, uint256 feeLiquidation, uint256 liquidationDiscount );
760	 event TransferAccount(address indexed oldOwner, address indexed newOwner);
761	 function openCreditAccount( uint256 amount, address onBehalfOf, uint256 leverageFactor, uint256 referralCode ) external override;
762	 function closeCreditAccount(address to, DataTypes.Exchange[] calldata paths) external override;
763	 function liquidateCreditAccount( address borrower, address to, bool force ) external;
764	 function repayCreditAccount(address to) external override;
765	 function repayCreditAccountETH(address borrower, address to) external returns (uint256);
766	 function increaseBorrowedAmount(uint256 amount) external override;
767	 function addCollateral( address onBehalfOf, address token, uint256 amount ) external override;
768	 function hasOpenedCreditAccount(address borrower) external view override returns (bool);
769	 function calcRepayAmount(address borrower, bool isLiquidated) external view override returns (uint256);
770	 function minAmount() external view returns (uint256);
771	 function maxAmount() external view returns (uint256);
772	 function maxLeverageFactor() external view returns (uint256);
773	 function underlyingToken() external view returns (address);
774	 function poolService() external view returns (address);
775	 function creditFilter() external view returns (ICreditFilter);
776	 function creditAccounts(address borrower) external view returns (address);
777	 function executeOrder( address borrower, address target, bytes memory data ) external returns (bytes memory);
778	 function approve(address targetContract, address token) external;
779	 function provideCreditAccountAllowance( address creditAccount, address toContract, address token ) external;
780	 function transferAccountOwnership(address newOwner) external;
781	 function getCreditAccountOrRevert(address borrower) external view override returns (address);
782	 function feeInterest() external view returns (uint256);
783	 function feeLiquidation() external view returns (uint256);
784	 function liquidationDiscount() external view returns (uint256);
785	 function minHealthFactor() external view returns (uint256);
786	 function defaultSwapContract() external view override returns (address);
787	 }
788	 pragma solidity ^0.7.4;
789	 interface ICreditFilter {
790	 event TokenAllowed(address indexed token, uint256 liquidityThreshold);
791	 event TokenForbidden(address indexed token);
792	 event ContractAllowed(address indexed protocol, address indexed adapter);
793	 event ContractForbidden(address indexed protocol);
794	 event NewFastCheckParameters(uint256 chiThreshold, uint256 fastCheckDelay);
795	 event TransferAccountAllowed( address indexed from, address indexed to, bool state );
796	 event TransferPluginAllowed( address indexed pugin, bool state );
797	 event PriceOracleUpdated(address indexed newPriceOracle);
798	 function allowToken(address token, uint256 liquidationThreshold) external;
799	 function allowContract(address targetContract, address adapter) external;
800	 function forbidContract(address targetContract) external;
801	 function checkCollateralChange( address creditAccount, address tokenIn, address tokenOut, uint256 amountIn, uint256 amountOut ) external;
802	 function checkMultiTokenCollateral( address creditAccount, uint256[] memory amountIn, uint256[] memory amountOut, address[] memory tokenIn, address[] memory tokenOut ) external;
803	 function connectCreditManager(address poolService) external;
804	 function initEnabledTokens(address creditAccount) external;
805	 function checkAndEnableToken(address creditAccount, address token) external;
806	 function allowedContractsCount() external view returns (uint256);
807	 function allowedContracts(uint256 id) external view returns (address);
808	 function revertIfTokenNotAllowed(address token) external view;
809	 function isTokenAllowed(address token) external view returns (bool);
810	 function allowedTokensCount() external view returns (uint256);
811	 function allowedTokens(uint256 id) external view returns (address);
812	 function calcTotalValue(address creditAccount) external view returns (uint256 total);
813	 function calcThresholdWeightedValue(address creditAccount) external view returns (uint256 total);
814	 function contractToAdapter(address allowedContract) external view returns (address);
815	 function underlyingToken() external view returns (address);
816	 function getCreditAccountTokenById(address creditAccount, uint256 id) external view returns ( address token, uint256 balance, uint256 tv, uint256 twv );
817	 function calcCreditAccountHealthFactor(address creditAccount) external view returns (uint256);
818	 function calcCreditAccountAccruedInterest(address creditAccount) external view returns (uint256);
819	 function enabledTokens(address creditAccount) external view returns (uint256);
820	 function liquidationThresholds(address token) external view returns (uint256);
821	 function priceOracle() external view returns (address);
822	 function updateUnderlyingTokenLiquidationThreshold() external;
823	 function revertIfCantIncreaseBorrowing( address creditAccount, uint256 minHealthFactor ) external view;
824	 function revertIfAccountTransferIsNotAllowed( address onwer, address creditAccount ) external view;
825	 function approveAccountTransfers(address from, bool state) external;
826	 function allowanceForAccountTransfers(address from, address to) external view returns (bool);
827	 }
828	 pragma solidity ^0.7.4;
829	 contract PriceOracle is ACLTrait, IPriceOracle {
830	 using SafeMath for uint256;
831	 address public wethAddress;
832	 mapping(address => address) public priceFeeds;
833	 mapping(address => uint256) public decimalsMultipliers;
834	 mapping(address => uint256) public decimalsDividers;
835	 uint constant public version = 1;
836	 constructor(address addressProvider) ACLTrait(addressProvider) {
837	 wethAddress = AddressProvider(addressProvider).getWethToken();
838	 decimalsMultipliers[wethAddress] = 1;
839	 decimalsDividers[wethAddress] = Constants.WAD;
840	 }
841	 function addPriceFeed(address token, address priceFeed) external override configuratorOnly {
842	 priceFeeds[token] = priceFeed;
843	 uint256 decimals = ERC20(token).decimals();
844	 require( decimals <= 18, Errors.PO_TOKENS_WITH_DECIMALS_MORE_18_ISNT_ALLOWED );
845	 require( AggregatorV3Interface(priceFeed).decimals() == 18, Errors.PO_AGGREGATOR_DECIMALS_SHOULD_BE_18 );
846	 decimalsMultipliers[token] = 10**(18 - decimals);
847	 decimalsDividers[token] = 10**(36 - decimals);
848	 emit NewPriceFeed(token, priceFeed);
849	 }
850	 function convert( uint256 amount, address tokenFrom, address tokenTo ) external view override returns (uint256) {
851	 return amount .mul(decimalsMultipliers[tokenFrom]) .mul(getLastPrice(tokenFrom, tokenTo)) .div(decimalsDividers[tokenTo]);
852	 }
853	 function getLastPrice(address tokenFrom, address tokenTo) public view override returns (uint256) {
854	 if (tokenFrom == tokenTo) return Constants.WAD;
855	 if (tokenFrom == wethAddress) {
856	 return Constants.WAD.mul(Constants.WAD).div(_getPrice(tokenTo));
857	 }
858	 if (tokenTo == wethAddress) {
859	 return _getPrice(tokenFrom);
860	 }
861	 return Constants.WAD.mul(_getPrice(tokenFrom)).div(_getPrice(tokenTo));
862	 }
863	 function _getPrice(address token) internal view returns (uint256) {
864	 require( priceFeeds[token] != address(0), Errors.PO_PRICE_FEED_DOESNT_EXIST );
865	 ( , int256 price, , , ) = AggregatorV3Interface(priceFeeds[token]).latestRoundData();
866	 return uint256(price);
867	 }
868	 }
869	 pragma solidity >=0.6.0 <0.8.0;
870	 contract ERC20 is Context, IERC20 {
871	 using SafeMath for uint256;
872	 mapping (address => uint256) private _balances;
873	 mapping (address => mapping (address => uint256)) private _allowances;
874	 uint256 private _totalSupply;
875	 string private _name;
876	 string private _symbol;
877	 uint8 private _decimals;
878	 constructor (string memory name_, string memory symbol_) public {
879	 _name = name_;
880	 _symbol = symbol_;
881	 _decimals = 18;
882	 }
883	 function name() public view virtual returns (string memory) {
884	 return _name;
885	 }
886	 function symbol() public view virtual returns (string memory) {
887	 return _symbol;
888	 }
889	 function decimals() public view virtual returns (uint8) {
890	 return _decimals;
891	 }
892	 function totalSupply() public view virtual override returns (uint256) {
893	 return _totalSupply;
894	 }
895	 function balanceOf(address account) public view virtual override returns (uint256) {
896	 return _balances[account];
897	 }
898	 function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
899	 _transfer(_msgSender(), recipient, amount);
900	 return true;
901	 }
902	 function allowance(address owner, address spender) public view virtual override returns (uint256) {
903	 return _allowances[owner][spender];
904	 }
905	 function approve(address spender, uint256 amount) public virtual override returns (bool) {
906	 _approve(_msgSender(), spender, amount);
907	 return true;
908	 }
909	 function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
910	 _transfer(sender, recipient, amount);
911	 _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
912	 return true;
913	 }
914	 function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
915	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
916	 return true;
917	 }
918	 function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
919	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
920	 return true;
921	 }
922	 function _transfer(address sender, address recipient, uint256 amount) internal virtual {
923	 require(sender != address(0), "ERC20: transfer from the zero address");
924	 require(recipient != address(0), "ERC20: transfer to the zero address");
925	 _beforeTokenTransfer(sender, recipient, amount);
926	 _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
927	 _balances[recipient] = _balances[recipient].add(amount);
928	 emit Transfer(sender, recipient, amount);
929	 }
930	 function _mint(address account, uint256 amount) internal virtual {
931	 require(account != address(0), "ERC20: mint to the zero address");
932	 _beforeTokenTransfer(address(0), account, amount);
933	 _totalSupply = _totalSupply.add(amount);
934	 _balances[account] = _balances[account].add(amount);
935	 emit Transfer(address(0), account, amount);
936	 }
937	 function _burn(address account, uint256 amount) internal virtual {
938	 require(account != address(0), "ERC20: burn from the zero address");
939	 _beforeTokenTransfer(account, address(0), amount);
940	 _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
941	 _totalSupply = _totalSupply.sub(amount);
942	 emit Transfer(account, address(0), amount);
943	 }
944	 function _approve(address owner, address spender, uint256 amount) internal virtual {
945	 require(owner != address(0), "ERC20: approve from the zero address");
946	 require(spender != address(0), "ERC20: approve to the zero address");
947	 _allowances[owner][spender] = amount;
948	 emit Approval(owner, spender, amount);
949	 }
950	 function _setupDecimals(uint8 decimals_) internal virtual {
951	 _decimals = decimals_;
952	 }
953	 function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {
954	 }
955	 }
956	 pragma solidity >=0.5.0;
957	 interface IUniswapV3SwapCallback {
958	 function uniswapV3SwapCallback( int256 amount0Delta, int256 amount1Delta, bytes calldata data ) external;
959	 }
960	 pragma solidity ^0.7.4;
961	 library PercentageMath {
962	 uint256 constant PERCENTAGE_FACTOR = 1e4;
963	 uint256 constant HALF_PERCENT = PERCENTAGE_FACTOR / 2;
964	 function percentMul(uint256 value, uint256 percentage) internal pure returns (uint256) {
965	 if (value == 0 || percentage == 0) {
966	 return 0;
967	 }
968	 require( value <= (type(uint256).max - HALF_PERCENT) / percentage, Errors.MATH_MULTIPLICATION_OVERFLOW );
969	 return (value * percentage + HALF_PERCENT) / PERCENTAGE_FACTOR;
970	 }
971	 function percentDiv(uint256 value, uint256 percentage) internal pure returns (uint256) {
972	 require(percentage != 0, Errors.MATH_DIVISION_BY_ZERO);
973	 uint256 halfPercentage = percentage / 2;
974	 require( value <= (type(uint256).max - halfPercentage) / PERCENTAGE_FACTOR, Errors.MATH_MULTIPLICATION_OVERFLOW );
975	 return (value * PERCENTAGE_FACTOR + halfPercentage) / percentage;
976	 }
977	 }
978	 pragma solidity ^0.7.4;
979	 contract ACL is Ownable {
980	 mapping(address => bool) public pausableAdminSet;
981	 mapping(address => bool) public unpausableAdminSet;
982	 uint256 public constant version = 1;
983	 event PausableAdminAdded(address indexed newAdmin);
984	 event PausableAdminRemoved(address indexed admin);
985	 event UnpausableAdminAdded(address indexed newAdmin);
986	 event UnpausableAdminRemoved(address indexed admin);
987	 function addPausableAdmin(address newAdmin) external onlyOwner {
988	 pausableAdminSet[newAdmin] = true;
989	 emit PausableAdminAdded(newAdmin);
990	 }
991	 function removePausableAdmin(address admin) external onlyOwner {
992	 pausableAdminSet[admin] = false;
993	 emit PausableAdminRemoved(admin);
994	 }
995	 function isPausableAdmin(address addr) external view returns (bool) {
996	 return pausableAdminSet[addr];
997	 }
998	 function addUnpausableAdmin(address newAdmin) external onlyOwner {
999	 unpausableAdminSet[newAdmin] = true;
1000	 emit UnpausableAdminAdded(newAdmin);
1001	 }
1002	 function removeUnpausableAdmin(address admin) external onlyOwner {
1003	 unpausableAdminSet[admin] = false;
1004	 emit UnpausableAdminRemoved(admin);
1005	 }
1006	 function isUnpausableAdmin(address addr) external view returns (bool) {
1007	 return unpausableAdminSet[addr];
1008	 }
1009	 function isConfigurator(address account) external view returns (bool) {
1010	 return account == owner();
1011	 }
1012	 }
1013	 pragma solidity ^0.7.4;
1014	 library DataTypes {
1015	 struct Exchange {
1016	 address[] path;
1017	 uint256 amountOutMin;
1018	 }
1019	 struct TokenBalance {
1020	 address token;
1021	 uint256 balance;
1022	 bool isAllowed;
1023	 }
1024	 struct ContractAdapter {
1025	 address allowedContract;
1026	 address adapter;
1027	 }
1028	 struct CreditAccountData {
1029	 address addr;
1030	 address borrower;
1031	 bool inUse;
1032	 address creditManager;
1033	 address underlyingToken;
1034	 uint256 borrowedAmountPlusInterest;
1035	 uint256 totalValue;
1036	 uint256 healthFactor;
1037	 uint256 borrowRate;
1038	 TokenBalance[] balances;
1039	 }
1040	 struct CreditAccountDataExtended {
1041	 address addr;
1042	 address borrower;
1043	 bool inUse;
1044	 address creditManager;
1045	 address underlyingToken;
1046	 uint256 borrowedAmountPlusInterest;
1047	 uint256 totalValue;
1048	 uint256 healthFactor;
1049	 uint256 borrowRate;
1050	 TokenBalance[] balances;
1051	 uint256 repayAmount;
1052	 uint256 liquidationAmount;
1053	 bool canBeClosed;
1054	 uint256 borrowedAmount;
1055	 uint256 cumulativeIndexAtOpen;
1056	 uint256 since;
1057	 }
1058	 struct CreditManagerData {
1059	 address addr;
1060	 bool hasAccount;
1061	 address underlyingToken;
1062	 bool isWETH;
1063	 bool canBorrow;
1064	 uint256 borrowRate;
1065	 uint256 minAmount;
1066	 uint256 maxAmount;
1067	 uint256 maxLeverageFactor;
1068	 uint256 availableLiquidity;
1069	 address[] allowedTokens;
1070	 ContractAdapter[] adapters;
1071	 }
1072	 struct PoolData {
1073	 address addr;
1074	 bool isWETH;
1075	 address underlyingToken;
1076	 address dieselToken;
1077	 uint256 linearCumulativeIndex;
1078	 uint256 availableLiquidity;
1079	 uint256 expectedLiquidity;
1080	 uint256 expectedLiquidityLimit;
1081	 uint256 totalBorrowed;
1082	 uint256 depositAPY_RAY;
1083	 uint256 borrowAPY_RAY;
1084	 uint256 dieselRate_RAY;
1085	 uint256 withdrawFee;
1086	 uint256 cumulativeIndex_RAY;
1087	 uint256 timestampLU;
1088	 }
1089	 struct TokenInfo {
1090	 address addr;
1091	 string symbol;
1092	 uint8 decimals;
1093	 }
1094	 struct AddressProviderData {
1095	 address contractRegister;
1096	 address acl;
1097	 address priceOracle;
1098	 address traderAccountFactory;
1099	 address dataCompressor;
1100	 address farmingFactory;
1101	 address accountMiner;
1102	 address treasuryContract;
1103	 address gearToken;
1104	 address wethToken;
1105	 address wethGateway;
1106	 }
1107	 struct MiningApproval {
1108	 address token;
1109	 address swapContract;
1110	 }
1111	 }
