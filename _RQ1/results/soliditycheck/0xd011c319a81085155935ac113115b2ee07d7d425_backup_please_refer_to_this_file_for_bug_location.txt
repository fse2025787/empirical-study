row number 
1	   pragma solidity ^0.4.11;
2	 pragma solidity >=0.4.18;
3	 contract OraclizeI {
4	 address public cbAddress;
5	 function query(uint _timestamp, string _datasource, string _arg) external payable returns (bytes32 _id);
6	 function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) external payable returns (bytes32 _id);
7	 function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id);
8	 function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) external payable returns (bytes32 _id);
9	 function queryN(uint _timestamp, string _datasource, bytes _argN) public payable returns (bytes32 _id);
10	 function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) external payable returns (bytes32 _id);
11	 function getPrice(string _datasource) public returns (uint _dsprice);
12	 function getPrice(string _datasource, uint gaslimit) public returns (uint _dsprice);
13	 function setProofType(byte _proofType) external;
14	 function setCustomGasPrice(uint _gasPrice) external;
15	 function randomDS_getSessionPubKeyHash() external constant returns(bytes32);
16	 }
17	 contract OraclizeAddrResolverI {
18	 function getAddress() public returns (address _addr);
19	 }
20	 library Buffer {
21	 struct buffer {
22	 bytes buf;
23	 uint capacity;
24	 }
25	 function init(buffer memory buf, uint _capacity) internal pure {
26	 uint capacity = _capacity;
27	 if(capacity % 32 != 0) capacity += 32 - (capacity % 32);
28	 buf.capacity = capacity;
29	 assembly {
30	 let ptr := mload(0x40) mstore(buf, ptr) mstore(ptr, 0) mstore(0x40, add(ptr, capacity)) }
31	 }
32	 function resize(buffer memory buf, uint capacity) private pure {
33	 bytes memory oldbuf = buf.buf;
34	 init(buf, capacity);
35	 append(buf, oldbuf);
36	 }
37	 function max(uint a, uint b) private pure returns(uint) {
38	 if(a > b) {
39	 return a;
40	 }
41	 return b;
42	 }
43	 function append(buffer memory buf, bytes data) internal pure returns(buffer memory) {
44	 if(data.length + buf.buf.length > buf.capacity) {
45	 resize(buf, max(buf.capacity, data.length) * 2);
46	 }
47	 uint dest;
48	 uint src;
49	 uint len = data.length;
50	 assembly {
51	 let bufptr := mload(buf) let buflen := mload(bufptr) dest := add(add(bufptr, buflen), 32) mstore(bufptr, add(buflen, mload(data))) src := add(data, 32) }
52	 for(; len >= 32; len -= 32) {
53	 assembly {
54	 mstore(dest, mload(src)) }
55	 dest += 32;
56	 src += 32;
57	 }
58	 uint mask = 256 ** (32 - len) - 1;
59	 assembly {
60	 let srcpart := and(mload(src), not(mask)) let destpart := and(mload(dest), mask) mstore(dest, or(destpart, srcpart)) }
61	 return buf;
62	 }
63	 function append(buffer memory buf, uint8 data) internal pure {
64	 if(buf.buf.length + 1 > buf.capacity) {
65	 resize(buf, buf.capacity * 2);
66	 }
67	 assembly {
68	 let bufptr := mload(buf) let buflen := mload(bufptr) let dest := add(add(bufptr, buflen), 32) mstore8(dest, data) mstore(bufptr, add(buflen, 1)) }
69	 }
70	 function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {
71	 if(len + buf.buf.length > buf.capacity) {
72	 resize(buf, max(buf.capacity, len) * 2);
73	 }
74	 uint mask = 256 ** len - 1;
75	 assembly {
76	 let bufptr := mload(buf) let buflen := mload(bufptr) let dest := add(add(bufptr, buflen), len) mstore(dest, or(and(mload(dest), not(mask)), data)) mstore(bufptr, add(buflen, len)) }
77	 return buf;
78	 }
79	 }
80	 library CBOR {
81	 using Buffer for Buffer.buffer;
82	 uint8 private constant MAJOR_TYPE_INT = 0;
83	 uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;
84	 uint8 private constant MAJOR_TYPE_BYTES = 2;
85	 uint8 private constant MAJOR_TYPE_STRING = 3;
86	 uint8 private constant MAJOR_TYPE_ARRAY = 4;
87	 uint8 private constant MAJOR_TYPE_MAP = 5;
88	 uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;
89	 function encodeType(Buffer.buffer memory buf, uint8 major, uint value) private pure {
90	 if(value <= 23) {
91	 buf.append(uint8((major << 5) | value));
92	 }
93	 else if(value <= 0xFF) {
94	 buf.append(uint8((major << 5) | 24));
95	 buf.appendInt(value, 1);
96	 }
97	 else if(value <= 0xFFFF) {
98	 buf.append(uint8((major << 5) | 25));
99	 buf.appendInt(value, 2);
100	 }
101	 else if(value <= 0xFFFFFFFF) {
102	 buf.append(uint8((major << 5) | 26));
103	 buf.appendInt(value, 4);
104	 }
105	 else if(value <= 0xFFFFFFFFFFFFFFFF) {
106	 buf.append(uint8((major << 5) | 27));
107	 buf.appendInt(value, 8);
108	 }
109	 }
110	 function encodeIndefiniteLengthType(Buffer.buffer memory buf, uint8 major) private pure {
111	 buf.append(uint8((major << 5) | 31));
112	 }
113	 function encodeUInt(Buffer.buffer memory buf, uint value) internal pure {
114	 encodeType(buf, MAJOR_TYPE_INT, value);
115	 }
116	 function encodeInt(Buffer.buffer memory buf, int value) internal pure {
117	 if(value >= 0) {
118	 encodeType(buf, MAJOR_TYPE_INT, uint(value));
119	 }
120	 else {
121	 encodeType(buf, MAJOR_TYPE_NEGATIVE_INT, uint(-1 - value));
122	 }
123	 }
124	 function encodeBytes(Buffer.buffer memory buf, bytes value) internal pure {
125	 encodeType(buf, MAJOR_TYPE_BYTES, value.length);
126	 buf.append(value);
127	 }
128	 function encodeString(Buffer.buffer memory buf, string value) internal pure {
129	 encodeType(buf, MAJOR_TYPE_STRING, bytes(value).length);
130	 buf.append(bytes(value));
131	 }
132	 function startArray(Buffer.buffer memory buf) internal pure {
133	 encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);
134	 }
135	 function startMap(Buffer.buffer memory buf) internal pure {
136	 encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);
137	 }
138	 function endSequence(Buffer.buffer memory buf) internal pure {
139	 encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);
140	 }
141	 }
142	 contract usingOraclize {
143	 uint constant day = 60*60*24;
144	 uint constant week = 60*60*24*7;
145	 uint constant month = 60*60*24*30;
146	 byte constant proofType_NONE = 0x00;
147	 byte constant proofType_TLSNotary = 0x10;
148	 byte constant proofType_Ledger = 0x30;
149	 byte constant proofType_Android = 0x40;
150	 byte constant proofType_Native = 0xF0;
151	 byte constant proofStorage_IPFS = 0x01;
152	 uint8 constant networkID_auto = 0;
153	 uint8 constant networkID_mainnet = 1;
154	 uint8 constant networkID_testnet = 2;
155	 uint8 constant networkID_morden = 2;
156	 uint8 constant networkID_consensys = 161;
157	 OraclizeAddrResolverI OAR;
158	 OraclizeI oraclize;
159	 modifier oraclizeAPI {
160	 if((address(OAR)==0)||(getCodeSize(address(OAR))==0)) oraclize_setNetwork(networkID_auto);
161	 if(address(oraclize) != OAR.getAddress()) oraclize = OraclizeI(OAR.getAddress());
162	 _;
163	 }
164	 modifier coupon(string code){
165	 oraclize = OraclizeI(OAR.getAddress());
166	 _;
167	 }
168	 function oraclize_setNetwork(uint8 networkID) internal returns(bool){
169	 return oraclize_setNetwork();
170	 networkID;
171	 }
172	 function oraclize_setNetwork() internal returns(bool){
173	 if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){
174	 OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);
175	 oraclize_setNetworkName("eth_mainnet");
176	 return true;
177	 }
178	 if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){
179	 OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);
180	 oraclize_setNetworkName("eth_ropsten3");
181	 return true;
182	 }
183	 if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){
184	 OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);
185	 oraclize_setNetworkName("eth_kovan");
186	 return true;
187	 }
188	 if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){
189	 OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);
190	 oraclize_setNetworkName("eth_rinkeby");
191	 return true;
192	 }
193	 if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){
194	 OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);
195	 return true;
196	 }
197	 if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){
198	 OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);
199	 return true;
200	 }
201	 if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){
202	 OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);
203	 return true;
204	 }
205	 return false;
206	 }
207	 function __callback(bytes32 myid, string result) public {
208	 __callback(myid, result, new bytes(0));
209	 }
210	 function __callback(bytes32 myid, string result, bytes proof) public {
211	 return;
212	 myid;
213	 result;
214	 proof;
215	 }
216	 function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){
217	 return oraclize.getPrice(datasource);
218	 }
219	 function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){
220	 return oraclize.getPrice(datasource, gaslimit);
221	 }
222	 function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){
223	 uint price = oraclize.getPrice(datasource);
224	 if (price > 1 ether + tx.gasprice*200000) return 0;
225	 return oraclize.query.value(price)(0, datasource, arg);
226	 }
227	 function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){
228	 uint price = oraclize.getPrice(datasource);
229	 if (price > 1 ether + tx.gasprice*200000) return 0;
230	 return oraclize.query.value(price)(timestamp, datasource, arg);
231	 }
232	 function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
233	 uint price = oraclize.getPrice(datasource, gaslimit);
234	 if (price > 1 ether + tx.gasprice*gaslimit) return 0;
235	 return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);
236	 }
237	 function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
238	 uint price = oraclize.getPrice(datasource, gaslimit);
239	 if (price > 1 ether + tx.gasprice*gaslimit) return 0;
240	 return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);
241	 }
242	 function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){
243	 uint price = oraclize.getPrice(datasource);
244	 if (price > 1 ether + tx.gasprice*200000) return 0;
245	 return oraclize.query2.value(price)(0, datasource, arg1, arg2);
246	 }
247	 function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){
248	 uint price = oraclize.getPrice(datasource);
249	 if (price > 1 ether + tx.gasprice*200000) return 0;
250	 return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);
251	 }
252	 function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
253	 uint price = oraclize.getPrice(datasource, gaslimit);
254	 if (price > 1 ether + tx.gasprice*gaslimit) return 0;
255	 return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);
256	 }
257	 function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
258	 uint price = oraclize.getPrice(datasource, gaslimit);
259	 if (price > 1 ether + tx.gasprice*gaslimit) return 0;
260	 return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);
261	 }
262	 function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){
263	 uint price = oraclize.getPrice(datasource);
264	 if (price > 1 ether + tx.gasprice*200000) return 0;
265	 bytes memory args = stra2cbor(argN);
266	 return oraclize.queryN.value(price)(0, datasource, args);
267	 }
268	 function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){
269	 uint price = oraclize.getPrice(datasource);
270	 if (price > 1 ether + tx.gasprice*200000) return 0;
271	 bytes memory args = stra2cbor(argN);
272	 return oraclize.queryN.value(price)(timestamp, datasource, args);
273	 }
274	 function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
275	 uint price = oraclize.getPrice(datasource, gaslimit);
276	 if (price > 1 ether + tx.gasprice*gaslimit) return 0;
277	 bytes memory args = stra2cbor(argN);
278	 return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);
279	 }
280	 function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
281	 uint price = oraclize.getPrice(datasource, gaslimit);
282	 if (price > 1 ether + tx.gasprice*gaslimit) return 0;
283	 bytes memory args = stra2cbor(argN);
284	 return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);
285	 }
286	 function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {
287	 string[] memory dynargs = new string[](1);
288	 dynargs[0] = args[0];
289	 return oraclize_query(datasource, dynargs);
290	 }
291	 function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {
292	 string[] memory dynargs = new string[](1);
293	 dynargs[0] = args[0];
294	 return oraclize_query(timestamp, datasource, dynargs);
295	 }
296	 function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
297	 string[] memory dynargs = new string[](1);
298	 dynargs[0] = args[0];
299	 return oraclize_query(timestamp, datasource, dynargs, gaslimit);
300	 }
301	 function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
302	 string[] memory dynargs = new string[](1);
303	 dynargs[0] = args[0];
304	 return oraclize_query(datasource, dynargs, gaslimit);
305	 }
306	 function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {
307	 string[] memory dynargs = new string[](2);
308	 dynargs[0] = args[0];
309	 dynargs[1] = args[1];
310	 return oraclize_query(datasource, dynargs);
311	 }
312	 function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {
313	 string[] memory dynargs = new string[](2);
314	 dynargs[0] = args[0];
315	 dynargs[1] = args[1];
316	 return oraclize_query(timestamp, datasource, dynargs);
317	 }
318	 function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
319	 string[] memory dynargs = new string[](2);
320	 dynargs[0] = args[0];
321	 dynargs[1] = args[1];
322	 return oraclize_query(timestamp, datasource, dynargs, gaslimit);
323	 }
324	 function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
325	 string[] memory dynargs = new string[](2);
326	 dynargs[0] = args[0];
327	 dynargs[1] = args[1];
328	 return oraclize_query(datasource, dynargs, gaslimit);
329	 }
330	 function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {
331	 string[] memory dynargs = new string[](3);
332	 dynargs[0] = args[0];
333	 dynargs[1] = args[1];
334	 dynargs[2] = args[2];
335	 return oraclize_query(datasource, dynargs);
336	 }
337	 function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {
338	 string[] memory dynargs = new string[](3);
339	 dynargs[0] = args[0];
340	 dynargs[1] = args[1];
341	 dynargs[2] = args[2];
342	 return oraclize_query(timestamp, datasource, dynargs);
343	 }
344	 function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
345	 string[] memory dynargs = new string[](3);
346	 dynargs[0] = args[0];
347	 dynargs[1] = args[1];
348	 dynargs[2] = args[2];
349	 return oraclize_query(timestamp, datasource, dynargs, gaslimit);
350	 }
351	 function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
352	 string[] memory dynargs = new string[](3);
353	 dynargs[0] = args[0];
354	 dynargs[1] = args[1];
355	 dynargs[2] = args[2];
356	 return oraclize_query(datasource, dynargs, gaslimit);
357	 }
358	 function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {
359	 string[] memory dynargs = new string[](4);
360	 dynargs[0] = args[0];
361	 dynargs[1] = args[1];
362	 dynargs[2] = args[2];
363	 dynargs[3] = args[3];
364	 return oraclize_query(datasource, dynargs);
365	 }
366	 function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {
367	 string[] memory dynargs = new string[](4);
368	 dynargs[0] = args[0];
369	 dynargs[1] = args[1];
370	 dynargs[2] = args[2];
371	 dynargs[3] = args[3];
372	 return oraclize_query(timestamp, datasource, dynargs);
373	 }
374	 function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
375	 string[] memory dynargs = new string[](4);
376	 dynargs[0] = args[0];
377	 dynargs[1] = args[1];
378	 dynargs[2] = args[2];
379	 dynargs[3] = args[3];
380	 return oraclize_query(timestamp, datasource, dynargs, gaslimit);
381	 }
382	 function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
383	 string[] memory dynargs = new string[](4);
384	 dynargs[0] = args[0];
385	 dynargs[1] = args[1];
386	 dynargs[2] = args[2];
387	 dynargs[3] = args[3];
388	 return oraclize_query(datasource, dynargs, gaslimit);
389	 }
390	 function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {
391	 string[] memory dynargs = new string[](5);
392	 dynargs[0] = args[0];
393	 dynargs[1] = args[1];
394	 dynargs[2] = args[2];
395	 dynargs[3] = args[3];
396	 dynargs[4] = args[4];
397	 return oraclize_query(datasource, dynargs);
398	 }
399	 function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {
400	 string[] memory dynargs = new string[](5);
401	 dynargs[0] = args[0];
402	 dynargs[1] = args[1];
403	 dynargs[2] = args[2];
404	 dynargs[3] = args[3];
405	 dynargs[4] = args[4];
406	 return oraclize_query(timestamp, datasource, dynargs);
407	 }
408	 function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
409	 string[] memory dynargs = new string[](5);
410	 dynargs[0] = args[0];
411	 dynargs[1] = args[1];
412	 dynargs[2] = args[2];
413	 dynargs[3] = args[3];
414	 dynargs[4] = args[4];
415	 return oraclize_query(timestamp, datasource, dynargs, gaslimit);
416	 }
417	 function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
418	 string[] memory dynargs = new string[](5);
419	 dynargs[0] = args[0];
420	 dynargs[1] = args[1];
421	 dynargs[2] = args[2];
422	 dynargs[3] = args[3];
423	 dynargs[4] = args[4];
424	 return oraclize_query(datasource, dynargs, gaslimit);
425	 }
426	 function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){
427	 uint price = oraclize.getPrice(datasource);
428	 if (price > 1 ether + tx.gasprice*200000) return 0;
429	 bytes memory args = ba2cbor(argN);
430	 return oraclize.queryN.value(price)(0, datasource, args);
431	 }
432	 function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){
433	 uint price = oraclize.getPrice(datasource);
434	 if (price > 1 ether + tx.gasprice*200000) return 0;
435	 bytes memory args = ba2cbor(argN);
436	 return oraclize.queryN.value(price)(timestamp, datasource, args);
437	 }
438	 function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
439	 uint price = oraclize.getPrice(datasource, gaslimit);
440	 if (price > 1 ether + tx.gasprice*gaslimit) return 0;
441	 bytes memory args = ba2cbor(argN);
442	 return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);
443	 }
444	 function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
445	 uint price = oraclize.getPrice(datasource, gaslimit);
446	 if (price > 1 ether + tx.gasprice*gaslimit) return 0;
447	 bytes memory args = ba2cbor(argN);
448	 return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);
449	 }
450	 function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {
451	 bytes[] memory dynargs = new bytes[](1);
452	 dynargs[0] = args[0];
453	 return oraclize_query(datasource, dynargs);
454	 }
455	 function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {
456	 bytes[] memory dynargs = new bytes[](1);
457	 dynargs[0] = args[0];
458	 return oraclize_query(timestamp, datasource, dynargs);
459	 }
460	 function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
461	 bytes[] memory dynargs = new bytes[](1);
462	 dynargs[0] = args[0];
463	 return oraclize_query(timestamp, datasource, dynargs, gaslimit);
464	 }
465	 function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
466	 bytes[] memory dynargs = new bytes[](1);
467	 dynargs[0] = args[0];
468	 return oraclize_query(datasource, dynargs, gaslimit);
469	 }
470	 function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {
471	 bytes[] memory dynargs = new bytes[](2);
472	 dynargs[0] = args[0];
473	 dynargs[1] = args[1];
474	 return oraclize_query(datasource, dynargs);
475	 }
476	 function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {
477	 bytes[] memory dynargs = new bytes[](2);
478	 dynargs[0] = args[0];
479	 dynargs[1] = args[1];
480	 return oraclize_query(timestamp, datasource, dynargs);
481	 }
482	 function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
483	 bytes[] memory dynargs = new bytes[](2);
484	 dynargs[0] = args[0];
485	 dynargs[1] = args[1];
486	 return oraclize_query(timestamp, datasource, dynargs, gaslimit);
487	 }
488	 function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
489	 bytes[] memory dynargs = new bytes[](2);
490	 dynargs[0] = args[0];
491	 dynargs[1] = args[1];
492	 return oraclize_query(datasource, dynargs, gaslimit);
493	 }
494	 function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {
495	 bytes[] memory dynargs = new bytes[](3);
496	 dynargs[0] = args[0];
497	 dynargs[1] = args[1];
498	 dynargs[2] = args[2];
499	 return oraclize_query(datasource, dynargs);
500	 }
501	 function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {
502	 bytes[] memory dynargs = new bytes[](3);
503	 dynargs[0] = args[0];
504	 dynargs[1] = args[1];
505	 dynargs[2] = args[2];
506	 return oraclize_query(timestamp, datasource, dynargs);
507	 }
508	 function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
509	 bytes[] memory dynargs = new bytes[](3);
510	 dynargs[0] = args[0];
511	 dynargs[1] = args[1];
512	 dynargs[2] = args[2];
513	 return oraclize_query(timestamp, datasource, dynargs, gaslimit);
514	 }
515	 function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
516	 bytes[] memory dynargs = new bytes[](3);
517	 dynargs[0] = args[0];
518	 dynargs[1] = args[1];
519	 dynargs[2] = args[2];
520	 return oraclize_query(datasource, dynargs, gaslimit);
521	 }
522	 function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {
523	 bytes[] memory dynargs = new bytes[](4);
524	 dynargs[0] = args[0];
525	 dynargs[1] = args[1];
526	 dynargs[2] = args[2];
527	 dynargs[3] = args[3];
528	 return oraclize_query(datasource, dynargs);
529	 }
530	 function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {
531	 bytes[] memory dynargs = new bytes[](4);
532	 dynargs[0] = args[0];
533	 dynargs[1] = args[1];
534	 dynargs[2] = args[2];
535	 dynargs[3] = args[3];
536	 return oraclize_query(timestamp, datasource, dynargs);
537	 }
538	 function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
539	 bytes[] memory dynargs = new bytes[](4);
540	 dynargs[0] = args[0];
541	 dynargs[1] = args[1];
542	 dynargs[2] = args[2];
543	 dynargs[3] = args[3];
544	 return oraclize_query(timestamp, datasource, dynargs, gaslimit);
545	 }
546	 function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
547	 bytes[] memory dynargs = new bytes[](4);
548	 dynargs[0] = args[0];
549	 dynargs[1] = args[1];
550	 dynargs[2] = args[2];
551	 dynargs[3] = args[3];
552	 return oraclize_query(datasource, dynargs, gaslimit);
553	 }
554	 function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {
555	 bytes[] memory dynargs = new bytes[](5);
556	 dynargs[0] = args[0];
557	 dynargs[1] = args[1];
558	 dynargs[2] = args[2];
559	 dynargs[3] = args[3];
560	 dynargs[4] = args[4];
561	 return oraclize_query(datasource, dynargs);
562	 }
563	 function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {
564	 bytes[] memory dynargs = new bytes[](5);
565	 dynargs[0] = args[0];
566	 dynargs[1] = args[1];
567	 dynargs[2] = args[2];
568	 dynargs[3] = args[3];
569	 dynargs[4] = args[4];
570	 return oraclize_query(timestamp, datasource, dynargs);
571	 }
572	 function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
573	 bytes[] memory dynargs = new bytes[](5);
574	 dynargs[0] = args[0];
575	 dynargs[1] = args[1];
576	 dynargs[2] = args[2];
577	 dynargs[3] = args[3];
578	 dynargs[4] = args[4];
579	 return oraclize_query(timestamp, datasource, dynargs, gaslimit);
580	 }
581	 function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
582	 bytes[] memory dynargs = new bytes[](5);
583	 dynargs[0] = args[0];
584	 dynargs[1] = args[1];
585	 dynargs[2] = args[2];
586	 dynargs[3] = args[3];
587	 dynargs[4] = args[4];
588	 return oraclize_query(datasource, dynargs, gaslimit);
589	 }
590	 function oraclize_cbAddress() oraclizeAPI internal returns (address){
591	 return oraclize.cbAddress();
592	 }
593	 function oraclize_setProof(byte proofP) oraclizeAPI internal {
594	 return oraclize.setProofType(proofP);
595	 }
596	 function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {
597	 return oraclize.setCustomGasPrice(gasPrice);
598	 }
599	 function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){
600	 return oraclize.randomDS_getSessionPubKeyHash();
601	 }
602	 function getCodeSize(address _addr) constant internal returns(uint _size) {
603	 assembly {
604	 _size := extcodesize(_addr) }
605	 }
606	 function parseAddr(string _a) internal pure returns (address){
607	 bytes memory tmp = bytes(_a);
608	 uint160 iaddr = 0;
609	 uint160 b1;
610	 uint160 b2;
611	 for (uint i=2; i<2+2*20; i+=2){
612	 iaddr *= 256;
613	 b1 = uint160(tmp[i]);
614	 b2 = uint160(tmp[i+1]);
615	 if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;
616	 else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;
617	 else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;
618	 if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;
619	 else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;
620	 else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;
621	 iaddr += (b1*16+b2);
622	 }
623	 return address(iaddr);
624	 }
625	 function strCompare(string _a, string _b) internal pure returns (int) {
626	 bytes memory a = bytes(_a);
627	 bytes memory b = bytes(_b);
628	 uint minLength = a.length;
629	 if (b.length < minLength) minLength = b.length;
630	 for (uint i = 0; i < minLength; i ++) if (a[i] < b[i]) return -1;
631	 else if (a[i] > b[i]) return 1;
632	 if (a.length < b.length) return -1;
633	 else if (a.length > b.length) return 1;
634	 else return 0;
635	 }
636	 function indexOf(string _haystack, string _needle) internal pure returns (int) {
637	 bytes memory h = bytes(_haystack);
638	 bytes memory n = bytes(_needle);
639	 if(h.length < 1 || n.length < 1 || (n.length > h.length)) return -1;
640	 else if(h.length > (2**128 -1)) return -1;
641	 else {
642	 uint subindex = 0;
643	 for (uint i = 0; i < h.length; i ++) {
644	 if (h[i] == n[0]) {
645	 subindex = 1;
646	 while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex]) {
647	 subindex++;
648	 }
649	 if(subindex == n.length) return int(i);
650	 }
651	 }
652	 return -1;
653	 }
654	 }
655	 function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {
656	 bytes memory _ba = bytes(_a);
657	 bytes memory _bb = bytes(_b);
658	 bytes memory _bc = bytes(_c);
659	 bytes memory _bd = bytes(_d);
660	 bytes memory _be = bytes(_e);
661	 string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);
662	 bytes memory babcde = bytes(abcde);
663	 uint k = 0;
664	 for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];
665	 for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];
666	 for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];
667	 for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];
668	 for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];
669	 return string(babcde);
670	 }
671	 function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {
672	 return strConcat(_a, _b, _c, _d, "");
673	 }
674	 function strConcat(string _a, string _b, string _c) internal pure returns (string) {
675	 return strConcat(_a, _b, _c, "", "");
676	 }
677	 function strConcat(string _a, string _b) internal pure returns (string) {
678	 return strConcat(_a, _b, "", "", "");
679	 }
680	 function parseInt(string _a) internal pure returns (uint) {
681	 return parseInt(_a, 0);
682	 }
683	 function parseInt(string _a, uint _b) internal pure returns (uint) {
684	 bytes memory bresult = bytes(_a);
685	 uint mint = 0;
686	 bool decimals = false;
687	 for (uint i=0; i<bresult.length; i++){
688	 if ((bresult[i] >= 48)&&(bresult[i] <= 57)){
689	 if (decimals){
690	 if (_b == 0) break;
691	 else _b--;
692	 }
693	 mint *= 10;
694	 mint += uint(bresult[i]) - 48;
695	 }
696	 else if (bresult[i] == 46) decimals = true;
697	 }
698	 if (_b > 0) mint *= 10**_b;
699	 return mint;
700	 }
701	 function uint2str(uint i) internal pure returns (string){
702	 if (i == 0) return "0";
703	 uint j = i;
704	 uint len;
705	 while (j != 0){
706	 len++;
707	 j /= 10;
708	 }
709	 bytes memory bstr = new bytes(len);
710	 uint k = len - 1;
711	 while (i != 0){
712	 bstr[k--] = byte(48 + i % 10);
713	 i /= 10;
714	 }
715	 return string(bstr);
716	 }
717	 using CBOR for Buffer.buffer;
718	 function stra2cbor(string[] arr) internal pure returns (bytes) {
719	 safeMemoryCleaner();
720	 Buffer.buffer memory buf;
721	 Buffer.init(buf, 1024);
722	 buf.startArray();
723	 for (uint i = 0; i < arr.length; i++) {
724	 buf.encodeString(arr[i]);
725	 }
726	 buf.endSequence();
727	 return buf.buf;
728	 }
729	 function ba2cbor(bytes[] arr) internal pure returns (bytes) {
730	 safeMemoryCleaner();
731	 Buffer.buffer memory buf;
732	 Buffer.init(buf, 1024);
733	 buf.startArray();
734	 for (uint i = 0; i < arr.length; i++) {
735	 buf.encodeBytes(arr[i]);
736	 }
737	 buf.endSequence();
738	 return buf.buf;
739	 }
740	 string oraclize_network_name;
741	 function oraclize_setNetworkName(string _network_name) internal {
742	 oraclize_network_name = _network_name;
743	 }
744	 function oraclize_getNetworkName() internal view returns (string) {
745	 return oraclize_network_name;
746	 }
747	 function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){
748	 require((_nbytes > 0) && (_nbytes <= 32));
749	 _delay *= 10;
750	 bytes memory nbytes = new bytes(1);
751	 nbytes[0] = byte(_nbytes);
752	 bytes memory unonce = new bytes(32);
753	 bytes memory sessionKeyHash = new bytes(32);
754	 bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();
755	 assembly {
756	 mstore(unonce, 0x20) mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp))) mstore(sessionKeyHash, 0x20) mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32) }
757	 bytes memory delay = new bytes(32);
758	 assembly {
759	 mstore(add(delay, 0x20), _delay) }
760	 bytes memory delay_bytes8 = new bytes(8);
761	 copyBytes(delay, 24, 8, delay_bytes8, 0);
762	 bytes[4] memory args = [unonce, nbytes, sessionKeyHash, delay];
763	 bytes32 queryId = oraclize_query("random", args, _customGasLimit);
764	 bytes memory delay_bytes8_left = new bytes(8);
765	 assembly {
766	 let x := mload(add(delay_bytes8, 0x20)) mstore8(add(delay_bytes8_left, 0x27), div(x, 0x100000000000000000000000000000000000000000000000000000000000000)) mstore8(add(delay_bytes8_left, 0x26), div(x, 0x1000000000000000000000000000000000000000000000000000000000000)) mstore8(add(delay_bytes8_left, 0x25), div(x, 0x10000000000000000000000000000000000000000000000000000000000)) mstore8(add(delay_bytes8_left, 0x24), div(x, 0x100000000000000000000000000000000000000000000000000000000)) mstore8(add(delay_bytes8_left, 0x23), div(x, 0x1000000000000000000000000000000000000000000000000000000)) mstore8(add(delay_bytes8_left, 0x22), div(x, 0x10000000000000000000000000000000000000000000000000000)) mstore8(add(delay_bytes8_left, 0x21), div(x, 0x100000000000000000000000000000000000000000000000000)) mstore8(add(delay_bytes8_left, 0x20), div(x, 0x1000000000000000000000000000000000000000000000000)) }
767	 oraclize_randomDS_setCommitment(queryId, keccak256(delay_bytes8_left, args[1], sha256(args[0]), args[2]));
768	 return queryId;
769	 }
770	 function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {
771	 oraclize_randomDS_args[queryId] = commitment;
772	 }
773	 mapping(bytes32=>bytes32) oraclize_randomDS_args;
774	 mapping(bytes32=>bool) oraclize_randomDS_sessionKeysHashVerified;
775	 function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){
776	 bool sigok;
777	 address signer;
778	 bytes32 sigr;
779	 bytes32 sigs;
780	 bytes memory sigr_ = new bytes(32);
781	 uint offset = 4+(uint(dersig[3]) - 0x20);
782	 sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);
783	 bytes memory sigs_ = new bytes(32);
784	 offset += 32 + 2;
785	 sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);
786	 assembly {
787	 sigr := mload(add(sigr_, 32)) sigs := mload(add(sigs_, 32)) }
788	 (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);
789	 if (address(keccak256(pubkey)) == signer) return true;
790	 else {
791	 (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);
792	 return (address(keccak256(pubkey)) == signer);
793	 }
794	 }
795	 function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {
796	 bool sigok;
797	 bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);
798	 copyBytes(proof, sig2offset, sig2.length, sig2, 0);
799	 bytes memory appkey1_pubkey = new bytes(64);
800	 copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);
801	 bytes memory tosign2 = new bytes(1+65+32);
802	 tosign2[0] = byte(1);
803	 copyBytes(proof, sig2offset-65, 65, tosign2, 1);
804	 bytes memory CODEHASH = hex"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c";
805	 copyBytes(CODEHASH, 0, 32, tosign2, 1+65);
806	 sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);
807	 if (sigok == false) return false;
808	 bytes memory LEDGERKEY = hex"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4";
809	 bytes memory tosign3 = new bytes(1+65);
810	 tosign3[0] = 0xFE;
811	 copyBytes(proof, 3, 65, tosign3, 1);
812	 bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);
813	 copyBytes(proof, 3+65, sig3.length, sig3, 0);
814	 sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);
815	 return sigok;
816	 }
817	 modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {
818	 require((_proof[0] == "L") && (_proof[1] == "P") && (_proof[2] == 1));
819	 bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());
820	 require(proofVerified);
821	 _;
822	 }
823	 function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){
824	 if ((_proof[0] != "L")||(_proof[1] != "P")||(_proof[2] != 1)) return 1;
825	 bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());
826	 if (proofVerified == false) return 2;
827	 return 0;
828	 }
829	 function matchBytes32Prefix(bytes32 content, bytes prefix, uint n_random_bytes) internal pure returns (bool){
830	 bool match_ = true;
831	 require(prefix.length == n_random_bytes);
832	 for (uint256 i=0; i< n_random_bytes; i++) {
833	 if (content[i] != prefix[i]) match_ = false;
834	 }
835	 return match_;
836	 }
837	 function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){
838	 uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;
839	 bytes memory keyhash = new bytes(32);
840	 copyBytes(proof, ledgerProofLength, 32, keyhash, 0);
841	 if (!(keccak256(keyhash) == keccak256(sha256(context_name, queryId)))) return false;
842	 bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);
843	 copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);
844	 if (!matchBytes32Prefix(sha256(sig1), result, uint(proof[ledgerProofLength+32+8]))) return false;
845	 bytes memory commitmentSlice1 = new bytes(8+1+32);
846	 copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);
847	 bytes memory sessionPubkey = new bytes(64);
848	 uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;
849	 copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);
850	 bytes32 sessionPubkeyHash = sha256(sessionPubkey);
851	 if (oraclize_randomDS_args[queryId] == keccak256(commitmentSlice1, sessionPubkeyHash)){
852	 delete oraclize_randomDS_args[queryId];
853	 }
854	 else return false;
855	 bytes memory tosign1 = new bytes(32+8+1+32);
856	 copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);
857	 if (!verifySig(sha256(tosign1), sig1, sessionPubkey)) return false;
858	 if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){
859	 oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);
860	 }
861	 return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];
862	 }
863	 function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {
864	 uint minLength = length + toOffset;
865	 require(to.length >= minLength);
866	 uint i = 32 + fromOffset;
867	 uint j = 32 + toOffset;
868	 while (i < (32 + fromOffset + length)) {
869	 assembly {
870	 let tmp := mload(add(from, i)) mstore(add(to, j), tmp) }
871	 i += 32;
872	 j += 32;
873	 }
874	 return to;
875	 }
876	 function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {
877	 bool ret;
878	 address addr;
879	 assembly {
880	 let size := mload(0x40) mstore(size, hash) mstore(add(size, 32), v) mstore(add(size, 64), r) mstore(add(size, 96), s) ret := call(3000, 1, 0, size, 128, size, 32) addr := mload(size) }
881	 return (ret, addr);
882	 }
883	 function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {
884	 bytes32 r;
885	 bytes32 s;
886	 uint8 v;
887	 if (sig.length != 65) return (false, 0);
888	 assembly {
889	 r := mload(add(sig, 32)) s := mload(add(sig, 64)) v := byte(0, mload(add(sig, 96))) }
890	 if (v < 27) v += 27;
891	 if (v != 27 && v != 28) return (false, 0);
892	 return safer_ecrecover(hash, v, r, s);
893	 }
894	 function safeMemoryCleaner() internal pure {
895	 assembly {
896	 let fmem := mload(0x40) codecopy(fmem, codesize, sub(msize, fmem)) }
897	 }
898	 }
899	 library SafeMath {
900	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
901	 uint256 c = a * b;
902	 assert(a == 0 || c / a == b);
903	 return c;
904	 }
905	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
906	 uint256 c = a / b;
907	 return c;
908	 }
909	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
910	 assert(b <= a);
911	 return a - b;
912	 }
913	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
914	 uint256 c = a + b;
915	 assert(c >= a);
916	 return c;
917	 }
918	 }
919	 interface token {
920	 function transfer(address , uint ) external;
921	 }
922	 contract Crowdsale is usingOraclize {
923	 using SafeMath for uint256;
924	 address public wallet;
925	 address public addressOfTokenUsedAsReward;
926	 token tokenReward;
927	 uint256 public weiRaised;
928	 event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);
929	 constructor () public {
930	 wallet = 0xE35120FbF4Fe6d9895cc8a93BD0796b5cB89e776;
931	 addressOfTokenUsedAsReward = 0x84Ed1B54fa1A26012E6fcA29d55B00BB15bb1deF;
932	 tokenReward = token(addressOfTokenUsedAsReward);
933	 }
934	 bool public started = true;
935	 function startSale() public {
936	 require (msg.sender == wallet);
937	 started = true;
938	 }
939	 function stopSale() public {
940	 require (msg.sender == wallet);
941	 started = false;
942	 }
943	 function changeWallet(address _wallet) public {
944	 require (msg.sender == wallet);
945	 wallet = _wallet;
946	 }
947	 function changeTokenReward(address _token) public {
948	 require(msg.sender==wallet);
949	 tokenReward = token(_token);
950	 addressOfTokenUsedAsReward = _token;
951	 }
952	 function () public payable {
953	 buyTokens(msg.sender);
954	 }
955	 mapping (bytes32 => address) public idToBeneficiary;
956	 mapping (bytes32 => uint) public idToWeiAmount;
957	 event newOraclizeQuery(string description);
958	 function __callback(bytes32 myid, string result) public {
959	 require (msg.sender == oraclize_cbAddress());
960	 address beneficiary = idToBeneficiary[myid];
961	 uint weiAmount = idToWeiAmount[myid];
962	 uint ethToCents = parseInt(result,2);
963	 uint tokens = weiAmount.mul(ethToCents)/100;
964	 tokenReward.transfer(beneficiary, tokens);
965	 emit TokenPurchase(beneficiary, beneficiary, weiAmount, tokens);
966	 }
967	 function buyTokens(address beneficiary) public payable {
968	 require(beneficiary != 0x0);
969	 require(validPurchase());
970	 uint256 weiAmount = msg.value;
971	 weiRaised = weiRaised.add(weiAmount);
972	 emit newOraclizeQuery("Oraclize query was sent, standing by for the answer..");
973	 bytes32 queryId = oraclize_query("URL", "json(https: idToBeneficiary[queryId] = beneficiary;
974	 idToWeiAmount[queryId] = weiAmount;
975	 forwardFunds();
976	 }
977	 function forwardFunds() internal {
978	 wallet.transfer(address(this).balance);
979	 }
980	 function validPurchase() internal constant returns (bool) {
981	 bool withinPeriod = started;
982	 bool nonZeroPurchase = msg.value != 0;
983	 return withinPeriod && nonZeroPurchase;
984	 }
985	 function withdrawTokens(uint256 _amount) public {
986	 require (msg.sender==wallet);
987	 tokenReward.transfer(wallet,_amount);
988	 }
989	 }
