row number 
1	          pragma solidity >=0.4.24 <0.7.0;
2	 contract Initializable {
3	 bool private initialized;
4	 bool private initializing;
5	 modifier initializer() {
6	 require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");
7	 bool isTopLevelCall = !initializing;
8	 if (isTopLevelCall) {
9	 initializing = true;
10	 initialized = true;
11	 }
12	 _;
13	 if (isTopLevelCall) {
14	 initializing = false;
15	 }
16	 }
17	 function isConstructor() private view returns (bool) {
18	 address self = address(this);
19	 uint256 cs;
20	 assembly {
21	 cs := extcodesize(self) }
22	 return cs == 0;
23	 }
24	 uint256[50] private ______gap;
25	 }
26	 pragma solidity ^0.5.0;
27	 contract Context is Initializable {
28	 constructor () internal {
29	 }
30	 function _msgSender() internal view returns (address payable) {
31	 return msg.sender;
32	 }
33	 function _msgData() internal view returns (bytes memory) {
34	 this;
35	 return msg.data;
36	 }
37	 }
38	 pragma solidity ^0.5.0;
39	 interface IERC20 {
40	 function totalSupply() external view returns (uint256);
41	 function balanceOf(address account) external view returns (uint256);
42	 function transfer(address recipient, uint256 amount) external returns (bool);
43	 function allowance(address owner, address spender) external view returns (uint256);
44	 function approve(address spender, uint256 amount) external returns (bool);
45	 function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
46	 event Transfer(address indexed from, address indexed to, uint256 value);
47	 event Approval(address indexed owner, address indexed spender, uint256 value);
48	 }
49	 pragma solidity ^0.5.0;
50	 library SafeMath {
51	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
52	 uint256 c = a + b;
53	 require(c >= a, "SafeMath: addition overflow");
54	 return c;
55	 }
56	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
57	 return sub(a, b, "SafeMath: subtraction overflow");
58	 }
59	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
60	 require(b <= a, errorMessage);
61	 uint256 c = a - b;
62	 return c;
63	 }
64	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
65	 if (a == 0) {
66	 return 0;
67	 }
68	 uint256 c = a * b;
69	 require(c / a == b, "SafeMath: multiplication overflow");
70	 return c;
71	 }
72	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
73	 return div(a, b, "SafeMath: division by zero");
74	 }
75	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
76	 require(b > 0, errorMessage);
77	 uint256 c = a / b;
78	 return c;
79	 }
80	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
81	 return mod(a, b, "SafeMath: modulo by zero");
82	 }
83	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
84	 require(b != 0, errorMessage);
85	 return a % b;
86	 }
87	 }
88	 pragma solidity ^0.5.0;
89	 contract ERC20 is Initializable, Context, IERC20 {
90	 using SafeMath for uint256;
91	 mapping (address => uint256) private _balances;
92	 mapping (address => mapping (address => uint256)) private _allowances;
93	 uint256 private _totalSupply;
94	 function totalSupply() public view returns (uint256) {
95	 return _totalSupply;
96	 }
97	 function balanceOf(address account) public view returns (uint256) {
98	 return _balances[account];
99	 }
100	 function transfer(address recipient, uint256 amount) public returns (bool) {
101	 _transfer(_msgSender(), recipient, amount);
102	 return true;
103	 }
104	 function allowance(address owner, address spender) public view returns (uint256) {
105	 return _allowances[owner][spender];
106	 }
107	 function approve(address spender, uint256 amount) public returns (bool) {
108	 _approve(_msgSender(), spender, amount);
109	 return true;
110	 }
111	 function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
112	 _transfer(sender, recipient, amount);
113	 _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
114	 return true;
115	 }
116	 function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
117	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
118	 return true;
119	 }
120	 function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
121	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
122	 return true;
123	 }
124	 function _transfer(address sender, address recipient, uint256 amount) internal {
125	 require(sender != address(0), "ERC20: transfer from the zero address");
126	 require(recipient != address(0), "ERC20: transfer to the zero address");
127	 _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
128	 _balances[recipient] = _balances[recipient].add(amount);
129	 emit Transfer(sender, recipient, amount);
130	 }
131	 function _mint(address account, uint256 amount) internal {
132	 require(account != address(0), "ERC20: mint to the zero address");
133	 _totalSupply = _totalSupply.add(amount);
134	 _balances[account] = _balances[account].add(amount);
135	 emit Transfer(address(0), account, amount);
136	 }
137	 function _burn(address account, uint256 amount) internal {
138	 require(account != address(0), "ERC20: burn from the zero address");
139	 _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
140	 _totalSupply = _totalSupply.sub(amount);
141	 emit Transfer(account, address(0), amount);
142	 }
143	 function _approve(address owner, address spender, uint256 amount) internal {
144	 require(owner != address(0), "ERC20: approve from the zero address");
145	 require(spender != address(0), "ERC20: approve to the zero address");
146	 _allowances[owner][spender] = amount;
147	 emit Approval(owner, spender, amount);
148	 }
149	 function _burnFrom(address account, uint256 amount) internal {
150	 _burn(account, amount);
151	 _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, "ERC20: burn amount exceeds allowance"));
152	 }
153	 uint256[50] private ______gap;
154	 }
155	 pragma solidity ^0.5.0;
156	 library Roles {
157	 struct Role {
158	 mapping (address => bool) bearer;
159	 }
160	 function add(Role storage role, address account) internal {
161	 require(!has(role, account), "Roles: account already has role");
162	 role.bearer[account] = true;
163	 }
164	 function remove(Role storage role, address account) internal {
165	 require(has(role, account), "Roles: account does not have role");
166	 role.bearer[account] = false;
167	 }
168	 function has(Role storage role, address account) internal view returns (bool) {
169	 require(account != address(0), "Roles: account is the zero address");
170	 return role.bearer[account];
171	 }
172	 }
173	 pragma solidity ^0.5.0;
174	 contract MinterRole is Initializable, Context {
175	 using Roles for Roles.Role;
176	 event MinterAdded(address indexed account);
177	 event MinterRemoved(address indexed account);
178	 Roles.Role private _minters;
179	 function initialize(address sender) public initializer {
180	 if (!isMinter(sender)) {
181	 _addMinter(sender);
182	 }
183	 }
184	 modifier onlyMinter() {
185	 require(isMinter(_msgSender()), "MinterRole: caller does not have the Minter role");
186	 _;
187	 }
188	 function isMinter(address account) public view returns (bool) {
189	 return _minters.has(account);
190	 }
191	 function addMinter(address account) public onlyMinter {
192	 _addMinter(account);
193	 }
194	 function renounceMinter() public {
195	 _removeMinter(_msgSender());
196	 }
197	 function _addMinter(address account) internal {
198	 _minters.add(account);
199	 emit MinterAdded(account);
200	 }
201	 function _removeMinter(address account) internal {
202	 _minters.remove(account);
203	 emit MinterRemoved(account);
204	 }
205	 uint256[50] private ______gap;
206	 }
207	 pragma solidity ^0.5.0;
208	 contract ERC20Mintable is Initializable, ERC20, MinterRole {
209	 function initialize(address sender) public initializer {
210	 MinterRole.initialize(sender);
211	 }
212	 function mint(address account, uint256 amount) public onlyMinter returns (bool) {
213	 _mint(account, amount);
214	 return true;
215	 }
216	 uint256[50] private ______gap;
217	 }
218	 pragma solidity ^0.5.5;
219	 library Address {
220	 function isContract(address account) internal view returns (bool) {
221	 bytes32 codehash;
222	 bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
223	 assembly {
224	 codehash := extcodehash(account) }
225	 return (codehash != accountHash && codehash != 0x0);
226	 }
227	 function toPayable(address account) internal pure returns (address payable) {
228	 return address(uint160(account));
229	 }
230	 function sendValue(address payable recipient, uint256 amount) internal {
231	 require(address(this).balance >= amount, "Address: insufficient balance");
232	 (bool success, ) = recipient.call.value(amount)("");
233	 require(success, "Address: unable to send value, recipient may have reverted");
234	 }
235	 }
236	 pragma solidity ^0.5.0;
237	 library SafeERC20 {
238	 using SafeMath for uint256;
239	 using Address for address;
240	 function safeTransfer(IERC20 token, address to, uint256 value) internal {
241	 callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
242	 }
243	 function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
244	 callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
245	 }
246	 function safeApprove(IERC20 token, address spender, uint256 value) internal {
247	 require((value == 0) || (token.allowance(address(this), spender) == 0), "SafeERC20: approve from non-zero to non-zero allowance" );
248	 callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
249	 }
250	 function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
251	 uint256 newAllowance = token.allowance(address(this), spender).add(value);
252	 callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
253	 }
254	 function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
255	 uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
256	 callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
257	 }
258	 function callOptionalReturn(IERC20 token, bytes memory data) private {
259	 require(address(token).isContract(), "SafeERC20: call to non-contract");
260	 (bool success, bytes memory returndata) = address(token).call(data);
261	 require(success, "SafeERC20: low-level call failed");
262	 if (returndata.length > 0) {
263	 require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
264	 }
265	 }
266	 }
267	 pragma solidity ^0.5.0;
268	 contract ERC20Burnable is Initializable, Context, ERC20 {
269	 function burn(uint256 amount) public {
270	 _burn(_msgSender(), amount);
271	 }
272	 function burnFrom(address account, uint256 amount) public {
273	 _burnFrom(account, amount);
274	 }
275	 uint256[50] private ______gap;
276	 }
277	 pragma solidity ^0.5.8;
278	 library Checkpointing {
279	 uint256 private constant MAX_UINT192 = uint256(uint192(-1));
280	 string private constant ERROR_VALUE_TOO_BIG = "CHECKPOINT_VALUE_TOO_BIG";
281	 string private constant ERROR_CANNOT_ADD_PAST_VALUE = "CHECKPOINT_CANNOT_ADD_PAST_VALUE";
282	 struct Checkpoint {
283	 uint64 time;
284	 uint192 value;
285	 }
286	 struct History {
287	 Checkpoint[] history;
288	 }
289	 function add(History storage self, uint64 _time, uint256 _value) internal {
290	 require(_value <= MAX_UINT192, ERROR_VALUE_TOO_BIG);
291	 _add192(self, _time, uint192(_value));
292	 }
293	 function getLast(History storage self) internal view returns (uint256) {
294	 uint256 length = self.history.length;
295	 if (length > 0) {
296	 return uint256(self.history[length - 1].value);
297	 }
298	 return 0;
299	 }
300	 function get(History storage self, uint64 _time) internal view returns (uint256) {
301	 return _binarySearch(self, _time);
302	 }
303	 function getRecent(History storage self, uint64 _time) internal view returns (uint256) {
304	 return _backwardsLinearSearch(self, _time);
305	 }
306	 function _add192(History storage self, uint64 _time, uint192 _value) private {
307	 uint256 length = self.history.length;
308	 if (length == 0 || self.history[self.history.length - 1].time < _time) {
309	 self.history.push(Checkpoint(_time, _value));
310	 }
311	 else {
312	 Checkpoint storage currentCheckpoint = self.history[length - 1];
313	 require(_time == currentCheckpoint.time, ERROR_CANNOT_ADD_PAST_VALUE);
314	 currentCheckpoint.value = _value;
315	 }
316	 }
317	 function _backwardsLinearSearch(History storage self, uint64 _time) private view returns (uint256) {
318	 uint256 length = self.history.length;
319	 if (length == 0) {
320	 return 0;
321	 }
322	 uint256 index = length - 1;
323	 Checkpoint storage checkpoint = self.history[index];
324	 while (index > 0 && checkpoint.time > _time) {
325	 index--;
326	 checkpoint = self.history[index];
327	 }
328	 return checkpoint.time > _time ? 0 : uint256(checkpoint.value);
329	 }
330	 function _binarySearch(History storage self, uint64 _time) private view returns (uint256) {
331	 uint256 length = self.history.length;
332	 if (length == 0) {
333	 return 0;
334	 }
335	 uint256 lastIndex = length - 1;
336	 if (_time >= self.history[lastIndex].time) {
337	 return uint256(self.history[lastIndex].value);
338	 }
339	 if (_time < self.history[0].time) {
340	 return 0;
341	 }
342	 uint256 low = 0;
343	 uint256 high = lastIndex;
344	 while (high > low) {
345	 uint256 mid = (high + low + 1) / 2;
346	 Checkpoint storage checkpoint = self.history[mid];
347	 uint64 midTime = checkpoint.time;
348	 if (_time > midTime) {
349	 low = mid;
350	 }
351	 else if (_time < midTime) {
352	 high = mid - 1;
353	 }
354	 else {
355	 return uint256(checkpoint.value);
356	 }
357	 }
358	 return uint256(self.history[low].value);
359	 }
360	 }
361	 pragma solidity ^0.5.8;
362	 library Uint256Helpers {
363	 uint256 private constant MAX_UINT8 = uint8(-1);
364	 uint256 private constant MAX_UINT64 = uint64(-1);
365	 string private constant ERROR_UINT8_NUMBER_TOO_BIG = "UINT8_NUMBER_TOO_BIG";
366	 string private constant ERROR_UINT64_NUMBER_TOO_BIG = "UINT64_NUMBER_TOO_BIG";
367	 function toUint8(uint256 a) internal pure returns (uint8) {
368	 require(a <= MAX_UINT8, ERROR_UINT8_NUMBER_TOO_BIG);
369	 return uint8(a);
370	 }
371	 function toUint64(uint256 a) internal pure returns (uint64) {
372	 require(a <= MAX_UINT64, ERROR_UINT64_NUMBER_TOO_BIG);
373	 return uint64(a);
374	 }
375	 }
376	 pragma solidity >=0.4.24 <0.7.0;
377	 contract InitializableV2 is Initializable {
378	 bool private isInitialized;
379	 string private constant ERROR_NOT_INITIALIZED = "InitializableV2: Not initialized";
380	 function initialize() public initializer {
381	 isInitialized = true;
382	 }
383	 function _requireIsInitialized() internal view {
384	 require(isInitialized == true, ERROR_NOT_INITIALIZED);
385	 }
386	 function _isInitialized() internal view returns (bool) {
387	 return isInitialized;
388	 }
389	 }
390	 pragma solidity ^0.5.0;
391	 contract Ownable is Initializable, Context {
392	 address private _owner;
393	 event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
394	 function initialize(address sender) public initializer {
395	 _owner = sender;
396	 emit OwnershipTransferred(address(0), _owner);
397	 }
398	 function owner() public view returns (address) {
399	 return _owner;
400	 }
401	 modifier onlyOwner() {
402	 require(isOwner(), "Ownable: caller is not the owner");
403	 _;
404	 }
405	 function isOwner() public view returns (bool) {
406	 return _msgSender() == _owner;
407	 }
408	 function renounceOwnership() public onlyOwner {
409	 emit OwnershipTransferred(_owner, address(0));
410	 _owner = address(0);
411	 }
412	 function transferOwnership(address newOwner) public onlyOwner {
413	 _transferOwnership(newOwner);
414	 }
415	 function _transferOwnership(address newOwner) internal {
416	 require(newOwner != address(0), "Ownable: new owner is the zero address");
417	 emit OwnershipTransferred(_owner, newOwner);
418	 _owner = newOwner;
419	 }
420	 uint256[50] private ______gap;
421	 }
422	 pragma solidity ^0.5.0;
423	 contract Registry is InitializableV2, Ownable {
424	 using SafeMath for uint256;
425	 mapping(bytes32 => address) private addressStorage;
426	 mapping(bytes32 => address[]) private addressStorageHistory;
427	 event ContractAdded( bytes32 indexed _name, address indexed _address );
428	 event ContractRemoved( bytes32 indexed _name, address indexed _address );
429	 event ContractUpgraded( bytes32 indexed _name, address indexed _oldAddress, address indexed _newAddress );
430	 function initialize() public initializer {
431	 Ownable.initialize(msg.sender);
432	 InitializableV2.initialize();
433	 }
434	 function addContract(bytes32 _name, address _address) external onlyOwner {
435	 _requireIsInitialized();
436	 require( addressStorage[_name] == address(0x00), "Registry: Contract already registered with given name." );
437	 require( _address != address(0x00), "Registry: Cannot register zero address." );
438	 setAddress(_name, _address);
439	 emit ContractAdded(_name, _address);
440	 }
441	 function removeContract(bytes32 _name) external onlyOwner {
442	 _requireIsInitialized();
443	 address contractAddress = addressStorage[_name];
444	 require( contractAddress != address(0x00), "Registry: Cannot remove - no contract registered with given _name." );
445	 setAddress(_name, address(0x00));
446	 emit ContractRemoved(_name, contractAddress);
447	 }
448	 function upgradeContract(bytes32 _name, address _newAddress) external onlyOwner {
449	 _requireIsInitialized();
450	 address oldAddress = addressStorage[_name];
451	 require( oldAddress != address(0x00), "Registry: Cannot upgrade - no contract registered with given _name." );
452	 require( _newAddress != address(0x00), "Registry: Cannot upgrade - cannot register zero address." );
453	 setAddress(_name, _newAddress);
454	 emit ContractUpgraded(_name, oldAddress, _newAddress);
455	 }
456	 function getContract(bytes32 _name) external view returns (address contractAddr) {
457	 _requireIsInitialized();
458	 return addressStorage[_name];
459	 }
460	 function getContract(bytes32 _name, uint256 _version) external view returns (address contractAddr) {
461	 _requireIsInitialized();
462	 require( _version <= addressStorageHistory[_name].length, "Registry: Index out of range _version." );
463	 return addressStorageHistory[_name][_version.sub(1)];
464	 }
465	 function getContractVersionCount(bytes32 _name) external view returns (uint256) {
466	 _requireIsInitialized();
467	 return addressStorageHistory[_name].length;
468	 }
469	 function setAddress(bytes32 _key, address _value) private {
470	 addressStorage[_key] = _value;
471	 addressStorageHistory[_key].push(_value);
472	 }
473	 }
474	 pragma solidity ^0.5.0;
475	 contract Governance is InitializableV2 {
476	 using SafeMath for uint256;
477	 string private constant ERROR_ONLY_GOVERNANCE = ( "Governance: Only callable by self" );
478	 string private constant ERROR_INVALID_VOTING_PERIOD = ( "Governance: Requires non-zero _votingPeriod" );
479	 string private constant ERROR_INVALID_REGISTRY = ( "Governance: Requires non-zero _registryAddress" );
480	 string private constant ERROR_INVALID_VOTING_QUORUM = ( "Governance: Requires _votingQuorumPercent between 1 & 100" );
481	 Registry private registry;
482	 address private stakingAddress;
483	 address private serviceProviderFactoryAddress;
484	 address private delegateManagerAddress;
485	 uint256 private votingPeriod;
486	 uint256 private executionDelay;
487	 uint256 private votingQuorumPercent;
488	 uint16 private maxInProgressProposals;
489	 address private guardianAddress;
490	 enum Outcome {
491	 InProgress, Rejected, ApprovedExecuted, QuorumNotMet, ApprovedExecutionFailed, Evaluating, Vetoed, TargetContractAddressChanged, TargetContractCodeHashChanged }
492	 enum Vote {
493	 None, No, Yes}
494	 struct Proposal {
495	 uint256 proposalId;
496	 address proposer;
497	 uint256 submissionBlockNumber;
498	 bytes32 targetContractRegistryKey;
499	 address targetContractAddress;
500	 uint256 callValue;
501	 string functionSignature;
502	 bytes callData;
503	 Outcome outcome;
504	 uint256 voteMagnitudeYes;
505	 uint256 voteMagnitudeNo;
506	 uint256 numVotes;
507	 mapping(address => Vote) votes;
508	 mapping(address => uint256) voteMagnitudes;
509	 bytes32 contractHash;
510	 }
511	 uint256 lastProposalId = 0;
512	 mapping(uint256 => Proposal) proposals;
513	 uint256[] inProgressProposals;
514	 event ProposalSubmitted( uint256 indexed _proposalId, address indexed _proposer, string _name, string _description );
515	 event ProposalVoteSubmitted( uint256 indexed _proposalId, address indexed _voter, Vote indexed _vote, uint256 _voterStake );
516	 event ProposalVoteUpdated( uint256 indexed _proposalId, address indexed _voter, Vote indexed _vote, uint256 _voterStake, Vote _previousVote );
517	 event ProposalOutcomeEvaluated( uint256 indexed _proposalId, Outcome indexed _outcome, uint256 _voteMagnitudeYes, uint256 _voteMagnitudeNo, uint256 _numVotes );
518	 event ProposalTransactionExecuted( uint256 indexed _proposalId, bool indexed _success, bytes _returnData );
519	 event GuardianTransactionExecuted( address indexed _targetContractAddress, uint256 _callValue, string indexed _functionSignature, bytes indexed _callData, bytes _returnData );
520	 event ProposalVetoed(uint256 indexed _proposalId);
521	 event RegistryAddressUpdated(address indexed _newRegistryAddress);
522	 event GuardianshipTransferred(address indexed _newGuardianAddress);
523	 event VotingPeriodUpdated(uint256 indexed _newVotingPeriod);
524	 event ExecutionDelayUpdated(uint256 indexed _newExecutionDelay);
525	 event VotingQuorumPercentUpdated(uint256 indexed _newVotingQuorumPercent);
526	 event MaxInProgressProposalsUpdated(uint256 indexed _newMaxInProgressProposals);
527	 function initialize( address _registryAddress, uint256 _votingPeriod, uint256 _executionDelay, uint256 _votingQuorumPercent, uint16 _maxInProgressProposals, address _guardianAddress ) public initializer {
528	 require(_registryAddress != address(0x00), ERROR_INVALID_REGISTRY);
529	 registry = Registry(_registryAddress);
530	 require(_votingPeriod > 0, ERROR_INVALID_VOTING_PERIOD);
531	 votingPeriod = _votingPeriod;
532	 executionDelay = _executionDelay;
533	 require( _maxInProgressProposals > 0, "Governance: Requires non-zero _maxInProgressProposals" );
534	 maxInProgressProposals = _maxInProgressProposals;
535	 require( _votingQuorumPercent > 0 && _votingQuorumPercent <= 100, ERROR_INVALID_VOTING_QUORUM );
536	 votingQuorumPercent = _votingQuorumPercent;
537	 require( _guardianAddress != address(0x00), "Governance: Requires non-zero _guardianAddress" );
538	 guardianAddress = _guardianAddress;
539	 InitializableV2.initialize();
540	 }
541	 function submitProposal( bytes32 _targetContractRegistryKey, uint256 _callValue, string calldata _functionSignature, bytes calldata _callData, string calldata _name, string calldata _description ) external returns (uint256) {
542	 _requireIsInitialized();
543	 _requireStakingAddressIsSet();
544	 _requireServiceProviderFactoryAddressIsSet();
545	 _requireDelegateManagerAddressIsSet();
546	 address proposer = msg.sender;
547	 require( this.inProgressProposalsAreUpToDate(), "Governance: Cannot submit new proposal until all evaluatable InProgress proposals are evaluated." );
548	 require( inProgressProposals.length < maxInProgressProposals, "Governance: Number of InProgress proposals already at max. Please evaluate if possible, or wait for current proposals' votingPeriods to expire." );
549	 require( _calculateAddressActiveStake(proposer) > 0 || proposer == guardianAddress, "Governance: Proposer must be address with non-zero total active stake or be guardianAddress." );
550	 address targetContractAddress = registry.getContract(_targetContractRegistryKey);
551	 require( targetContractAddress != address(0x00), "Governance: _targetContractRegistryKey must point to valid registered contract" );
552	 require( bytes(_functionSignature).length != 0, "Governance: _functionSignature cannot be empty." );
553	 require(bytes(_description).length > 0, "Governance: _description length must be > 0");
554	 require(bytes(_name).length > 0, "Governance: _name length must be > 0");
555	 uint256 newProposalId = lastProposalId.add(1);
556	 proposals[newProposalId] = Proposal({
557	 proposalId: newProposalId, proposer: proposer, submissionBlockNumber: block.number, targetContractRegistryKey: _targetContractRegistryKey, targetContractAddress: targetContractAddress, callValue: _callValue, functionSignature: _functionSignature, callData: _callData, outcome: Outcome.InProgress, voteMagnitudeYes: 0, voteMagnitudeNo: 0, numVotes: 0, contractHash: _getCodeHash(targetContractAddress) }
558	 );
559	 inProgressProposals.push(newProposalId);
560	 emit ProposalSubmitted( newProposalId, proposer, _name, _description );
561	 lastProposalId = newProposalId;
562	 return newProposalId;
563	 }
564	 function submitVote(uint256 _proposalId, Vote _vote) external {
565	 _requireIsInitialized();
566	 _requireStakingAddressIsSet();
567	 _requireServiceProviderFactoryAddressIsSet();
568	 _requireDelegateManagerAddressIsSet();
569	 _requireValidProposalId(_proposalId);
570	 address voter = msg.sender;
571	 uint256 submissionBlockNumber = proposals[_proposalId].submissionBlockNumber;
572	 uint256 endBlockNumber = submissionBlockNumber.add(votingPeriod);
573	 require( block.number > submissionBlockNumber && block.number <= endBlockNumber, "Governance: Proposal votingPeriod has ended" );
574	 uint256 voterActiveStake = _calculateAddressActiveStake(voter);
575	 require( voterActiveStake > 0, "Governance: Voter must be address with non-zero total active stake." );
576	 require( proposals[_proposalId].votes[voter] == Vote.None, "Governance: To update previous vote, call updateVote()" );
577	 require( _vote == Vote.Yes || _vote == Vote.No, "Governance: Can only submit a Yes or No vote" );
578	 proposals[_proposalId].votes[voter] = _vote;
579	 proposals[_proposalId].voteMagnitudes[voter] = voterActiveStake;
580	 if (_vote == Vote.Yes) {
581	 _increaseVoteMagnitudeYes(_proposalId, voterActiveStake);
582	 }
583	 else {
584	 _increaseVoteMagnitudeNo(_proposalId, voterActiveStake);
585	 }
586	 proposals[_proposalId].numVotes = proposals[_proposalId].numVotes.add(1);
587	 emit ProposalVoteSubmitted( _proposalId, voter, _vote, voterActiveStake );
588	 }
589	 function updateVote(uint256 _proposalId, Vote _vote) external {
590	 _requireIsInitialized();
591	 _requireStakingAddressIsSet();
592	 _requireServiceProviderFactoryAddressIsSet();
593	 _requireDelegateManagerAddressIsSet();
594	 _requireValidProposalId(_proposalId);
595	 address voter = msg.sender;
596	 uint256 submissionBlockNumber = proposals[_proposalId].submissionBlockNumber;
597	 uint256 endBlockNumber = submissionBlockNumber.add(votingPeriod);
598	 require( block.number > submissionBlockNumber && block.number <= endBlockNumber, "Governance: Proposal votingPeriod has ended" );
599	 Vote previousVote = proposals[_proposalId].votes[voter];
600	 require( previousVote != Vote.None, "Governance: To submit new vote, call submitVote()" );
601	 require( _vote == Vote.Yes || _vote == Vote.No, "Governance: Can only submit a Yes or No vote" );
602	 proposals[_proposalId].votes[voter] = _vote;
603	 uint256 voteMagnitude = proposals[_proposalId].voteMagnitudes[voter];
604	 if (previousVote == Vote.Yes && _vote == Vote.No) {
605	 _decreaseVoteMagnitudeYes(_proposalId, voteMagnitude);
606	 _increaseVoteMagnitudeNo(_proposalId, voteMagnitude);
607	 }
608	 else if (previousVote == Vote.No && _vote == Vote.Yes) {
609	 _decreaseVoteMagnitudeNo(_proposalId, voteMagnitude);
610	 _increaseVoteMagnitudeYes(_proposalId, voteMagnitude);
611	 }
612	 emit ProposalVoteUpdated( _proposalId, voter, _vote, voteMagnitude, previousVote );
613	 }
614	 function evaluateProposalOutcome(uint256 _proposalId) external returns (Outcome) {
615	 _requireIsInitialized();
616	 _requireStakingAddressIsSet();
617	 _requireServiceProviderFactoryAddressIsSet();
618	 _requireDelegateManagerAddressIsSet();
619	 _requireValidProposalId(_proposalId);
620	 require( proposals[_proposalId].outcome == Outcome.InProgress, "Governance: Can only evaluate InProgress proposal." );
621	 proposals[_proposalId].outcome = Outcome.Evaluating;
622	 uint256 submissionBlockNumber = proposals[_proposalId].submissionBlockNumber;
623	 uint256 endBlockNumber = submissionBlockNumber.add(votingPeriod).add(executionDelay);
624	 require( block.number > endBlockNumber, "Governance: Proposal votingPeriod & executionDelay must end before evaluation." );
625	 address targetContractAddress = registry.getContract( proposals[_proposalId].targetContractRegistryKey );
626	 Outcome outcome;
627	 if (targetContractAddress != proposals[_proposalId].targetContractAddress) {
628	 outcome = Outcome.TargetContractAddressChanged;
629	 }
630	 else if (_getCodeHash(targetContractAddress) != proposals[_proposalId].contractHash) {
631	 outcome = Outcome.TargetContractCodeHashChanged;
632	 }
633	 else if (_quorumMet(proposals[_proposalId], Staking(stakingAddress)) == false) {
634	 outcome = Outcome.QuorumNotMet;
635	 }
636	 else if ( proposals[_proposalId].voteMagnitudeYes > proposals[_proposalId].voteMagnitudeNo ) {
637	 (bool success, bytes memory returnData) = _executeTransaction( targetContractAddress, proposals[_proposalId].callValue, proposals[_proposalId].functionSignature, proposals[_proposalId].callData );
638	 emit ProposalTransactionExecuted( _proposalId, success, returnData );
639	 if (success) {
640	 outcome = Outcome.ApprovedExecuted;
641	 }
642	 else {
643	 outcome = Outcome.ApprovedExecutionFailed;
644	 }
645	 }
646	 else {
647	 outcome = Outcome.Rejected;
648	 }
649	 proposals[_proposalId].outcome = outcome;
650	 _removeFromInProgressProposals(_proposalId);
651	 emit ProposalOutcomeEvaluated( _proposalId, outcome, proposals[_proposalId].voteMagnitudeYes, proposals[_proposalId].voteMagnitudeNo, proposals[_proposalId].numVotes );
652	 return outcome;
653	 }
654	 function vetoProposal(uint256 _proposalId) external {
655	 _requireIsInitialized();
656	 _requireValidProposalId(_proposalId);
657	 require( msg.sender == guardianAddress, "Governance: Only guardian can veto proposals." );
658	 require( proposals[_proposalId].outcome == Outcome.InProgress, "Governance: Cannot veto inactive proposal." );
659	 proposals[_proposalId].outcome = Outcome.Vetoed;
660	 _removeFromInProgressProposals(_proposalId);
661	 emit ProposalVetoed(_proposalId);
662	 }
663	 function setStakingAddress(address _stakingAddress) external {
664	 _requireIsInitialized();
665	 require(msg.sender == address(this), ERROR_ONLY_GOVERNANCE);
666	 require(_stakingAddress != address(0x00), "Governance: Requires non-zero _stakingAddress");
667	 stakingAddress = _stakingAddress;
668	 }
669	 function setServiceProviderFactoryAddress(address _serviceProviderFactoryAddress) external {
670	 _requireIsInitialized();
671	 require(msg.sender == address(this), ERROR_ONLY_GOVERNANCE);
672	 require( _serviceProviderFactoryAddress != address(0x00), "Governance: Requires non-zero _serviceProviderFactoryAddress" );
673	 serviceProviderFactoryAddress = _serviceProviderFactoryAddress;
674	 }
675	 function setDelegateManagerAddress(address _delegateManagerAddress) external {
676	 _requireIsInitialized();
677	 require(msg.sender == address(this), ERROR_ONLY_GOVERNANCE);
678	 require( _delegateManagerAddress != address(0x00), "Governance: Requires non-zero _delegateManagerAddress" );
679	 delegateManagerAddress = _delegateManagerAddress;
680	 }
681	 function setVotingPeriod(uint256 _votingPeriod) external {
682	 _requireIsInitialized();
683	 require(msg.sender == address(this), ERROR_ONLY_GOVERNANCE);
684	 require(_votingPeriod > 0, ERROR_INVALID_VOTING_PERIOD);
685	 votingPeriod = _votingPeriod;
686	 emit VotingPeriodUpdated(_votingPeriod);
687	 }
688	 function setVotingQuorumPercent(uint256 _votingQuorumPercent) external {
689	 _requireIsInitialized();
690	 require(msg.sender == address(this), ERROR_ONLY_GOVERNANCE);
691	 require( _votingQuorumPercent > 0 && _votingQuorumPercent <= 100, ERROR_INVALID_VOTING_QUORUM );
692	 votingQuorumPercent = _votingQuorumPercent;
693	 emit VotingQuorumPercentUpdated(_votingQuorumPercent);
694	 }
695	 function setRegistryAddress(address _registryAddress) external {
696	 _requireIsInitialized();
697	 require(msg.sender == address(this), ERROR_ONLY_GOVERNANCE);
698	 require(_registryAddress != address(0x00), ERROR_INVALID_REGISTRY);
699	 registry = Registry(_registryAddress);
700	 emit RegistryAddressUpdated(_registryAddress);
701	 }
702	 function setMaxInProgressProposals(uint16 _newMaxInProgressProposals) external {
703	 _requireIsInitialized();
704	 require(msg.sender == address(this), ERROR_ONLY_GOVERNANCE);
705	 require( _newMaxInProgressProposals > 0, "Governance: Requires non-zero _newMaxInProgressProposals" );
706	 maxInProgressProposals = _newMaxInProgressProposals;
707	 emit MaxInProgressProposalsUpdated(_newMaxInProgressProposals);
708	 }
709	 function setExecutionDelay(uint256 _newExecutionDelay) external {
710	 _requireIsInitialized();
711	 require(msg.sender == address(this), ERROR_ONLY_GOVERNANCE);
712	 executionDelay = _newExecutionDelay;
713	 emit ExecutionDelayUpdated(_newExecutionDelay);
714	 }
715	 function guardianExecuteTransaction( bytes32 _targetContractRegistryKey, uint256 _callValue, string calldata _functionSignature, bytes calldata _callData ) external {
716	 _requireIsInitialized();
717	 require( msg.sender == guardianAddress, "Governance: Only guardian." );
718	 address targetContractAddress = registry.getContract(_targetContractRegistryKey);
719	 require( targetContractAddress != address(0x00), "Governance: _targetContractRegistryKey must point to valid registered contract" );
720	 require( bytes(_functionSignature).length != 0, "Governance: _functionSignature cannot be empty." );
721	 (bool success, bytes memory returnData) = _executeTransaction( targetContractAddress, _callValue, _functionSignature, _callData );
722	 require(success, "Governance: Transaction failed.");
723	 emit GuardianTransactionExecuted( targetContractAddress, _callValue, _functionSignature, _callData, returnData );
724	 }
725	 function transferGuardianship(address _newGuardianAddress) external {
726	 _requireIsInitialized();
727	 require( msg.sender == guardianAddress, "Governance: Only guardian." );
728	 guardianAddress = _newGuardianAddress;
729	 emit GuardianshipTransferred(_newGuardianAddress);
730	 }
731	 function getProposalById(uint256 _proposalId) external view returns ( uint256 proposalId, address proposer, uint256 submissionBlockNumber, bytes32 targetContractRegistryKey, address targetContractAddress, uint256 callValue, string memory functionSignature, bytes memory callData, Outcome outcome, uint256 voteMagnitudeYes, uint256 voteMagnitudeNo, uint256 numVotes ) {
732	 _requireIsInitialized();
733	 _requireValidProposalId(_proposalId);
734	 Proposal memory proposal = proposals[_proposalId];
735	 return ( proposal.proposalId, proposal.proposer, proposal.submissionBlockNumber, proposal.targetContractRegistryKey, proposal.targetContractAddress, proposal.callValue, proposal.functionSignature, proposal.callData, proposal.outcome, proposal.voteMagnitudeYes, proposal.voteMagnitudeNo, proposal.numVotes );
736	 }
737	 function getProposalTargetContractHash(uint256 _proposalId) external view returns (bytes32) {
738	 _requireIsInitialized();
739	 _requireValidProposalId(_proposalId);
740	 return (proposals[_proposalId].contractHash);
741	 }
742	 function getVoteInfoByProposalAndVoter(uint256 _proposalId, address _voter) external view returns (Vote vote, uint256 voteMagnitude) {
743	 _requireIsInitialized();
744	 _requireValidProposalId(_proposalId);
745	 return ( proposals[_proposalId].votes[_voter], proposals[_proposalId].voteMagnitudes[_voter] );
746	 }
747	 function getGuardianAddress() external view returns (address) {
748	 _requireIsInitialized();
749	 return guardianAddress;
750	 }
751	 function getStakingAddress() external view returns (address) {
752	 _requireIsInitialized();
753	 return stakingAddress;
754	 }
755	 function getServiceProviderFactoryAddress() external view returns (address) {
756	 _requireIsInitialized();
757	 return serviceProviderFactoryAddress;
758	 }
759	 function getDelegateManagerAddress() external view returns (address) {
760	 _requireIsInitialized();
761	 return delegateManagerAddress;
762	 }
763	 function getVotingPeriod() external view returns (uint256) {
764	 _requireIsInitialized();
765	 return votingPeriod;
766	 }
767	 function getVotingQuorumPercent() external view returns (uint256) {
768	 _requireIsInitialized();
769	 return votingQuorumPercent;
770	 }
771	 function getRegistryAddress() external view returns (address) {
772	 _requireIsInitialized();
773	 return address(registry);
774	 }
775	 function isGovernanceAddress() external pure returns (bool) {
776	 return true;
777	 }
778	 function getMaxInProgressProposals() external view returns (uint16) {
779	 _requireIsInitialized();
780	 return maxInProgressProposals;
781	 }
782	 function getExecutionDelay() external view returns (uint256) {
783	 _requireIsInitialized();
784	 return executionDelay;
785	 }
786	 function getInProgressProposals() external view returns (uint256[] memory) {
787	 _requireIsInitialized();
788	 return inProgressProposals;
789	 }
790	 function inProgressProposalsAreUpToDate() external view returns (bool) {
791	 _requireIsInitialized();
792	 for (uint256 i = 0; i < inProgressProposals.length; i++) {
793	 if ( block.number > (proposals[inProgressProposals[i]].submissionBlockNumber).add(votingPeriod).add(executionDelay) ) {
794	 return false;
795	 }
796	 }
797	 return true;
798	 }
799	 function _executeTransaction( address _targetContractAddress, uint256 _callValue, string memory _functionSignature, bytes memory _callData ) internal returns (bool success, bytes memory returnData) {
800	 bytes memory encodedCallData = abi.encodePacked( bytes4(keccak256(bytes(_functionSignature))), _callData );
801	 (success, returnData) = ( _targetContractAddress.call.value(_callValue)(encodedCallData) );
802	 return (success, returnData);
803	 }
804	 function _increaseVoteMagnitudeYes(uint256 _proposalId, uint256 _voterStake) internal {
805	 proposals[_proposalId].voteMagnitudeYes = ( proposals[_proposalId].voteMagnitudeYes.add(_voterStake) );
806	 }
807	 function _increaseVoteMagnitudeNo(uint256 _proposalId, uint256 _voterStake) internal {
808	 proposals[_proposalId].voteMagnitudeNo = ( proposals[_proposalId].voteMagnitudeNo.add(_voterStake) );
809	 }
810	 function _decreaseVoteMagnitudeYes(uint256 _proposalId, uint256 _voterStake) internal {
811	 proposals[_proposalId].voteMagnitudeYes = ( proposals[_proposalId].voteMagnitudeYes.sub(_voterStake) );
812	 }
813	 function _decreaseVoteMagnitudeNo(uint256 _proposalId, uint256 _voterStake) internal {
814	 proposals[_proposalId].voteMagnitudeNo = ( proposals[_proposalId].voteMagnitudeNo.sub(_voterStake) );
815	 }
816	 function _removeFromInProgressProposals(uint256 _proposalId) internal {
817	 uint256 index = 0;
818	 for (uint256 i = 0; i < inProgressProposals.length; i++) {
819	 if (inProgressProposals[i] == _proposalId) {
820	 index = i;
821	 break;
822	 }
823	 }
824	 inProgressProposals[index] = inProgressProposals[inProgressProposals.length - 1];
825	 inProgressProposals.pop();
826	 }
827	 function _quorumMet(Proposal memory proposal, Staking stakingContract) internal view returns (bool) {
828	 uint256 participation = ( (proposal.voteMagnitudeYes + proposal.voteMagnitudeNo) .mul(100) .div(stakingContract.totalStakedAt(proposal.submissionBlockNumber)) );
829	 return participation >= votingQuorumPercent;
830	 }
831	 function _requireStakingAddressIsSet() private view {
832	 require( stakingAddress != address(0x00), "Governance: stakingAddress is not set" );
833	 }
834	 function _requireServiceProviderFactoryAddressIsSet() private view {
835	 require( serviceProviderFactoryAddress != address(0x00), "Governance: serviceProviderFactoryAddress is not set" );
836	 }
837	 function _requireDelegateManagerAddressIsSet() private view {
838	 require( delegateManagerAddress != address(0x00), "Governance: delegateManagerAddress is not set" );
839	 }
840	 function _requireValidProposalId(uint256 _proposalId) private view {
841	 require( _proposalId <= lastProposalId && _proposalId > 0, "Governance: Must provide valid non-zero _proposalId" );
842	 }
843	 function _calculateAddressActiveStake(address _address) private view returns (uint256) {
844	 ServiceProviderFactory spFactory = ServiceProviderFactory(serviceProviderFactoryAddress);
845	 DelegateManagerV2 delegateManager = DelegateManagerV2(delegateManagerAddress);
846	 (uint256 directDeployerStake,,,,,) = spFactory.getServiceProviderDetails(_address);
847	 (uint256 lockedDeployerStake,) = spFactory.getPendingDecreaseStakeRequest(_address);
848	 uint256 activeDeployerStake = directDeployerStake.sub(lockedDeployerStake);
849	 uint256 totalDelegatorStake = delegateManager.getTotalDelegatorStake(_address);
850	 (,uint256 lockedDelegatorStake, ) = delegateManager.getPendingUndelegateRequest(_address);
851	 uint256 activeDelegatorStake = totalDelegatorStake.sub(lockedDelegatorStake);
852	 uint256 activeStake = activeDeployerStake.add(activeDelegatorStake);
853	 return activeStake;
854	 }
855	 function _getCodeHash(address _contract) private view returns (bytes32) {
856	 bytes32 contractHash;
857	 assembly {
858	 contractHash := extcodehash(_contract) }
859	 return contractHash;
860	 }
861	 }
862	 pragma solidity ^0.5.0;
863	 contract Staking is InitializableV2 {
864	 using SafeMath for uint256;
865	 using Uint256Helpers for uint256;
866	 using Checkpointing for Checkpointing.History;
867	 using SafeERC20 for ERC20;
868	 string private constant ERROR_TOKEN_NOT_CONTRACT = "Staking: Staking token is not a contract";
869	 string private constant ERROR_AMOUNT_ZERO = "Staking: Zero amount not allowed";
870	 string private constant ERROR_ONLY_GOVERNANCE = "Staking: Only governance";
871	 string private constant ERROR_ONLY_DELEGATE_MANAGER = ( "Staking: Only callable from DelegateManager" );
872	 string private constant ERROR_ONLY_SERVICE_PROVIDER_FACTORY = ( "Staking: Only callable from ServiceProviderFactory" );
873	 address private governanceAddress;
874	 address private claimsManagerAddress;
875	 address private delegateManagerAddress;
876	 address private serviceProviderFactoryAddress;
877	 struct Account {
878	 Checkpointing.History stakedHistory;
879	 Checkpointing.History claimHistory;
880	 }
881	 ERC20 internal stakingToken;
882	 mapping (address => Account) internal accounts;
883	 Checkpointing.History internal totalStakedHistory;
884	 event Staked(address indexed user, uint256 amount, uint256 total);
885	 event Unstaked(address indexed user, uint256 amount, uint256 total);
886	 event Slashed(address indexed user, uint256 amount, uint256 total);
887	 function initialize( address _tokenAddress, address _governanceAddress ) public initializer {
888	 require(Address.isContract(_tokenAddress), ERROR_TOKEN_NOT_CONTRACT);
889	 stakingToken = ERC20(_tokenAddress);
890	 _updateGovernanceAddress(_governanceAddress);
891	 InitializableV2.initialize();
892	 }
893	 function setGovernanceAddress(address _governanceAddress) external {
894	 _requireIsInitialized();
895	 require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);
896	 _updateGovernanceAddress(_governanceAddress);
897	 }
898	 function setClaimsManagerAddress(address _claimsManager) external {
899	 _requireIsInitialized();
900	 require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);
901	 claimsManagerAddress = _claimsManager;
902	 }
903	 function setServiceProviderFactoryAddress(address _spFactory) external {
904	 _requireIsInitialized();
905	 require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);
906	 serviceProviderFactoryAddress = _spFactory;
907	 }
908	 function setDelegateManagerAddress(address _delegateManager) external {
909	 _requireIsInitialized();
910	 require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);
911	 delegateManagerAddress = _delegateManager;
912	 }
913	 function stakeRewards(uint256 _amount, address _stakerAccount) external {
914	 _requireIsInitialized();
915	 _requireClaimsManagerAddressIsSet();
916	 require( msg.sender == claimsManagerAddress, "Staking: Only callable from ClaimsManager" );
917	 _stakeFor(_stakerAccount, msg.sender, _amount);
918	 this.updateClaimHistory(_amount, _stakerAccount);
919	 }
920	 function updateClaimHistory(uint256 _amount, address _stakerAccount) external {
921	 _requireIsInitialized();
922	 _requireClaimsManagerAddressIsSet();
923	 require( msg.sender == claimsManagerAddress || msg.sender == address(this), "Staking: Only callable from ClaimsManager or Staking.sol" );
924	 accounts[_stakerAccount].claimHistory.add(block.number.toUint64(), _amount);
925	 }
926	 function slash( uint256 _amount, address _slashAddress ) external {
927	 _requireIsInitialized();
928	 _requireDelegateManagerAddressIsSet();
929	 require( msg.sender == delegateManagerAddress, ERROR_ONLY_DELEGATE_MANAGER );
930	 _burnFor(_slashAddress, _amount);
931	 emit Slashed( _slashAddress, _amount, totalStakedFor(_slashAddress) );
932	 }
933	 function stakeFor( address _accountAddress, uint256 _amount ) external {
934	 _requireIsInitialized();
935	 _requireServiceProviderFactoryAddressIsSet();
936	 require( msg.sender == serviceProviderFactoryAddress, ERROR_ONLY_SERVICE_PROVIDER_FACTORY );
937	 _stakeFor( _accountAddress, _accountAddress, _amount );
938	 }
939	 function unstakeFor( address _accountAddress, uint256 _amount ) external {
940	 _requireIsInitialized();
941	 _requireServiceProviderFactoryAddressIsSet();
942	 require( msg.sender == serviceProviderFactoryAddress, ERROR_ONLY_SERVICE_PROVIDER_FACTORY );
943	 _unstakeFor( _accountAddress, _accountAddress, _amount );
944	 }
945	 function delegateStakeFor( address _accountAddress, address _delegatorAddress, uint256 _amount ) external {
946	 _requireIsInitialized();
947	 _requireDelegateManagerAddressIsSet();
948	 require( msg.sender == delegateManagerAddress, ERROR_ONLY_DELEGATE_MANAGER );
949	 _stakeFor( _accountAddress, _delegatorAddress, _amount);
950	 }
951	 function undelegateStakeFor( address _accountAddress, address _delegatorAddress, uint256 _amount ) external {
952	 _requireIsInitialized();
953	 _requireDelegateManagerAddressIsSet();
954	 require( msg.sender == delegateManagerAddress, ERROR_ONLY_DELEGATE_MANAGER );
955	 _unstakeFor( _accountAddress, _delegatorAddress, _amount);
956	 }
957	 function token() external view returns (address) {
958	 _requireIsInitialized();
959	 return address(stakingToken);
960	 }
961	 function supportsHistory() external view returns (bool) {
962	 _requireIsInitialized();
963	 return true;
964	 }
965	 function lastStakedFor(address _accountAddress) external view returns (uint256) {
966	 _requireIsInitialized();
967	 uint256 length = accounts[_accountAddress].stakedHistory.history.length;
968	 if (length > 0) {
969	 return uint256(accounts[_accountAddress].stakedHistory.history[length - 1].time);
970	 }
971	 return 0;
972	 }
973	 function lastClaimedFor(address _accountAddress) external view returns (uint256) {
974	 _requireIsInitialized();
975	 uint256 length = accounts[_accountAddress].claimHistory.history.length;
976	 if (length > 0) {
977	 return uint256(accounts[_accountAddress].claimHistory.history[length - 1].time);
978	 }
979	 return 0;
980	 }
981	 function totalStakedForAt( address _accountAddress, uint256 _blockNumber ) external view returns (uint256) {
982	 _requireIsInitialized();
983	 return accounts[_accountAddress].stakedHistory.get(_blockNumber.toUint64());
984	 }
985	 function totalStakedAt(uint256 _blockNumber) external view returns (uint256) {
986	 _requireIsInitialized();
987	 return totalStakedHistory.get(_blockNumber.toUint64());
988	 }
989	 function getGovernanceAddress() external view returns (address) {
990	 _requireIsInitialized();
991	 return governanceAddress;
992	 }
993	 function getClaimsManagerAddress() external view returns (address) {
994	 _requireIsInitialized();
995	 return claimsManagerAddress;
996	 }
997	 function getServiceProviderFactoryAddress() external view returns (address) {
998	 _requireIsInitialized();
999	 return serviceProviderFactoryAddress;
1000	 }
1001	 function getDelegateManagerAddress() external view returns (address) {
1002	 _requireIsInitialized();
1003	 return delegateManagerAddress;
1004	 }
1005	 function isStaker(address _accountAddress) external view returns (bool) {
1006	 _requireIsInitialized();
1007	 return totalStakedFor(_accountAddress) > 0;
1008	 }
1009	 function totalStakedFor(address _accountAddress) public view returns (uint256) {
1010	 _requireIsInitialized();
1011	 return accounts[_accountAddress].stakedHistory.getLast();
1012	 }
1013	 function totalStaked() public view returns (uint256) {
1014	 _requireIsInitialized();
1015	 return totalStakedHistory.getLast();
1016	 }
1017	 function _stakeFor( address _stakeAccount, address _transferAccount, uint256 _amount ) internal {
1018	 require(_amount > 0, ERROR_AMOUNT_ZERO);
1019	 _modifyStakeBalance(_stakeAccount, _amount, true);
1020	 _modifyTotalStaked(_amount, true);
1021	 stakingToken.safeTransferFrom(_transferAccount, address(this), _amount);
1022	 emit Staked( _stakeAccount, _amount, totalStakedFor(_stakeAccount));
1023	 }
1024	 function _unstakeFor( address _stakeAccount, address _transferAccount, uint256 _amount ) internal {
1025	 require(_amount > 0, ERROR_AMOUNT_ZERO);
1026	 _modifyStakeBalance(_stakeAccount, _amount, false);
1027	 _modifyTotalStaked(_amount, false);
1028	 stakingToken.safeTransfer(_transferAccount, _amount);
1029	 emit Unstaked( _stakeAccount, _amount, totalStakedFor(_stakeAccount) );
1030	 }
1031	 function _burnFor(address _stakeAccount, uint256 _amount) internal {
1032	 require(_amount > 0, ERROR_AMOUNT_ZERO);
1033	 _modifyStakeBalance(_stakeAccount, _amount, false);
1034	 _modifyTotalStaked(_amount, false);
1035	 ERC20Burnable(address(stakingToken)).burn(_amount);
1036	 }
1037	 function _modifyStakeBalance(address _accountAddress, uint256 _by, bool _increase) internal {
1038	 uint256 currentInternalStake = accounts[_accountAddress].stakedHistory.getLast();
1039	 uint256 newStake;
1040	 if (_increase) {
1041	 newStake = currentInternalStake.add(_by);
1042	 }
1043	 else {
1044	 require( currentInternalStake >= _by, "Staking: Cannot decrease greater than current balance");
1045	 newStake = currentInternalStake.sub(_by);
1046	 }
1047	 accounts[_accountAddress].stakedHistory.add(block.number.toUint64(), newStake);
1048	 }
1049	 function _modifyTotalStaked(uint256 _by, bool _increase) internal {
1050	 uint256 currentStake = totalStaked();
1051	 uint256 newStake;
1052	 if (_increase) {
1053	 newStake = currentStake.add(_by);
1054	 }
1055	 else {
1056	 newStake = currentStake.sub(_by);
1057	 }
1058	 totalStakedHistory.add(block.number.toUint64(), newStake);
1059	 }
1060	 function _updateGovernanceAddress(address _governanceAddress) internal {
1061	 require( Governance(_governanceAddress).isGovernanceAddress() == true, "Staking: _governanceAddress is not a valid governance contract" );
1062	 governanceAddress = _governanceAddress;
1063	 }
1064	 function _requireClaimsManagerAddressIsSet() private view {
1065	 require(claimsManagerAddress != address(0x00), "Staking: claimsManagerAddress is not set");
1066	 }
1067	 function _requireDelegateManagerAddressIsSet() private view {
1068	 require( delegateManagerAddress != address(0x00), "Staking: delegateManagerAddress is not set" );
1069	 }
1070	 function _requireServiceProviderFactoryAddressIsSet() private view {
1071	 require( serviceProviderFactoryAddress != address(0x00), "Staking: serviceProviderFactoryAddress is not set" );
1072	 }
1073	 }
1074	 pragma solidity ^0.5.0;
1075	 contract ServiceTypeManager is InitializableV2 {
1076	 address governanceAddress;
1077	 string private constant ERROR_ONLY_GOVERNANCE = ( "ServiceTypeManager: Only callable by Governance contract" );
1078	 mapping(bytes32 => bytes32[]) private serviceTypeVersions;
1079	 mapping(bytes32 => mapping(bytes32 => bool)) private serviceTypeVersionInfo;
1080	 bytes32[] private validServiceTypes;
1081	 struct ServiceTypeInfo {
1082	 bool isValid;
1083	 uint256 minStake;
1084	 uint256 maxStake;
1085	 }
1086	 mapping(bytes32 => ServiceTypeInfo) private serviceTypeInfo;
1087	 event SetServiceVersion( bytes32 indexed _serviceType, bytes32 indexed _serviceVersion );
1088	 event ServiceTypeAdded( bytes32 indexed _serviceType, uint256 indexed _serviceTypeMin, uint256 indexed _serviceTypeMax );
1089	 event ServiceTypeRemoved(bytes32 indexed _serviceType);
1090	 function initialize(address _governanceAddress) public initializer {
1091	 _updateGovernanceAddress(_governanceAddress);
1092	 InitializableV2.initialize();
1093	 }
1094	 function getGovernanceAddress() external view returns (address) {
1095	 _requireIsInitialized();
1096	 return governanceAddress;
1097	 }
1098	 function setGovernanceAddress(address _governanceAddress) external {
1099	 _requireIsInitialized();
1100	 require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);
1101	 _updateGovernanceAddress(_governanceAddress);
1102	 }
1103	 function addServiceType( bytes32 _serviceType, uint256 _serviceTypeMin, uint256 _serviceTypeMax ) external {
1104	 _requireIsInitialized();
1105	 require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);
1106	 require( !this.serviceTypeIsValid(_serviceType), "ServiceTypeManager: Already known service type" );
1107	 require( _serviceTypeMax > _serviceTypeMin, "ServiceTypeManager: Max stake must be non-zero and greater than min stake" );
1108	 require( serviceTypeInfo[_serviceType].maxStake == 0, "ServiceTypeManager: Cannot re-add serviceType after it was removed." );
1109	 validServiceTypes.push(_serviceType);
1110	 serviceTypeInfo[_serviceType] = ServiceTypeInfo({
1111	 isValid: true, minStake: _serviceTypeMin, maxStake: _serviceTypeMax }
1112	 );
1113	 emit ServiceTypeAdded(_serviceType, _serviceTypeMin, _serviceTypeMax);
1114	 }
1115	 function removeServiceType(bytes32 _serviceType) external {
1116	 _requireIsInitialized();
1117	 require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);
1118	 uint256 serviceIndex = 0;
1119	 bool foundService = false;
1120	 for (uint256 i = 0; i < validServiceTypes.length; i ++) {
1121	 if (validServiceTypes[i] == _serviceType) {
1122	 serviceIndex = i;
1123	 foundService = true;
1124	 break;
1125	 }
1126	 }
1127	 require(foundService == true, "ServiceTypeManager: Invalid service type, not found");
1128	 uint256 lastIndex = validServiceTypes.length - 1;
1129	 validServiceTypes[serviceIndex] = validServiceTypes[lastIndex];
1130	 validServiceTypes.length--;
1131	 serviceTypeInfo[_serviceType].isValid = false;
1132	 emit ServiceTypeRemoved(_serviceType);
1133	 }
1134	 function getServiceTypeInfo(bytes32 _serviceType) external view returns (bool isValid, uint256 minStake, uint256 maxStake) {
1135	 _requireIsInitialized();
1136	 return ( serviceTypeInfo[_serviceType].isValid, serviceTypeInfo[_serviceType].minStake, serviceTypeInfo[_serviceType].maxStake );
1137	 }
1138	 function getValidServiceTypes() external view returns (bytes32[] memory) {
1139	 _requireIsInitialized();
1140	 return validServiceTypes;
1141	 }
1142	 function serviceTypeIsValid(bytes32 _serviceType) external view returns (bool) {
1143	 _requireIsInitialized();
1144	 return serviceTypeInfo[_serviceType].isValid;
1145	 }
1146	 function setServiceVersion( bytes32 _serviceType, bytes32 _serviceVersion ) external {
1147	 _requireIsInitialized();
1148	 require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);
1149	 require(this.serviceTypeIsValid(_serviceType), "ServiceTypeManager: Invalid service type");
1150	 require( serviceTypeVersionInfo[_serviceType][_serviceVersion] == false, "ServiceTypeManager: Already registered" );
1151	 serviceTypeVersions[_serviceType].push(_serviceVersion);
1152	 serviceTypeVersionInfo[_serviceType][_serviceVersion] = true;
1153	 emit SetServiceVersion(_serviceType, _serviceVersion);
1154	 }
1155	 function getVersion(bytes32 _serviceType, uint256 _versionIndex) external view returns (bytes32) {
1156	 _requireIsInitialized();
1157	 require( serviceTypeVersions[_serviceType].length > _versionIndex, "ServiceTypeManager: No registered version of serviceType" );
1158	 return (serviceTypeVersions[_serviceType][_versionIndex]);
1159	 }
1160	 function getCurrentVersion(bytes32 _serviceType) external view returns (bytes32) {
1161	 _requireIsInitialized();
1162	 require( serviceTypeVersions[_serviceType].length >= 1, "ServiceTypeManager: No registered version of serviceType" );
1163	 uint256 latestVersionIndex = serviceTypeVersions[_serviceType].length - 1;
1164	 return (serviceTypeVersions[_serviceType][latestVersionIndex]);
1165	 }
1166	 function getNumberOfVersions(bytes32 _serviceType) external view returns (uint256) {
1167	 _requireIsInitialized();
1168	 return serviceTypeVersions[_serviceType].length;
1169	 }
1170	 function serviceVersionIsValid(bytes32 _serviceType, bytes32 _serviceVersion) external view returns (bool) {
1171	 _requireIsInitialized();
1172	 return serviceTypeVersionInfo[_serviceType][_serviceVersion];
1173	 }
1174	 function _updateGovernanceAddress(address _governanceAddress) internal {
1175	 require( Governance(_governanceAddress).isGovernanceAddress() == true, "ServiceTypeManager: _governanceAddress is not a valid governance contract" );
1176	 governanceAddress = _governanceAddress;
1177	 }
1178	 }
1179	 pragma solidity ^0.5.0;
1180	 contract ClaimsManager is InitializableV2 {
1181	 using SafeMath for uint256;
1182	 using SafeERC20 for ERC20;
1183	 string private constant ERROR_ONLY_GOVERNANCE = ( "ClaimsManager: Only callable by Governance contract" );
1184	 address private governanceAddress;
1185	 address private stakingAddress;
1186	 address private serviceProviderFactoryAddress;
1187	 address private delegateManagerAddress;
1188	 uint256 private fundingRoundBlockDiff;
1189	 uint256 private fundingAmount;
1190	 uint256 private roundNumber;
1191	 ERC20Mintable private audiusToken;
1192	 address private communityPoolAddress;
1193	 uint256 private recurringCommunityFundingAmount;
1194	 struct Round {
1195	 uint256 fundedBlock;
1196	 uint256 fundedAmount;
1197	 uint256 totalClaimedInRound;
1198	 }
1199	 Round private currentRound;
1200	 event RoundInitiated( uint256 indexed _blockNumber, uint256 indexed _roundNumber, uint256 indexed _fundAmount );
1201	 event ClaimProcessed( address indexed _claimer, uint256 indexed _rewards, uint256 _oldTotal, uint256 indexed _newTotal );
1202	 event CommunityRewardsTransferred( address indexed _transferAddress, uint256 indexed _amount );
1203	 event FundingAmountUpdated(uint256 indexed _amount);
1204	 event FundingRoundBlockDiffUpdated(uint256 indexed _blockDifference);
1205	 event GovernanceAddressUpdated(address indexed _newGovernanceAddress);
1206	 event StakingAddressUpdated(address indexed _newStakingAddress);
1207	 event ServiceProviderFactoryAddressUpdated(address indexed _newServiceProviderFactoryAddress);
1208	 event DelegateManagerAddressUpdated(address indexed _newDelegateManagerAddress);
1209	 event RecurringCommunityFundingAmountUpdated(uint256 indexed _amount);
1210	 event CommunityPoolAddressUpdated(address indexed _newCommunityPoolAddress);
1211	 function initialize( address _tokenAddress, address _governanceAddress ) public initializer {
1212	 _updateGovernanceAddress(_governanceAddress);
1213	 audiusToken = ERC20Mintable(_tokenAddress);
1214	 fundingRoundBlockDiff = 46523;
1215	 fundingAmount = 1342465753420000000000000;
1216	 roundNumber = 0;
1217	 currentRound = Round({
1218	 fundedBlock: 0, fundedAmount: 0, totalClaimedInRound: 0 }
1219	 );
1220	 recurringCommunityFundingAmount = 0;
1221	 communityPoolAddress = address(0x0);
1222	 InitializableV2.initialize();
1223	 }
1224	 function getFundingRoundBlockDiff() external view returns (uint256) {
1225	 _requireIsInitialized();
1226	 return fundingRoundBlockDiff;
1227	 }
1228	 function getLastFundedBlock() external view returns (uint256) {
1229	 _requireIsInitialized();
1230	 return currentRound.fundedBlock;
1231	 }
1232	 function getFundsPerRound() external view returns (uint256) {
1233	 _requireIsInitialized();
1234	 return fundingAmount;
1235	 }
1236	 function getTotalClaimedInRound() external view returns (uint256) {
1237	 _requireIsInitialized();
1238	 return currentRound.totalClaimedInRound;
1239	 }
1240	 function getGovernanceAddress() external view returns (address) {
1241	 _requireIsInitialized();
1242	 return governanceAddress;
1243	 }
1244	 function getServiceProviderFactoryAddress() external view returns (address) {
1245	 _requireIsInitialized();
1246	 return serviceProviderFactoryAddress;
1247	 }
1248	 function getDelegateManagerAddress() external view returns (address) {
1249	 _requireIsInitialized();
1250	 return delegateManagerAddress;
1251	 }
1252	 function getStakingAddress() external view returns (address) {
1253	 _requireIsInitialized();
1254	 return stakingAddress;
1255	 }
1256	 function getCommunityPoolAddress() external view returns (address) {
1257	 _requireIsInitialized();
1258	 return communityPoolAddress;
1259	 }
1260	 function getRecurringCommunityFundingAmount() external view returns (uint256) {
1261	 _requireIsInitialized();
1262	 return recurringCommunityFundingAmount;
1263	 }
1264	 function setGovernanceAddress(address _governanceAddress) external {
1265	 _requireIsInitialized();
1266	 require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);
1267	 _updateGovernanceAddress(_governanceAddress);
1268	 emit GovernanceAddressUpdated(_governanceAddress);
1269	 }
1270	 function setStakingAddress(address _stakingAddress) external {
1271	 _requireIsInitialized();
1272	 require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);
1273	 stakingAddress = _stakingAddress;
1274	 emit StakingAddressUpdated(_stakingAddress);
1275	 }
1276	 function setServiceProviderFactoryAddress(address _serviceProviderFactoryAddress) external {
1277	 _requireIsInitialized();
1278	 require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);
1279	 serviceProviderFactoryAddress = _serviceProviderFactoryAddress;
1280	 emit ServiceProviderFactoryAddressUpdated(_serviceProviderFactoryAddress);
1281	 }
1282	 function setDelegateManagerAddress(address _delegateManagerAddress) external {
1283	 _requireIsInitialized();
1284	 require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);
1285	 delegateManagerAddress = _delegateManagerAddress;
1286	 emit DelegateManagerAddressUpdated(_delegateManagerAddress);
1287	 }
1288	 function initiateRound() external {
1289	 _requireIsInitialized();
1290	 _requireStakingAddressIsSet();
1291	 require( block.number.sub(currentRound.fundedBlock) > fundingRoundBlockDiff, "ClaimsManager: Required block difference not met" );
1292	 currentRound = Round({
1293	 fundedBlock: block.number, fundedAmount: fundingAmount, totalClaimedInRound: 0 }
1294	 );
1295	 roundNumber = roundNumber.add(1);
1296	 if (recurringCommunityFundingAmount > 0 && communityPoolAddress != address(0x0)) {
1297	 audiusToken.mint(address(this), recurringCommunityFundingAmount);
1298	 audiusToken.approve(communityPoolAddress, recurringCommunityFundingAmount);
1299	 ERC20(address(audiusToken)).safeTransfer(communityPoolAddress, recurringCommunityFundingAmount);
1300	 emit CommunityRewardsTransferred(communityPoolAddress, recurringCommunityFundingAmount);
1301	 }
1302	 emit RoundInitiated( currentRound.fundedBlock, roundNumber, currentRound.fundedAmount );
1303	 }
1304	 function processClaim( address _claimer, uint256 _totalLockedForSP ) external returns (uint256) {
1305	 _requireIsInitialized();
1306	 _requireStakingAddressIsSet();
1307	 _requireDelegateManagerAddressIsSet();
1308	 _requireServiceProviderFactoryAddressIsSet();
1309	 require( msg.sender == delegateManagerAddress, "ClaimsManager: ProcessClaim only accessible to DelegateManager" );
1310	 Staking stakingContract = Staking(stakingAddress);
1311	 uint256 lastUserClaimBlock = stakingContract.lastClaimedFor(_claimer);
1312	 require( lastUserClaimBlock <= currentRound.fundedBlock, "ClaimsManager: Claim already processed for user" );
1313	 uint256 totalStakedAtFundBlockForClaimer = stakingContract.totalStakedForAt( _claimer, currentRound.fundedBlock);
1314	 (,,bool withinBounds,,,) = ( ServiceProviderFactory(serviceProviderFactoryAddress).getServiceProviderDetails(_claimer) );
1315	 uint256 totalActiveClaimerStake = totalStakedAtFundBlockForClaimer.sub(_totalLockedForSP);
1316	 uint256 totalStakedAtFundBlock = stakingContract.totalStakedAt(currentRound.fundedBlock);
1317	 uint256 rewardsForClaimer = ( totalActiveClaimerStake.mul(fundingAmount) ).div(totalStakedAtFundBlock);
1318	 if (!withinBounds || rewardsForClaimer == 0) {
1319	 stakingContract.updateClaimHistory(0, _claimer);
1320	 emit ClaimProcessed( _claimer, 0, totalStakedAtFundBlockForClaimer, totalActiveClaimerStake );
1321	 return 0;
1322	 }
1323	 audiusToken.mint(address(this), rewardsForClaimer);
1324	 audiusToken.approve(stakingAddress, rewardsForClaimer);
1325	 stakingContract.stakeRewards(rewardsForClaimer, _claimer);
1326	 currentRound.totalClaimedInRound = currentRound.totalClaimedInRound.add(rewardsForClaimer);
1327	 uint256 newTotal = stakingContract.totalStakedFor(_claimer);
1328	 emit ClaimProcessed( _claimer, rewardsForClaimer, totalStakedAtFundBlockForClaimer, newTotal );
1329	 return rewardsForClaimer;
1330	 }
1331	 function updateFundingAmount(uint256 _newAmount) external {
1332	 _requireIsInitialized();
1333	 require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);
1334	 fundingAmount = _newAmount;
1335	 emit FundingAmountUpdated(_newAmount);
1336	 }
1337	 function claimPending(address _sp) external view returns (bool) {
1338	 _requireIsInitialized();
1339	 _requireStakingAddressIsSet();
1340	 _requireServiceProviderFactoryAddressIsSet();
1341	 uint256 lastClaimedForSP = Staking(stakingAddress).lastClaimedFor(_sp);
1342	 (,,,uint256 numEndpoints,,) = ( ServiceProviderFactory(serviceProviderFactoryAddress).getServiceProviderDetails(_sp) );
1343	 return (lastClaimedForSP < currentRound.fundedBlock && numEndpoints > 0);
1344	 }
1345	 function updateFundingRoundBlockDiff(uint256 _newFundingRoundBlockDiff) external {
1346	 _requireIsInitialized();
1347	 require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);
1348	 emit FundingRoundBlockDiffUpdated(_newFundingRoundBlockDiff);
1349	 fundingRoundBlockDiff = _newFundingRoundBlockDiff;
1350	 }
1351	 function updateRecurringCommunityFundingAmount( uint256 _newRecurringCommunityFundingAmount ) external {
1352	 _requireIsInitialized();
1353	 require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);
1354	 recurringCommunityFundingAmount = _newRecurringCommunityFundingAmount;
1355	 emit RecurringCommunityFundingAmountUpdated(_newRecurringCommunityFundingAmount);
1356	 }
1357	 function updateCommunityPoolAddress(address _newCommunityPoolAddress) external {
1358	 _requireIsInitialized();
1359	 require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);
1360	 communityPoolAddress = _newCommunityPoolAddress;
1361	 emit CommunityPoolAddressUpdated(_newCommunityPoolAddress);
1362	 }
1363	 function _updateGovernanceAddress(address _governanceAddress) private {
1364	 require( Governance(_governanceAddress).isGovernanceAddress() == true, "ClaimsManager: _governanceAddress is not a valid governance contract" );
1365	 governanceAddress = _governanceAddress;
1366	 }
1367	 function _requireStakingAddressIsSet() private view {
1368	 require(stakingAddress != address(0x00), "ClaimsManager: stakingAddress is not set");
1369	 }
1370	 function _requireDelegateManagerAddressIsSet() private view {
1371	 require( delegateManagerAddress != address(0x00), "ClaimsManager: delegateManagerAddress is not set" );
1372	 }
1373	 function _requireServiceProviderFactoryAddressIsSet() private view {
1374	 require( serviceProviderFactoryAddress != address(0x00), "ClaimsManager: serviceProviderFactoryAddress is not set" );
1375	 }
1376	 }
1377	 pragma solidity ^0.5.0;
1378	 contract ServiceProviderFactory is InitializableV2 {
1379	 using SafeMath for uint256;
1380	 uint256 private constant DEPLOYER_CUT_BASE = 100;
1381	 string private constant ERROR_ONLY_GOVERNANCE = ( "ServiceProviderFactory: Only callable by Governance contract" );
1382	 string private constant ERROR_ONLY_SP_GOVERNANCE = ( "ServiceProviderFactory: Only callable by Service Provider or Governance" );
1383	 address private stakingAddress;
1384	 address private delegateManagerAddress;
1385	 address private governanceAddress;
1386	 address private serviceTypeManagerAddress;
1387	 address private claimsManagerAddress;
1388	 uint256 private decreaseStakeLockupDuration;
1389	 uint256 private deployerCutLockupDuration;
1390	 struct ServiceProviderDetails {
1391	 uint256 deployerStake;
1392	 uint256 deployerCut;
1393	 bool validBounds;
1394	 uint256 numberOfEndpoints;
1395	 uint256 minAccountStake;
1396	 uint256 maxAccountStake;
1397	 }
1398	 struct DecreaseStakeRequest {
1399	 uint256 decreaseAmount;
1400	 uint256 lockupExpiryBlock;
1401	 }
1402	 struct UpdateDeployerCutRequest {
1403	 uint256 newDeployerCut;
1404	 uint256 lockupExpiryBlock;
1405	 }
1406	 struct ServiceEndpoint {
1407	 address owner;
1408	 string endpoint;
1409	 uint256 blocknumber;
1410	 address delegateOwnerWallet;
1411	 }
1412	 mapping(address => ServiceProviderDetails) private spDetails;
1413	 mapping(bytes32 => uint256) private serviceProviderTypeIDs;
1414	 mapping(bytes32 => mapping(uint256 => ServiceEndpoint)) private serviceProviderInfo;
1415	 mapping(bytes32 => uint256) private serviceProviderEndpointToId;
1416	 mapping(address => mapping(bytes32 => uint256[])) private serviceProviderAddressToId;
1417	 mapping(address => DecreaseStakeRequest) private decreaseStakeRequests;
1418	 mapping(address => UpdateDeployerCutRequest) private updateDeployerCutRequests;
1419	 event RegisteredServiceProvider( uint256 indexed _spID, bytes32 indexed _serviceType, address indexed _owner, string _endpoint, uint256 _stakeAmount );
1420	 event DeregisteredServiceProvider( uint256 indexed _spID, bytes32 indexed _serviceType, address indexed _owner, string _endpoint, uint256 _unstakeAmount );
1421	 event IncreasedStake( address indexed _owner, uint256 indexed _increaseAmount, uint256 indexed _newStakeAmount );
1422	 event DecreaseStakeRequested( address indexed _owner, uint256 indexed _decreaseAmount, uint256 indexed _lockupExpiryBlock );
1423	 event DecreaseStakeRequestCancelled( address indexed _owner, uint256 indexed _decreaseAmount, uint256 indexed _lockupExpiryBlock );
1424	 event DecreaseStakeRequestEvaluated( address indexed _owner, uint256 indexed _decreaseAmount, uint256 indexed _newStakeAmount );
1425	 event EndpointUpdated( bytes32 indexed _serviceType, address indexed _owner, string _oldEndpoint, string _newEndpoint, uint256 indexed _spID );
1426	 event DelegateOwnerWalletUpdated( address indexed _owner, bytes32 indexed _serviceType, uint256 indexed _spID, address _updatedWallet );
1427	 event DeployerCutUpdateRequested( address indexed _owner, uint256 indexed _updatedCut, uint256 indexed _lockupExpiryBlock );
1428	 event DeployerCutUpdateRequestCancelled( address indexed _owner, uint256 indexed _requestedCut, uint256 indexed _finalCut );
1429	 event DeployerCutUpdateRequestEvaluated( address indexed _owner, uint256 indexed _updatedCut );
1430	 event DecreaseStakeLockupDurationUpdated(uint256 indexed _lockupDuration);
1431	 event UpdateDeployerCutLockupDurationUpdated(uint256 indexed _lockupDuration);
1432	 event GovernanceAddressUpdated(address indexed _newGovernanceAddress);
1433	 event StakingAddressUpdated(address indexed _newStakingAddress);
1434	 event ClaimsManagerAddressUpdated(address indexed _newClaimsManagerAddress);
1435	 event DelegateManagerAddressUpdated(address indexed _newDelegateManagerAddress);
1436	 event ServiceTypeManagerAddressUpdated(address indexed _newServiceTypeManagerAddress);
1437	 function initialize ( address _governanceAddress, address _claimsManagerAddress, uint256 _decreaseStakeLockupDuration, uint256 _deployerCutLockupDuration ) public initializer {
1438	 _updateGovernanceAddress(_governanceAddress);
1439	 claimsManagerAddress = _claimsManagerAddress;
1440	 _updateDecreaseStakeLockupDuration(_decreaseStakeLockupDuration);
1441	 _updateDeployerCutLockupDuration(_deployerCutLockupDuration);
1442	 InitializableV2.initialize();
1443	 }
1444	 function register( bytes32 _serviceType, string calldata _endpoint, uint256 _stakeAmount, address _delegateOwnerWallet ) external returns (uint256) {
1445	 _requireIsInitialized();
1446	 _requireStakingAddressIsSet();
1447	 _requireServiceTypeManagerAddressIsSet();
1448	 _requireClaimsManagerAddressIsSet();
1449	 require( ServiceTypeManager(serviceTypeManagerAddress).serviceTypeIsValid(_serviceType), "ServiceProviderFactory: Valid service type required");
1450	 if (_stakeAmount > 0) {
1451	 require( !_claimPending(msg.sender), "ServiceProviderFactory: No pending claim expected" );
1452	 Staking(stakingAddress).stakeFor(msg.sender, _stakeAmount);
1453	 }
1454	 require ( serviceProviderEndpointToId[keccak256(bytes(_endpoint))] == 0, "ServiceProviderFactory: Endpoint already registered");
1455	 uint256 newServiceProviderID = serviceProviderTypeIDs[_serviceType].add(1);
1456	 serviceProviderTypeIDs[_serviceType] = newServiceProviderID;
1457	 serviceProviderInfo[_serviceType][newServiceProviderID] = ServiceEndpoint({
1458	 owner: msg.sender, endpoint: _endpoint, blocknumber: block.number, delegateOwnerWallet: _delegateOwnerWallet }
1459	 );
1460	 serviceProviderEndpointToId[keccak256(bytes(_endpoint))] = newServiceProviderID;
1461	 serviceProviderAddressToId[msg.sender][_serviceType].push(newServiceProviderID);
1462	 spDetails[msg.sender].numberOfEndpoints = spDetails[msg.sender].numberOfEndpoints.add(1);
1463	 spDetails[msg.sender].deployerStake = ( spDetails[msg.sender].deployerStake.add(_stakeAmount) );
1464	 (, uint256 typeMin, uint256 typeMax) = ServiceTypeManager( serviceTypeManagerAddress ).getServiceTypeInfo(_serviceType);
1465	 spDetails[msg.sender].minAccountStake = spDetails[msg.sender].minAccountStake.add(typeMin);
1466	 spDetails[msg.sender].maxAccountStake = spDetails[msg.sender].maxAccountStake.add(typeMax);
1467	 this.validateAccountStakeBalance(msg.sender);
1468	 uint256 currentlyStakedForOwner = Staking(stakingAddress).totalStakedFor(msg.sender);
1469	 spDetails[msg.sender].validBounds = true;
1470	 emit RegisteredServiceProvider( newServiceProviderID, _serviceType, msg.sender, _endpoint, currentlyStakedForOwner );
1471	 return newServiceProviderID;
1472	 }
1473	 function deregister( bytes32 _serviceType, string calldata _endpoint ) external returns (uint256) {
1474	 _requireIsInitialized();
1475	 _requireStakingAddressIsSet();
1476	 _requireServiceTypeManagerAddressIsSet();
1477	 uint256 unstakeAmount = 0;
1478	 bool unstaked = false;
1479	 if (spDetails[msg.sender].numberOfEndpoints == 1) {
1480	 unstakeAmount = spDetails[msg.sender].deployerStake;
1481	 decreaseStakeRequests[msg.sender] = DecreaseStakeRequest({
1482	 decreaseAmount: unstakeAmount, lockupExpiryBlock: block.number.add(decreaseStakeLockupDuration) }
1483	 );
1484	 unstaked = true;
1485	 }
1486	 require ( serviceProviderEndpointToId[keccak256(bytes(_endpoint))] != 0, "ServiceProviderFactory: Endpoint not registered");
1487	 uint256 deregisteredID = serviceProviderEndpointToId[keccak256(bytes(_endpoint))];
1488	 serviceProviderEndpointToId[keccak256(bytes(_endpoint))] = 0;
1489	 require( keccak256(bytes(serviceProviderInfo[_serviceType][deregisteredID].endpoint)) == keccak256(bytes(_endpoint)), "ServiceProviderFactory: Invalid endpoint for service type");
1490	 require ( serviceProviderInfo[_serviceType][deregisteredID].owner == msg.sender, "ServiceProviderFactory: Only callable by endpoint owner");
1491	 delete serviceProviderInfo[_serviceType][deregisteredID];
1492	 uint256 spTypeLength = serviceProviderAddressToId[msg.sender][_serviceType].length;
1493	 for (uint256 i = 0; i < spTypeLength; i ++) {
1494	 if (serviceProviderAddressToId[msg.sender][_serviceType][i] == deregisteredID) {
1495	 serviceProviderAddressToId[msg.sender][_serviceType][i] = serviceProviderAddressToId[msg.sender][_serviceType][spTypeLength - 1];
1496	 serviceProviderAddressToId[msg.sender][_serviceType].length--;
1497	 break;
1498	 }
1499	 }
1500	 spDetails[msg.sender].numberOfEndpoints -= 1;
1501	 (, uint256 typeMin, uint256 typeMax) = ServiceTypeManager( serviceTypeManagerAddress ).getServiceTypeInfo(_serviceType);
1502	 spDetails[msg.sender].minAccountStake = spDetails[msg.sender].minAccountStake.sub(typeMin);
1503	 spDetails[msg.sender].maxAccountStake = spDetails[msg.sender].maxAccountStake.sub(typeMax);
1504	 emit DeregisteredServiceProvider( deregisteredID, _serviceType, msg.sender, _endpoint, unstakeAmount);
1505	 if (!unstaked) {
1506	 this.validateAccountStakeBalance(msg.sender);
1507	 spDetails[msg.sender].validBounds = true;
1508	 }
1509	 return deregisteredID;
1510	 }
1511	 function increaseStake( uint256 _increaseStakeAmount ) external returns (uint256) {
1512	 _requireIsInitialized();
1513	 _requireStakingAddressIsSet();
1514	 _requireClaimsManagerAddressIsSet();
1515	 require( spDetails[msg.sender].numberOfEndpoints > 0, "ServiceProviderFactory: Registered endpoint required to increase stake" );
1516	 require( !_claimPending(msg.sender), "ServiceProviderFactory: No claim expected to be pending prior to stake transfer" );
1517	 Staking stakingContract = Staking( stakingAddress );
1518	 stakingContract.stakeFor(msg.sender, _increaseStakeAmount);
1519	 uint256 newStakeAmount = stakingContract.totalStakedFor(msg.sender);
1520	 spDetails[msg.sender].deployerStake = ( spDetails[msg.sender].deployerStake.add(_increaseStakeAmount) );
1521	 this.validateAccountStakeBalance(msg.sender);
1522	 spDetails[msg.sender].validBounds = true;
1523	 emit IncreasedStake( msg.sender, _increaseStakeAmount, newStakeAmount );
1524	 return newStakeAmount;
1525	 }
1526	 function requestDecreaseStake(uint256 _decreaseStakeAmount) external returns (uint256) {
1527	 _requireIsInitialized();
1528	 _requireStakingAddressIsSet();
1529	 _requireClaimsManagerAddressIsSet();
1530	 require( _decreaseStakeAmount > 0, "ServiceProviderFactory: Requested stake decrease amount must be greater than zero" );
1531	 require( !_claimPending(msg.sender), "ServiceProviderFactory: No claim expected to be pending prior to stake transfer" );
1532	 Staking stakingContract = Staking( stakingAddress );
1533	 uint256 currentStakeAmount = stakingContract.totalStakedFor(msg.sender);
1534	 _validateBalanceInternal(msg.sender, (currentStakeAmount.sub(_decreaseStakeAmount)));
1535	 uint256 expiryBlock = block.number.add(decreaseStakeLockupDuration);
1536	 decreaseStakeRequests[msg.sender] = DecreaseStakeRequest({
1537	 decreaseAmount: _decreaseStakeAmount, lockupExpiryBlock: expiryBlock }
1538	 );
1539	 emit DecreaseStakeRequested(msg.sender, _decreaseStakeAmount, expiryBlock);
1540	 return currentStakeAmount.sub(_decreaseStakeAmount);
1541	 }
1542	 function cancelDecreaseStakeRequest(address _account) external {
1543	 _requireIsInitialized();
1544	 _requireDelegateManagerAddressIsSet();
1545	 require( msg.sender == _account || msg.sender == delegateManagerAddress, "ServiceProviderFactory: Only owner or DelegateManager" );
1546	 require( _decreaseRequestIsPending(_account), "ServiceProviderFactory: Decrease stake request must be pending" );
1547	 DecreaseStakeRequest memory cancelledRequest = decreaseStakeRequests[_account];
1548	 decreaseStakeRequests[_account] = DecreaseStakeRequest({
1549	 decreaseAmount: 0, lockupExpiryBlock: 0 }
1550	 );
1551	 emit DecreaseStakeRequestCancelled( _account, cancelledRequest.decreaseAmount, cancelledRequest.lockupExpiryBlock );
1552	 }
1553	 function decreaseStake() external returns (uint256) {
1554	 _requireIsInitialized();
1555	 _requireStakingAddressIsSet();
1556	 require( _decreaseRequestIsPending(msg.sender), "ServiceProviderFactory: Decrease stake request must be pending" );
1557	 require( decreaseStakeRequests[msg.sender].lockupExpiryBlock <= block.number, "ServiceProviderFactory: Lockup must be expired" );
1558	 Staking stakingContract = Staking( stakingAddress );
1559	 uint256 decreaseAmount = decreaseStakeRequests[msg.sender].decreaseAmount;
1560	 stakingContract.unstakeFor(msg.sender, decreaseAmount);
1561	 uint256 newStakeAmount = stakingContract.totalStakedFor(msg.sender);
1562	 spDetails[msg.sender].deployerStake = ( spDetails[msg.sender].deployerStake.sub(decreaseAmount) );
1563	 if (spDetails[msg.sender].numberOfEndpoints > 0) {
1564	 this.validateAccountStakeBalance(msg.sender);
1565	 }
1566	 spDetails[msg.sender].validBounds = true;
1567	 delete decreaseStakeRequests[msg.sender];
1568	 emit DecreaseStakeRequestEvaluated(msg.sender, decreaseAmount, newStakeAmount);
1569	 return newStakeAmount;
1570	 }
1571	 function updateDelegateOwnerWallet( bytes32 _serviceType, string calldata _endpoint, address _updatedDelegateOwnerWallet ) external {
1572	 _requireIsInitialized();
1573	 uint256 spID = this.getServiceProviderIdFromEndpoint(_endpoint);
1574	 require( serviceProviderInfo[_serviceType][spID].owner == msg.sender, "ServiceProviderFactory: Invalid update operation, wrong owner" );
1575	 serviceProviderInfo[_serviceType][spID].delegateOwnerWallet = _updatedDelegateOwnerWallet;
1576	 emit DelegateOwnerWalletUpdated( msg.sender, _serviceType, spID, _updatedDelegateOwnerWallet );
1577	 }
1578	 function updateEndpoint( bytes32 _serviceType, string calldata _oldEndpoint, string calldata _newEndpoint ) external returns (uint256) {
1579	 _requireIsInitialized();
1580	 uint256 spId = this.getServiceProviderIdFromEndpoint(_oldEndpoint);
1581	 require ( spId != 0, "ServiceProviderFactory: Could not find service provider with that endpoint" );
1582	 ServiceEndpoint memory serviceEndpoint = serviceProviderInfo[_serviceType][spId];
1583	 require( serviceEndpoint.owner == msg.sender, "ServiceProviderFactory: Invalid update endpoint operation, wrong owner" );
1584	 require( keccak256(bytes(serviceEndpoint.endpoint)) == keccak256(bytes(_oldEndpoint)), "ServiceProviderFactory: Old endpoint doesn't match what's registered for the service provider" );
1585	 serviceProviderEndpointToId[keccak256(bytes(serviceEndpoint.endpoint))] = 0;
1586	 serviceEndpoint.endpoint = _newEndpoint;
1587	 serviceProviderInfo[_serviceType][spId] = serviceEndpoint;
1588	 serviceProviderEndpointToId[keccak256(bytes(_newEndpoint))] = spId;
1589	 emit EndpointUpdated(_serviceType, msg.sender, _oldEndpoint, _newEndpoint, spId);
1590	 return spId;
1591	 }
1592	 function requestUpdateDeployerCut(address _serviceProvider, uint256 _cut) external {
1593	 _requireIsInitialized();
1594	 require( msg.sender == _serviceProvider || msg.sender == governanceAddress, ERROR_ONLY_SP_GOVERNANCE );
1595	 require( (updateDeployerCutRequests[_serviceProvider].lockupExpiryBlock == 0) && (updateDeployerCutRequests[_serviceProvider].newDeployerCut == 0), "ServiceProviderFactory: Update deployer cut operation pending" );
1596	 require( _cut <= DEPLOYER_CUT_BASE, "ServiceProviderFactory: Service Provider cut cannot exceed base value" );
1597	 uint256 expiryBlock = block.number + deployerCutLockupDuration;
1598	 updateDeployerCutRequests[_serviceProvider] = UpdateDeployerCutRequest({
1599	 lockupExpiryBlock: expiryBlock, newDeployerCut: _cut }
1600	 );
1601	 emit DeployerCutUpdateRequested(_serviceProvider, _cut, expiryBlock);
1602	 }
1603	 function cancelUpdateDeployerCut(address _serviceProvider) external {
1604	 _requireIsInitialized();
1605	 _requirePendingDeployerCutOperation(_serviceProvider);
1606	 require( msg.sender == _serviceProvider || msg.sender == governanceAddress, ERROR_ONLY_SP_GOVERNANCE );
1607	 UpdateDeployerCutRequest memory cancelledRequest = ( updateDeployerCutRequests[_serviceProvider] );
1608	 delete updateDeployerCutRequests[_serviceProvider];
1609	 emit DeployerCutUpdateRequestCancelled( _serviceProvider, cancelledRequest.newDeployerCut, spDetails[_serviceProvider].deployerCut );
1610	 }
1611	 function updateDeployerCut(address _serviceProvider) external {
1612	 _requireIsInitialized();
1613	 _requirePendingDeployerCutOperation(_serviceProvider);
1614	 require( msg.sender == _serviceProvider || msg.sender == governanceAddress, ERROR_ONLY_SP_GOVERNANCE );
1615	 require( updateDeployerCutRequests[_serviceProvider].lockupExpiryBlock <= block.number, "ServiceProviderFactory: Lockup must be expired" );
1616	 spDetails[_serviceProvider].deployerCut = ( updateDeployerCutRequests[_serviceProvider].newDeployerCut );
1617	 delete updateDeployerCutRequests[_serviceProvider];
1618	 emit DeployerCutUpdateRequestEvaluated( _serviceProvider, spDetails[_serviceProvider].deployerCut );
1619	 }
1620	 function updateServiceProviderStake( address _serviceProvider, uint256 _amount ) external {
1621	 _requireIsInitialized();
1622	 _requireStakingAddressIsSet();
1623	 _requireDelegateManagerAddressIsSet();
1624	 require( msg.sender == delegateManagerAddress, "ServiceProviderFactory: only callable by DelegateManager" );
1625	 spDetails[_serviceProvider].deployerStake = _amount;
1626	 _updateServiceProviderBoundStatus(_serviceProvider);
1627	 }
1628	 function updateDecreaseStakeLockupDuration(uint256 _duration) external {
1629	 _requireIsInitialized();
1630	 require( msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE );
1631	 _updateDecreaseStakeLockupDuration(_duration);
1632	 emit DecreaseStakeLockupDurationUpdated(_duration);
1633	 }
1634	 function updateDeployerCutLockupDuration(uint256 _duration) external {
1635	 _requireIsInitialized();
1636	 require( msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE );
1637	 _updateDeployerCutLockupDuration(_duration);
1638	 emit UpdateDeployerCutLockupDurationUpdated(_duration);
1639	 }
1640	 function getServiceProviderDeployerCutBase() external view returns (uint256) {
1641	 _requireIsInitialized();
1642	 return DEPLOYER_CUT_BASE;
1643	 }
1644	 function getDeployerCutLockupDuration() external view returns (uint256) {
1645	 _requireIsInitialized();
1646	 return deployerCutLockupDuration;
1647	 }
1648	 function getTotalServiceTypeProviders(bytes32 _serviceType) external view returns (uint256) {
1649	 _requireIsInitialized();
1650	 return serviceProviderTypeIDs[_serviceType];
1651	 }
1652	 function getServiceProviderIdFromEndpoint(string calldata _endpoint) external view returns (uint256) {
1653	 _requireIsInitialized();
1654	 return serviceProviderEndpointToId[keccak256(bytes(_endpoint))];
1655	 }
1656	 function getServiceProviderIdsFromAddress(address _ownerAddress, bytes32 _serviceType) external view returns (uint256[] memory) {
1657	 _requireIsInitialized();
1658	 return serviceProviderAddressToId[_ownerAddress][_serviceType];
1659	 }
1660	 function getServiceEndpointInfo(bytes32 _serviceType, uint256 _serviceId) external view returns (address owner, string memory endpoint, uint256 blockNumber, address delegateOwnerWallet) {
1661	 _requireIsInitialized();
1662	 ServiceEndpoint memory serviceEndpoint = serviceProviderInfo[_serviceType][_serviceId];
1663	 return ( serviceEndpoint.owner, serviceEndpoint.endpoint, serviceEndpoint.blocknumber, serviceEndpoint.delegateOwnerWallet );
1664	 }
1665	 function getServiceProviderDetails(address _serviceProvider) external view returns ( uint256 deployerStake, uint256 deployerCut, bool validBounds, uint256 numberOfEndpoints, uint256 minAccountStake, uint256 maxAccountStake) {
1666	 _requireIsInitialized();
1667	 return ( spDetails[_serviceProvider].deployerStake, spDetails[_serviceProvider].deployerCut, spDetails[_serviceProvider].validBounds, spDetails[_serviceProvider].numberOfEndpoints, spDetails[_serviceProvider].minAccountStake, spDetails[_serviceProvider].maxAccountStake );
1668	 }
1669	 function getPendingDecreaseStakeRequest(address _serviceProvider) external view returns (uint256 amount, uint256 lockupExpiryBlock) {
1670	 _requireIsInitialized();
1671	 return ( decreaseStakeRequests[_serviceProvider].decreaseAmount, decreaseStakeRequests[_serviceProvider].lockupExpiryBlock );
1672	 }
1673	 function getPendingUpdateDeployerCutRequest(address _serviceProvider) external view returns (uint256 newDeployerCut, uint256 lockupExpiryBlock) {
1674	 _requireIsInitialized();
1675	 return ( updateDeployerCutRequests[_serviceProvider].newDeployerCut, updateDeployerCutRequests[_serviceProvider].lockupExpiryBlock );
1676	 }
1677	 function getDecreaseStakeLockupDuration() external view returns (uint256) {
1678	 _requireIsInitialized();
1679	 return decreaseStakeLockupDuration;
1680	 }
1681	 function validateAccountStakeBalance(address _serviceProvider) external view {
1682	 _requireIsInitialized();
1683	 _requireStakingAddressIsSet();
1684	 _validateBalanceInternal( _serviceProvider, Staking(stakingAddress).totalStakedFor(_serviceProvider) );
1685	 }
1686	 function getGovernanceAddress() external view returns (address) {
1687	 _requireIsInitialized();
1688	 return governanceAddress;
1689	 }
1690	 function getStakingAddress() external view returns (address) {
1691	 _requireIsInitialized();
1692	 return stakingAddress;
1693	 }
1694	 function getDelegateManagerAddress() external view returns (address) {
1695	 _requireIsInitialized();
1696	 return delegateManagerAddress;
1697	 }
1698	 function getServiceTypeManagerAddress() external view returns (address) {
1699	 _requireIsInitialized();
1700	 return serviceTypeManagerAddress;
1701	 }
1702	 function getClaimsManagerAddress() external view returns (address) {
1703	 _requireIsInitialized();
1704	 return claimsManagerAddress;
1705	 }
1706	 function setGovernanceAddress(address _governanceAddress) external {
1707	 _requireIsInitialized();
1708	 require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);
1709	 _updateGovernanceAddress(_governanceAddress);
1710	 emit GovernanceAddressUpdated(_governanceAddress);
1711	 }
1712	 function setStakingAddress(address _address) external {
1713	 _requireIsInitialized();
1714	 require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);
1715	 stakingAddress = _address;
1716	 emit StakingAddressUpdated(_address);
1717	 }
1718	 function setDelegateManagerAddress(address _address) external {
1719	 _requireIsInitialized();
1720	 require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);
1721	 delegateManagerAddress = _address;
1722	 emit DelegateManagerAddressUpdated(_address);
1723	 }
1724	 function setServiceTypeManagerAddress(address _address) external {
1725	 _requireIsInitialized();
1726	 require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);
1727	 serviceTypeManagerAddress = _address;
1728	 emit ServiceTypeManagerAddressUpdated(_address);
1729	 }
1730	 function setClaimsManagerAddress(address _address) external {
1731	 _requireIsInitialized();
1732	 require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);
1733	 claimsManagerAddress = _address;
1734	 emit ClaimsManagerAddressUpdated(_address);
1735	 }
1736	 function _updateServiceProviderBoundStatus(address _serviceProvider) internal {
1737	 uint256 totalSPStake = Staking(stakingAddress).totalStakedFor(_serviceProvider);
1738	 if (totalSPStake < spDetails[_serviceProvider].minAccountStake || totalSPStake > spDetails[_serviceProvider].maxAccountStake) {
1739	 spDetails[_serviceProvider].validBounds = false;
1740	 }
1741	 else {
1742	 spDetails[_serviceProvider].validBounds = true;
1743	 }
1744	 }
1745	 function _updateGovernanceAddress(address _governanceAddress) internal {
1746	 require( Governance(_governanceAddress).isGovernanceAddress() == true, "ServiceProviderFactory: _governanceAddress is not a valid governance contract" );
1747	 governanceAddress = _governanceAddress;
1748	 }
1749	 function _updateDeployerCutLockupDuration(uint256 _duration) internal {
1750	 require( ClaimsManager(claimsManagerAddress).getFundingRoundBlockDiff() < _duration, "ServiceProviderFactory: Incoming duration must be greater than funding round block diff" );
1751	 deployerCutLockupDuration = _duration;
1752	 }
1753	 function _updateDecreaseStakeLockupDuration(uint256 _duration) internal {
1754	 Governance governance = Governance(governanceAddress);
1755	 require( _duration > governance.getVotingPeriod() + governance.getExecutionDelay(), "ServiceProviderFactory: decreaseStakeLockupDuration duration must be greater than governance votingPeriod + executionDelay" );
1756	 decreaseStakeLockupDuration = _duration;
1757	 }
1758	 function _validateBalanceInternal(address _serviceProvider, uint256 _amount) internal view {
1759	 require( _amount <= spDetails[_serviceProvider].maxAccountStake, "ServiceProviderFactory: Maximum stake amount exceeded" );
1760	 require( spDetails[_serviceProvider].deployerStake >= spDetails[_serviceProvider].minAccountStake, "ServiceProviderFactory: Minimum stake requirement not met" );
1761	 }
1762	 function _decreaseRequestIsPending(address _serviceProvider) internal view returns (bool) {
1763	 return ( (decreaseStakeRequests[_serviceProvider].lockupExpiryBlock > 0) && (decreaseStakeRequests[_serviceProvider].decreaseAmount > 0) );
1764	 }
1765	 function _claimPending(address _serviceProvider) internal view returns (bool) {
1766	 return ClaimsManager(claimsManagerAddress).claimPending(_serviceProvider);
1767	 }
1768	 function _requirePendingDeployerCutOperation (address _serviceProvider) private view {
1769	 require( (updateDeployerCutRequests[_serviceProvider].lockupExpiryBlock != 0), "ServiceProviderFactory: No update deployer cut operation pending" );
1770	 }
1771	 function _requireStakingAddressIsSet() private view {
1772	 require( stakingAddress != address(0x00), "ServiceProviderFactory: stakingAddress is not set" );
1773	 }
1774	 function _requireDelegateManagerAddressIsSet() private view {
1775	 require( delegateManagerAddress != address(0x00), "ServiceProviderFactory: delegateManagerAddress is not set" );
1776	 }
1777	 function _requireServiceTypeManagerAddressIsSet() private view {
1778	 require( serviceTypeManagerAddress != address(0x00), "ServiceProviderFactory: serviceTypeManagerAddress is not set" );
1779	 }
1780	 function _requireClaimsManagerAddressIsSet() private view {
1781	 require( claimsManagerAddress != address(0x00), "ServiceProviderFactory: claimsManagerAddress is not set" );
1782	 }
1783	 }
1784	 pragma solidity ^0.5.0;
1785	 contract DelegateManagerV2 is InitializableV2 {
1786	 using SafeMath for uint256;
1787	 string private constant ERROR_ONLY_GOVERNANCE = ( "DelegateManager: Only callable by Governance contract" );
1788	 string private constant ERROR_MINIMUM_DELEGATION = ( "DelegateManager: Minimum delegation amount required" );
1789	 string private constant ERROR_ONLY_SP_GOVERNANCE = ( "DelegateManager: Only callable by target SP or governance" );
1790	 string private constant ERROR_DELEGATOR_STAKE = ( "DelegateManager: Delegator must be staked for SP" );
1791	 address private governanceAddress;
1792	 address private stakingAddress;
1793	 address private serviceProviderFactoryAddress;
1794	 address private claimsManagerAddress;
1795	 uint256 private undelegateLockupDuration;
1796	 uint256 private maxDelegators;
1797	 uint256 private minDelegationAmount;
1798	 uint256 private removeDelegatorLockupDuration;
1799	 uint256 private removeDelegatorEvalDuration;
1800	 ERC20Mintable private audiusToken;
1801	 struct ServiceProviderDelegateInfo {
1802	 uint256 totalDelegatedStake;
1803	 uint256 totalLockedUpStake;
1804	 address[] delegators;
1805	 }
1806	 struct UndelegateStakeRequest {
1807	 address serviceProvider;
1808	 uint256 amount;
1809	 uint256 lockupExpiryBlock;
1810	 }
1811	 mapping (address => ServiceProviderDelegateInfo) private spDelegateInfo;
1812	 mapping (address => mapping(address => uint256)) private delegateInfo;
1813	 mapping (address => uint256) private delegatorTotalStake;
1814	 mapping (address => UndelegateStakeRequest) private undelegateRequests;
1815	 mapping (address => mapping (address => uint256)) private removeDelegatorRequests;
1816	 event IncreaseDelegatedStake( address indexed _delegator, address indexed _serviceProvider, uint256 indexed _increaseAmount );
1817	 event UndelegateStakeRequested( address indexed _delegator, address indexed _serviceProvider, uint256 indexed _amount, uint256 _lockupExpiryBlock );
1818	 event UndelegateStakeRequestCancelled( address indexed _delegator, address indexed _serviceProvider, uint256 indexed _amount );
1819	 event UndelegateStakeRequestEvaluated( address indexed _delegator, address indexed _serviceProvider, uint256 indexed _amount );
1820	 event Claim( address indexed _claimer, uint256 indexed _rewards, uint256 indexed _newTotal );
1821	 event Slash( address indexed _target, uint256 indexed _amount, uint256 indexed _newTotal );
1822	 event RemoveDelegatorRequested( address indexed _serviceProvider, address indexed _delegator, uint256 indexed _lockupExpiryBlock );
1823	 event RemoveDelegatorRequestCancelled( address indexed _serviceProvider, address indexed _delegator );
1824	 event RemoveDelegatorRequestEvaluated( address indexed _serviceProvider, address indexed _delegator, uint256 indexed _unstakedAmount );
1825	 event MaxDelegatorsUpdated(uint256 indexed _maxDelegators);
1826	 event MinDelegationUpdated(uint256 indexed _minDelegationAmount);
1827	 event UndelegateLockupDurationUpdated(uint256 indexed _undelegateLockupDuration);
1828	 event GovernanceAddressUpdated(address indexed _newGovernanceAddress);
1829	 event StakingAddressUpdated(address indexed _newStakingAddress);
1830	 event ServiceProviderFactoryAddressUpdated(address indexed _newServiceProviderFactoryAddress);
1831	 event ClaimsManagerAddressUpdated(address indexed _newClaimsManagerAddress);
1832	 event RemoveDelegatorLockupDurationUpdated(uint256 indexed _removeDelegatorLockupDuration);
1833	 event RemoveDelegatorEvalDurationUpdated(uint256 indexed _removeDelegatorEvalDuration);
1834	 string private constant ERROR_ONLY_SERVICE_PROVIDER = ( "DelegateManager: Only callable by valid Service Provider" );
1835	 mapping (address => uint256) private spMinDelegationAmounts;
1836	 event SPMinDelegationAmountUpdated( address indexed _serviceProvider, uint256 indexed _spMinDelegationAmount );
1837	 function initialize ( address _tokenAddress, address _governanceAddress, uint256 _undelegateLockupDuration ) public initializer {
1838	 _updateGovernanceAddress(_governanceAddress);
1839	 audiusToken = ERC20Mintable(_tokenAddress);
1840	 maxDelegators = 175;
1841	 minDelegationAmount = 100 * 10**uint256(18);
1842	 InitializableV2.initialize();
1843	 _updateUndelegateLockupDuration(_undelegateLockupDuration);
1844	 _updateRemoveDelegatorLockupDuration(46523);
1845	 removeDelegatorEvalDuration = 6646;
1846	 }
1847	 function delegateStake( address _targetSP, uint256 _amount ) external returns (uint256) {
1848	 _requireIsInitialized();
1849	 _requireStakingAddressIsSet();
1850	 _requireServiceProviderFactoryAddressIsSet();
1851	 _requireClaimsManagerAddressIsSet();
1852	 require( !_claimPending(_targetSP), "DelegateManager: Delegation not permitted for SP pending claim" );
1853	 address delegator = msg.sender;
1854	 Staking stakingContract = Staking(stakingAddress);
1855	 stakingContract.delegateStakeFor( _targetSP, delegator, _amount );
1856	 if (!_delegatorExistsForSP(delegator, _targetSP)) {
1857	 spDelegateInfo[_targetSP].delegators.push(delegator);
1858	 require( spDelegateInfo[_targetSP].delegators.length <= maxDelegators, "DelegateManager: Maximum delegators exceeded" );
1859	 }
1860	 _updateDelegatorStake( delegator, _targetSP, spDelegateInfo[_targetSP].totalDelegatedStake.add(_amount), delegateInfo[delegator][_targetSP].add(_amount), delegatorTotalStake[delegator].add(_amount) );
1861	 require( (delegateInfo[delegator][_targetSP] >= minDelegationAmount && delegateInfo[delegator][_targetSP] >= spMinDelegationAmounts[_targetSP] ), ERROR_MINIMUM_DELEGATION );
1862	 ServiceProviderFactory( serviceProviderFactoryAddress ).validateAccountStakeBalance(_targetSP);
1863	 emit IncreaseDelegatedStake( delegator, _targetSP, _amount );
1864	 return delegateInfo[delegator][_targetSP];
1865	 }
1866	 function requestUndelegateStake( address _target, uint256 _amount ) external returns (uint256) {
1867	 _requireIsInitialized();
1868	 _requireClaimsManagerAddressIsSet();
1869	 require( _amount > 0, "DelegateManager: Requested undelegate stake amount must be greater than zero" );
1870	 require( !_claimPending(_target), "DelegateManager: Undelegate request not permitted for SP pending claim" );
1871	 address delegator = msg.sender;
1872	 require( _delegatorExistsForSP(delegator, _target), ERROR_DELEGATOR_STAKE );
1873	 require( !_undelegateRequestIsPending(delegator), "DelegateManager: No pending lockup expected" );
1874	 uint256 currentlyDelegatedToSP = delegateInfo[delegator][_target];
1875	 require( _amount <= currentlyDelegatedToSP, "DelegateManager: Cannot decrease greater than currently staked for this ServiceProvider" );
1876	 uint256 lockupExpiryBlock = block.number.add(undelegateLockupDuration);
1877	 _updateUndelegateStakeRequest( delegator, _target, _amount, lockupExpiryBlock );
1878	 _updateServiceProviderLockupAmount( _target, spDelegateInfo[_target].totalLockedUpStake.add(_amount) );
1879	 emit UndelegateStakeRequested(delegator, _target, _amount, lockupExpiryBlock);
1880	 return delegateInfo[delegator][_target].sub(_amount);
1881	 }
1882	 function cancelUndelegateStakeRequest() external {
1883	 _requireIsInitialized();
1884	 address delegator = msg.sender;
1885	 require( _undelegateRequestIsPending(delegator), "DelegateManager: Pending lockup expected" );
1886	 uint256 unstakeAmount = undelegateRequests[delegator].amount;
1887	 address unlockFundsSP = undelegateRequests[delegator].serviceProvider;
1888	 _updateServiceProviderLockupAmount( unlockFundsSP, spDelegateInfo[unlockFundsSP].totalLockedUpStake.sub(unstakeAmount) );
1889	 _resetUndelegateStakeRequest(delegator);
1890	 emit UndelegateStakeRequestCancelled(delegator, unlockFundsSP, unstakeAmount);
1891	 }
1892	 function undelegateStake() external returns (uint256) {
1893	 _requireIsInitialized();
1894	 _requireStakingAddressIsSet();
1895	 _requireServiceProviderFactoryAddressIsSet();
1896	 _requireClaimsManagerAddressIsSet();
1897	 address delegator = msg.sender;
1898	 require( _undelegateRequestIsPending(delegator), "DelegateManager: Pending lockup expected" );
1899	 require( undelegateRequests[delegator].lockupExpiryBlock <= block.number, "DelegateManager: Lockup must be expired" );
1900	 require( !_claimPending(undelegateRequests[delegator].serviceProvider), "DelegateManager: Undelegate not permitted for SP pending claim" );
1901	 address serviceProvider = undelegateRequests[delegator].serviceProvider;
1902	 uint256 unstakeAmount = undelegateRequests[delegator].amount;
1903	 Staking(stakingAddress).undelegateStakeFor( serviceProvider, delegator, unstakeAmount );
1904	 _updateDelegatorStake( delegator, serviceProvider, spDelegateInfo[serviceProvider].totalDelegatedStake.sub(unstakeAmount), delegateInfo[delegator][serviceProvider].sub(unstakeAmount), delegatorTotalStake[delegator].sub(unstakeAmount) );
1905	 require( ( delegateInfo[delegator][serviceProvider] >= minDelegationAmount && delegateInfo[delegator][serviceProvider] >= spMinDelegationAmounts[serviceProvider] ) || delegateInfo[delegator][serviceProvider] == 0, ERROR_MINIMUM_DELEGATION );
1906	 if (delegateInfo[delegator][serviceProvider] == 0) {
1907	 _removeFromDelegatorsList(serviceProvider, delegator);
1908	 }
1909	 _updateServiceProviderLockupAmount( serviceProvider, spDelegateInfo[serviceProvider].totalLockedUpStake.sub(unstakeAmount) );
1910	 _resetUndelegateStakeRequest(delegator);
1911	 emit UndelegateStakeRequestEvaluated( delegator, serviceProvider, unstakeAmount );
1912	 (uint256 spDeployerStake,,,,,) = ( ServiceProviderFactory(serviceProviderFactoryAddress).getServiceProviderDetails(serviceProvider) );
1913	 ServiceProviderFactory(serviceProviderFactoryAddress).updateServiceProviderStake( serviceProvider, spDeployerStake );
1914	 return delegateInfo[delegator][serviceProvider];
1915	 }
1916	 function claimRewards(address _serviceProvider) external {
1917	 _requireIsInitialized();
1918	 _requireStakingAddressIsSet();
1919	 _requireServiceProviderFactoryAddressIsSet();
1920	 _requireClaimsManagerAddressIsSet();
1921	 ServiceProviderFactory spFactory = ServiceProviderFactory(serviceProviderFactoryAddress);
1922	 ( uint256 totalBalanceInStaking, uint256 totalBalanceInSPFactory, uint256 totalActiveFunds, uint256 totalRewards, uint256 deployerCut ) = _validateClaimRewards(spFactory, _serviceProvider);
1923	 if (totalRewards == 0) {
1924	 return;
1925	 }
1926	 uint256 totalDelegatedStakeIncrease = _distributeDelegateRewards( _serviceProvider, totalActiveFunds, totalRewards, deployerCut, spFactory.getServiceProviderDeployerCutBase() );
1927	 spDelegateInfo[_serviceProvider].totalDelegatedStake = ( spDelegateInfo[_serviceProvider].totalDelegatedStake.add(totalDelegatedStakeIncrease) );
1928	 uint256 spRewardShare = totalRewards.sub(totalDelegatedStakeIncrease);
1929	 uint256 newSPFactoryBalance = totalBalanceInSPFactory.add(spRewardShare);
1930	 require( totalBalanceInStaking == newSPFactoryBalance.add(spDelegateInfo[_serviceProvider].totalDelegatedStake), "DelegateManager: claimRewards amount mismatch" );
1931	 spFactory.updateServiceProviderStake( _serviceProvider, newSPFactoryBalance );
1932	 }
1933	 function slash(uint256 _amount, address _slashAddress) external {
1934	 _requireIsInitialized();
1935	 _requireStakingAddressIsSet();
1936	 _requireServiceProviderFactoryAddressIsSet();
1937	 require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);
1938	 Staking stakingContract = Staking(stakingAddress);
1939	 ServiceProviderFactory spFactory = ServiceProviderFactory(serviceProviderFactoryAddress);
1940	 uint256 totalBalanceInStakingPreSlash = stakingContract.totalStakedFor(_slashAddress);
1941	 require( (totalBalanceInStakingPreSlash >= _amount), "DelegateManager: Cannot slash more than total currently staked" );
1942	 (uint256 spLockedStake,) = spFactory.getPendingDecreaseStakeRequest(_slashAddress);
1943	 if (spLockedStake > 0) {
1944	 spFactory.cancelDecreaseStakeRequest(_slashAddress);
1945	 }
1946	 (uint256 totalBalanceInSPFactory,,,,,) = ( spFactory.getServiceProviderDetails(_slashAddress) );
1947	 require( totalBalanceInSPFactory > 0, "DelegateManager: Service Provider stake required" );
1948	 stakingContract.slash(_amount, _slashAddress);
1949	 uint256 totalBalanceInStakingAfterSlash = stakingContract.totalStakedFor(_slashAddress);
1950	 emit Slash(_slashAddress, _amount, totalBalanceInStakingAfterSlash);
1951	 uint256 totalDelegatedStakeDecrease = 0;
1952	 for (uint256 i = 0; i < spDelegateInfo[_slashAddress].delegators.length; i++) {
1953	 address delegator = spDelegateInfo[_slashAddress].delegators[i];
1954	 uint256 preSlashDelegateStake = delegateInfo[delegator][_slashAddress];
1955	 uint256 newDelegateStake = ( totalBalanceInStakingAfterSlash.mul(preSlashDelegateStake) ).div(totalBalanceInStakingPreSlash);
1956	 delegateInfo[delegator][_slashAddress] = ( delegateInfo[delegator][_slashAddress].sub(preSlashDelegateStake.sub(newDelegateStake)) );
1957	 _updateDelegatorTotalStake( delegator, delegatorTotalStake[delegator].sub(preSlashDelegateStake.sub(newDelegateStake)) );
1958	 totalDelegatedStakeDecrease = ( totalDelegatedStakeDecrease.add(preSlashDelegateStake.sub(newDelegateStake)) );
1959	 if (undelegateRequests[delegator].amount != 0) {
1960	 address unstakeSP = undelegateRequests[delegator].serviceProvider;
1961	 uint256 unstakeAmount = undelegateRequests[delegator].amount;
1962	 _updateServiceProviderLockupAmount( unstakeSP, spDelegateInfo[unstakeSP].totalLockedUpStake.sub(unstakeAmount) );
1963	 _resetUndelegateStakeRequest(delegator);
1964	 }
1965	 }
1966	 spDelegateInfo[_slashAddress].totalDelegatedStake = ( spDelegateInfo[_slashAddress].totalDelegatedStake.sub(totalDelegatedStakeDecrease) );
1967	 uint256 totalStakeDecrease = ( totalBalanceInStakingPreSlash.sub(totalBalanceInStakingAfterSlash) );
1968	 uint256 totalSPFactoryBalanceDecrease = ( totalStakeDecrease.sub(totalDelegatedStakeDecrease) );
1969	 spFactory.updateServiceProviderStake( _slashAddress, totalBalanceInSPFactory.sub(totalSPFactoryBalanceDecrease) );
1970	 }
1971	 function requestRemoveDelegator(address _serviceProvider, address _delegator) external {
1972	 _requireIsInitialized();
1973	 require( msg.sender == _serviceProvider || msg.sender == governanceAddress, ERROR_ONLY_SP_GOVERNANCE );
1974	 require( removeDelegatorRequests[_serviceProvider][_delegator] == 0, "DelegateManager: Pending remove delegator request" );
1975	 require( _delegatorExistsForSP(_delegator, _serviceProvider), ERROR_DELEGATOR_STAKE );
1976	 removeDelegatorRequests[_serviceProvider][_delegator] = ( block.number + removeDelegatorLockupDuration );
1977	 emit RemoveDelegatorRequested( _serviceProvider, _delegator, removeDelegatorRequests[_serviceProvider][_delegator] );
1978	 }
1979	 function cancelRemoveDelegatorRequest(address _serviceProvider, address _delegator) external {
1980	 require( msg.sender == _serviceProvider || msg.sender == governanceAddress, ERROR_ONLY_SP_GOVERNANCE );
1981	 require( removeDelegatorRequests[_serviceProvider][_delegator] != 0, "DelegateManager: No pending request" );
1982	 removeDelegatorRequests[_serviceProvider][_delegator] = 0;
1983	 emit RemoveDelegatorRequestCancelled(_serviceProvider, _delegator);
1984	 }
1985	 function removeDelegator(address _serviceProvider, address _delegator) external {
1986	 _requireIsInitialized();
1987	 _requireStakingAddressIsSet();
1988	 require( msg.sender == _serviceProvider || msg.sender == governanceAddress, ERROR_ONLY_SP_GOVERNANCE );
1989	 require( removeDelegatorRequests[_serviceProvider][_delegator] != 0, "DelegateManager: No pending request" );
1990	 require( block.number >= removeDelegatorRequests[_serviceProvider][_delegator], "DelegateManager: Lockup must be expired" );
1991	 require( block.number < removeDelegatorRequests[_serviceProvider][_delegator] + removeDelegatorEvalDuration, "DelegateManager: RemoveDelegator evaluation window expired" );
1992	 uint256 unstakeAmount = delegateInfo[_delegator][_serviceProvider];
1993	 Staking(stakingAddress).undelegateStakeFor( _serviceProvider, _delegator, unstakeAmount );
1994	 _updateDelegatorStake( _delegator, _serviceProvider, spDelegateInfo[_serviceProvider].totalDelegatedStake.sub(unstakeAmount), delegateInfo[_delegator][_serviceProvider].sub(unstakeAmount), delegatorTotalStake[_delegator].sub(unstakeAmount) );
1995	 if ( _undelegateRequestIsPending(_delegator) && undelegateRequests[_delegator].serviceProvider == _serviceProvider ) {
1996	 _updateServiceProviderLockupAmount( _serviceProvider, spDelegateInfo[_serviceProvider].totalLockedUpStake.sub(undelegateRequests[_delegator].amount) );
1997	 _resetUndelegateStakeRequest(_delegator);
1998	 }
1999	 _removeFromDelegatorsList(_serviceProvider, _delegator);
2000	 removeDelegatorRequests[_serviceProvider][_delegator] = 0;
2001	 emit RemoveDelegatorRequestEvaluated(_serviceProvider, _delegator, unstakeAmount);
2002	 }
2003	 function updateSPMinDelegationAmount( address _serviceProvider, uint256 _spMinDelegationAmount ) external {
2004	 _requireIsInitialized();
2005	 require(msg.sender == _serviceProvider, ERROR_ONLY_SERVICE_PROVIDER);
2006	 (,,, uint256 numEndpoints,,) = ( ServiceProviderFactory(serviceProviderFactoryAddress) .getServiceProviderDetails(_serviceProvider) );
2007	 require(numEndpoints > 0, ERROR_ONLY_SERVICE_PROVIDER);
2008	 spMinDelegationAmounts[_serviceProvider] = _spMinDelegationAmount;
2009	 emit SPMinDelegationAmountUpdated(_serviceProvider, _spMinDelegationAmount);
2010	 }
2011	 function updateUndelegateLockupDuration(uint256 _duration) external {
2012	 _requireIsInitialized();
2013	 require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);
2014	 _updateUndelegateLockupDuration(_duration);
2015	 emit UndelegateLockupDurationUpdated(_duration);
2016	 }
2017	 function updateMaxDelegators(uint256 _maxDelegators) external {
2018	 _requireIsInitialized();
2019	 require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);
2020	 maxDelegators = _maxDelegators;
2021	 emit MaxDelegatorsUpdated(_maxDelegators);
2022	 }
2023	 function updateMinDelegationAmount(uint256 _minDelegationAmount) external {
2024	 _requireIsInitialized();
2025	 require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);
2026	 minDelegationAmount = _minDelegationAmount;
2027	 emit MinDelegationUpdated(_minDelegationAmount);
2028	 }
2029	 function updateRemoveDelegatorLockupDuration(uint256 _duration) external {
2030	 _requireIsInitialized();
2031	 require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);
2032	 _updateRemoveDelegatorLockupDuration(_duration);
2033	 emit RemoveDelegatorLockupDurationUpdated(_duration);
2034	 }
2035	 function updateRemoveDelegatorEvalDuration(uint256 _duration) external {
2036	 _requireIsInitialized();
2037	 require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);
2038	 removeDelegatorEvalDuration = _duration;
2039	 emit RemoveDelegatorEvalDurationUpdated(_duration);
2040	 }
2041	 function setGovernanceAddress(address _governanceAddress) external {
2042	 _requireIsInitialized();
2043	 require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);
2044	 _updateGovernanceAddress(_governanceAddress);
2045	 governanceAddress = _governanceAddress;
2046	 emit GovernanceAddressUpdated(_governanceAddress);
2047	 }
2048	 function setStakingAddress(address _stakingAddress) external {
2049	 _requireIsInitialized();
2050	 require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);
2051	 stakingAddress = _stakingAddress;
2052	 emit StakingAddressUpdated(_stakingAddress);
2053	 }
2054	 function setServiceProviderFactoryAddress(address _spFactory) external {
2055	 _requireIsInitialized();
2056	 require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);
2057	 serviceProviderFactoryAddress = _spFactory;
2058	 emit ServiceProviderFactoryAddressUpdated(_spFactory);
2059	 }
2060	 function setClaimsManagerAddress(address _claimsManagerAddress) external {
2061	 _requireIsInitialized();
2062	 require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);
2063	 claimsManagerAddress = _claimsManagerAddress;
2064	 emit ClaimsManagerAddressUpdated(_claimsManagerAddress);
2065	 }
2066	 function getDelegatorsList(address _sp) external view returns (address[] memory) {
2067	 _requireIsInitialized();
2068	 return spDelegateInfo[_sp].delegators;
2069	 }
2070	 function getTotalDelegatorStake(address _delegator) external view returns (uint256) {
2071	 _requireIsInitialized();
2072	 return delegatorTotalStake[_delegator];
2073	 }
2074	 function getTotalDelegatedToServiceProvider(address _sp) external view returns (uint256) {
2075	 _requireIsInitialized();
2076	 return spDelegateInfo[_sp].totalDelegatedStake;
2077	 }
2078	 function getTotalLockedDelegationForServiceProvider(address _sp) external view returns (uint256) {
2079	 _requireIsInitialized();
2080	 return spDelegateInfo[_sp].totalLockedUpStake;
2081	 }
2082	 function getDelegatorStakeForServiceProvider(address _delegator, address _serviceProvider) external view returns (uint256) {
2083	 _requireIsInitialized();
2084	 return delegateInfo[_delegator][_serviceProvider];
2085	 }
2086	 function getPendingUndelegateRequest(address _delegator) external view returns (address target, uint256 amount, uint256 lockupExpiryBlock) {
2087	 _requireIsInitialized();
2088	 UndelegateStakeRequest memory req = undelegateRequests[_delegator];
2089	 return (req.serviceProvider, req.amount, req.lockupExpiryBlock);
2090	 }
2091	 function getPendingRemoveDelegatorRequest( address _serviceProvider, address _delegator ) external view returns (uint256) {
2092	 _requireIsInitialized();
2093	 return removeDelegatorRequests[_serviceProvider][_delegator];
2094	 }
2095	 function getSPMinDelegationAmount(address _serviceProvider) external view returns (uint256) {
2096	 return spMinDelegationAmounts[_serviceProvider];
2097	 }
2098	 function getUndelegateLockupDuration() external view returns (uint256) {
2099	 _requireIsInitialized();
2100	 return undelegateLockupDuration;
2101	 }
2102	 function getMaxDelegators() external view returns (uint256) {
2103	 _requireIsInitialized();
2104	 return maxDelegators;
2105	 }
2106	 function getMinDelegationAmount() external view returns (uint256) {
2107	 _requireIsInitialized();
2108	 return minDelegationAmount;
2109	 }
2110	 function getRemoveDelegatorLockupDuration() external view returns (uint256) {
2111	 _requireIsInitialized();
2112	 return removeDelegatorLockupDuration;
2113	 }
2114	 function getRemoveDelegatorEvalDuration() external view returns (uint256) {
2115	 _requireIsInitialized();
2116	 return removeDelegatorEvalDuration;
2117	 }
2118	 function getGovernanceAddress() external view returns (address) {
2119	 _requireIsInitialized();
2120	 return governanceAddress;
2121	 }
2122	 function getServiceProviderFactoryAddress() external view returns (address) {
2123	 _requireIsInitialized();
2124	 return serviceProviderFactoryAddress;
2125	 }
2126	 function getClaimsManagerAddress() external view returns (address) {
2127	 _requireIsInitialized();
2128	 return claimsManagerAddress;
2129	 }
2130	 function getStakingAddress() external view returns (address) {
2131	 _requireIsInitialized();
2132	 return stakingAddress;
2133	 }
2134	 function _validateClaimRewards(ServiceProviderFactory spFactory, address _serviceProvider) internal returns ( uint256 totalBalanceInStaking, uint256 totalBalanceInSPFactory, uint256 totalActiveFunds, uint256 totalRewards, uint256 deployerCut ) {
2135	 (uint256 spLockedStake,) = spFactory.getPendingDecreaseStakeRequest(_serviceProvider);
2136	 uint256 totalLockedUpStake = ( spDelegateInfo[_serviceProvider].totalLockedUpStake.add(spLockedStake) );
2137	 uint256 mintedRewards = ClaimsManager(claimsManagerAddress).processClaim( _serviceProvider, totalLockedUpStake );
2138	 totalBalanceInStaking = Staking(stakingAddress).totalStakedFor(_serviceProvider);
2139	 ( totalBalanceInSPFactory, deployerCut, ,,, ) = spFactory.getServiceProviderDetails(_serviceProvider);
2140	 uint256 totalBalanceOutsideStaking = ( totalBalanceInSPFactory.add(spDelegateInfo[_serviceProvider].totalDelegatedStake) );
2141	 totalActiveFunds = totalBalanceOutsideStaking.sub(totalLockedUpStake);
2142	 require( mintedRewards == totalBalanceInStaking.sub(totalBalanceOutsideStaking), "DelegateManager: Reward amount mismatch" );
2143	 emit Claim(_serviceProvider, totalRewards, totalBalanceInStaking);
2144	 return ( totalBalanceInStaking, totalBalanceInSPFactory, totalActiveFunds, mintedRewards, deployerCut );
2145	 }
2146	 function _updateDelegatorStake( address _delegator, address _serviceProvider, uint256 _totalServiceProviderDelegatedStake, uint256 _totalStakedForSpFromDelegator, uint256 _totalDelegatorStake ) internal {
2147	 spDelegateInfo[_serviceProvider].totalDelegatedStake = _totalServiceProviderDelegatedStake;
2148	 delegateInfo[_delegator][_serviceProvider] = _totalStakedForSpFromDelegator;
2149	 _updateDelegatorTotalStake(_delegator, _totalDelegatorStake);
2150	 }
2151	 function _resetUndelegateStakeRequest(address _delegator) internal {
2152	 _updateUndelegateStakeRequest(_delegator, address(0), 0, 0);
2153	 }
2154	 function _updateUndelegateStakeRequest( address _delegator, address _serviceProvider, uint256 _amount, uint256 _lockupExpiryBlock ) internal {
2155	 undelegateRequests[_delegator] = UndelegateStakeRequest({
2156	 lockupExpiryBlock: _lockupExpiryBlock, amount: _amount, serviceProvider: _serviceProvider }
2157	 );
2158	 }
2159	 function _updateDelegatorTotalStake(address _delegator, uint256 _amount) internal {
2160	 delegatorTotalStake[_delegator] = _amount;
2161	 }
2162	 function _updateServiceProviderLockupAmount( address _serviceProvider, uint256 _updatedLockupAmount ) internal {
2163	 spDelegateInfo[_serviceProvider].totalLockedUpStake = _updatedLockupAmount;
2164	 }
2165	 function _removeFromDelegatorsList(address _serviceProvider, address _delegator) internal {
2166	 for (uint256 i = 0; i < spDelegateInfo[_serviceProvider].delegators.length; i++) {
2167	 if (spDelegateInfo[_serviceProvider].delegators[i] == _delegator) {
2168	 spDelegateInfo[_serviceProvider].delegators[i] = spDelegateInfo[_serviceProvider].delegators[spDelegateInfo[_serviceProvider].delegators.length - 1];
2169	 spDelegateInfo[_serviceProvider].delegators.length--;
2170	 break;
2171	 }
2172	 }
2173	 }
2174	 function _distributeDelegateRewards( address _sp, uint256 _totalActiveFunds, uint256 _totalRewards, uint256 _deployerCut, uint256 _deployerCutBase ) internal returns (uint256 totalDelegatedStakeIncrease) {
2175	 for (uint256 i = 0; i < spDelegateInfo[_sp].delegators.length; i++) {
2176	 address delegator = spDelegateInfo[_sp].delegators[i];
2177	 uint256 delegateStakeToSP = delegateInfo[delegator][_sp];
2178	 if (undelegateRequests[delegator].serviceProvider == _sp) {
2179	 delegateStakeToSP = delegateStakeToSP.sub(undelegateRequests[delegator].amount);
2180	 }
2181	 uint256 rewardsPriorToSPCut = ( delegateStakeToSP.mul(_totalRewards) ).div(_totalActiveFunds);
2182	 uint256 spDeployerCut = ( (delegateStakeToSP.mul(_totalRewards)).mul(_deployerCut) ).div( _totalActiveFunds.mul(_deployerCutBase) );
2183	 delegateInfo[delegator][_sp] = ( delegateInfo[delegator][_sp].add(rewardsPriorToSPCut.sub(spDeployerCut)) );
2184	 _updateDelegatorTotalStake( delegator, delegatorTotalStake[delegator].add(rewardsPriorToSPCut.sub(spDeployerCut)) );
2185	 totalDelegatedStakeIncrease = ( totalDelegatedStakeIncrease.add(rewardsPriorToSPCut.sub(spDeployerCut)) );
2186	 }
2187	 return (totalDelegatedStakeIncrease);
2188	 }
2189	 function _updateGovernanceAddress(address _governanceAddress) internal {
2190	 require( Governance(_governanceAddress).isGovernanceAddress() == true, "DelegateManager: _governanceAddress is not a valid governance contract" );
2191	 governanceAddress = _governanceAddress;
2192	 }
2193	 function _updateRemoveDelegatorLockupDuration(uint256 _duration) internal {
2194	 Governance governance = Governance(governanceAddress);
2195	 require( _duration > governance.getVotingPeriod() + governance.getExecutionDelay(), "DelegateManager: removeDelegatorLockupDuration duration must be greater than governance votingPeriod + executionDelay" );
2196	 removeDelegatorLockupDuration = _duration;
2197	 }
2198	 function _updateUndelegateLockupDuration(uint256 _duration) internal {
2199	 Governance governance = Governance(governanceAddress);
2200	 require( _duration > governance.getVotingPeriod() + governance.getExecutionDelay(), "DelegateManager: undelegateLockupDuration duration must be greater than governance votingPeriod + executionDelay" );
2201	 undelegateLockupDuration = _duration;
2202	 }
2203	 function _delegatorExistsForSP( address _delegator, address _serviceProvider ) internal view returns (bool) {
2204	 for (uint256 i = 0; i < spDelegateInfo[_serviceProvider].delegators.length; i++) {
2205	 if (spDelegateInfo[_serviceProvider].delegators[i] == _delegator) {
2206	 return true;
2207	 }
2208	 }
2209	 return false;
2210	 }
2211	 function _claimPending(address _sp) internal view returns (bool) {
2212	 ClaimsManager claimsManager = ClaimsManager(claimsManagerAddress);
2213	 return claimsManager.claimPending(_sp);
2214	 }
2215	 function _undelegateRequestIsPending(address _delegator) internal view returns (bool) {
2216	 return ( (undelegateRequests[_delegator].lockupExpiryBlock != 0) && (undelegateRequests[_delegator].amount != 0) && (undelegateRequests[_delegator].serviceProvider != address(0)) );
2217	 }
2218	 function _requireStakingAddressIsSet() private view {
2219	 require( stakingAddress != address(0x00), "DelegateManager: stakingAddress is not set" );
2220	 }
2221	 function _requireServiceProviderFactoryAddressIsSet() private view {
2222	 require( serviceProviderFactoryAddress != address(0x00), "DelegateManager: serviceProviderFactoryAddress is not set" );
2223	 }
2224	 function _requireClaimsManagerAddressIsSet() private view {
2225	 require( claimsManagerAddress != address(0x00), "DelegateManager: claimsManagerAddress is not set" );
2226	 }
2227	 }
