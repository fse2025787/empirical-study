row number 
1	          pragma solidity 0.5.17;
2	 interface IntVoteInterface {
3	 modifier votable(bytes32 _proposalId) {
4	 revert("proposal is not votable");
5	 _;
6	 }
7	 event NewProposal( bytes32 indexed _proposalId, address indexed _organization, uint256 _numOfChoices, address _proposer, bytes32 _paramsHash );
8	 event ExecuteProposal(bytes32 indexed _proposalId, address indexed _organization, uint256 _decision, uint256 _totalReputation );
9	 event VoteProposal( bytes32 indexed _proposalId, address indexed _organization, address indexed _voter, uint256 _vote, uint256 _reputation );
10	 event CancelProposal(bytes32 indexed _proposalId, address indexed _organization );
11	 event CancelVoting(bytes32 indexed _proposalId, address indexed _organization, address indexed _voter);
12	 function propose( uint256 _numOfChoices, bytes32 _proposalParameters, address _proposer, address _organization ) external returns(bytes32);
13	 function vote( bytes32 _proposalId, uint256 _vote, uint256 _rep, address _voter ) external returns(bool);
14	 function cancelVote(bytes32 _proposalId) external;
15	 function getNumberOfChoices(bytes32 _proposalId) external view returns(uint256);
16	 function isVotable(bytes32 _proposalId) external view returns(bool);
17	 function voteStatus(bytes32 _proposalId, uint256 _choice) external view returns(uint256);
18	 function isAbstainAllow() external pure returns(bool);
19	 function getAllowedRangeOfChoices() external pure returns(uint256 min, uint256 max);
20	 }
21	 pragma solidity ^0.5.0;
22	 interface IERC20 {
23	 function totalSupply() external view returns (uint256);
24	 function balanceOf(address account) external view returns (uint256);
25	 function transfer(address recipient, uint256 amount) external returns (bool);
26	 function allowance(address owner, address spender) external view returns (uint256);
27	 function approve(address spender, uint256 amount) external returns (bool);
28	 function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
29	 event Transfer(address indexed from, address indexed to, uint256 value);
30	 event Approval(address indexed owner, address indexed spender, uint256 value);
31	 }
32	 pragma solidity 0.5.17;
33	 interface VotingMachineCallbacksInterface {
34	 function mintReputation(uint256 _amount, address _beneficiary, bytes32 _proposalId) external returns(bool);
35	 function burnReputation(uint256 _amount, address _owner, bytes32 _proposalId) external returns(bool);
36	 function stakingTokenTransfer(IERC20 _stakingToken, address _beneficiary, uint256 _amount, bytes32 _proposalId) external returns(bool);
37	 function getTotalReputationSupply(bytes32 _proposalId) external view returns(uint256);
38	 function reputationOf(address _owner, bytes32 _proposalId) external view returns(uint256);
39	 function balanceOfStakingToken(IERC20 _stakingToken, bytes32 _proposalId) external view returns(uint256);
40	 }
41	 pragma solidity ^0.5.0;
42	 contract Context {
43	 constructor () internal {
44	 }
45	 function _msgSender() internal view returns (address payable) {
46	 return msg.sender;
47	 }
48	 function _msgData() internal view returns (bytes memory) {
49	 this;
50	 return msg.data;
51	 }
52	 }
53	 pragma solidity ^0.5.0;
54	 contract Ownable is Context {
55	 address private _owner;
56	 event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
57	 constructor () internal {
58	 _owner = _msgSender();
59	 emit OwnershipTransferred(address(0), _owner);
60	 }
61	 function owner() public view returns (address) {
62	 return _owner;
63	 }
64	 modifier onlyOwner() {
65	 require(isOwner(), "Ownable: caller is not the owner");
66	 _;
67	 }
68	 function isOwner() public view returns (bool) {
69	 return _msgSender() == _owner;
70	 }
71	 function renounceOwnership() public onlyOwner {
72	 emit OwnershipTransferred(_owner, address(0));
73	 _owner = address(0);
74	 }
75	 function transferOwnership(address newOwner) public onlyOwner {
76	 _transferOwnership(newOwner);
77	 }
78	 function _transferOwnership(address newOwner) internal {
79	 require(newOwner != address(0), "Ownable: new owner is the zero address");
80	 emit OwnershipTransferred(_owner, newOwner);
81	 _owner = newOwner;
82	 }
83	 }
84	 pragma solidity 0.5.17;
85	 contract Reputation is Ownable {
86	 uint8 public decimals = 18;
87	 event Mint(address indexed _to, uint256 _amount);
88	 event Burn(address indexed _from, uint256 _amount);
89	 struct Checkpoint {
90	 uint128 fromBlock;
91	 uint128 value;
92	 }
93	 mapping (address => Checkpoint[]) private balances;
94	 Checkpoint[] private totalSupplyHistory;
95	 function mint(address _user, uint256 _amount) public onlyOwner returns (bool) {
96	 uint256 curTotalSupply = totalSupply();
97	 require(curTotalSupply + _amount >= curTotalSupply, "total supply overflow");
98	 uint256 previousBalanceTo = balanceOf(_user);
99	 require(previousBalanceTo + _amount >= previousBalanceTo, "balace overflow");
100	 updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);
101	 updateValueAtNow(balances[_user], previousBalanceTo + _amount);
102	 emit Mint(_user, _amount);
103	 return true;
104	 }
105	 function burn(address _user, uint256 _amount) public onlyOwner returns (bool) {
106	 uint256 curTotalSupply = totalSupply();
107	 uint256 amountBurned = _amount;
108	 uint256 previousBalanceFrom = balanceOf(_user);
109	 if (previousBalanceFrom < amountBurned) {
110	 amountBurned = previousBalanceFrom;
111	 }
112	 updateValueAtNow(totalSupplyHistory, curTotalSupply - amountBurned);
113	 updateValueAtNow(balances[_user], previousBalanceFrom - amountBurned);
114	 emit Burn(_user, amountBurned);
115	 return true;
116	 }
117	 function totalSupply() public view returns (uint256) {
118	 return totalSupplyAt(block.number);
119	 }
120	 function balanceOf(address _owner) public view returns (uint256 balance) {
121	 return balanceOfAt(_owner, block.number);
122	 }
123	 function totalSupplyAt(uint256 _blockNumber) public view returns(uint256) {
124	 if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) {
125	 return 0;
126	 }
127	 else {
128	 return getValueAt(totalSupplyHistory, _blockNumber);
129	 }
130	 }
131	 function balanceOfAt(address _owner, uint256 _blockNumber) public view returns (uint256) {
132	 if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)) {
133	 return 0;
134	 }
135	 else {
136	 return getValueAt(balances[_owner], _blockNumber);
137	 }
138	 }
139	 function getValueAt(Checkpoint[] storage checkpoints, uint256 _block) internal view returns (uint256) {
140	 if (checkpoints.length == 0) {
141	 return 0;
142	 }
143	 if (_block >= checkpoints[checkpoints.length-1].fromBlock) {
144	 return checkpoints[checkpoints.length-1].value;
145	 }
146	 if (_block < checkpoints[0].fromBlock) {
147	 return 0;
148	 }
149	 uint256 min = 0;
150	 uint256 max = checkpoints.length-1;
151	 while (max > min) {
152	 uint256 mid = (max + min + 1) / 2;
153	 if (checkpoints[mid].fromBlock <= _block) {
154	 min = mid;
155	 }
156	 else {
157	 max = mid-1;
158	 }
159	 }
160	 return checkpoints[min].value;
161	 }
162	 function updateValueAtNow(Checkpoint[] storage checkpoints, uint256 _value) internal {
163	 require(uint128(_value) == _value, "reputation overflow");
164	 if ((checkpoints.length == 0) || (checkpoints[checkpoints.length - 1].fromBlock < block.number)) {
165	 Checkpoint storage newCheckPoint = checkpoints[checkpoints.length++];
166	 newCheckPoint.fromBlock = uint128(block.number);
167	 newCheckPoint.value = uint128(_value);
168	 }
169	 else {
170	 Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1];
171	 oldCheckPoint.value = uint128(_value);
172	 }
173	 }
174	 }
175	 pragma solidity ^0.5.0;
176	 library SafeMath {
177	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
178	 uint256 c = a + b;
179	 require(c >= a, "SafeMath: addition overflow");
180	 return c;
181	 }
182	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
183	 return sub(a, b, "SafeMath: subtraction overflow");
184	 }
185	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
186	 require(b <= a, errorMessage);
187	 uint256 c = a - b;
188	 return c;
189	 }
190	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
191	 if (a == 0) {
192	 return 0;
193	 }
194	 uint256 c = a * b;
195	 require(c / a == b, "SafeMath: multiplication overflow");
196	 return c;
197	 }
198	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
199	 return div(a, b, "SafeMath: division by zero");
200	 }
201	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
202	 require(b > 0, errorMessage);
203	 uint256 c = a / b;
204	 return c;
205	 }
206	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
207	 return mod(a, b, "SafeMath: modulo by zero");
208	 }
209	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
210	 require(b != 0, errorMessage);
211	 return a % b;
212	 }
213	 }
214	 pragma solidity ^0.5.0;
215	 contract ERC20 is Context, IERC20 {
216	 using SafeMath for uint256;
217	 mapping (address => uint256) private _balances;
218	 mapping (address => mapping (address => uint256)) private _allowances;
219	 uint256 private _totalSupply;
220	 function totalSupply() public view returns (uint256) {
221	 return _totalSupply;
222	 }
223	 function balanceOf(address account) public view returns (uint256) {
224	 return _balances[account];
225	 }
226	 function transfer(address recipient, uint256 amount) public returns (bool) {
227	 _transfer(_msgSender(), recipient, amount);
228	 return true;
229	 }
230	 function allowance(address owner, address spender) public view returns (uint256) {
231	 return _allowances[owner][spender];
232	 }
233	 function approve(address spender, uint256 amount) public returns (bool) {
234	 _approve(_msgSender(), spender, amount);
235	 return true;
236	 }
237	 function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
238	 _transfer(sender, recipient, amount);
239	 _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
240	 return true;
241	 }
242	 function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
243	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
244	 return true;
245	 }
246	 function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
247	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
248	 return true;
249	 }
250	 function _transfer(address sender, address recipient, uint256 amount) internal {
251	 require(sender != address(0), "ERC20: transfer from the zero address");
252	 require(recipient != address(0), "ERC20: transfer to the zero address");
253	 _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
254	 _balances[recipient] = _balances[recipient].add(amount);
255	 emit Transfer(sender, recipient, amount);
256	 }
257	 function _mint(address account, uint256 amount) internal {
258	 require(account != address(0), "ERC20: mint to the zero address");
259	 _totalSupply = _totalSupply.add(amount);
260	 _balances[account] = _balances[account].add(amount);
261	 emit Transfer(address(0), account, amount);
262	 }
263	 function _burn(address account, uint256 amount) internal {
264	 require(account != address(0), "ERC20: burn from the zero address");
265	 _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
266	 _totalSupply = _totalSupply.sub(amount);
267	 emit Transfer(account, address(0), amount);
268	 }
269	 function _approve(address owner, address spender, uint256 amount) internal {
270	 require(owner != address(0), "ERC20: approve from the zero address");
271	 require(spender != address(0), "ERC20: approve to the zero address");
272	 _allowances[owner][spender] = amount;
273	 emit Approval(owner, spender, amount);
274	 }
275	 function _burnFrom(address account, uint256 amount) internal {
276	 _burn(account, amount);
277	 _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, "ERC20: burn amount exceeds allowance"));
278	 }
279	 }
280	 pragma solidity ^0.5.0;
281	 contract ERC20Burnable is Context, ERC20 {
282	 function burn(uint256 amount) public {
283	 _burn(_msgSender(), amount);
284	 }
285	 function burnFrom(address account, uint256 amount) public {
286	 _burnFrom(account, amount);
287	 }
288	 }
289	 pragma solidity 0.5.17;
290	 contract DAOToken is ERC20, ERC20Burnable, Ownable {
291	 string public name;
292	 string public symbol;
293	 uint8 public constant decimals = 18;
294	 uint256 public cap;
295	 constructor(string memory _name, string memory _symbol, uint256 _cap) public {
296	 name = _name;
297	 symbol = _symbol;
298	 cap = _cap;
299	 }
300	 function mint(address _to, uint256 _amount) public onlyOwner returns (bool) {
301	 if (cap > 0) require(totalSupply().add(_amount) <= cap);
302	 _mint(_to, _amount);
303	 return true;
304	 }
305	 }
306	 pragma solidity ^0.5.5;
307	 library Address {
308	 function isContract(address account) internal view returns (bool) {
309	 bytes32 codehash;
310	 bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
311	 assembly {
312	 codehash := extcodehash(account) }
313	 return (codehash != 0x0 && codehash != accountHash);
314	 }
315	 function toPayable(address account) internal pure returns (address payable) {
316	 return address(uint160(account));
317	 }
318	 function sendValue(address payable recipient, uint256 amount) internal {
319	 require(address(this).balance >= amount, "Address: insufficient balance");
320	 (bool success, ) = recipient.call.value(amount)("");
321	 require(success, "Address: unable to send value, recipient may have reverted");
322	 }
323	 }
324	 pragma solidity 0.5.17;
325	 library SafeERC20 {
326	 using Address for address;
327	 bytes4 constant private TRANSFER_SELECTOR = bytes4(keccak256(bytes("transfer(address,uint256)")));
328	 bytes4 constant private TRANSFERFROM_SELECTOR = bytes4(keccak256(bytes("transferFrom(address,address,uint256)")));
329	 bytes4 constant private APPROVE_SELECTOR = bytes4(keccak256(bytes("approve(address,uint256)")));
330	 function safeTransfer(address _erc20Addr, address _to, uint256 _value) internal {
331	 require(_erc20Addr.isContract());
332	 (bool success, bytes memory returnValue) = _erc20Addr.call(abi.encodeWithSelector(TRANSFER_SELECTOR, _to, _value));
333	 require(success);
334	 require(returnValue.length == 0 || (returnValue.length == 32 && (returnValue[31] != 0)));
335	 }
336	 function safeTransferFrom(address _erc20Addr, address _from, address _to, uint256 _value) internal {
337	 require(_erc20Addr.isContract());
338	 (bool success, bytes memory returnValue) = _erc20Addr.call(abi.encodeWithSelector(TRANSFERFROM_SELECTOR, _from, _to, _value));
339	 require(success);
340	 require(returnValue.length == 0 || (returnValue.length == 32 && (returnValue[31] != 0)));
341	 }
342	 function safeApprove(address _erc20Addr, address _spender, uint256 _value) internal {
343	 require(_erc20Addr.isContract());
344	 require((_value == 0) || (IERC20(_erc20Addr).allowance(address(this), _spender) == 0));
345	 (bool success, bytes memory returnValue) = _erc20Addr.call(abi.encodeWithSelector(APPROVE_SELECTOR, _spender, _value));
346	 require(success);
347	 require(returnValue.length == 0 || (returnValue.length == 32 && (returnValue[31] != 0)));
348	 }
349	 }
350	 pragma solidity 0.5.17;
351	 contract Avatar is Ownable {
352	 using SafeERC20 for address;
353	 string public orgName;
354	 DAOToken public nativeToken;
355	 Reputation public nativeReputation;
356	 event GenericCall(address indexed _contract, bytes _data, uint _value, bool _success);
357	 event SendEther(uint256 _amountInWei, address indexed _to);
358	 event ExternalTokenTransfer(address indexed _externalToken, address indexed _to, uint256 _value);
359	 event ExternalTokenTransferFrom(address indexed _externalToken, address _from, address _to, uint256 _value);
360	 event ExternalTokenApproval(address indexed _externalToken, address _spender, uint256 _value);
361	 event ReceiveEther(address indexed _sender, uint256 _value);
362	 event MetaData(string _metaData);
363	 constructor(string memory _orgName, DAOToken _nativeToken, Reputation _nativeReputation) public {
364	 orgName = _orgName;
365	 nativeToken = _nativeToken;
366	 nativeReputation = _nativeReputation;
367	 }
368	 function() external payable {
369	 emit ReceiveEther(msg.sender, msg.value);
370	 }
371	 function genericCall(address _contract, bytes memory _data, uint256 _value) public onlyOwner returns(bool success, bytes memory returnValue) {
372	 (success, returnValue) = _contract.call.value(_value)(_data);
373	 emit GenericCall(_contract, _data, _value, success);
374	 }
375	 function sendEther(uint256 _amountInWei, address payable _to) public onlyOwner returns(bool) {
376	 _to.transfer(_amountInWei);
377	 emit SendEther(_amountInWei, _to);
378	 return true;
379	 }
380	 function externalTokenTransfer(IERC20 _externalToken, address _to, uint256 _value) public onlyOwner returns(bool) {
381	 address(_externalToken).safeTransfer(_to, _value);
382	 emit ExternalTokenTransfer(address(_externalToken), _to, _value);
383	 return true;
384	 }
385	 function externalTokenTransferFrom( IERC20 _externalToken, address _from, address _to, uint256 _value ) public onlyOwner returns(bool) {
386	 address(_externalToken).safeTransferFrom(_from, _to, _value);
387	 emit ExternalTokenTransferFrom(address(_externalToken), _from, _to, _value);
388	 return true;
389	 }
390	 function externalTokenApproval(IERC20 _externalToken, address _spender, uint256 _value) public onlyOwner returns(bool) {
391	 address(_externalToken).safeApprove(_spender, _value);
392	 emit ExternalTokenApproval(address(_externalToken), _spender, _value);
393	 return true;
394	 }
395	 function metaData(string memory _metaData) public onlyOwner returns(bool) {
396	 emit MetaData(_metaData);
397	 return true;
398	 }
399	 }
400	 pragma solidity 0.5.17;
401	 contract UniversalSchemeInterface {
402	 function getParametersFromController(Avatar _avatar) internal view returns(bytes32);
403	 }
404	 pragma solidity 0.5.17;
405	 contract GlobalConstraintInterface {
406	 enum CallPhase {
407	 Pre, Post, PreAndPost }
408	 function pre( address _scheme, bytes32 _params, bytes32 _method ) public returns(bool);
409	 function post( address _scheme, bytes32 _params, bytes32 _method ) public returns(bool);
410	 function when() public returns(CallPhase);
411	 }
412	 pragma solidity 0.5.17;
413	 contract Controller {
414	 struct Scheme {
415	 bytes32 paramsHash;
416	 bytes4 permissions;
417	 }
418	 struct GlobalConstraint {
419	 address gcAddress;
420	 bytes32 params;
421	 }
422	 struct GlobalConstraintRegister {
423	 bool isRegistered;
424	 uint256 index;
425	 }
426	 mapping(address=>Scheme) public schemes;
427	 Avatar public avatar;
428	 DAOToken public nativeToken;
429	 Reputation public nativeReputation;
430	 address public newController;
431	 GlobalConstraint[] public globalConstraintsPre;
432	 GlobalConstraint[] public globalConstraintsPost;
433	 mapping(address=>GlobalConstraintRegister) public globalConstraintsRegisterPre;
434	 mapping(address=>GlobalConstraintRegister) public globalConstraintsRegisterPost;
435	 event MintReputation (address indexed _sender, address indexed _to, uint256 _amount);
436	 event BurnReputation (address indexed _sender, address indexed _from, uint256 _amount);
437	 event MintTokens (address indexed _sender, address indexed _beneficiary, uint256 _amount);
438	 event RegisterScheme (address indexed _sender, address indexed _scheme);
439	 event UnregisterScheme (address indexed _sender, address indexed _scheme);
440	 event UpgradeController(address indexed _oldController, address _newController);
441	 event AddGlobalConstraint( address indexed _globalConstraint, bytes32 _params, GlobalConstraintInterface.CallPhase _when);
442	 event RemoveGlobalConstraint(address indexed _globalConstraint, uint256 _index, bool _isPre);
443	 constructor( Avatar _avatar) public {
444	 avatar = _avatar;
445	 nativeToken = avatar.nativeToken();
446	 nativeReputation = avatar.nativeReputation();
447	 schemes[msg.sender] = Scheme({
448	 paramsHash: bytes32(0), permissions: bytes4(0x0000001F)}
449	 );
450	 emit RegisterScheme (msg.sender, msg.sender);
451	 }
452	 function() external {
453	 revert();
454	 }
455	 modifier onlyRegisteredScheme() {
456	 require(schemes[msg.sender].permissions&bytes4(0x00000001) == bytes4(0x00000001));
457	 _;
458	 }
459	 modifier onlyRegisteringSchemes() {
460	 require(schemes[msg.sender].permissions&bytes4(0x00000002) == bytes4(0x00000002));
461	 _;
462	 }
463	 modifier onlyGlobalConstraintsScheme() {
464	 require(schemes[msg.sender].permissions&bytes4(0x00000004) == bytes4(0x00000004));
465	 _;
466	 }
467	 modifier onlyUpgradingScheme() {
468	 require(schemes[msg.sender].permissions&bytes4(0x00000008) == bytes4(0x00000008));
469	 _;
470	 }
471	 modifier onlyGenericCallScheme() {
472	 require(schemes[msg.sender].permissions&bytes4(0x00000010) == bytes4(0x00000010));
473	 _;
474	 }
475	 modifier onlyMetaDataScheme() {
476	 require(schemes[msg.sender].permissions&bytes4(0x00000010) == bytes4(0x00000010));
477	 _;
478	 }
479	 modifier onlySubjectToConstraint(bytes32 func) {
480	 uint256 idx;
481	 for (idx = 0; idx < globalConstraintsPre.length; idx++) {
482	 require( (GlobalConstraintInterface(globalConstraintsPre[idx].gcAddress)) .pre(msg.sender, globalConstraintsPre[idx].params, func));
483	 }
484	 _;
485	 for (idx = 0; idx < globalConstraintsPost.length; idx++) {
486	 require( (GlobalConstraintInterface(globalConstraintsPost[idx].gcAddress)) .post(msg.sender, globalConstraintsPost[idx].params, func));
487	 }
488	 }
489	 modifier isAvatarValid(address _avatar) {
490	 require(_avatar == address(avatar));
491	 _;
492	 }
493	 function mintReputation(uint256 _amount, address _to, address _avatar) external onlyRegisteredScheme onlySubjectToConstraint("mintReputation") isAvatarValid(_avatar) returns(bool) {
494	 emit MintReputation(msg.sender, _to, _amount);
495	 return nativeReputation.mint(_to, _amount);
496	 }
497	 function burnReputation(uint256 _amount, address _from, address _avatar) external onlyRegisteredScheme onlySubjectToConstraint("burnReputation") isAvatarValid(_avatar) returns(bool) {
498	 emit BurnReputation(msg.sender, _from, _amount);
499	 return nativeReputation.burn(_from, _amount);
500	 }
501	 function mintTokens(uint256 _amount, address _beneficiary, address _avatar) external onlyRegisteredScheme onlySubjectToConstraint("mintTokens") isAvatarValid(_avatar) returns(bool) {
502	 emit MintTokens(msg.sender, _beneficiary, _amount);
503	 return nativeToken.mint(_beneficiary, _amount);
504	 }
505	 function registerScheme(address _scheme, bytes32 _paramsHash, bytes4 _permissions, address _avatar) external onlyRegisteringSchemes onlySubjectToConstraint("registerScheme") isAvatarValid(_avatar) returns(bool) {
506	 Scheme memory scheme = schemes[_scheme];
507	 require(bytes4(0x0000001f)&(_permissions^scheme.permissions)&(~schemes[msg.sender].permissions) == bytes4(0));
508	 require(bytes4(0x0000001f)&(scheme.permissions&(~schemes[msg.sender].permissions)) == bytes4(0));
509	 schemes[_scheme].paramsHash = _paramsHash;
510	 schemes[_scheme].permissions = _permissions|bytes4(0x00000001);
511	 emit RegisterScheme(msg.sender, _scheme);
512	 return true;
513	 }
514	 function unregisterScheme( address _scheme, address _avatar) external onlyRegisteringSchemes onlySubjectToConstraint("unregisterScheme") isAvatarValid(_avatar) returns(bool) {
515	 if (_isSchemeRegistered(_scheme) == false) {
516	 return false;
517	 }
518	 require(bytes4(0x0000001f)&(schemes[_scheme].permissions&(~schemes[msg.sender].permissions)) == bytes4(0));
519	 emit UnregisterScheme(msg.sender, _scheme);
520	 delete schemes[_scheme];
521	 return true;
522	 }
523	 function unregisterSelf(address _avatar) external isAvatarValid(_avatar) returns(bool) {
524	 if (_isSchemeRegistered(msg.sender) == false) {
525	 return false;
526	 }
527	 delete schemes[msg.sender];
528	 emit UnregisterScheme(msg.sender, msg.sender);
529	 return true;
530	 }
531	 function addGlobalConstraint(address _globalConstraint, bytes32 _params, address _avatar) external onlyGlobalConstraintsScheme isAvatarValid(_avatar) returns(bool) {
532	 GlobalConstraintInterface.CallPhase when = GlobalConstraintInterface(_globalConstraint).when();
533	 if ((when == GlobalConstraintInterface.CallPhase.Pre)|| (when == GlobalConstraintInterface.CallPhase.PreAndPost)) {
534	 if (!globalConstraintsRegisterPre[_globalConstraint].isRegistered) {
535	 globalConstraintsPre.push(GlobalConstraint(_globalConstraint, _params));
536	 globalConstraintsRegisterPre[_globalConstraint] = GlobalConstraintRegister(true, globalConstraintsPre.length-1);
537	 }
538	 else {
539	 globalConstraintsPre[globalConstraintsRegisterPre[_globalConstraint].index].params = _params;
540	 }
541	 }
542	 if ((when == GlobalConstraintInterface.CallPhase.Post)|| (when == GlobalConstraintInterface.CallPhase.PreAndPost)) {
543	 if (!globalConstraintsRegisterPost[_globalConstraint].isRegistered) {
544	 globalConstraintsPost.push(GlobalConstraint(_globalConstraint, _params));
545	 globalConstraintsRegisterPost[_globalConstraint] = GlobalConstraintRegister(true, globalConstraintsPost.length-1);
546	 }
547	 else {
548	 globalConstraintsPost[globalConstraintsRegisterPost[_globalConstraint].index].params = _params;
549	 }
550	 }
551	 emit AddGlobalConstraint(_globalConstraint, _params, when);
552	 return true;
553	 }
554	 function removeGlobalConstraint (address _globalConstraint, address _avatar) external onlyGlobalConstraintsScheme isAvatarValid(_avatar) returns(bool) {
555	 GlobalConstraintRegister memory globalConstraintRegister;
556	 GlobalConstraint memory globalConstraint;
557	 GlobalConstraintInterface.CallPhase when = GlobalConstraintInterface(_globalConstraint).when();
558	 bool retVal = false;
559	 if ((when == GlobalConstraintInterface.CallPhase.Pre)|| (when == GlobalConstraintInterface.CallPhase.PreAndPost)) {
560	 globalConstraintRegister = globalConstraintsRegisterPre[_globalConstraint];
561	 if (globalConstraintRegister.isRegistered) {
562	 if (globalConstraintRegister.index < globalConstraintsPre.length-1) {
563	 globalConstraint = globalConstraintsPre[globalConstraintsPre.length-1];
564	 globalConstraintsPre[globalConstraintRegister.index] = globalConstraint;
565	 globalConstraintsRegisterPre[globalConstraint.gcAddress].index = globalConstraintRegister.index;
566	 }
567	 globalConstraintsPre.length--;
568	 delete globalConstraintsRegisterPre[_globalConstraint];
569	 retVal = true;
570	 }
571	 }
572	 if ((when == GlobalConstraintInterface.CallPhase.Post)|| (when == GlobalConstraintInterface.CallPhase.PreAndPost)) {
573	 globalConstraintRegister = globalConstraintsRegisterPost[_globalConstraint];
574	 if (globalConstraintRegister.isRegistered) {
575	 if (globalConstraintRegister.index < globalConstraintsPost.length-1) {
576	 globalConstraint = globalConstraintsPost[globalConstraintsPost.length-1];
577	 globalConstraintsPost[globalConstraintRegister.index] = globalConstraint;
578	 globalConstraintsRegisterPost[globalConstraint.gcAddress].index = globalConstraintRegister.index;
579	 }
580	 globalConstraintsPost.length--;
581	 delete globalConstraintsRegisterPost[_globalConstraint];
582	 retVal = true;
583	 }
584	 }
585	 if (retVal) {
586	 emit RemoveGlobalConstraint( _globalConstraint, globalConstraintRegister.index, when == GlobalConstraintInterface.CallPhase.Pre );
587	 }
588	 return retVal;
589	 }
590	 function upgradeController(address _newController, Avatar _avatar) external onlyUpgradingScheme isAvatarValid(address(_avatar)) returns(bool) {
591	 require(newController == address(0));
592	 require(_newController != address(0));
593	 newController = _newController;
594	 avatar.transferOwnership(_newController);
595	 require(avatar.owner() == _newController);
596	 if (nativeToken.owner() == address(this)) {
597	 nativeToken.transferOwnership(_newController);
598	 require(nativeToken.owner() == _newController);
599	 }
600	 if (nativeReputation.owner() == address(this)) {
601	 nativeReputation.transferOwnership(_newController);
602	 require(nativeReputation.owner() == _newController);
603	 }
604	 emit UpgradeController(address(this), newController);
605	 return true;
606	 }
607	 function genericCall(address _contract, bytes calldata _data, Avatar _avatar, uint256 _value) external onlyGenericCallScheme onlySubjectToConstraint("genericCall") isAvatarValid(address(_avatar)) returns (bool, bytes memory) {
608	 return avatar.genericCall(_contract, _data, _value);
609	 }
610	 function sendEther(uint256 _amountInWei, address payable _to, Avatar _avatar) external onlyRegisteredScheme onlySubjectToConstraint("sendEther") isAvatarValid(address(_avatar)) returns(bool) {
611	 return avatar.sendEther(_amountInWei, _to);
612	 }
613	 function externalTokenTransfer(IERC20 _externalToken, address _to, uint256 _value, Avatar _avatar) external onlyRegisteredScheme onlySubjectToConstraint("externalTokenTransfer") isAvatarValid(address(_avatar)) returns(bool) {
614	 return avatar.externalTokenTransfer(_externalToken, _to, _value);
615	 }
616	 function externalTokenTransferFrom( IERC20 _externalToken, address _from, address _to, uint256 _value, Avatar _avatar) external onlyRegisteredScheme onlySubjectToConstraint("externalTokenTransferFrom") isAvatarValid(address(_avatar)) returns(bool) {
617	 return avatar.externalTokenTransferFrom(_externalToken, _from, _to, _value);
618	 }
619	 function externalTokenApproval(IERC20 _externalToken, address _spender, uint256 _value, Avatar _avatar) external onlyRegisteredScheme onlySubjectToConstraint("externalTokenIncreaseApproval") isAvatarValid(address(_avatar)) returns(bool) {
620	 return avatar.externalTokenApproval(_externalToken, _spender, _value);
621	 }
622	 function metaData(string calldata _metaData, Avatar _avatar) external onlyMetaDataScheme isAvatarValid(address(_avatar)) returns(bool) {
623	 return avatar.metaData(_metaData);
624	 }
625	 function getNativeReputation(address _avatar) external isAvatarValid(_avatar) view returns(address) {
626	 return address(nativeReputation);
627	 }
628	 function isSchemeRegistered(address _scheme, address _avatar) external isAvatarValid(_avatar) view returns(bool) {
629	 return _isSchemeRegistered(_scheme);
630	 }
631	 function getSchemeParameters(address _scheme, address _avatar) external isAvatarValid(_avatar) view returns(bytes32) {
632	 return schemes[_scheme].paramsHash;
633	 }
634	 function getSchemePermissions(address _scheme, address _avatar) external isAvatarValid(_avatar) view returns(bytes4) {
635	 return schemes[_scheme].permissions;
636	 }
637	 function getGlobalConstraintParameters(address _globalConstraint, address) external view returns(bytes32) {
638	 GlobalConstraintRegister memory register = globalConstraintsRegisterPre[_globalConstraint];
639	 if (register.isRegistered) {
640	 return globalConstraintsPre[register.index].params;
641	 }
642	 register = globalConstraintsRegisterPost[_globalConstraint];
643	 if (register.isRegistered) {
644	 return globalConstraintsPost[register.index].params;
645	 }
646	 }
647	 function globalConstraintsCount(address _avatar) external isAvatarValid(_avatar) view returns(uint, uint) {
648	 return (globalConstraintsPre.length, globalConstraintsPost.length);
649	 }
650	 function isGlobalConstraintRegistered(address _globalConstraint, address _avatar) external isAvatarValid(_avatar) view returns(bool) {
651	 return (globalConstraintsRegisterPre[_globalConstraint].isRegistered || globalConstraintsRegisterPost[_globalConstraint].isRegistered);
652	 }
653	 function _isSchemeRegistered(address _scheme) private view returns(bool) {
654	 return (schemes[_scheme].permissions&bytes4(0x00000001) != bytes4(0));
655	 }
656	 }
657	 pragma solidity 0.5.17;
658	 contract UniversalScheme is UniversalSchemeInterface {
659	 function getParametersFromController(Avatar _avatar) internal view returns(bytes32) {
660	 require(Controller(_avatar.owner()).isSchemeRegistered(address(this), address(_avatar)), "scheme is not registered");
661	 return Controller(_avatar.owner()).getSchemeParameters(address(this), address(_avatar));
662	 }
663	 }
664	 pragma solidity ^0.5.0;
665	 library ECDSA {
666	 function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {
667	 if (signature.length != 65) {
668	 return (address(0));
669	 }
670	 bytes32 r;
671	 bytes32 s;
672	 uint8 v;
673	 assembly {
674	 r := mload(add(signature, 0x20)) s := mload(add(signature, 0x40)) v := byte(0, mload(add(signature, 0x60))) }
675	 if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {
676	 return address(0);
677	 }
678	 if (v != 27 && v != 28) {
679	 return address(0);
680	 }
681	 return ecrecover(hash, v, r, s);
682	 }
683	 function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {
684	 return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
685	 }
686	 }
687	 pragma solidity 0.5.17;
688	 library RealMath {
689	 uint256 constant private REAL_BITS = 256;
690	 uint256 constant private REAL_FBITS = 40;
691	 uint256 constant private REAL_ONE = uint256(1) << REAL_FBITS;
692	 function pow(uint256 realBase, uint256 exponent) internal pure returns (uint256) {
693	 uint256 tempRealBase = realBase;
694	 uint256 tempExponent = exponent;
695	 uint256 realResult = REAL_ONE;
696	 while (tempExponent != 0) {
697	 if ((tempExponent & 0x1) == 0x1) {
698	 realResult = mul(realResult, tempRealBase);
699	 }
700	 tempExponent = tempExponent >> 1;
701	 if (tempExponent != 0) {
702	 tempRealBase = mul(tempRealBase, tempRealBase);
703	 }
704	 }
705	 return realResult;
706	 }
707	 function fraction(uint216 numerator, uint216 denominator) internal pure returns (uint256) {
708	 return div(uint256(numerator) * REAL_ONE, uint256(denominator) * REAL_ONE);
709	 }
710	 function mul(uint256 realA, uint256 realB) private pure returns (uint256) {
711	 uint256 res = realA * realB;
712	 require(res/realA == realB, "RealMath mul overflow");
713	 return (res >> REAL_FBITS);
714	 }
715	 function div(uint256 realNumerator, uint256 realDenominator) private pure returns (uint256) {
716	 return uint256((uint256(realNumerator) * REAL_ONE) / uint256(realDenominator));
717	 }
718	 }
719	 pragma solidity 0.5.17;
720	 interface ProposalExecuteInterface {
721	 function executeProposal(bytes32 _proposalId, int _decision) external returns(bool);
722	 }
723	 pragma solidity ^0.5.0;
724	 library Math {
725	 function max(uint256 a, uint256 b) internal pure returns (uint256) {
726	 return a >= b ? a : b;
727	 }
728	 function min(uint256 a, uint256 b) internal pure returns (uint256) {
729	 return a < b ? a : b;
730	 }
731	 function average(uint256 a, uint256 b) internal pure returns (uint256) {
732	 return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);
733	 }
734	 }
735	 pragma solidity 0.5.17;
736	 contract GenesisProtocolLogic is IntVoteInterface {
737	 using SafeMath for uint256;
738	 using Math for uint256;
739	 using RealMath for uint216;
740	 using RealMath for uint256;
741	 using Address for address;
742	 enum ProposalState {
743	 None, ExpiredInQueue, Executed, Queued, PreBoosted, Boosted, QuietEndingPeriod}
744	 enum ExecutionState {
745	 None, QueueBarCrossed, QueueTimeOut, PreBoostedBarCrossed, BoostedTimeOut, BoostedBarCrossed}
746	 struct Parameters {
747	 uint256 queuedVoteRequiredPercentage;
748	 uint256 queuedVotePeriodLimit;
749	 uint256 boostedVotePeriodLimit;
750	 uint256 preBoostedVotePeriodLimit;
751	 uint256 thresholdConst;
752	 uint256 limitExponentValue;
753	 uint256 quietEndingPeriod;
754	 uint256 proposingRepReward;
755	 uint256 votersReputationLossRatio;
756	 uint256 minimumDaoBounty;
757	 uint256 daoBountyConst;
758	 uint256 activationTime;
759	 address voteOnBehalf;
760	 }
761	 struct Voter {
762	 uint256 vote;
763	 uint256 reputation;
764	 bool preBoosted;
765	 }
766	 struct Staker {
767	 uint256 vote;
768	 uint256 amount;
769	 uint256 amount4Bounty;
770	 }
771	 struct Proposal {
772	 bytes32 organizationId;
773	 address callbacks;
774	 ProposalState state;
775	 uint256 winningVote;
776	 address proposer;
777	 uint256 currentBoostedVotePeriodLimit;
778	 bytes32 paramsHash;
779	 uint256 daoBountyRemain;
780	 uint256 daoBounty;
781	 uint256 totalStakes;
782	 uint256 confidenceThreshold;
783	 uint256 secondsFromTimeOutTillExecuteBoosted;
784	 uint[3] times;
785	 bool daoRedeemItsWinnings;
786	 mapping(uint256 => uint256 ) votes;
787	 mapping(uint256 => uint256 ) preBoostedVotes;
788	 mapping(address => Voter ) voters;
789	 mapping(uint256 => uint256 ) stakes;
790	 mapping(address => Staker ) stakers;
791	 }
792	 event Stake(bytes32 indexed _proposalId, address indexed _organization, address indexed _staker, uint256 _vote, uint256 _amount );
793	 event Redeem(bytes32 indexed _proposalId, address indexed _organization, address indexed _beneficiary, uint256 _amount );
794	 event RedeemDaoBounty(bytes32 indexed _proposalId, address indexed _organization, address indexed _beneficiary, uint256 _amount );
795	 event RedeemReputation(bytes32 indexed _proposalId, address indexed _organization, address indexed _beneficiary, uint256 _amount );
796	 event StateChange(bytes32 indexed _proposalId, ProposalState _proposalState);
797	 event GPExecuteProposal(bytes32 indexed _proposalId, ExecutionState _executionState);
798	 event ExpirationCallBounty(bytes32 indexed _proposalId, address indexed _beneficiary, uint256 _amount);
799	 event ConfidenceLevelChange(bytes32 indexed _proposalId, uint256 _confidenceThreshold);
800	 mapping(bytes32=>Parameters) public parameters;
801	 mapping(bytes32=>Proposal) public proposals;
802	 mapping(bytes32=>uint) public orgBoostedProposalsCnt;
803	 mapping(bytes32 => address ) public organizations;
804	 mapping(bytes32 => uint256 ) public averagesDownstakesOfBoosted;
805	 uint256 constant public NUM_OF_CHOICES = 2;
806	 uint256 constant public NO = 2;
807	 uint256 constant public YES = 1;
808	 uint256 public proposalsCnt;
809	 IERC20 public stakingToken;
810	 address constant private GEN_TOKEN_ADDRESS = 0x543Ff227F64Aa17eA132Bf9886cAb5DB55DCAddf;
811	 uint256 constant private MAX_BOOSTED_PROPOSALS = 4096;
812	 constructor(IERC20 _stakingToken) public {
813	 if (address(GEN_TOKEN_ADDRESS).isContract()) {
814	 stakingToken = IERC20(GEN_TOKEN_ADDRESS);
815	 }
816	 else {
817	 stakingToken = _stakingToken;
818	 }
819	 }
820	 modifier votable(bytes32 _proposalId) {
821	 require(_isVotable(_proposalId), "proposal is not votable");
822	 _;
823	 }
824	 function propose(uint256, bytes32 _paramsHash, address _proposer, address _organization) external returns(bytes32) {
825	 require(now > parameters[_paramsHash].activationTime, "not active yet");
826	 require(parameters[_paramsHash].queuedVoteRequiredPercentage >= 50, "no parameters exist");
827	 bytes32 proposalId = keccak256(abi.encodePacked(this, proposalsCnt));
828	 proposalsCnt = proposalsCnt.add(1);
829	 Proposal memory proposal;
830	 proposal.callbacks = msg.sender;
831	 proposal.organizationId = keccak256(abi.encodePacked(msg.sender, _organization));
832	 proposal.state = ProposalState.Queued;
833	 proposal.times[0] = now;
834	 proposal.currentBoostedVotePeriodLimit = parameters[_paramsHash].boostedVotePeriodLimit;
835	 proposal.proposer = _proposer;
836	 proposal.winningVote = NO;
837	 proposal.paramsHash = _paramsHash;
838	 if (organizations[proposal.organizationId] == address(0)) {
839	 if (_organization == address(0)) {
840	 organizations[proposal.organizationId] = msg.sender;
841	 }
842	 else {
843	 organizations[proposal.organizationId] = _organization;
844	 }
845	 }
846	 uint256 daoBounty = parameters[_paramsHash].daoBountyConst.mul(averagesDownstakesOfBoosted[proposal.organizationId]).div(100);
847	 proposal.daoBountyRemain = daoBounty.max(parameters[_paramsHash].minimumDaoBounty);
848	 proposals[proposalId] = proposal;
849	 proposals[proposalId].stakes[NO] = proposal.daoBountyRemain;
850	 emit NewProposal(proposalId, organizations[proposal.organizationId], NUM_OF_CHOICES, _proposer, _paramsHash);
851	 return proposalId;
852	 }
853	 function executeBoosted(bytes32 _proposalId) external returns(uint256 expirationCallBounty) {
854	 Proposal storage proposal = proposals[_proposalId];
855	 require(proposal.state == ProposalState.Boosted || proposal.state == ProposalState.QuietEndingPeriod, "proposal state in not Boosted nor QuietEndingPeriod");
856	 require(_execute(_proposalId), "proposal need to expire");
857	 proposal.secondsFromTimeOutTillExecuteBoosted = now.sub(proposal.currentBoostedVotePeriodLimit.add(proposal.times[1]));
858	 expirationCallBounty = calcExecuteCallBounty(_proposalId);
859	 proposal.totalStakes = proposal.totalStakes.sub(expirationCallBounty);
860	 require(stakingToken.transfer(msg.sender, expirationCallBounty), "transfer to msg.sender failed");
861	 emit ExpirationCallBounty(_proposalId, msg.sender, expirationCallBounty);
862	 }
863	 function setParameters( uint[11] calldata _params, address _voteOnBehalf ) external returns(bytes32) {
864	 require(_params[0] <= 100 && _params[0] >= 50, "50 <= queuedVoteRequiredPercentage <= 100");
865	 require(_params[4] <= 16000 && _params[4] > 1000, "1000 < thresholdConst <= 16000");
866	 require(_params[7] <= 100, "votersReputationLossRatio <= 100");
867	 require(_params[2] >= _params[5], "boostedVotePeriodLimit >= quietEndingPeriod");
868	 require(_params[8] > 0, "minimumDaoBounty should be > 0");
869	 require(_params[9] > 0, "daoBountyConst should be > 0");
870	 bytes32 paramsHash = getParametersHash(_params, _voteOnBehalf);
871	 if (parameters[paramsHash].queuedVoteRequiredPercentage > 0) {
872	 return paramsHash;
873	 }
874	 uint256 limitExponent = 172;
875	 uint256 j = 2;
876	 for (uint256 i = 2000; i < 16000; i = i*2) {
877	 if ((_params[4] > i) && (_params[4] <= i*2)) {
878	 limitExponent = limitExponent/j;
879	 break;
880	 }
881	 j++;
882	 }
883	 parameters[paramsHash] = Parameters({
884	 queuedVoteRequiredPercentage: _params[0], queuedVotePeriodLimit: _params[1], boostedVotePeriodLimit: _params[2], preBoostedVotePeriodLimit: _params[3], thresholdConst:uint216(_params[4]).fraction(uint216(1000)), limitExponentValue:limitExponent, quietEndingPeriod: _params[5], proposingRepReward: _params[6], votersReputationLossRatio:_params[7], minimumDaoBounty:_params[8], daoBountyConst:_params[9], activationTime:_params[10], voteOnBehalf:_voteOnBehalf }
885	 );
886	 return paramsHash;
887	 }
888	 function redeem(bytes32 _proposalId, address _beneficiary) public returns (uint[3] memory rewards) {
889	 Proposal storage proposal = proposals[_proposalId];
890	 require((proposal.state == ProposalState.Executed)||(proposal.state == ProposalState.ExpiredInQueue), "Proposal should be Executed or ExpiredInQueue");
891	 Parameters memory params = parameters[proposal.paramsHash];
892	 Staker storage staker = proposal.stakers[_beneficiary];
893	 uint256 totalWinningStakes = proposal.stakes[proposal.winningVote];
894	 uint256 totalStakesLeftAfterCallBounty = proposal.stakes[NO].add(proposal.stakes[YES]).sub(calcExecuteCallBounty(_proposalId));
895	 if (staker.amount > 0) {
896	 if (proposal.state == ProposalState.ExpiredInQueue) {
897	 rewards[0] = staker.amount;
898	 }
899	 else if (staker.vote == proposal.winningVote) {
900	 if (staker.vote == YES) {
901	 if (proposal.daoBounty < totalStakesLeftAfterCallBounty) {
902	 uint256 _totalStakes = totalStakesLeftAfterCallBounty.sub(proposal.daoBounty);
903	 rewards[0] = (staker.amount.mul(_totalStakes))/totalWinningStakes;
904	 }
905	 }
906	 else {
907	 rewards[0] = (staker.amount.mul(totalStakesLeftAfterCallBounty))/totalWinningStakes;
908	 }
909	 }
910	 staker.amount = 0;
911	 }
912	 if (proposal.daoRedeemItsWinnings == false && _beneficiary == organizations[proposal.organizationId] && proposal.state != ProposalState.ExpiredInQueue && proposal.winningVote == NO) {
913	 rewards[0] = rewards[0] .add((proposal.daoBounty.mul(totalStakesLeftAfterCallBounty))/totalWinningStakes) .sub(proposal.daoBounty);
914	 proposal.daoRedeemItsWinnings = true;
915	 }
916	 Voter storage voter = proposal.voters[_beneficiary];
917	 if ((voter.reputation != 0) && (voter.preBoosted)) {
918	 if (proposal.state == ProposalState.ExpiredInQueue) {
919	 rewards[1] = ((voter.reputation.mul(params.votersReputationLossRatio))/100);
920	 }
921	 else if (proposal.winningVote == voter.vote) {
922	 uint256 lostReputation;
923	 if (proposal.winningVote == YES) {
924	 lostReputation = proposal.preBoostedVotes[NO];
925	 }
926	 else {
927	 lostReputation = proposal.preBoostedVotes[YES];
928	 }
929	 lostReputation = (lostReputation.mul(params.votersReputationLossRatio))/100;
930	 rewards[1] = ((voter.reputation.mul(params.votersReputationLossRatio))/100) .add((voter.reputation.mul(lostReputation))/proposal.preBoostedVotes[proposal.winningVote]);
931	 }
932	 voter.reputation = 0;
933	 }
934	 if ((proposal.proposer == _beneficiary)&&(proposal.winningVote == YES)&&(proposal.proposer != address(0))) {
935	 rewards[2] = params.proposingRepReward;
936	 proposal.proposer = address(0);
937	 }
938	 if (rewards[0] != 0) {
939	 proposal.totalStakes = proposal.totalStakes.sub(rewards[0]);
940	 require(stakingToken.transfer(_beneficiary, rewards[0]), "transfer to beneficiary failed");
941	 emit Redeem(_proposalId, organizations[proposal.organizationId], _beneficiary, rewards[0]);
942	 }
943	 if (rewards[1].add(rewards[2]) != 0) {
944	 VotingMachineCallbacksInterface(proposal.callbacks) .mintReputation(rewards[1].add(rewards[2]), _beneficiary, _proposalId);
945	 emit RedeemReputation( _proposalId, organizations[proposal.organizationId], _beneficiary, rewards[1].add(rewards[2]) );
946	 }
947	 }
948	 function redeemDaoBounty(bytes32 _proposalId, address _beneficiary) public returns(uint256 redeemedAmount, uint256 potentialAmount) {
949	 Proposal storage proposal = proposals[_proposalId];
950	 require(proposal.state == ProposalState.Executed, "proposal state must be executed");
951	 uint256 totalWinningStakes = proposal.stakes[proposal.winningVote];
952	 Staker storage staker = proposal.stakers[_beneficiary];
953	 if ( (staker.amount4Bounty > 0)&& (staker.vote == proposal.winningVote)&& (proposal.winningVote == YES)&& (totalWinningStakes != 0)) {
954	 potentialAmount = (staker.amount4Bounty * proposal.daoBounty)/totalWinningStakes;
955	 }
956	 if ((potentialAmount != 0)&& (VotingMachineCallbacksInterface(proposal.callbacks) .balanceOfStakingToken(stakingToken, _proposalId) >= potentialAmount)) {
957	 staker.amount4Bounty = 0;
958	 proposal.daoBountyRemain = proposal.daoBountyRemain.sub(potentialAmount);
959	 require( VotingMachineCallbacksInterface(proposal.callbacks) .stakingTokenTransfer(stakingToken, _beneficiary, potentialAmount, _proposalId), "failed at stakingTokenTransfer");
960	 redeemedAmount = potentialAmount;
961	 emit RedeemDaoBounty(_proposalId, organizations[proposal.organizationId], _beneficiary, redeemedAmount);
962	 }
963	 }
964	 function calcExecuteCallBounty(bytes32 _proposalId) public view returns(uint256) {
965	 uint maxRewardSeconds = 1500;
966	 uint rewardSeconds = uint256(maxRewardSeconds).min(proposals[_proposalId].secondsFromTimeOutTillExecuteBoosted);
967	 return rewardSeconds.mul(proposals[_proposalId].stakes[YES]).div(maxRewardSeconds*10);
968	 }
969	 function shouldBoost(bytes32 _proposalId) public view returns(bool) {
970	 Proposal memory proposal = proposals[_proposalId];
971	 return (_score(_proposalId) > threshold(proposal.paramsHash, proposal.organizationId));
972	 }
973	 function threshold(bytes32 _paramsHash, bytes32 _organizationId) public view returns(uint256) {
974	 uint256 power = orgBoostedProposalsCnt[_organizationId];
975	 Parameters storage params = parameters[_paramsHash];
976	 if (power > params.limitExponentValue) {
977	 power = params.limitExponentValue;
978	 }
979	 return params.thresholdConst.pow(power);
980	 }
981	 function getParametersHash( uint[11] memory _params, address _voteOnBehalf ) public pure returns(bytes32) {
982	 return keccak256( abi.encodePacked( keccak256( abi.encodePacked( _params[0], _params[1], _params[2], _params[3], _params[4], _params[5], _params[6], _params[7], _params[8], _params[9], _params[10]) ), _voteOnBehalf ));
983	 }
984	 function _execute(bytes32 _proposalId) internal votable(_proposalId) returns(bool) {
985	 Proposal storage proposal = proposals[_proposalId];
986	 Parameters memory params = parameters[proposal.paramsHash];
987	 Proposal memory tmpProposal = proposal;
988	 uint256 totalReputation = VotingMachineCallbacksInterface(proposal.callbacks).getTotalReputationSupply(_proposalId);
989	 uint256 executionBar = (totalReputation/100) * params.queuedVoteRequiredPercentage;
990	 ExecutionState executionState = ExecutionState.None;
991	 uint256 averageDownstakesOfBoosted;
992	 uint256 confidenceThreshold;
993	 if (proposal.votes[proposal.winningVote] > executionBar) {
994	 if (proposal.state == ProposalState.Queued) {
995	 executionState = ExecutionState.QueueBarCrossed;
996	 }
997	 else if (proposal.state == ProposalState.PreBoosted) {
998	 executionState = ExecutionState.PreBoostedBarCrossed;
999	 }
1000	 else {
1001	 executionState = ExecutionState.BoostedBarCrossed;
1002	 }
1003	 proposal.state = ProposalState.Executed;
1004	 }
1005	 else {
1006	 if (proposal.state == ProposalState.Queued) {
1007	 if ((now - proposal.times[0]) >= params.queuedVotePeriodLimit) {
1008	 proposal.state = ProposalState.ExpiredInQueue;
1009	 proposal.winningVote = NO;
1010	 executionState = ExecutionState.QueueTimeOut;
1011	 }
1012	 else {
1013	 confidenceThreshold = threshold(proposal.paramsHash, proposal.organizationId);
1014	 if (_score(_proposalId) > confidenceThreshold) {
1015	 proposal.state = ProposalState.PreBoosted;
1016	 proposal.times[2] = now;
1017	 proposal.confidenceThreshold = confidenceThreshold;
1018	 }
1019	 }
1020	 }
1021	 if (proposal.state == ProposalState.PreBoosted) {
1022	 confidenceThreshold = threshold(proposal.paramsHash, proposal.organizationId);
1023	 if ((now - proposal.times[2]) >= params.preBoostedVotePeriodLimit) {
1024	 if (_score(_proposalId) > confidenceThreshold) {
1025	 if (orgBoostedProposalsCnt[proposal.organizationId] < MAX_BOOSTED_PROPOSALS) {
1026	 proposal.state = ProposalState.Boosted;
1027	 proposal.times[1] = now;
1028	 orgBoostedProposalsCnt[proposal.organizationId]++;
1029	 averageDownstakesOfBoosted = averagesDownstakesOfBoosted[proposal.organizationId];
1030	 averagesDownstakesOfBoosted[proposal.organizationId] = uint256(int256(averageDownstakesOfBoosted) + ((int256(proposal.stakes[NO])-int256(averageDownstakesOfBoosted))/ int256(orgBoostedProposalsCnt[proposal.organizationId])));
1031	 }
1032	 }
1033	 else {
1034	 proposal.state = ProposalState.Queued;
1035	 }
1036	 }
1037	 else {
1038	 uint256 proposalScore = _score(_proposalId);
1039	 if (proposalScore <= proposal.confidenceThreshold.min(confidenceThreshold)) {
1040	 proposal.state = ProposalState.Queued;
1041	 }
1042	 else if (proposal.confidenceThreshold > proposalScore) {
1043	 proposal.confidenceThreshold = confidenceThreshold;
1044	 emit ConfidenceLevelChange(_proposalId, confidenceThreshold);
1045	 }
1046	 }
1047	 }
1048	 }
1049	 if ((proposal.state == ProposalState.Boosted) || (proposal.state == ProposalState.QuietEndingPeriod)) {
1050	 if ((now - proposal.times[1]) >= proposal.currentBoostedVotePeriodLimit) {
1051	 proposal.state = ProposalState.Executed;
1052	 executionState = ExecutionState.BoostedTimeOut;
1053	 }
1054	 }
1055	 if (executionState != ExecutionState.None) {
1056	 if ((executionState == ExecutionState.BoostedTimeOut) || (executionState == ExecutionState.BoostedBarCrossed)) {
1057	 orgBoostedProposalsCnt[tmpProposal.organizationId] = orgBoostedProposalsCnt[tmpProposal.organizationId].sub(1);
1058	 uint256 boostedProposals = orgBoostedProposalsCnt[tmpProposal.organizationId];
1059	 if (boostedProposals == 0) {
1060	 averagesDownstakesOfBoosted[proposal.organizationId] = 0;
1061	 }
1062	 else {
1063	 averageDownstakesOfBoosted = averagesDownstakesOfBoosted[proposal.organizationId];
1064	 averagesDownstakesOfBoosted[proposal.organizationId] = (averageDownstakesOfBoosted.mul(boostedProposals+1).sub(proposal.stakes[NO]))/boostedProposals;
1065	 }
1066	 }
1067	 emit ExecuteProposal( _proposalId, organizations[proposal.organizationId], proposal.winningVote, totalReputation );
1068	 emit GPExecuteProposal(_proposalId, executionState);
1069	 proposal.daoBounty = proposal.daoBountyRemain;
1070	 ProposalExecuteInterface(proposal.callbacks).executeProposal(_proposalId, int(proposal.winningVote));
1071	 }
1072	 if (tmpProposal.state != proposal.state) {
1073	 emit StateChange(_proposalId, proposal.state);
1074	 }
1075	 return (executionState != ExecutionState.None);
1076	 }
1077	 function _stake(bytes32 _proposalId, uint256 _vote, uint256 _amount, address _staker) internal returns(bool) {
1078	 require(_vote <= NUM_OF_CHOICES && _vote > 0, "wrong vote value");
1079	 require(_amount > 0, "staking amount should be >0");
1080	 if (_execute(_proposalId)) {
1081	 return true;
1082	 }
1083	 Proposal storage proposal = proposals[_proposalId];
1084	 if ((proposal.state != ProposalState.PreBoosted) && (proposal.state != ProposalState.Queued)) {
1085	 return false;
1086	 }
1087	 Staker storage staker = proposal.stakers[_staker];
1088	 if ((staker.amount > 0) && (staker.vote != _vote)) {
1089	 return false;
1090	 }
1091	 uint256 amount = _amount;
1092	 require(stakingToken.transferFrom(_staker, address(this), amount), "fail transfer from staker");
1093	 proposal.totalStakes = proposal.totalStakes.add(amount);
1094	 staker.amount = staker.amount.add(amount);
1095	 require(staker.amount <= 0x100000000000000000000000000000000, "staking amount is too high");
1096	 require(proposal.totalStakes <= uint256(0x100000000000000000000000000000000).sub(proposal.daoBountyRemain), "total stakes is too high");
1097	 if (_vote == YES) {
1098	 staker.amount4Bounty = staker.amount4Bounty.add(amount);
1099	 }
1100	 staker.vote = _vote;
1101	 proposal.stakes[_vote] = amount.add(proposal.stakes[_vote]);
1102	 emit Stake(_proposalId, organizations[proposal.organizationId], _staker, _vote, _amount);
1103	 return _execute(_proposalId);
1104	 }
1105	 function internalVote(bytes32 _proposalId, address _voter, uint256 _vote, uint256 _rep) internal returns(bool) {
1106	 require(_vote <= NUM_OF_CHOICES && _vote > 0, "0 < _vote <= 2");
1107	 if (_execute(_proposalId)) {
1108	 return true;
1109	 }
1110	 Parameters memory params = parameters[proposals[_proposalId].paramsHash];
1111	 Proposal storage proposal = proposals[_proposalId];
1112	 uint256 reputation = VotingMachineCallbacksInterface(proposal.callbacks).reputationOf(_voter, _proposalId);
1113	 require(reputation > 0, "_voter must have reputation");
1114	 require(reputation >= _rep, "reputation >= _rep");
1115	 uint256 rep = _rep;
1116	 if (rep == 0) {
1117	 rep = reputation;
1118	 }
1119	 if (proposal.voters[_voter].reputation != 0) {
1120	 return false;
1121	 }
1122	 proposal.votes[_vote] = rep.add(proposal.votes[_vote]);
1123	 if ((proposal.votes[_vote] > proposal.votes[proposal.winningVote]) || ((proposal.votes[NO] == proposal.votes[proposal.winningVote]) && proposal.winningVote == YES)) {
1124	 if (proposal.state == ProposalState.Boosted && ((now - proposal.times[1]) >= (params.boostedVotePeriodLimit - params.quietEndingPeriod))|| proposal.state == ProposalState.QuietEndingPeriod) {
1125	 if (proposal.state != ProposalState.QuietEndingPeriod) {
1126	 proposal.currentBoostedVotePeriodLimit = params.quietEndingPeriod;
1127	 proposal.state = ProposalState.QuietEndingPeriod;
1128	 emit StateChange(_proposalId, proposal.state);
1129	 }
1130	 proposal.times[1] = now;
1131	 }
1132	 proposal.winningVote = _vote;
1133	 }
1134	 proposal.voters[_voter] = Voter({
1135	 reputation: rep, vote: _vote, preBoosted:((proposal.state == ProposalState.PreBoosted) || (proposal.state == ProposalState.Queued)) }
1136	 );
1137	 if ((proposal.state == ProposalState.PreBoosted) || (proposal.state == ProposalState.Queued)) {
1138	 proposal.preBoostedVotes[_vote] = rep.add(proposal.preBoostedVotes[_vote]);
1139	 uint256 reputationDeposit = (params.votersReputationLossRatio.mul(rep))/100;
1140	 VotingMachineCallbacksInterface(proposal.callbacks).burnReputation(reputationDeposit, _voter, _proposalId);
1141	 }
1142	 emit VoteProposal(_proposalId, organizations[proposal.organizationId], _voter, _vote, rep);
1143	 return _execute(_proposalId);
1144	 }
1145	 function _score(bytes32 _proposalId) internal view returns(uint256) {
1146	 Proposal storage proposal = proposals[_proposalId];
1147	 return uint216(proposal.stakes[YES]).fraction(uint216(proposal.stakes[NO]));
1148	 }
1149	 function _isVotable(bytes32 _proposalId) internal view returns(bool) {
1150	 ProposalState pState = proposals[_proposalId].state;
1151	 return ((pState == ProposalState.PreBoosted)|| (pState == ProposalState.Boosted)|| (pState == ProposalState.QuietEndingPeriod)|| (pState == ProposalState.Queued) );
1152	 }
1153	 }
1154	 pragma solidity 0.5.17;
1155	 contract GenesisProtocol is IntVoteInterface, GenesisProtocolLogic {
1156	 using ECDSA for bytes32;
1157	 bytes32 public constant DELEGATION_HASH_EIP712 = keccak256(abi.encodePacked( "address GenesisProtocolAddress", "bytes32 ProposalId", "uint256 Vote", "uint256 AmountToStake", "uint256 Nonce" ));
1158	 mapping(address=>uint256) public stakesNonce;
1159	 constructor(IERC20 _stakingToken) public GenesisProtocolLogic(_stakingToken) {
1160	 }
1161	 function stake(bytes32 _proposalId, uint256 _vote, uint256 _amount) external returns(bool) {
1162	 return _stake(_proposalId, _vote, _amount, msg.sender);
1163	 }
1164	 function stakeWithSignature( bytes32 _proposalId, uint256 _vote, uint256 _amount, uint256 _nonce, uint256 _signatureType, bytes calldata _signature ) external returns(bool) {
1165	 bytes32 delegationDigest;
1166	 if (_signatureType == 2) {
1167	 delegationDigest = keccak256( abi.encodePacked( DELEGATION_HASH_EIP712, keccak256( abi.encodePacked( address(this), _proposalId, _vote, _amount, _nonce) ) ) );
1168	 }
1169	 else {
1170	 delegationDigest = keccak256( abi.encodePacked( address(this), _proposalId, _vote, _amount, _nonce) ).toEthSignedMessageHash();
1171	 }
1172	 address staker = delegationDigest.recover(_signature);
1173	 require(staker != address(0), "staker address cannot be 0");
1174	 require(stakesNonce[staker] == _nonce, "wrong nonce");
1175	 stakesNonce[staker] = stakesNonce[staker].add(1);
1176	 return _stake(_proposalId, _vote, _amount, staker);
1177	 }
1178	 function vote(bytes32 _proposalId, uint256 _vote, uint256 _amount, address _voter) external votable(_proposalId) returns(bool) {
1179	 Proposal storage proposal = proposals[_proposalId];
1180	 Parameters memory params = parameters[proposal.paramsHash];
1181	 address voter;
1182	 if (params.voteOnBehalf != address(0)) {
1183	 require(msg.sender == params.voteOnBehalf, "msg.sender is not authorized to vote");
1184	 voter = _voter;
1185	 }
1186	 else {
1187	 voter = msg.sender;
1188	 }
1189	 return internalVote(_proposalId, voter, _vote, _amount);
1190	 }
1191	 function cancelVote(bytes32 _proposalId) external votable(_proposalId) {
1192	 return;
1193	 }
1194	 function execute(bytes32 _proposalId) external votable(_proposalId) returns(bool) {
1195	 return _execute(_proposalId);
1196	 }
1197	 function getNumberOfChoices(bytes32) external view returns(uint256) {
1198	 return NUM_OF_CHOICES;
1199	 }
1200	 function getProposalTimes(bytes32 _proposalId) external view returns(uint[3] memory times) {
1201	 return proposals[_proposalId].times;
1202	 }
1203	 function voteInfo(bytes32 _proposalId, address _voter) external view returns(uint, uint) {
1204	 Voter memory voter = proposals[_proposalId].voters[_voter];
1205	 return (voter.vote, voter.reputation);
1206	 }
1207	 function voteStatus(bytes32 _proposalId, uint256 _choice) external view returns(uint256) {
1208	 return proposals[_proposalId].votes[_choice];
1209	 }
1210	 function isVotable(bytes32 _proposalId) external view returns(bool) {
1211	 return _isVotable(_proposalId);
1212	 }
1213	 function proposalStatus(bytes32 _proposalId) external view returns(uint256, uint256, uint256, uint256) {
1214	 return ( proposals[_proposalId].preBoostedVotes[YES], proposals[_proposalId].preBoostedVotes[NO], proposals[_proposalId].stakes[YES], proposals[_proposalId].stakes[NO] );
1215	 }
1216	 function getProposalOrganization(bytes32 _proposalId) external view returns(bytes32) {
1217	 return (proposals[_proposalId].organizationId);
1218	 }
1219	 function getStaker(bytes32 _proposalId, address _staker) external view returns(uint256, uint256) {
1220	 return (proposals[_proposalId].stakers[_staker].vote, proposals[_proposalId].stakers[_staker].amount);
1221	 }
1222	 function voteStake(bytes32 _proposalId, uint256 _vote) external view returns(uint256) {
1223	 return proposals[_proposalId].stakes[_vote];
1224	 }
1225	 function winningVote(bytes32 _proposalId) external view returns(uint256) {
1226	 return proposals[_proposalId].winningVote;
1227	 }
1228	 function state(bytes32 _proposalId) external view returns(ProposalState) {
1229	 return proposals[_proposalId].state;
1230	 }
1231	 function isAbstainAllow() external pure returns(bool) {
1232	 return false;
1233	 }
1234	 function getAllowedRangeOfChoices() external pure returns(uint256 min, uint256 max) {
1235	 return (YES, NO);
1236	 }
1237	 function score(bytes32 _proposalId) public view returns(uint256) {
1238	 return _score(_proposalId);
1239	 }
1240	 }
1241	 pragma solidity 0.5.17;
1242	 contract VotingMachineCallbacks is VotingMachineCallbacksInterface {
1243	 struct ProposalInfo {
1244	 uint256 blockNumber;
1245	 Avatar avatar;
1246	 }
1247	 modifier onlyVotingMachine(bytes32 _proposalId) {
1248	 require(proposalsInfo[msg.sender][_proposalId].avatar != Avatar(address(0)), "only VotingMachine");
1249	 _;
1250	 }
1251	 mapping(address => mapping(bytes32 => ProposalInfo)) public proposalsInfo;
1252	 function mintReputation(uint256 _amount, address _beneficiary, bytes32 _proposalId) external onlyVotingMachine(_proposalId) returns(bool) {
1253	 Avatar avatar = proposalsInfo[msg.sender][_proposalId].avatar;
1254	 if (avatar == Avatar(0)) {
1255	 return false;
1256	 }
1257	 return Controller(avatar.owner()).mintReputation(_amount, _beneficiary, address(avatar));
1258	 }
1259	 function burnReputation(uint256 _amount, address _beneficiary, bytes32 _proposalId) external onlyVotingMachine(_proposalId) returns(bool) {
1260	 Avatar avatar = proposalsInfo[msg.sender][_proposalId].avatar;
1261	 if (avatar == Avatar(0)) {
1262	 return false;
1263	 }
1264	 return Controller(avatar.owner()).burnReputation(_amount, _beneficiary, address(avatar));
1265	 }
1266	 function stakingTokenTransfer( IERC20 _stakingToken, address _beneficiary, uint256 _amount, bytes32 _proposalId) external onlyVotingMachine(_proposalId) returns(bool) {
1267	 Avatar avatar = proposalsInfo[msg.sender][_proposalId].avatar;
1268	 if (avatar == Avatar(0)) {
1269	 return false;
1270	 }
1271	 return Controller(avatar.owner()).externalTokenTransfer(_stakingToken, _beneficiary, _amount, avatar);
1272	 }
1273	 function balanceOfStakingToken(IERC20 _stakingToken, bytes32 _proposalId) external view returns(uint256) {
1274	 Avatar avatar = proposalsInfo[msg.sender][_proposalId].avatar;
1275	 if (proposalsInfo[msg.sender][_proposalId].avatar == Avatar(0)) {
1276	 return 0;
1277	 }
1278	 return _stakingToken.balanceOf(address(avatar));
1279	 }
1280	 function getTotalReputationSupply(bytes32 _proposalId) external view returns(uint256) {
1281	 ProposalInfo memory proposal = proposalsInfo[msg.sender][_proposalId];
1282	 if (proposal.avatar == Avatar(0)) {
1283	 return 0;
1284	 }
1285	 return proposal.avatar.nativeReputation().totalSupplyAt(proposal.blockNumber);
1286	 }
1287	 function reputationOf(address _owner, bytes32 _proposalId) external view returns(uint256) {
1288	 ProposalInfo memory proposal = proposalsInfo[msg.sender][_proposalId];
1289	 if (proposal.avatar == Avatar(0)) {
1290	 return 0;
1291	 }
1292	 return proposal.avatar.nativeReputation().balanceOfAt(_owner, proposal.blockNumber);
1293	 }
1294	 }
1295	 pragma solidity 0.5.17;
1296	 contract ContributionReward is UniversalScheme, VotingMachineCallbacks, ProposalExecuteInterface {
1297	 using SafeMath for uint;
1298	 event NewContributionProposal( address indexed _avatar, bytes32 indexed _proposalId, address indexed _intVoteInterface, string _descriptionHash, int256 _reputationChange, uint[5] _rewards, IERC20 _externalToken, address _beneficiary );
1299	 event ProposalExecuted(address indexed _avatar, bytes32 indexed _proposalId, int256 _param);
1300	 event RedeemReputation( address indexed _avatar, bytes32 indexed _proposalId, address indexed _beneficiary, int256 _amount);
1301	 event RedeemEther(address indexed _avatar, bytes32 indexed _proposalId, address indexed _beneficiary, uint256 _amount);
1302	 event RedeemNativeToken(address indexed _avatar, bytes32 indexed _proposalId, address indexed _beneficiary, uint256 _amount);
1303	 event RedeemExternalToken(address indexed _avatar, bytes32 indexed _proposalId, address indexed _beneficiary, uint256 _amount);
1304	 struct ContributionProposal {
1305	 uint256 nativeTokenReward;
1306	 int256 reputationChange;
1307	 uint256 ethReward;
1308	 IERC20 externalToken;
1309	 uint256 externalTokenReward;
1310	 address payable beneficiary;
1311	 uint256 periodLength;
1312	 uint256 numberOfPeriods;
1313	 uint256 executionTime;
1314	 uint[4] redeemedPeriods;
1315	 }
1316	 mapping(address=>mapping(bytes32=>ContributionProposal)) public organizationsProposals;
1317	 struct Parameters {
1318	 bytes32 voteApproveParams;
1319	 IntVoteInterface intVote;
1320	 }
1321	 mapping(bytes32=>Parameters) public parameters;
1322	 function executeProposal(bytes32 _proposalId, int256 _param) external onlyVotingMachine(_proposalId) returns(bool) {
1323	 ProposalInfo memory proposal = proposalsInfo[msg.sender][_proposalId];
1324	 require(organizationsProposals[address(proposal.avatar)][_proposalId].executionTime == 0);
1325	 require(organizationsProposals[address(proposal.avatar)][_proposalId].beneficiary != address(0));
1326	 if (_param == 1) {
1327	 organizationsProposals[address(proposal.avatar)][_proposalId].executionTime = now;
1328	 }
1329	 emit ProposalExecuted(address(proposal.avatar), _proposalId, _param);
1330	 return true;
1331	 }
1332	 function setParameters( bytes32 _voteApproveParams, IntVoteInterface _intVote ) public returns(bytes32) {
1333	 bytes32 paramsHash = getParametersHash( _voteApproveParams, _intVote );
1334	 parameters[paramsHash].voteApproveParams = _voteApproveParams;
1335	 parameters[paramsHash].intVote = _intVote;
1336	 return paramsHash;
1337	 }
1338	 function proposeContributionReward( Avatar _avatar, string memory _descriptionHash, int256 _reputationChange, uint[5] memory _rewards, IERC20 _externalToken, address payable _beneficiary ) public returns(bytes32) {
1339	 validateProposalParams(_reputationChange, _rewards);
1340	 Parameters memory controllerParams = parameters[getParametersFromController(_avatar)];
1341	 bytes32 contributionId = controllerParams.intVote.propose( 2, controllerParams.voteApproveParams, msg.sender, address(_avatar) );
1342	 address payable beneficiary = _beneficiary;
1343	 if (beneficiary == address(0)) {
1344	 beneficiary = msg.sender;
1345	 }
1346	 ContributionProposal memory proposal = ContributionProposal({
1347	 nativeTokenReward: _rewards[0], reputationChange: _reputationChange, ethReward: _rewards[1], externalToken: _externalToken, externalTokenReward: _rewards[2], beneficiary: beneficiary, periodLength: _rewards[3], numberOfPeriods: _rewards[4], executionTime: 0, redeemedPeriods:[uint(0), uint(0), uint(0), uint(0)] }
1348	 );
1349	 organizationsProposals[address(_avatar)][contributionId] = proposal;
1350	 emit NewContributionProposal( address(_avatar), contributionId, address(controllerParams.intVote), _descriptionHash, _reputationChange, _rewards, _externalToken, beneficiary );
1351	 proposalsInfo[address(controllerParams.intVote)][contributionId] = ProposalInfo({
1352	 blockNumber:block.number, avatar:_avatar }
1353	 );
1354	 return contributionId;
1355	 }
1356	 function redeemReputation(bytes32 _proposalId, Avatar _avatar) public returns(int256 reputation) {
1357	 ContributionProposal memory _proposal = organizationsProposals[address(_avatar)][_proposalId];
1358	 ContributionProposal storage proposal = organizationsProposals[address(_avatar)][_proposalId];
1359	 require(proposal.executionTime != 0);
1360	 uint256 periodsToPay = getPeriodsToPay(_proposalId, address(_avatar), 0);
1361	 proposal.reputationChange = 0;
1362	 reputation = int(periodsToPay) * _proposal.reputationChange;
1363	 if (reputation > 0) {
1364	 require( Controller( _avatar.owner()).mintReputation(uint(reputation), _proposal.beneficiary, address(_avatar)));
1365	 }
1366	 else if (reputation < 0) {
1367	 require( Controller( _avatar.owner()).burnReputation(uint(reputation*(-1)), _proposal.beneficiary, address(_avatar)));
1368	 }
1369	 if (reputation != 0) {
1370	 proposal.redeemedPeriods[0] = proposal.redeemedPeriods[0].add(periodsToPay);
1371	 emit RedeemReputation(address(_avatar), _proposalId, _proposal.beneficiary, reputation);
1372	 }
1373	 proposal.reputationChange = _proposal.reputationChange;
1374	 }
1375	 function redeemNativeToken(bytes32 _proposalId, Avatar _avatar) public returns(uint256 amount) {
1376	 ContributionProposal memory _proposal = organizationsProposals[address(_avatar)][_proposalId];
1377	 ContributionProposal storage proposal = organizationsProposals[address(_avatar)][_proposalId];
1378	 require(proposal.executionTime != 0);
1379	 uint256 periodsToPay = getPeriodsToPay(_proposalId, address(_avatar), 1);
1380	 proposal.nativeTokenReward = 0;
1381	 amount = periodsToPay.mul(_proposal.nativeTokenReward);
1382	 if (amount > 0) {
1383	 require(Controller(_avatar.owner()).mintTokens(amount, _proposal.beneficiary, address(_avatar)));
1384	 proposal.redeemedPeriods[1] = proposal.redeemedPeriods[1].add(periodsToPay);
1385	 emit RedeemNativeToken(address(_avatar), _proposalId, _proposal.beneficiary, amount);
1386	 }
1387	 proposal.nativeTokenReward = _proposal.nativeTokenReward;
1388	 }
1389	 function redeemEther(bytes32 _proposalId, Avatar _avatar) public returns(uint256 amount) {
1390	 ContributionProposal memory _proposal = organizationsProposals[address(_avatar)][_proposalId];
1391	 ContributionProposal storage proposal = organizationsProposals[address(_avatar)][_proposalId];
1392	 require(proposal.executionTime != 0);
1393	 uint256 periodsToPay = getPeriodsToPay(_proposalId, address(_avatar), 2);
1394	 proposal.ethReward = 0;
1395	 amount = periodsToPay.mul(_proposal.ethReward);
1396	 if (amount > 0) {
1397	 require(Controller(_avatar.owner()).sendEther(amount, _proposal.beneficiary, _avatar));
1398	 proposal.redeemedPeriods[2] = proposal.redeemedPeriods[2].add(periodsToPay);
1399	 emit RedeemEther(address(_avatar), _proposalId, _proposal.beneficiary, amount);
1400	 }
1401	 proposal.ethReward = _proposal.ethReward;
1402	 }
1403	 function redeemExternalToken(bytes32 _proposalId, Avatar _avatar) public returns(uint256 amount) {
1404	 ContributionProposal memory _proposal = organizationsProposals[address(_avatar)][_proposalId];
1405	 ContributionProposal storage proposal = organizationsProposals[address(_avatar)][_proposalId];
1406	 require(proposal.executionTime != 0);
1407	 uint256 periodsToPay = getPeriodsToPay(_proposalId, address(_avatar), 3);
1408	 proposal.externalTokenReward = 0;
1409	 if (proposal.externalToken != IERC20(0) && _proposal.externalTokenReward > 0) {
1410	 amount = periodsToPay.mul(_proposal.externalTokenReward);
1411	 if (amount > 0) {
1412	 require( Controller( _avatar.owner()) .externalTokenTransfer(_proposal.externalToken, _proposal.beneficiary, amount, _avatar));
1413	 proposal.redeemedPeriods[3] = proposal.redeemedPeriods[3].add(periodsToPay);
1414	 emit RedeemExternalToken(address(_avatar), _proposalId, _proposal.beneficiary, amount);
1415	 }
1416	 }
1417	 proposal.externalTokenReward = _proposal.externalTokenReward;
1418	 }
1419	 function redeem(bytes32 _proposalId, Avatar _avatar, bool[4] memory _whatToRedeem) public returns(int256 reputationReward, uint256 nativeTokenReward, uint256 etherReward, uint256 externalTokenReward) {
1420	 if (_whatToRedeem[0]) {
1421	 reputationReward = redeemReputation(_proposalId, _avatar);
1422	 }
1423	 if (_whatToRedeem[1]) {
1424	 nativeTokenReward = redeemNativeToken(_proposalId, _avatar);
1425	 }
1426	 if (_whatToRedeem[2]) {
1427	 etherReward = redeemEther(_proposalId, _avatar);
1428	 }
1429	 if (_whatToRedeem[3]) {
1430	 externalTokenReward = redeemExternalToken(_proposalId, _avatar);
1431	 }
1432	 }
1433	 function getPeriodsToPay(bytes32 _proposalId, address _avatar, uint256 _redeemType) public view returns (uint256) {
1434	 require(_redeemType <= 3, "should be in the redeemedPeriods range");
1435	 ContributionProposal memory _proposal = organizationsProposals[_avatar][_proposalId];
1436	 if (_proposal.executionTime == 0) return 0;
1437	 uint256 periodsFromExecution;
1438	 if (_proposal.periodLength > 0) {
1439	 periodsFromExecution = (now.sub(_proposal.executionTime))/(_proposal.periodLength);
1440	 }
1441	 uint256 periodsToPay;
1442	 if ((_proposal.periodLength == 0) || (periodsFromExecution >= _proposal.numberOfPeriods)) {
1443	 periodsToPay = _proposal.numberOfPeriods.sub(_proposal.redeemedPeriods[_redeemType]);
1444	 }
1445	 else {
1446	 periodsToPay = periodsFromExecution.sub(_proposal.redeemedPeriods[_redeemType]);
1447	 }
1448	 return periodsToPay;
1449	 }
1450	 function getRedeemedPeriods(bytes32 _proposalId, address _avatar, uint256 _redeemType) public view returns (uint256) {
1451	 return organizationsProposals[_avatar][_proposalId].redeemedPeriods[_redeemType];
1452	 }
1453	 function getProposalEthReward(bytes32 _proposalId, address _avatar) public view returns (uint256) {
1454	 return organizationsProposals[_avatar][_proposalId].ethReward;
1455	 }
1456	 function getProposalExternalTokenReward(bytes32 _proposalId, address _avatar) public view returns (uint256) {
1457	 return organizationsProposals[_avatar][_proposalId].externalTokenReward;
1458	 }
1459	 function getProposalExternalToken(bytes32 _proposalId, address _avatar) public view returns (address) {
1460	 return address(organizationsProposals[_avatar][_proposalId].externalToken);
1461	 }
1462	 function getProposalExecutionTime(bytes32 _proposalId, address _avatar) public view returns (uint256) {
1463	 return organizationsProposals[_avatar][_proposalId].executionTime;
1464	 }
1465	 function getParametersHash( bytes32 _voteApproveParams, IntVoteInterface _intVote ) public pure returns(bytes32) {
1466	 return (keccak256(abi.encodePacked(_voteApproveParams, _intVote)));
1467	 }
1468	 function validateProposalParams(int256 _reputationChange, uint[5] memory _rewards) private pure {
1469	 require(((_rewards[3] > 0) || (_rewards[4] == 1)), "periodLength equal 0 require numberOfPeriods to be 1");
1470	 if (_rewards[4] > 0) {
1471	 require(!(int(_rewards[4]) == -1 && _reputationChange == (-2**255)), "numberOfPeriods * _reputationChange will overflow");
1472	 require((int(_rewards[4]) * _reputationChange) / int(_rewards[4]) == _reputationChange, "numberOfPeriods * reputationChange will overflow");
1473	 require((_rewards[4] * _rewards[0]) / _rewards[4] == _rewards[0], "numberOfPeriods * tokenReward will overflow");
1474	 require((_rewards[4] * _rewards[1]) / _rewards[4] == _rewards[1], "numberOfPeriods * ethReward will overflow");
1475	 require((_rewards[4] * _rewards[2]) / _rewards[4] == _rewards[2], "numberOfPeriods * texternalTokenReward will overflow");
1476	 }
1477	 }
1478	 }
1479	 pragma solidity 0.5.17;
1480	 contract ContributionRewardExt is VotingMachineCallbacks, ProposalExecuteInterface {
1481	 using SafeMath for uint;
1482	 using SafeERC20 for address;
1483	 event NewContributionProposal( address indexed _avatar, bytes32 indexed _proposalId, address indexed _intVoteInterface, string _descriptionHash, int256 _reputationChange, uint[3] _rewards, IERC20 _externalToken, address _beneficiary, address _proposer );
1484	 event ProposalExecuted(address indexed _avatar, bytes32 indexed _proposalId, int256 _param);
1485	 event RedeemReputation( address indexed _avatar, bytes32 indexed _proposalId, address indexed _beneficiary, int256 _amount);
1486	 event RedeemEther(address indexed _avatar, bytes32 indexed _proposalId, address indexed _beneficiary, uint256 _amount);
1487	 event RedeemNativeToken(address indexed _avatar, bytes32 indexed _proposalId, address indexed _beneficiary, uint256 _amount);
1488	 event RedeemExternalToken(address indexed _avatar, bytes32 indexed _proposalId, address indexed _beneficiary, uint256 _amount);
1489	 struct ContributionProposal {
1490	 uint256 nativeTokenReward;
1491	 int256 reputationChange;
1492	 uint256 ethReward;
1493	 IERC20 externalToken;
1494	 uint256 externalTokenReward;
1495	 address payable beneficiary;
1496	 uint256 nativeTokenRewardLeft;
1497	 uint256 reputationChangeLeft;
1498	 uint256 ethRewardLeft;
1499	 uint256 externalTokenRewardLeft;
1500	 bool acceptedByVotingMachine;
1501	 }
1502	 modifier onlyRewarder() {
1503	 require(msg.sender == rewarder, "msg.sender is not authorized");
1504	 _;
1505	 }
1506	 mapping(bytes32=>ContributionProposal) public organizationProposals;
1507	 IntVoteInterface public votingMachine;
1508	 bytes32 public voteParams;
1509	 Avatar public avatar;
1510	 address public rewarder;
1511	 function() external payable {
1512	 }
1513	 function initialize( Avatar _avatar, IntVoteInterface _votingMachine, bytes32 _voteParams, address _rewarder ) external {
1514	 require(avatar == Avatar(0), "can be called only one time");
1515	 require(_avatar != Avatar(0), "avatar cannot be zero");
1516	 require(_votingMachine != IntVoteInterface(0), "votingMachine cannot be zero");
1517	 avatar = _avatar;
1518	 votingMachine = _votingMachine;
1519	 voteParams = _voteParams;
1520	 rewarder = _rewarder;
1521	 }
1522	 function executeProposal(bytes32 _proposalId, int256 _decision) external onlyVotingMachine(_proposalId) returns(bool) {
1523	 require(organizationProposals[_proposalId].acceptedByVotingMachine == false);
1524	 require(organizationProposals[_proposalId].beneficiary != address(0));
1525	 if (_decision == 1) {
1526	 organizationProposals[_proposalId].acceptedByVotingMachine = true;
1527	 }
1528	 emit ProposalExecuted(address(avatar), _proposalId, _decision);
1529	 return true;
1530	 }
1531	 function proposeContributionReward( string memory _descriptionHash, int256 _reputationChange, uint[3] memory _rewards, IERC20 _externalToken, address payable _beneficiary, address _proposer ) public returns(bytes32 proposalId) {
1532	 address proposer = _proposer;
1533	 if (proposer == address(0)) {
1534	 proposer = msg.sender;
1535	 }
1536	 proposalId = votingMachine.propose(2, voteParams, proposer, address(avatar));
1537	 address payable beneficiary = _beneficiary;
1538	 if (beneficiary == address(0)) {
1539	 beneficiary = msg.sender;
1540	 }
1541	 if (beneficiary == address(this)) {
1542	 require(_reputationChange >= 0, "negative rep change not allowed for this case");
1543	 }
1544	 ContributionProposal memory proposal = ContributionProposal({
1545	 nativeTokenReward: _rewards[0], reputationChange: _reputationChange, ethReward: _rewards[1], externalToken: _externalToken, externalTokenReward: _rewards[2], beneficiary: beneficiary, nativeTokenRewardLeft: 0, reputationChangeLeft: 0, ethRewardLeft: 0, externalTokenRewardLeft: 0, acceptedByVotingMachine: false }
1546	 );
1547	 organizationProposals[proposalId] = proposal;
1548	 emit NewContributionProposal( address(avatar), proposalId, address(votingMachine), _descriptionHash, _reputationChange, _rewards, _externalToken, beneficiary, proposer );
1549	 proposalsInfo[address(votingMachine)][proposalId] = ProposalInfo({
1550	 blockNumber:block.number, avatar:avatar }
1551	 );
1552	 }
1553	 function redeemReputation(bytes32 _proposalId) public returns(int256 reputation) {
1554	 ContributionProposal storage proposal = organizationProposals[_proposalId];
1555	 require(proposal.acceptedByVotingMachine, "proposal was not accepted by the voting machine");
1556	 if (proposal.beneficiary == address(this)) {
1557	 if (proposal.reputationChangeLeft == 0) {
1558	 proposal.reputationChangeLeft = uint256(proposal.reputationChange);
1559	 proposal.reputationChange = 0;
1560	 }
1561	 }
1562	 else {
1563	 reputation = proposal.reputationChange;
1564	 proposal.reputationChange = 0;
1565	 if (reputation > 0) {
1566	 require( Controller( avatar.owner()).mintReputation(uint(reputation), proposal.beneficiary, address(avatar)));
1567	 }
1568	 else if (reputation < 0) {
1569	 require( Controller( avatar.owner()).burnReputation(uint(reputation*(-1)), proposal.beneficiary, address(avatar)));
1570	 }
1571	 if (reputation != 0) {
1572	 emit RedeemReputation(address(avatar), _proposalId, proposal.beneficiary, reputation);
1573	 }
1574	 }
1575	 }
1576	 function redeemNativeToken(bytes32 _proposalId) public returns(uint256 amount) {
1577	 ContributionProposal storage proposal = organizationProposals[_proposalId];
1578	 require(proposal.acceptedByVotingMachine, "proposal was not accepted by the voting machine");
1579	 if (proposal.beneficiary == address(this)) {
1580	 if (proposal.nativeTokenRewardLeft == 0) {
1581	 proposal.nativeTokenRewardLeft = proposal.nativeTokenReward;
1582	 }
1583	 }
1584	 amount = proposal.nativeTokenReward;
1585	 proposal.nativeTokenReward = 0;
1586	 if (amount > 0) {
1587	 require(Controller(avatar.owner()).mintTokens(amount, proposal.beneficiary, address(avatar)));
1588	 emit RedeemNativeToken(address(avatar), _proposalId, proposal.beneficiary, amount);
1589	 }
1590	 }
1591	 function redeemEther(bytes32 _proposalId) public returns(uint256 amount) {
1592	 ContributionProposal storage proposal = organizationProposals[_proposalId];
1593	 require(proposal.acceptedByVotingMachine, "proposal was not accepted by the voting machine");
1594	 if (proposal.beneficiary == address(this)) {
1595	 if (proposal.ethRewardLeft == 0) {
1596	 proposal.ethRewardLeft = proposal.ethReward;
1597	 }
1598	 }
1599	 amount = proposal.ethReward;
1600	 proposal.ethReward = 0;
1601	 if (amount > 0) {
1602	 require(Controller(avatar.owner()).sendEther(amount, proposal.beneficiary, avatar));
1603	 emit RedeemEther(address(avatar), _proposalId, proposal.beneficiary, amount);
1604	 }
1605	 }
1606	 function redeemExternalToken(bytes32 _proposalId) public returns(uint256 amount) {
1607	 ContributionProposal storage proposal = organizationProposals[_proposalId];
1608	 require(proposal.acceptedByVotingMachine, "proposal was not accepted by the voting machine");
1609	 if (proposal.beneficiary == address(this)) {
1610	 if (proposal.externalTokenRewardLeft == 0) {
1611	 proposal.externalTokenRewardLeft = proposal.externalTokenReward;
1612	 }
1613	 }
1614	 if (proposal.externalToken != IERC20(0) && proposal.externalTokenReward > 0) {
1615	 amount = proposal.externalTokenReward;
1616	 proposal.externalTokenReward = 0;
1617	 require( Controller( avatar.owner()) .externalTokenTransfer(proposal.externalToken, proposal.beneficiary, amount, avatar));
1618	 emit RedeemExternalToken(address(avatar), _proposalId, proposal.beneficiary, amount);
1619	 }
1620	 }
1621	 function redeemReputationByRewarder(bytes32 _proposalId, address _beneficiary, uint256 _reputation) public onlyRewarder {
1622	 ContributionProposal storage proposal = organizationProposals[_proposalId];
1623	 require(proposal.acceptedByVotingMachine, "proposal was not accepted by the voting machine");
1624	 proposal.reputationChangeLeft = proposal.reputationChangeLeft.sub(_reputation, "cannot redeem more reputation than allocated for this proposal or no redeemReputation was called");
1625	 require( Controller( avatar.owner()).mintReputation(_reputation, _beneficiary, address(avatar)));
1626	 if (_reputation != 0) {
1627	 emit RedeemReputation(address(avatar), _proposalId, _beneficiary, int256(_reputation));
1628	 }
1629	 }
1630	 function redeemNativeTokenByRewarder(bytes32 _proposalId, address _beneficiary, uint256 _amount) public onlyRewarder {
1631	 ContributionProposal storage proposal = organizationProposals[_proposalId];
1632	 require(proposal.acceptedByVotingMachine, "proposal was not accepted by the voting machine");
1633	 proposal.nativeTokenRewardLeft = proposal.nativeTokenRewardLeft.sub(_amount, "cannot redeem more tokens than allocated for this proposal or no redeemNativeToken was called");
1634	 if (_amount > 0) {
1635	 address(avatar.nativeToken()).safeTransfer(_beneficiary, _amount);
1636	 emit RedeemNativeToken(address(avatar), _proposalId, _beneficiary, _amount);
1637	 }
1638	 }
1639	 function redeemEtherByRewarder(bytes32 _proposalId, address payable _beneficiary, uint256 _amount) public onlyRewarder {
1640	 ContributionProposal storage proposal = organizationProposals[_proposalId];
1641	 require(proposal.acceptedByVotingMachine, "proposal was not accepted by the voting machine");
1642	 proposal.ethRewardLeft = proposal.ethRewardLeft.sub(_amount, "cannot redeem more Ether than allocated for this proposal or no redeemEther was called");
1643	 if (_amount > 0) {
1644	 _beneficiary.transfer(_amount);
1645	 emit RedeemEther(address(avatar), _proposalId, _beneficiary, _amount);
1646	 }
1647	 }
1648	 function redeemExternalTokenByRewarder(bytes32 _proposalId, address _beneficiary, uint256 _amount) public onlyRewarder {
1649	 ContributionProposal storage proposal = organizationProposals[_proposalId];
1650	 require(proposal.acceptedByVotingMachine, "proposal was not accepted by the voting machine");
1651	 proposal.externalTokenRewardLeft = proposal.externalTokenRewardLeft.sub(_amount, "cannot redeem more tokens than allocated for this proposal or no redeemExternalToken was called");
1652	 if (proposal.externalToken != IERC20(0)) {
1653	 if (_amount > 0) {
1654	 address(proposal.externalToken).safeTransfer(_beneficiary, _amount);
1655	 emit RedeemExternalToken(address(avatar), _proposalId, _beneficiary, _amount);
1656	 }
1657	 }
1658	 }
1659	 function redeem(bytes32 _proposalId, bool[4] memory _whatToRedeem) public returns(int256 reputationReward, uint256 nativeTokenReward, uint256 etherReward, uint256 externalTokenReward) {
1660	 if (_whatToRedeem[0]) {
1661	 reputationReward = redeemReputation(_proposalId);
1662	 }
1663	 if (_whatToRedeem[1]) {
1664	 nativeTokenReward = redeemNativeToken(_proposalId);
1665	 }
1666	 if (_whatToRedeem[2]) {
1667	 etherReward = redeemEther(_proposalId);
1668	 }
1669	 if (_whatToRedeem[3]) {
1670	 externalTokenReward = redeemExternalToken(_proposalId);
1671	 }
1672	 }
1673	 function getProposalEthReward(bytes32 _proposalId) public view returns (uint256) {
1674	 return organizationProposals[_proposalId].ethReward;
1675	 }
1676	 function getProposalExternalTokenReward(bytes32 _proposalId) public view returns (uint256) {
1677	 return organizationProposals[_proposalId].externalTokenReward;
1678	 }
1679	 function getProposalExternalToken(bytes32 _proposalId) public view returns (address) {
1680	 return address(organizationProposals[_proposalId].externalToken);
1681	 }
1682	 function getProposalReputationReward(bytes32 _proposalId) public view returns (int256) {
1683	 return organizationProposals[_proposalId].reputationChange;
1684	 }
1685	 function getProposalNativeTokenReward(bytes32 _proposalId) public view returns (uint256) {
1686	 return organizationProposals[_proposalId].nativeTokenReward;
1687	 }
1688	 function getProposalAcceptedByVotingMachine(bytes32 _proposalId) public view returns (bool) {
1689	 return organizationProposals[_proposalId].acceptedByVotingMachine;
1690	 }
1691	 }
1692	 pragma solidity 0.5.17;
1693	 contract Redeemer {
1694	 using SafeMath for uint;
1695	 function redeem(ContributionReward _contributionReward, GenesisProtocol _genesisProtocol, bytes32 _proposalId, Avatar _avatar, address _beneficiary) external returns(uint[3] memory gpRewards, uint[2] memory gpDaoBountyReward, bool executed, uint256 winningVote, int256 crReputationReward, uint256 crNativeTokenReward, uint256 crEthReward, uint256 crExternalTokenReward) {
1696	 bool callContributionReward;
1697	 (gpRewards, gpDaoBountyReward, executed, winningVote, callContributionReward) = genesisProtocolRedeem(_genesisProtocol, _proposalId, _beneficiary);
1698	 if (callContributionReward) {
1699	 if (_contributionReward.getProposalExecutionTime(_proposalId, address(_avatar)) > 0) {
1700	 (crReputationReward, crNativeTokenReward, crEthReward, crExternalTokenReward) = contributionRewardRedeem(_contributionReward, _proposalId, _avatar);
1701	 }
1702	 }
1703	 }
1704	 function redeemFromCRExt(ContributionRewardExt _contributionRewardExt, GenesisProtocol _genesisProtocol, bytes32 _proposalId, address _beneficiary) external returns(uint[3] memory gpRewards, uint[2] memory gpDaoBountyReward, bool executed, uint256 winningVote, int256 crReputationReward, uint256 crNativeTokenReward, uint256 crEthReward, uint256 crExternalTokenReward) {
1705	 bool callContributionReward;
1706	 (gpRewards, gpDaoBountyReward, executed, winningVote, callContributionReward) = genesisProtocolRedeem(_genesisProtocol, _proposalId, _beneficiary);
1707	 if (callContributionReward) {
1708	 if (_contributionRewardExt.getProposalAcceptedByVotingMachine(_proposalId)) {
1709	 (crReputationReward, crNativeTokenReward, crEthReward, crExternalTokenReward) = contributionRewardExtRedeem(_contributionRewardExt, _proposalId);
1710	 }
1711	 }
1712	 }
1713	 function genesisProtocolRedeem(GenesisProtocol _genesisProtocol, bytes32 _proposalId, address _beneficiary) private returns(uint[3] memory gpRewards, uint[2] memory gpDaoBountyReward, bool executed, uint256 winningVote, bool callContributionReward) {
1714	 GenesisProtocol.ProposalState pState = _genesisProtocol.state(_proposalId);
1715	 if ((pState == GenesisProtocolLogic.ProposalState.Queued)|| (pState == GenesisProtocolLogic.ProposalState.PreBoosted)|| (pState == GenesisProtocolLogic.ProposalState.Boosted)|| (pState == GenesisProtocolLogic.ProposalState.QuietEndingPeriod)) {
1716	 executed = _genesisProtocol.execute(_proposalId);
1717	 }
1718	 pState = _genesisProtocol.state(_proposalId);
1719	 if ((pState == GenesisProtocolLogic.ProposalState.Executed) || (pState == GenesisProtocolLogic.ProposalState.ExpiredInQueue)) {
1720	 gpRewards = _genesisProtocol.redeem(_proposalId, _beneficiary);
1721	 if (pState == GenesisProtocolLogic.ProposalState.Executed) {
1722	 (gpDaoBountyReward[0], gpDaoBountyReward[1]) = _genesisProtocol.redeemDaoBounty(_proposalId, _beneficiary);
1723	 }
1724	 winningVote = _genesisProtocol.winningVote(_proposalId);
1725	 callContributionReward = true;
1726	 }
1727	 }
1728	 function contributionRewardRedeem(ContributionReward _contributionReward, bytes32 _proposalId, Avatar _avatar) private returns (int256 reputation, uint256 nativeToken, uint256 eth, uint256 externalToken) {
1729	 bool[4] memory whatToRedeem;
1730	 whatToRedeem[0] = true;
1731	 whatToRedeem[1] = true;
1732	 uint256 periodsToPay = _contributionReward.getPeriodsToPay(_proposalId, address(_avatar), 2);
1733	 uint256 ethReward = _contributionReward.getProposalEthReward(_proposalId, address(_avatar));
1734	 uint256 externalTokenReward = _contributionReward.getProposalExternalTokenReward(_proposalId, address(_avatar));
1735	 address externalTokenAddress = _contributionReward.getProposalExternalToken(_proposalId, address(_avatar));
1736	 ethReward = periodsToPay.mul(ethReward);
1737	 if ((ethReward == 0) || (address(_avatar).balance < ethReward)) {
1738	 whatToRedeem[2] = false;
1739	 }
1740	 else {
1741	 whatToRedeem[2] = true;
1742	 }
1743	 periodsToPay = _contributionReward.getPeriodsToPay(_proposalId, address(_avatar), 3);
1744	 externalTokenReward = periodsToPay.mul(externalTokenReward);
1745	 if ((externalTokenReward == 0) || (IERC20(externalTokenAddress).balanceOf(address(_avatar)) < externalTokenReward)) {
1746	 whatToRedeem[3] = false;
1747	 }
1748	 else {
1749	 whatToRedeem[3] = true;
1750	 }
1751	 (reputation, nativeToken, eth, externalToken) = _contributionReward.redeem(_proposalId, _avatar, whatToRedeem);
1752	 }
1753	 function contributionRewardExtRedeem(ContributionRewardExt _contributionRewardExt, bytes32 _proposalId) private returns (int256 reputation, uint256 nativeToken, uint256 eth, uint256 externalToken) {
1754	 bool[4] memory whatToRedeem;
1755	 whatToRedeem[0] = true;
1756	 whatToRedeem[1] = true;
1757	 uint256 ethReward = _contributionRewardExt.getProposalEthReward(_proposalId);
1758	 uint256 externalTokenReward = _contributionRewardExt.getProposalExternalTokenReward(_proposalId);
1759	 address externalTokenAddress = _contributionRewardExt.getProposalExternalToken(_proposalId);
1760	 if ((ethReward == 0) || (address(_contributionRewardExt.avatar()).balance < ethReward)) {
1761	 whatToRedeem[2] = false;
1762	 }
1763	 else {
1764	 whatToRedeem[2] = true;
1765	 }
1766	 if ((externalTokenReward == 0) || (IERC20(externalTokenAddress).balanceOf(address(_contributionRewardExt.avatar())) < externalTokenReward)) {
1767	 whatToRedeem[3] = false;
1768	 }
1769	 else {
1770	 whatToRedeem[3] = true;
1771	 }
1772	 (reputation, nativeToken, eth, externalToken) = _contributionRewardExt.redeem(_proposalId, whatToRedeem);
1773	 }
1774	 }
