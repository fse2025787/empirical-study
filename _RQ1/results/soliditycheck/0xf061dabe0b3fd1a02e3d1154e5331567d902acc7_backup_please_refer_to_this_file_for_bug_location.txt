row number 
1	       pragma solidity 0.6.12;
2	 library SafeMath {
3	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
4	 uint256 c = a + b;
5	 require(c >= a, "SafeMath: addition overflow");
6	 return c;
7	 }
8	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
9	 return sub(a, b, "SafeMath: subtraction overflow");
10	 }
11	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
12	 require(b <= a, errorMessage);
13	 uint256 c = a - b;
14	 return c;
15	 }
16	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
17	 if (a == 0) {
18	 return 0;
19	 }
20	 uint256 c = a * b;
21	 require(c / a == b, "SafeMath: multiplication overflow");
22	 return c;
23	 }
24	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
25	 return div(a, b, "SafeMath: division by zero");
26	 }
27	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
28	 require(b > 0, errorMessage);
29	 uint256 c = a / b;
30	 return c;
31	 }
32	 }
33	 abstract contract Context {
34	 function _msgSender() internal view virtual returns (address payable) {
35	 return msg.sender;
36	 }
37	 function _msgData() internal view virtual returns (bytes memory) {
38	 this;
39	 return msg.data;
40	 }
41	 }
42	 interface IERC20 {
43	 function totalSupply() external view returns (uint256);
44	 function balanceOf(address account) external view returns (uint256);
45	 function transfer(address recipient, uint256 amount) external returns (bool);
46	 function allowance(address owner, address spender) external view returns (uint256);
47	 function approve(address spender, uint256 amount) external returns (bool);
48	 function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
49	 event Transfer(address indexed from, address indexed to, uint256 value);
50	 event Approval(address indexed owner, address indexed spender, uint256 value);
51	 }
52	 library Address {
53	 function isContract(address account) internal view returns (bool) {
54	 bytes32 codehash;
55	 bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
56	 assembly {
57	 codehash := extcodehash(account) }
58	 return (codehash != accountHash && codehash != 0x0);
59	 }
60	 function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
61	 return _functionCallWithValue(target, data, 0, errorMessage);
62	 }
63	 function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {
64	 require(isContract(target), "Address: call to non-contract");
65	 (bool success, bytes memory returndata) = target.call{
66	 value: weiValue }
67	 (data);
68	 if (success) {
69	 return returndata;
70	 }
71	 else {
72	 if (returndata.length > 0) {
73	 assembly {
74	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
75	 }
76	 else {
77	 revert(errorMessage);
78	 }
79	 }
80	 }
81	 }
82	 contract ERC20 is Context, IERC20 {
83	 using SafeMath for uint256;
84	 using Address for address;
85	 mapping (address => uint256) private _balances;
86	 mapping (address => mapping (address => uint256)) private _allowances;
87	 uint256 private _totalSupply;
88	 string private _name;
89	 string private _symbol;
90	 uint8 private _decimals;
91	 constructor (string memory name, string memory symbol) public {
92	 _name = name;
93	 _symbol = symbol;
94	 _decimals = 18;
95	 }
96	 function name() public view returns (string memory) {
97	 return _name;
98	 }
99	 function symbol() public view returns (string memory) {
100	 return _symbol;
101	 }
102	 function decimals() public view returns (uint8) {
103	 return _decimals;
104	 }
105	 function totalSupply() public view override returns (uint256) {
106	 return _totalSupply;
107	 }
108	 function balanceOf(address account) public view override returns (uint256) {
109	 return _balances[account];
110	 }
111	 function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
112	 _transfer(_msgSender(), recipient, amount);
113	 return true;
114	 }
115	 function allowance(address owner, address spender) public view virtual override returns (uint256) {
116	 return _allowances[owner][spender];
117	 }
118	 function approve(address spender, uint256 amount) public virtual override returns (bool) {
119	 _approve(_msgSender(), spender, amount);
120	 return true;
121	 }
122	 function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
123	 _transfer(sender, recipient, amount);
124	 _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
125	 return true;
126	 }
127	 function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
128	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
129	 return true;
130	 }
131	 function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
132	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
133	 return true;
134	 }
135	 function _transfer(address sender, address recipient, uint256 amount) internal virtual {
136	 require(sender != address(0), "ERC20: transfer from the zero address");
137	 require(recipient != address(0), "ERC20: transfer to the zero address");
138	 _beforeTokenTransfer(sender, recipient, amount);
139	 _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
140	 _balances[recipient] = _balances[recipient].add(amount);
141	 emit Transfer(sender, recipient, amount);
142	 }
143	 function _mint(address account, uint256 amount) internal virtual {
144	 require(account != address(0), "ERC20: mint to the zero address");
145	 _beforeTokenTransfer(address(0), account, amount);
146	 _totalSupply = _totalSupply.add(amount);
147	 _balances[account] = _balances[account].add(amount);
148	 emit Transfer(address(0), account, amount);
149	 }
150	 function _burn(address account, uint256 amount) internal virtual {
151	 require(account != address(0), "ERC20: burn from the zero address");
152	 _beforeTokenTransfer(account, address(0), amount);
153	 _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
154	 _totalSupply = _totalSupply.sub(amount);
155	 emit Transfer(account, address(0), amount);
156	 }
157	 function _approve(address owner, address spender, uint256 amount) internal virtual {
158	 require(owner != address(0), "ERC20: approve from the zero address");
159	 require(spender != address(0), "ERC20: approve to the zero address");
160	 _allowances[owner][spender] = amount;
161	 emit Approval(owner, spender, amount);
162	 }
163	 function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {
164	 }
165	 }
166	 library SafeERC20 {
167	 using SafeMath for uint256;
168	 using Address for address;
169	 function safeTransfer(IERC20 token, address to, uint256 value) internal {
170	 _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
171	 }
172	 function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
173	 _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
174	 }
175	 function safeApprove(IERC20 token, address spender, uint256 value) internal {
176	 require((value == 0) || (token.allowance(address(this), spender) == 0), "SafeERC20: approve from non-zero to non-zero allowance" );
177	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
178	 }
179	 function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
180	 uint256 newAllowance = token.allowance(address(this), spender).add(value);
181	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
182	 }
183	 function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
184	 uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
185	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
186	 }
187	 function _callOptionalReturn(IERC20 token, bytes memory data) private {
188	 bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
189	 if (returndata.length > 0) {
190	 require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
191	 }
192	 }
193	 }
194	 interface IVault is IERC20 {
195	 function token() external view returns (address);
196	 function claimInsurance() external;
197	 function getRatio() external view returns (uint256);
198	 function deposit(uint256) external;
199	 function withdraw(uint256) external;
200	 function earn() external;
201	 }
202	 interface UniswapRouterV2 {
203	 function swapExactTokensForTokens( uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline ) external returns (uint256[] memory amounts);
204	 function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);
205	 }
206	 interface IController {
207	 function vaults(address) external view returns (address);
208	 function devfund() external view returns (address);
209	 function treasury() external view returns (address);
210	 }
211	 interface IMasterchef {
212	 function notifyBuybackReward(uint256 _amount) external;
213	 }
214	 abstract contract StrategyBase {
215	 using SafeERC20 for IERC20;
216	 using Address for address;
217	 using SafeMath for uint256;
218	 mapping(address => bool) public benignCallers;
219	 uint256 public performanceFee = 30000;
220	 uint256 public constant performanceMax = 100000;
221	 uint256 public treasuryFee = 0;
222	 uint256 public constant treasuryMax = 100000;
223	 uint256 public devFundFee = 0;
224	 uint256 public constant devFundMax = 100000;
225	 uint256 public delayBlockRequired = 1000;
226	 uint256 public lastHarvestBlock;
227	 uint256 public lastHarvestInWant;
228	 bool public buybackEnabled = true;
229	 address public mmToken = 0xa283aA7CfBB27EF0cfBcb2493dD9F4330E0fd304;
230	 address public masterChef = 0xf8873a6080e8dbF41ADa900498DE0951074af577;
231	 address public want;
232	 address public constant weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
233	 address public governance;
234	 address public controller;
235	 address public strategist;
236	 address public timelock;
237	 address public univ2Router2 = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;
238	 address public sushiRouter = 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F;
239	 constructor( address _want, address _governance, address _strategist, address _controller, address _timelock ) public {
240	 require(_want != address(0));
241	 require(_governance != address(0));
242	 require(_strategist != address(0));
243	 require(_controller != address(0));
244	 require(_timelock != address(0));
245	 want = _want;
246	 governance = _governance;
247	 strategist = _strategist;
248	 controller = _controller;
249	 timelock = _timelock;
250	 }
251	 modifier onlyBenevolent {
252	 require(msg.sender == governance || msg.sender == strategist);
253	 _;
254	 }
255	 modifier onlyBenignCallers {
256	 require(msg.sender == governance || msg.sender == strategist || benignCallers[msg.sender]);
257	 _;
258	 }
259	 function balanceOfWant() public view returns (uint256) {
260	 return IERC20(want).balanceOf(address(this));
261	 }
262	 function balanceOfPool() public virtual view returns (uint256);
263	 function balanceOf() public view returns (uint256) {
264	 uint256 delayReduction = 0;
265	 uint256 currentBlock = block.number;
266	 if (delayBlockRequired > 0 && lastHarvestInWant > 0 && currentBlock.sub(lastHarvestBlock) < delayBlockRequired){
267	 uint256 diffBlock = lastHarvestBlock.add(delayBlockRequired).sub(currentBlock);
268	 delayReduction = lastHarvestInWant.mul(diffBlock).mul(1e18).div(delayBlockRequired).div(1e18);
269	 }
270	 return balanceOfWant().add(balanceOfPool()).sub(delayReduction);
271	 }
272	 function getName() external virtual pure returns (string memory);
273	 function setBenignCallers(address _caller, bool _enabled) external{
274	 require(msg.sender == governance, "!governance");
275	 benignCallers[_caller] = _enabled;
276	 }
277	 function setDelayBlockRequired(uint256 _delayBlockRequired) external {
278	 require(msg.sender == governance, "!governance");
279	 delayBlockRequired = _delayBlockRequired;
280	 }
281	 function setDevFundFee(uint256 _devFundFee) external {
282	 require(msg.sender == timelock, "!timelock");
283	 devFundFee = _devFundFee;
284	 }
285	 function setTreasuryFee(uint256 _treasuryFee) external {
286	 require(msg.sender == timelock, "!timelock");
287	 treasuryFee = _treasuryFee;
288	 }
289	 function setPerformanceFee(uint256 _performanceFee) external {
290	 require(msg.sender == timelock, "!timelock");
291	 performanceFee = _performanceFee;
292	 }
293	 function setStrategist(address _strategist) external {
294	 require(msg.sender == governance, "!governance");
295	 strategist = _strategist;
296	 }
297	 function setGovernance(address _governance) external {
298	 require(msg.sender == governance, "!governance");
299	 governance = _governance;
300	 }
301	 function setTimelock(address _timelock) external {
302	 require(msg.sender == timelock, "!timelock");
303	 timelock = _timelock;
304	 }
305	 function setController(address _controller) external {
306	 require(msg.sender == timelock, "!timelock");
307	 controller = _controller;
308	 }
309	 function setBuybackEnabled(bool _buybackEnabled) external {
310	 require(msg.sender == governance, "!governance");
311	 buybackEnabled = _buybackEnabled;
312	 }
313	 function setMasterChef(address _masterChef) external {
314	 require(msg.sender == governance, "!governance");
315	 masterChef = _masterChef;
316	 }
317	 function deposit() public virtual;
318	 function withdraw(IERC20 _asset) external virtual returns (uint256 balance);
319	 function _withdrawNonWantAsset(IERC20 _asset) internal returns (uint256 balance) {
320	 require(msg.sender == controller, "!controller");
321	 require(want != address(_asset), "want");
322	 balance = _asset.balanceOf(address(this));
323	 _asset.safeTransfer(controller, balance);
324	 }
325	 function withdraw(uint256 _amount) external {
326	 require(msg.sender == controller, "!controller");
327	 uint256 _balance = IERC20(want).balanceOf(address(this));
328	 if (_balance < _amount) {
329	 _amount = _withdrawSome(_amount.sub(_balance));
330	 _amount = _amount.add(_balance);
331	 }
332	 uint256 _feeDev = _amount.mul(devFundFee).div(devFundMax);
333	 uint256 _feeTreasury = _amount.mul(treasuryFee).div(treasuryMax);
334	 address _vault = IController(controller).vaults(address(want));
335	 require(_vault != address(0), "!vault");
336	 if (buybackEnabled == true && (_feeDev > 0 || _feeTreasury > 0)) {
337	 (address _buybackPrinciple, uint256 _buybackAmount) = _convertWantToBuyback(_feeDev.add(_feeTreasury));
338	 buybackAndNotify(_buybackPrinciple, _buybackAmount);
339	 }
340	 IERC20(want).safeTransfer(_vault, _amount.sub(_feeDev).sub(_feeTreasury));
341	 }
342	 function buybackAndNotify(address _buybackPrinciple, uint256 _buybackAmount) internal {
343	 if (buybackEnabled == true && _buybackAmount > 0) {
344	 _swapUniswap(_buybackPrinciple, mmToken, _buybackAmount);
345	 uint256 _mmBought = IERC20(mmToken).balanceOf(address(this));
346	 IERC20(mmToken).safeTransfer(masterChef, _mmBought);
347	 IMasterchef(masterChef).notifyBuybackReward(_mmBought);
348	 }
349	 }
350	 bool public emergencyExit;
351	 function setEmergencyExit(bool _enable) external {
352	 require(msg.sender == governance, "!governance");
353	 emergencyExit = _enable;
354	 }
355	 function withdrawAll() external returns (uint256 balance) {
356	 require(msg.sender == controller, "!controller");
357	 if (!emergencyExit) {
358	 _withdrawAll();
359	 }
360	 balance = IERC20(want).balanceOf(address(this));
361	 address _vault = IController(controller).vaults(address(want));
362	 require(_vault != address(0), "!vault");
363	 IERC20(want).safeTransfer(_vault, balance);
364	 }
365	 function _withdrawAll() internal {
366	 _withdrawSome(balanceOfPool());
367	 }
368	 function _withdrawSome(uint256 _amount) internal virtual returns (uint256);
369	 function _convertWantToBuyback(uint256 _lpAmount) internal virtual returns (address, uint256);
370	 function harvest() public virtual;
371	 function figureOutPath(address _from, address _to, uint256 _amount) public view returns (bool useSushi, address[] memory swapPath){
372	 address[] memory path;
373	 address[] memory sushipath;
374	 path = new address[](2);
375	 path[0] = _from;
376	 path[1] = _to;
377	 sushipath = new address[](2);
378	 sushipath[0] = _from;
379	 sushipath[1] = _to;
380	 uint256 _sushiOut = sushipath.length > 0? UniswapRouterV2(sushiRouter).getAmountsOut(_amount, sushipath)[sushipath.length - 1] : 0;
381	 uint256 _uniOut = sushipath.length > 0? UniswapRouterV2(univ2Router2).getAmountsOut(_amount, path)[path.length - 1] : 1;
382	 bool useSushi = _sushiOut > _uniOut? true : false;
383	 address[] memory swapPath = useSushi ? sushipath : path;
384	 return (useSushi, swapPath);
385	 }
386	 function _swapUniswap( address _from, address _to, uint256 _amount ) internal {
387	 (bool useSushi, address[] memory swapPath) = figureOutPath(_from, _to, _amount);
388	 address _router = useSushi? sushiRouter : univ2Router2;
389	 _swapUniswapWithDetailConfig(_from, _to, _amount, 1, swapPath, _router);
390	 }
391	 function _swapUniswapWithDetailConfig( address _from, address _to, uint256 _amount, uint256 _amountOutMin, address[] memory _swapPath, address _router ) internal {
392	 require(_to != address(0), '!invalidOutToken');
393	 require(_router != address(0), '!swapRouter');
394	 require(IERC20(_from).balanceOf(address(this)) >= _amount, '!notEnoughtAmountIn');
395	 if (_amount > 0){
396	 IERC20(_from).safeApprove(_router, 0);
397	 IERC20(_from).safeApprove(_router, _amount);
398	 UniswapRouterV2(_router).swapExactTokensForTokens( _amount, _amountOutMin, _swapPath, address(this), now );
399	 }
400	 }
401	 }
402	 interface AggregatorV3Interface {
403	 function latestRoundData() external view returns ( uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound );
404	 }
405	 interface ManagerLike {
406	 function ilks(uint256) external view returns (bytes32);
407	 function owns(uint256) external view returns (address);
408	 function urns(uint256) external view returns (address);
409	 function vat() external view returns (address);
410	 function open(bytes32, address) external returns (uint256);
411	 function give(uint256, address) external;
412	 function frob(uint256, int256, int256) external;
413	 function flux(uint256, address, uint256) external;
414	 function move(uint256, address, uint256) external;
415	 function exit(address, uint256, address, uint256) external;
416	 function quit(uint256, address) external;
417	 function enter(address, uint256) external;
418	 }
419	 interface VatLike {
420	 function can(address, address) external view returns (uint256);
421	 function ilks(bytes32) external view returns (uint256, uint256, uint256, uint256, uint256);
422	 function dai(address) external view returns (uint256);
423	 function urns(bytes32, address) external view returns (uint256, uint256);
424	 function frob(bytes32, address, address, address, int256, int256) external;
425	 function hope(address) external;
426	 function move(address, address, uint256) external;
427	 }
428	 interface GemJoinLike {
429	 function dec() external returns (uint256);
430	 function join(address, uint256) external payable;
431	 function exit(address, uint256) external;
432	 }
433	 interface DaiJoinLike {
434	 function join(address, uint256) external payable;
435	 function exit(address, uint256) external;
436	 }
437	 interface JugLike {
438	 function drip(bytes32) external returns (uint256);
439	 }
440	 abstract contract StrategyMakerBase is StrategyBase {
441	 address public constant dssCdpManager = 0x5ef30b9986345249bc32d8928B7ee64DE9435E39;
442	 address public constant daiJoin = 0x9759A6Ac90977b93B58547b4A71c78317f391A28;
443	 address public constant jug = 0x19c0976f590D67707E62397C87829d896Dc0f1F1;
444	 address public constant vat = 0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B;
445	 address public constant debtToken = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
446	 uint256 public minDebt = 30001000000000000000000;
447	 address public constant eth_usd = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;
448	 address public collateral;
449	 uint256 public collateralDecimal = 1e18;
450	 address public gemJoin;
451	 address public collateralOracle;
452	 bytes32 public collateralIlk;
453	 AggregatorV3Interface internal priceFeed;
454	 uint256 public collateralPriceDecimal = 1;
455	 bool public collateralPriceEth = false;
456	 uint256 public cdpId = 0;
457	 uint256 public minRatio = 155;
458	 uint256 public ratioBuff = 500;
459	 uint256 public constant ratioBuffMax = 10000;
460	 uint256 constant RAY = 10 ** 27;
461	 constructor( address _collateralJoin, bytes32 _collateralIlk, address _collateral, uint256 _collateralDecimal, address _collateralOracle, uint256 _collateralPriceDecimal, bool _collateralPriceEth, address _want, address _governance, address _strategist, address _controller, address _timelock ) public StrategyBase(_want, _governance, _strategist, _controller, _timelock) {
462	 require(_want == _collateral, '!mismatchWant');
463	 gemJoin = _collateralJoin;
464	 collateralIlk = _collateralIlk;
465	 collateral = _collateral;
466	 collateralDecimal = _collateralDecimal;
467	 collateralOracle = _collateralOracle;
468	 priceFeed = AggregatorV3Interface(collateralOracle);
469	 collateralPriceDecimal = _collateralPriceDecimal;
470	 collateralPriceEth = _collateralPriceEth;
471	 }
472	 modifier onlyCDPInUse {
473	 uint256 collateralAmt = getCollateralBalance();
474	 require(collateralAmt > 0, '!zeroCollateral');
475	 uint256 debtAmt = getDebtBalance();
476	 require(debtAmt > 0, '!zeroDebt');
477	 _;
478	 }
479	 modifier onlyCDPInitiated {
480	 require(cdpId > 0, '!noCDP');
481	 _;
482	 }
483	 modifier onlyAboveMinDebt(uint256 _daiAmt) {
484	 uint256 debtAmt = getDebtBalance();
485	 require((_daiAmt < debtAmt && (debtAmt.sub(_daiAmt) >= minDebt)) || debtAmt <= _daiAmt, '!minDebt');
486	 _;
487	 }
488	 function getCollateralBalance() public view returns (uint256) {
489	 (uint256 ink, ) = VatLike(vat).urns(collateralIlk, ManagerLike(dssCdpManager).urns(cdpId));
490	 return ink.mul(collateralDecimal).div(1e18);
491	 }
492	 function getDebtBalance() public view returns (uint256) {
493	 address urnHandler = ManagerLike(dssCdpManager).urns(cdpId);
494	 (, uint256 art) = VatLike(vat).urns(collateralIlk, urnHandler);
495	 (, uint256 rate, , , ) = VatLike(vat).ilks(collateralIlk);
496	 uint rad = mul(art, rate);
497	 if (rad == 0) {
498	 return 0;
499	 }
500	 uint256 wad = rad / RAY;
501	 return mul(wad, RAY) < rad ? wad + 1 : wad;
502	 }
503	 function ilkDebts() public view returns(uint256, uint256, bool){
504	 (uint256 Art, uint256 rate,,uint256 line,) = VatLike(vat).ilks(collateralIlk);
505	 uint256 currentDebt = Art.mul(rate).div(RAY);
506	 uint256 maxDebt = line.div(RAY);
507	 return (currentDebt, maxDebt, maxDebt > currentDebt);
508	 }
509	 function balanceOfPool() public override view returns (uint256){
510	 return getCollateralBalance();
511	 }
512	 function collateralValue(uint256 collateralAmt) public view returns (uint256){
513	 uint256 collateralPrice = getLatestCollateralPrice();
514	 return collateralAmt.mul(collateralPrice).mul(1e18).div(collateralDecimal).div(collateralPriceDecimal);
515	 }
516	 function currentRatio() public view returns (uint256) {
517	 uint256 _collateral = cdpId > 0? getCollateralBalance() : 0;
518	 if (_collateral > 0){
519	 uint256 collateralAmt = collateralValue(_collateral).mul(100);
520	 uint256 debtAmt = getDebtBalance();
521	 return collateralAmt.div(debtAmt);
522	 }
523	 else{
524	 return 0;
525	 }
526	 }
527	 function calculateDebtFor(uint256 collateralAmt, bool borrow) public view returns (uint256) {
528	 uint256 maxDebt = collateralAmt > 0? collateralValue(collateralAmt).mul(ratioBuffMax).div(_getBufferedMinRatio(ratioBuffMax)) : 0;
529	 uint256 debtAmt = getDebtBalance();
530	 uint256 debt = 0;
531	 if (borrow && maxDebt >= debtAmt){
532	 debt = maxDebt.sub(debtAmt);
533	 }
534	 else if (!borrow && debtAmt >= maxDebt){
535	 debt = debtAmt.sub(maxDebt);
536	 }
537	 return (debt > 0)? debt : 0;
538	 }
539	 function _getBufferedMinRatio(uint256 _multiplier) internal view returns (uint256){
540	 return _multiplier.mul(minRatio).mul(ratioBuffMax.add(ratioBuff)).div(ratioBuffMax).div(100);
541	 }
542	 function borrowableDebt() public view returns (uint256) {
543	 uint256 collateralAmt = getCollateralBalance();
544	 return calculateDebtFor(collateralAmt, true);
545	 }
546	 function requiredPaidDebt(uint256 _redeemCollateralAmt) public view returns (uint256) {
547	 uint256 totalCollateral = getCollateralBalance();
548	 uint256 collateralAmt = _redeemCollateralAmt >= totalCollateral? 0 : totalCollateral.sub(_redeemCollateralAmt);
549	 return calculateDebtFor(collateralAmt, false);
550	 }
551	 function _convertWantToBuyback(uint256 _lpAmount) internal virtual override returns (address, uint256);
552	 function _depositDAI(uint256 _daiAmt) internal virtual;
553	 function _withdrawDAI(uint256 _daiAmt) internal virtual;
554	 function _swapDebtToWant(uint256 _swapIn) internal virtual returns(uint256);
555	 function getLatestCollateralPrice() public view returns (uint256){
556	 require(collateralOracle != address(0), '!_collateralOracle');
557	 ( uint80 roundID, int price, uint startedAt, uint timeStamp, uint80 answeredInRound ) = priceFeed.latestRoundData();
558	 if (price > 0){
559	 int ethPrice = 1;
560	 if (collateralPriceEth){
561	 (,ethPrice,,,) = AggregatorV3Interface(eth_usd).latestRoundData();
562	 }
563	 return uint256(price).mul(collateralPriceDecimal).mul(uint256(ethPrice)).div(1e8).div(collateralPriceEth? 1e18 : 1);
564	 }
565	 else{
566	 return 0;
567	 }
568	 }
569	 function setMinDebt(uint256 _minDebt) external onlyBenevolent {
570	 minDebt = _minDebt;
571	 }
572	 function setMinRatio(uint256 _minRatio) external onlyBenevolent {
573	 minRatio = _minRatio;
574	 }
575	 function setRatioBuff(uint256 _ratioBuff) external onlyBenevolent {
576	 ratioBuff = _ratioBuff;
577	 }
578	 function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {
579	 require(y == 0 || (z = x * y) / y == x, "mul-overflow");
580	 }
581	 function toRad(uint256 wad) internal pure returns (uint256 rad) {
582	 rad = mul(wad, RAY);
583	 }
584	 function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {
585	 require((z = x - y) <= x, "sub-overflow");
586	 }
587	 function toInt(uint256 x) internal pure returns (int256 y) {
588	 y = int256(x);
589	 require(y >= 0, "int-overflow");
590	 }
591	 function convertTo18(address gemJoin, uint256 amt) internal returns (uint256 wad) {
592	 wad = mul(amt, 10 ** (18 - GemJoinLike(gemJoin).dec()));
593	 }
594	 function _getDrawDart(address vat, address jug, address urn, bytes32 ilk, uint wad) internal returns (int256 dart) {
595	 uint256 rate = JugLike(jug).drip(ilk);
596	 uint256 dai = VatLike(vat).dai(urn);
597	 if (dai < toRad(wad)) {
598	 dart = toInt(sub(toRad(wad), dai).div(rate));
599	 dart = mul(uint256(dart), rate) < toRad(wad) ? dart + 1 : dart;
600	 }
601	 }
602	 function _getWipeDart(address vat, uint dai, address urn, bytes32 ilk) internal view returns (int256 dart) {
603	 (, uint256 rate,,,) = VatLike(vat).ilks(ilk);
604	 (, uint256 art) = VatLike(vat).urns(ilk, urn);
605	 dart = toInt(dai.div(rate));
606	 dart = uint256(dart) <= art ? - dart : - toInt(art);
607	 }
608	 function openCDP() external onlyBenevolent{
609	 require(cdpId <= 0, "!cdpAlreadyOpened");
610	 cdpId = ManagerLike(dssCdpManager).open(collateralIlk, address(this));
611	 IERC20(collateral).approve(gemJoin, uint256(-1));
612	 IERC20(debtToken).approve(daiJoin, uint256(-1));
613	 }
614	 function getUrnVatIlk() internal returns (address, address, bytes32){
615	 return (ManagerLike(dssCdpManager).urns(cdpId), ManagerLike(dssCdpManager).vat(), ManagerLike(dssCdpManager).ilks(cdpId));
616	 }
617	 function addCollateralAndBorrow(uint256 _collateralAmt, uint256 _daiAmt) internal onlyCDPInitiated {
618	 require(_daiAmt.add(getDebtBalance()) >= minDebt, '!minDebt');
619	 (address urn, address vat, bytes32 ilk) = getUrnVatIlk();
620	 GemJoinLike(gemJoin).join(urn, _collateralAmt);
621	 ManagerLike(dssCdpManager).frob(cdpId, toInt(convertTo18(gemJoin, _collateralAmt)), _getDrawDart(vat, jug, urn, ilk, _daiAmt));
622	 ManagerLike(dssCdpManager).move(cdpId, address(this), toRad(_daiAmt));
623	 if (VatLike(vat).can(address(this), address(daiJoin)) == 0) {
624	 VatLike(vat).hope(daiJoin);
625	 }
626	 DaiJoinLike(daiJoin).exit(address(this), _daiAmt);
627	 }
628	 function repayAndRedeemCollateral(uint256 _collateralAmt, uint _daiAmt) internal onlyCDPInitiated onlyAboveMinDebt(_daiAmt) {
629	 (address urn, address vat, bytes32 ilk) = getUrnVatIlk();
630	 if (_daiAmt > 0){
631	 DaiJoinLike(daiJoin).join(urn, _daiAmt);
632	 }
633	 uint256 wad18 = _collateralAmt > 0? convertTo18(gemJoin, _collateralAmt) : 0;
634	 ManagerLike(dssCdpManager).frob(cdpId, -toInt(wad18), _getWipeDart(vat, VatLike(vat).dai(urn), urn, ilk));
635	 if (_collateralAmt > 0){
636	 ManagerLike(dssCdpManager).flux(cdpId, address(this), wad18);
637	 GemJoinLike(gemJoin).exit(address(this), _collateralAmt);
638	 }
639	 }
640	 function keepMinRatio() external onlyCDPInUse onlyBenignCallers {
641	 uint256 requiredPaidback = requiredPaidDebt(0);
642	 if (requiredPaidback > 0){
643	 _withdrawDAI(requiredPaidback);
644	 uint256 wad = IERC20(debtToken).balanceOf(address(this));
645	 require(wad >= requiredPaidback, '!keepMinRatioRedeem');
646	 repayAndRedeemCollateral(0, requiredPaidback);
647	 uint256 goodRatio = currentRatio();
648	 require(goodRatio >= minRatio.sub(1), '!stillBelowMinRatio');
649	 }
650	 }
651	 function deposit() public override {
652	 uint256 _want = balanceOfWant();
653	 (,,bool roomForNewMint) = ilkDebts();
654	 if (_want > 0 && roomForNewMint) {
655	 uint256 _newDebt = calculateDebtFor(_want.add(getCollateralBalance()), true);
656	 if(_newDebt > 0 && _newDebt.add(getDebtBalance()) >= minDebt){
657	 addCollateralAndBorrow(_want, _newDebt);
658	 uint256 wad = IERC20(debtToken).balanceOf(address(this));
659	 _depositDAI(_newDebt > wad? wad : _newDebt);
660	 }
661	 }
662	 }
663	 function _withdrawSome(uint256 _amount) internal override returns (uint256) {
664	 bool _full = _amount >= getCollateralBalance();
665	 uint256 requiredPaidback = requiredPaidDebt(_amount);
666	 if (requiredPaidback > 0){
667	 _withdrawDAI(requiredPaidback);
668	 require(IERC20(debtToken).balanceOf(address(this)) >= requiredPaidback, '!mismatchAfterWithdraw');
669	 }
670	 repayAndRedeemCollateral(_amount, requiredPaidback);
671	 if (_full){
672	 _swapDebtToWant(IERC20(debtToken).balanceOf(address(this)));
673	 }
674	 return _amount;
675	 }
676	 }
677	 contract CarefulMath {
678	 enum MathError {
679	 NO_ERROR, DIVISION_BY_ZERO, INTEGER_OVERFLOW, INTEGER_UNDERFLOW }
680	 function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {
681	 if (a == 0) {
682	 return (MathError.NO_ERROR, 0);
683	 }
684	 uint c = a * b;
685	 if (c / a != b) {
686	 return (MathError.INTEGER_OVERFLOW, 0);
687	 }
688	 else {
689	 return (MathError.NO_ERROR, c);
690	 }
691	 }
692	 function addUInt(uint a, uint b) internal pure returns (MathError, uint) {
693	 uint c = a + b;
694	 if (c >= a) {
695	 return (MathError.NO_ERROR, c);
696	 }
697	 else {
698	 return (MathError.INTEGER_OVERFLOW, 0);
699	 }
700	 }
701	 }
702	 contract Exponential is CarefulMath {
703	 uint constant expScale = 1e18;
704	 uint constant doubleScale = 1e36;
705	 uint constant halfExpScale = expScale/2;
706	 uint constant mantissaOne = expScale;
707	 struct Exp {
708	 uint mantissa;
709	 }
710	 struct Double {
711	 uint mantissa;
712	 }
713	 function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {
714	 (MathError err, Exp memory product) = mulScalar(a, scalar);
715	 if (err != MathError.NO_ERROR) {
716	 return (err, 0);
717	 }
718	 return (MathError.NO_ERROR, truncate(product));
719	 }
720	 function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {
721	 (MathError err, Exp memory product) = mulScalar(a, scalar);
722	 if (err != MathError.NO_ERROR) {
723	 return (err, 0);
724	 }
725	 return addUInt(truncate(product), addend);
726	 }
727	 function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {
728	 (MathError err0, uint scaledMantissa) = mulUInt(a.mantissa, scalar);
729	 if (err0 != MathError.NO_ERROR) {
730	 return (err0, Exp({
731	 mantissa: 0}
732	 ));
733	 }
734	 return (MathError.NO_ERROR, Exp({
735	 mantissa: scaledMantissa}
736	 ));
737	 }
738	 function truncate(Exp memory exp) pure internal returns (uint) {
739	 return exp.mantissa / expScale;
740	 }
741	 }
742	 interface IFuseToken {
743	 function mint(uint mintAmount) external returns (uint);
744	 function redeem(uint redeemTokens) external returns (uint);
745	 function redeemUnderlying(uint redeemAmount) external returns (uint);
746	 function exchangeRateCurrent() external returns (uint);
747	 function exchangeRateStored() external view returns (uint);
748	 function supplyRatePerBlock() external view returns (uint);
749	 function balanceOfUnderlying(address account) external returns (uint);
750	 }
751	 interface ICurveFi_3 {
752	 function exchange(int128 from, int128 to, uint256 _from_amount, uint256 _min_to_amount) external;
753	 }
754	 contract StrategyMakerWBTCV2 is StrategyMakerBase, Exponential {
755	 address public wbtc_collateral = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;
756	 address public link_btc_usd = 0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c;
757	 uint256 public wbtc_collateral_decimal = 1e8;
758	 bytes32 public wbtc_ilk = "WBTC-A";
759	 address public wbtc_apt = 0xBF72Da2Bd84c5170618Fbe5914B0ECA9638d5eb5;
760	 uint256 public constant weth_price_decimal = 1;
761	 bool public constant wbtc_price_eth = false;
762	 address public constant curve3crvPool = 0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7;
763	 address public constant usdcToken = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
764	 address public fusePool = 0x989273ec41274C4227bCB878C2c26fdd3afbE70d;
765	 uint256 public fusePoolDecimal = 8;
766	 uint256 public harvestRatio = 9000;
767	 uint256 public slippageSwap = 500;
768	 uint256 public constant DENOMINATOR = 10000;
769	 constructor(address _governance, address _strategist, address _controller, address _timelock) public StrategyMakerBase( wbtc_apt, wbtc_ilk, wbtc_collateral, wbtc_collateral_decimal, link_btc_usd, weth_price_decimal, wbtc_price_eth, wbtc_collateral, _governance, _strategist, _controller, _timelock ) {
770	 IERC20(debtToken).safeApprove(curve3crvPool, uint256(-1));
771	 _setupPoolApprovals();
772	 }
773	 function setSlippageSwap(uint256 _slippage) public onlyBenevolent{
774	 slippageSwap = _slippage;
775	 }
776	 function setHarvestRatio(uint256 _ratio) public onlyBenevolent{
777	 harvestRatio = _ratio;
778	 }
779	 function _setupPoolApprovals() internal {
780	 IERC20(debtToken).safeApprove(fusePool, uint256(-1));
781	 IERC20(fusePool).safeApprove(fusePool, uint256(-1));
782	 }
783	 function migrateFusePool(address _fusePool) public {
784	 require(msg.sender == timelock, '!timelock');
785	 if (IERC20(fusePool).balanceOf(address(this)) > 0){
786	 _withdrawDAI(IFuseToken(fusePool).balanceOfUnderlying(address(this)));
787	 require(IFuseToken(fusePool).balanceOfUnderlying(address(this)) == 0, '!stillGotSomeInFuse');
788	 }
789	 fusePool = _fusePool;
790	 fusePoolDecimal = ERC20(fusePool).decimals();
791	 _setupPoolApprovals();
792	 _depositDAI(IERC20(debtToken).balanceOf(address(this)));
793	 }
794	 function harvest() public override onlyBenevolent {
795	 uint256 _claimable = getHarvestable();
796	 uint256 _wantAmount;
797	 if (_claimable > 0){
798	 _withdrawDAI(_claimable);
799	 _wantAmount = _swapDebtToWant(IERC20(debtToken).balanceOf(address(this)));
800	 }
801	 if (_wantAmount > 0){
802	 uint256 _buybackLpAmount = _wantAmount.mul(performanceFee).div(performanceMax);
803	 if (buybackEnabled == true && _buybackLpAmount > 0){
804	 (, uint256 _wethAmt) = _convertWantToBuyback(_buybackLpAmount);
805	 buybackAndNotify(weth, _wethAmt);
806	 }
807	 uint256 _wantBal = balanceOfWant();
808	 if (_wantBal > 0){
809	 lastHarvestBlock = block.number;
810	 lastHarvestInWant = _wantBal;
811	 deposit();
812	 }
813	 }
814	 }
815	 function _convertWantToBuyback(uint256 _lpAmount) internal override returns (address, uint256){
816	 if (_lpAmount <= 0){
817	 return (weth, 0);
818	 }
819	 address[] memory _swapPath = new address[](2);
820	 _swapPath[0] = want;
821	 _swapPath[1] = weth;
822	 _swapUniswap(want, weth, _lpAmount);
823	 return (weth, IERC20(weth).balanceOf(address(this)));
824	 }
825	 function _swapDebtToWant(uint256 _swapIn) internal override returns(uint256){
826	 uint256 _outMin;
827	 if (_swapIn > 0){
828	 uint256 _debtAmt = IERC20(debtToken).balanceOf(address(this));
829	 uint256 _toSwap = _swapIn > _debtAmt? _debtAmt : _swapIn;
830	 _outMin = wantFromDebt(_toSwap);
831	 ICurveFi_3(curve3crvPool).exchange(0, 1, _toSwap, 0);
832	 }
833	 uint256 _want = balanceOfWant();
834	 uint256 _usdcAmt = IERC20(usdcToken).balanceOf(address(this));
835	 if (_usdcAmt > 0){
836	 address[] memory _swapPath = new address[](3);
837	 _swapPath[0] = usdcToken;
838	 _swapPath[1] = weth;
839	 _swapPath[2] = want;
840	 _swapUniswapWithDetailConfig(usdcToken, want, _usdcAmt, _outMin, _swapPath, sushiRouter);
841	 }
842	 uint256 _wantAfter = balanceOfWant();
843	 return _wantAfter > _want? _wantAfter.sub(_want) : 0;
844	 }
845	 function wantFromDebt(uint256 _toSwappedDebt) public view returns (uint256){
846	 (,int wantPrice,,,) = AggregatorV3Interface(link_btc_usd).latestRoundData();
847	 uint256 _want = _toSwappedDebt.mul(wbtc_collateral_decimal).div(1e18).mul(1e8).div(uint256(wantPrice));
848	 return _want.mul(DENOMINATOR.sub(slippageSwap)).div(DENOMINATOR);
849	 }
850	 function _depositDAI(uint256 _daiAmt) internal override{
851	 uint256 _debt = IERC20(debtToken).balanceOf(address(this));
852	 if (_debt == 0){
853	 return;
854	 }
855	 require(IFuseToken(fusePool).mint(_debt) == 0, '!mintFuse');
856	 }
857	 function _withdrawDAI(uint256 _daiAmt) internal override{
858	 if (_daiAmt == 0){
859	 return;
860	 }
861	 if (_daiAmt >= getDebtBalance()){
862	 require(IFuseToken(fusePool).redeem(IERC20(fusePool).balanceOf(address(this))) == 0, '!redeemAllFromFuse');
863	 }
864	 else {
865	 require(IFuseToken(fusePool).redeemUnderlying(_daiAmt) == 0, '!redeemUnderlyingFromFuse');
866	 }
867	 }
868	 function withdraw(IERC20 _asset) external override returns (uint256 balance) {
869	 require(address(_asset) != fusePool, '!fusePool');
870	 _withdrawNonWantAsset(_asset);
871	 }
872	 function balanceOfDebtToken() public view returns (uint256){
873	 uint exchangeRateStored = IFuseToken(fusePool).exchangeRateStored();
874	 (, uint256 bal) = mulScalarTruncate(Exp({
875	 mantissa: exchangeRateStored}
876	 ), IERC20(fusePool).balanceOf(address(this)));
877	 return bal.add(IERC20(debtToken).balanceOf(address(this)));
878	 }
879	 function getHarvestable() public returns (uint256) {
880	 uint256 _bal = IFuseToken(fusePool).balanceOfUnderlying(address(this));
881	 uint256 _debt = getDebtBalance();
882	 return _bal > _debt? (_bal.sub(_debt)).mul(harvestRatio).div(DENOMINATOR) : 0;
883	 }
884	 function getName() external override pure returns (string memory) {
885	 return "StrategyMakerWBTCV2";
886	 }
887	 }
