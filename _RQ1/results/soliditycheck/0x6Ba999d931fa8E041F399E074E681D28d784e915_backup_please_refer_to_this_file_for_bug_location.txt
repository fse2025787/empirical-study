row number 
1	  pragma abicoder v2;
2	 pragma solidity >=0.6.0 <0.8.0;
3	 abstract contract Context {
4	 function _msgSender() internal view virtual returns (address payable) {
5	 return msg.sender;
6	 }
7	 function _msgData() internal view virtual returns (bytes memory) {
8	 this;
9	 return msg.data;
10	 }
11	 }
12	 pragma solidity >=0.6.0 <0.8.0;
13	 interface IERC20 {
14	 function totalSupply() external view returns (uint256);
15	 function balanceOf(address account) external view returns (uint256);
16	 function transfer(address recipient, uint256 amount) external returns (bool);
17	 function allowance(address owner, address spender) external view returns (uint256);
18	 function approve(address spender, uint256 amount) external returns (bool);
19	 function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
20	 event Transfer(address indexed from, address indexed to, uint256 value);
21	 event Approval(address indexed owner, address indexed spender, uint256 value);
22	 }
23	 pragma solidity >=0.6.0 <0.8.0;
24	 abstract contract Ownable is Context {
25	 address private _owner;
26	 event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
27	 constructor () internal {
28	 address msgSender = _msgSender();
29	 _owner = msgSender;
30	 emit OwnershipTransferred(address(0), msgSender);
31	 }
32	 function owner() public view virtual returns (address) {
33	 return _owner;
34	 }
35	 modifier onlyOwner() {
36	 require(owner() == _msgSender(), "Ownable: caller is not the owner");
37	 _;
38	 }
39	 function renounceOwnership() public virtual onlyOwner {
40	 emit OwnershipTransferred(_owner, address(0));
41	 _owner = address(0);
42	 }
43	 function transferOwnership(address newOwner) public virtual onlyOwner {
44	 require(newOwner != address(0), "Ownable: new owner is the zero address");
45	 emit OwnershipTransferred(_owner, newOwner);
46	 _owner = newOwner;
47	 }
48	 }
49	 pragma solidity >=0.6.0 <0.8.0;
50	 contract ERC20 is Context, IERC20 {
51	 using SafeMath for uint256;
52	 mapping (address => uint256) private _balances;
53	 mapping (address => mapping (address => uint256)) private _allowances;
54	 uint256 private _totalSupply;
55	 string private _name;
56	 string private _symbol;
57	 uint8 private _decimals;
58	 constructor (string memory name_, string memory symbol_) public {
59	 _name = name_;
60	 _symbol = symbol_;
61	 _decimals = 18;
62	 }
63	 function name() public view virtual returns (string memory) {
64	 return _name;
65	 }
66	 function symbol() public view virtual returns (string memory) {
67	 return _symbol;
68	 }
69	 function decimals() public view virtual returns (uint8) {
70	 return _decimals;
71	 }
72	 function totalSupply() public view virtual override returns (uint256) {
73	 return _totalSupply;
74	 }
75	 function balanceOf(address account) public view virtual override returns (uint256) {
76	 return _balances[account];
77	 }
78	 function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
79	 _transfer(_msgSender(), recipient, amount);
80	 return true;
81	 }
82	 function allowance(address owner, address spender) public view virtual override returns (uint256) {
83	 return _allowances[owner][spender];
84	 }
85	 function approve(address spender, uint256 amount) public virtual override returns (bool) {
86	 _approve(_msgSender(), spender, amount);
87	 return true;
88	 }
89	 function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
90	 _transfer(sender, recipient, amount);
91	 _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
92	 return true;
93	 }
94	 function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
95	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
96	 return true;
97	 }
98	 function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
99	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
100	 return true;
101	 }
102	 function _transfer(address sender, address recipient, uint256 amount) internal virtual {
103	 require(sender != address(0), "ERC20: transfer from the zero address");
104	 require(recipient != address(0), "ERC20: transfer to the zero address");
105	 _beforeTokenTransfer(sender, recipient, amount);
106	 _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
107	 _balances[recipient] = _balances[recipient].add(amount);
108	 emit Transfer(sender, recipient, amount);
109	 }
110	 function _mint(address account, uint256 amount) internal virtual {
111	 require(account != address(0), "ERC20: mint to the zero address");
112	 _beforeTokenTransfer(address(0), account, amount);
113	 _totalSupply = _totalSupply.add(amount);
114	 _balances[account] = _balances[account].add(amount);
115	 emit Transfer(address(0), account, amount);
116	 }
117	 function _burn(address account, uint256 amount) internal virtual {
118	 require(account != address(0), "ERC20: burn from the zero address");
119	 _beforeTokenTransfer(account, address(0), amount);
120	 _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
121	 _totalSupply = _totalSupply.sub(amount);
122	 emit Transfer(account, address(0), amount);
123	 }
124	 function _approve(address owner, address spender, uint256 amount) internal virtual {
125	 require(owner != address(0), "ERC20: approve from the zero address");
126	 require(spender != address(0), "ERC20: approve to the zero address");
127	 _allowances[owner][spender] = amount;
128	 emit Approval(owner, spender, amount);
129	 }
130	 function _setupDecimals(uint8 decimals_) internal virtual {
131	 _decimals = decimals_;
132	 }
133	 function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {
134	 }
135	 }
136	 pragma solidity >=0.5.0;
137	 interface IUniswapV3MintCallback {
138	 function uniswapV3MintCallback( uint256 amount0Owed, uint256 amount1Owed, bytes calldata data ) external;
139	 }
140	 pragma solidity >=0.5.0;
141	 interface IUniswapV3SwapCallback {
142	 function uniswapV3SwapCallback( int256 amount0Delta, int256 amount1Delta, bytes calldata data ) external;
143	 }
144	 pragma solidity 0.7.6;
145	 interface IVault {
146	 function deposit( uint256, uint256, address ) external returns (uint256);
147	 function withdraw( uint256, address, address ) external returns (uint256, uint256);
148	 function rebalance( int24 _baseLower, int24 _baseUpper, int24 _limitLower, int24 _limitUpper, address feeRecipient, int256 swapQuantity ) external;
149	 function getTotalAmounts() external view returns (uint256, uint256);
150	 event Deposit( address indexed sender, address indexed to, uint256 shares, uint256 amount0, uint256 amount1 );
151	 event Withdraw( address indexed sender, address indexed to, uint256 shares, uint256 amount0, uint256 amount1 );
152	 event Rebalance( int24 tick, uint256 totalAmount0, uint256 totalAmount1, uint256 feeAmount0, uint256 feeAmount1, uint256 totalSupply );
153	 }
154	 pragma solidity >=0.5.0;
155	 interface IUniswapV3PoolImmutables {
156	 function factory() external view returns (address);
157	 function token0() external view returns (address);
158	 function token1() external view returns (address);
159	 function fee() external view returns (uint24);
160	 function tickSpacing() external view returns (int24);
161	 function maxLiquidityPerTick() external view returns (uint128);
162	 }
163	 pragma solidity >=0.5.0;
164	 interface IUniswapV3PoolState {
165	 function slot0() external view returns ( uint160 sqrtPriceX96, int24 tick, uint16 observationIndex, uint16 observationCardinality, uint16 observationCardinalityNext, uint8 feeProtocol, bool unlocked );
166	 function feeGrowthGlobal0X128() external view returns (uint256);
167	 function feeGrowthGlobal1X128() external view returns (uint256);
168	 function protocolFees() external view returns (uint128 token0, uint128 token1);
169	 function liquidity() external view returns (uint128);
170	 function ticks(int24 tick) external view returns ( uint128 liquidityGross, int128 liquidityNet, uint256 feeGrowthOutside0X128, uint256 feeGrowthOutside1X128, int56 tickCumulativeOutside, uint160 secondsPerLiquidityOutsideX128, uint32 secondsOutside, bool initialized );
171	 function tickBitmap(int16 wordPosition) external view returns (uint256);
172	 function positions(bytes32 key) external view returns ( uint128 _liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, uint128 tokensOwed0, uint128 tokensOwed1 );
173	 function observations(uint256 index) external view returns ( uint32 blockTimestamp, int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128, bool initialized );
174	 }
175	 pragma solidity >=0.5.0;
176	 interface IUniswapV3PoolDerivedState {
177	 function observe(uint32[] calldata secondsAgos) external view returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);
178	 function snapshotCumulativesInside(int24 tickLower, int24 tickUpper) external view returns ( int56 tickCumulativeInside, uint160 secondsPerLiquidityInsideX128, uint32 secondsInside );
179	 }
180	 pragma solidity >=0.5.0;
181	 interface IUniswapV3PoolActions {
182	 function initialize(uint160 sqrtPriceX96) external;
183	 function mint( address recipient, int24 tickLower, int24 tickUpper, uint128 amount, bytes calldata data ) external returns (uint256 amount0, uint256 amount1);
184	 function collect( address recipient, int24 tickLower, int24 tickUpper, uint128 amount0Requested, uint128 amount1Requested ) external returns (uint128 amount0, uint128 amount1);
185	 function burn( int24 tickLower, int24 tickUpper, uint128 amount ) external returns (uint256 amount0, uint256 amount1);
186	 function swap( address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes calldata data ) external returns (int256 amount0, int256 amount1);
187	 function flash( address recipient, uint256 amount0, uint256 amount1, bytes calldata data ) external;
188	 function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;
189	 }
190	 pragma solidity >=0.5.0;
191	 interface IUniswapV3PoolOwnerActions {
192	 function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;
193	 function collectProtocol( address recipient, uint128 amount0Requested, uint128 amount1Requested ) external returns (uint128 amount0, uint128 amount1);
194	 }
195	 pragma solidity >=0.5.0;
196	 interface IUniswapV3PoolEvents {
197	 event Initialize(uint160 sqrtPriceX96, int24 tick);
198	 event Mint( address sender, address indexed owner, int24 indexed tickLower, int24 indexed tickUpper, uint128 amount, uint256 amount0, uint256 amount1 );
199	 event Collect( address indexed owner, address recipient, int24 indexed tickLower, int24 indexed tickUpper, uint128 amount0, uint128 amount1 );
200	 event Burn( address indexed owner, int24 indexed tickLower, int24 indexed tickUpper, uint128 amount, uint256 amount0, uint256 amount1 );
201	 event Swap( address indexed sender, address indexed recipient, int256 amount0, int256 amount1, uint160 sqrtPriceX96, uint128 liquidity, int24 tick );
202	 event Flash( address indexed sender, address indexed recipient, uint256 amount0, uint256 amount1, uint256 paid0, uint256 paid1 );
203	 event IncreaseObservationCardinalityNext( uint16 observationCardinalityNextOld, uint16 observationCardinalityNextNew );
204	 event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);
205	 event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);
206	 }
207	 pragma solidity =0.7.6;
208	 contract HypervisorFactory is Ownable {
209	 IUniswapV3Factory public uniswapV3Factory;
210	 mapping(address => mapping(address => mapping(uint24 => address))) public getHypervisor;
211	 address[] public allHypervisors;
212	 event HypervisorCreated(address token0, address token1, uint24 fee, address hypervisor, uint256);
213	 constructor(address _uniswapV3Factory) {
214	 uniswapV3Factory = IUniswapV3Factory(_uniswapV3Factory);
215	 }
216	 function allHypervisorsLength() external view returns (uint256) {
217	 return allHypervisors.length;
218	 }
219	 function createHypervisor( address tokenA, address tokenB, uint24 fee, int24 _baseLower, int24 _baseUpper, int24 _limitLower, int24 _limitUpper ) external onlyOwner returns (address hypervisor) {
220	 require(tokenA != tokenB, 'SF: IDENTICAL_ADDRESSES');
221	 (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
222	 require(token0 != address(0), 'SF: ZERO_ADDRESS');
223	 require(getHypervisor[token0][token1][fee] == address(0), 'SF: HYPERVISOR_EXISTS');
224	 int24 tickSpacing = uniswapV3Factory.feeAmountTickSpacing(fee);
225	 require(tickSpacing != 0, 'SF: INCORRECT_FEE');
226	 address pool = uniswapV3Factory.getPool(token0, token1, fee);
227	 if (pool == address(0)) {
228	 pool = uniswapV3Factory.createPool(token0, token1, fee);
229	 }
230	 hypervisor = address( new Hypervisor{
231	 salt: keccak256(abi.encodePacked(token0, token1, fee, tickSpacing))}
232	 (pool, owner(), _baseLower, _baseUpper, _limitLower,_limitUpper) );
233	 getHypervisor[token0][token1][fee] = hypervisor;
234	 getHypervisor[token1][token0][fee] = hypervisor;
235	 allHypervisors.push(hypervisor);
236	 emit HypervisorCreated(token0, token1, fee, hypervisor, allHypervisors.length);
237	 }
238	 }
239	 pragma solidity >=0.5.0;
240	 interface IUniswapV3Factory {
241	 event OwnerChanged(address indexed oldOwner, address indexed newOwner);
242	 event PoolCreated( address indexed token0, address indexed token1, uint24 indexed fee, int24 tickSpacing, address pool );
243	 event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);
244	 function owner() external view returns (address);
245	 function feeAmountTickSpacing(uint24 fee) external view returns (int24);
246	 function getPool( address tokenA, address tokenB, uint24 fee ) external view returns (address pool);
247	 function createPool( address tokenA, address tokenB, uint24 fee ) external returns (address pool);
248	 function setOwner(address _owner) external;
249	 function enableFeeAmount(uint24 fee, int24 tickSpacing) external;
250	 }
251	 pragma solidity 0.7.6;
252	 contract Hypervisor is IVault, IUniswapV3MintCallback, IUniswapV3SwapCallback, ERC20 {
253	 using SafeERC20 for IERC20;
254	 using SafeMath for uint256;
255	 using SignedSafeMath for int256;
256	 IUniswapV3Pool public pool;
257	 IERC20 public token0;
258	 IERC20 public token1;
259	 uint24 public fee;
260	 int24 public tickSpacing;
261	 int24 public baseLower;
262	 int24 public baseUpper;
263	 int24 public limitLower;
264	 int24 public limitUpper;
265	 address public owner;
266	 uint256 public deposit0Max;
267	 uint256 public deposit1Max;
268	 uint256 public maxTotalSupply;
269	 mapping(address=>bool) public list;
270	 bool public whitelisted;
271	 constructor( address _pool, address _owner, int24 _baseLower, int24 _baseUpper, int24 _limitLower, int24 _limitUpper ) ERC20("Visor ETH-USDT Uni v3", "vETH-USDTV3-1") {
272	 pool = IUniswapV3Pool(_pool);
273	 token0 = IERC20(pool.token0());
274	 token1 = IERC20(pool.token1());
275	 fee = pool.fee();
276	 tickSpacing = pool.tickSpacing();
277	 owner = _owner;
278	 baseLower = _baseLower;
279	 baseUpper = _baseUpper;
280	 limitLower = _limitLower;
281	 limitUpper = _limitUpper;
282	 maxTotalSupply = 0;
283	 deposit0Max = uint256(-1);
284	 deposit1Max = uint256(-1);
285	 whitelisted = false;
286	 }
287	 function deposit( uint256 deposit0, uint256 deposit1, address to ) external override returns (uint256 shares) {
288	 require(deposit0 > 0 || deposit1 > 0, "deposits must be nonzero");
289	 require(deposit0 < deposit0Max && deposit1 < deposit1Max, "deposits must be less than maximum amounts");
290	 require(to != address(0) && to != address(this), "to");
291	 if(whitelisted) {
292	 require(list[to], "must be on the list");
293	 }
294	 (uint128 baseLiquidity,,) = _position(baseLower, baseUpper);
295	 if (baseLiquidity > 0) {
296	 pool.burn(baseLower, baseUpper, 0);
297	 }
298	 (uint128 limitLiquidity,,) = _position(limitLower, limitUpper);
299	 if (limitLiquidity > 0) {
300	 pool.burn(limitLower, limitUpper, 0);
301	 }
302	 uint160 sqrtPrice = TickMath.getSqrtRatioAtTick(currentTick());
303	 uint256 price = FullMath.mulDiv(uint256(sqrtPrice).mul(uint256(sqrtPrice)), 1e18, 2**(96 * 2));
304	 (uint256 pool0, uint256 pool1) = getTotalAmounts();
305	 uint256 deposit0PricedInToken1 = deposit0.mul(price).div(1e18);
306	 shares = deposit1.add(deposit0PricedInToken1);
307	 if (deposit0 > 0) {
308	 token0.safeTransferFrom(msg.sender, address(this), deposit0);
309	 }
310	 if (deposit1 > 0) {
311	 token1.safeTransferFrom(msg.sender, address(this), deposit1);
312	 }
313	 if (totalSupply() != 0) {
314	 uint256 pool0PricedInToken1 = pool0.mul(price).div(1e18);
315	 shares = shares.mul(totalSupply()).div(pool0PricedInToken1.add(pool1));
316	 }
317	 _mint(to, shares);
318	 emit Deposit(msg.sender, to, shares, deposit0, deposit1);
319	 require(maxTotalSupply == 0 || totalSupply() <= maxTotalSupply, "maxTotalSupply");
320	 }
321	 function withdraw( uint256 shares, address to, address from ) external override returns (uint256 amount0, uint256 amount1) {
322	 require(shares > 0, "shares");
323	 require(to != address(0), "to");
324	 (uint256 base0, uint256 base1) = _burnLiquidity(baseLower, baseUpper, _liquidityForShares(baseLower, baseUpper, shares), to, false);
325	 (uint256 limit0, uint256 limit1) = _burnLiquidity(limitLower, limitUpper, _liquidityForShares(limitLower, limitUpper, shares), to, false);
326	 uint256 totalSupply = totalSupply();
327	 uint256 unusedAmount0 = token0.balanceOf(address(this)).mul(shares).div(totalSupply);
328	 uint256 unusedAmount1 = token1.balanceOf(address(this)).mul(shares).div(totalSupply);
329	 if (unusedAmount0 > 0) token0.safeTransfer(to, unusedAmount0);
330	 if (unusedAmount1 > 0) token1.safeTransfer(to, unusedAmount1);
331	 amount0 = base0.add(limit0).add(unusedAmount0);
332	 amount1 = base1.add(limit1).add(unusedAmount1);
333	 require(from == msg.sender || IUniversalVault(from).owner() == msg.sender, "Sender must own the tokens");
334	 _burn(from, shares);
335	 emit Withdraw(from, to, shares, amount0, amount1);
336	 }
337	 function rebalance( int24 _baseLower, int24 _baseUpper, int24 _limitLower, int24 _limitUpper, address feeRecipient, int256 swapQuantity ) external override onlyOwner {
338	 require(_baseLower < _baseUpper && _baseLower % tickSpacing == 0 && _baseUpper % tickSpacing == 0, "base position invalid");
339	 require(_limitLower < _limitUpper && _limitLower % tickSpacing == 0 && _limitUpper % tickSpacing == 0, "limit position invalid");
340	 (uint128 baseLiquidity,,) = _position(baseLower, baseUpper);
341	 if (baseLiquidity > 0) {
342	 pool.burn(baseLower, baseUpper, 0);
343	 }
344	 (uint128 limitLiquidity,,) = _position(limitLower, limitUpper);
345	 if (limitLiquidity > 0) {
346	 pool.burn(limitLower, limitUpper, 0);
347	 }
348	 (, uint256 feesLimit0, uint256 feesLimit1) = _position(baseLower, baseUpper);
349	 (, uint256 feesBase0, uint256 feesBase1) = _position(limitLower, limitUpper);
350	 uint256 fees0 = feesBase0.add(feesLimit0);
351	 uint256 fees1 = feesBase1.add(feesLimit1);
352	 _burnLiquidity(baseLower, baseUpper, baseLiquidity, address(this), true);
353	 _burnLiquidity(limitLower, limitUpper, limitLiquidity, address(this), true);
354	 if(fees0 > 0) token0.safeTransfer(feeRecipient, fees0.div(10));
355	 if(fees1 > 0) token1.safeTransfer(feeRecipient, fees1.div(10));
356	 emit Rebalance( currentTick(), token0.balanceOf(address(this)), token1.balanceOf(address(this)), fees0, fees1, totalSupply() );
357	 if (swapQuantity != 0) {
358	 pool.swap( address(this), swapQuantity > 0, swapQuantity > 0 ? swapQuantity : -swapQuantity, swapQuantity > 0 ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1, abi.encode(address(this)) );
359	 }
360	 baseLower = _baseLower;
361	 baseUpper = _baseUpper;
362	 baseLiquidity = _liquidityForAmounts( baseLower, baseUpper, token0.balanceOf(address(this)), token1.balanceOf(address(this)) );
363	 _mintLiquidity(baseLower, baseUpper, baseLiquidity, address(this));
364	 limitLower = _limitLower;
365	 limitUpper = _limitUpper;
366	 limitLiquidity = _liquidityForAmounts( limitLower, limitUpper, token0.balanceOf(address(this)), token1.balanceOf(address(this)) );
367	 _mintLiquidity(limitLower, limitUpper, limitLiquidity, address(this));
368	 }
369	 function _mintLiquidity( int24 tickLower, int24 tickUpper, uint128 liquidity, address payer ) internal returns (uint256 amount0, uint256 amount1) {
370	 if (liquidity > 0) {
371	 (amount0, amount1) = pool.mint( address(this), tickLower, tickUpper, liquidity, abi.encode(payer) );
372	 }
373	 }
374	 function _burnLiquidity( int24 tickLower, int24 tickUpper, uint128 liquidity, address to, bool collectAll ) internal returns (uint256 amount0, uint256 amount1) {
375	 if (liquidity > 0) {
376	 (uint256 owed0, uint256 owed1) = pool.burn(tickLower, tickUpper, liquidity);
377	 uint128 collect0 = collectAll ? type(uint128).max : _uint128Safe(owed0);
378	 uint128 collect1 = collectAll ? type(uint128).max : _uint128Safe(owed1);
379	 if (collect0 > 0 || collect1 > 0) {
380	 (amount0, amount1) = pool.collect(to, tickLower, tickUpper, collect0, collect1);
381	 }
382	 }
383	 }
384	 function _liquidityForShares( int24 tickLower, int24 tickUpper, uint256 shares ) internal view returns (uint128) {
385	 (uint128 position,,) = _position(tickLower, tickUpper);
386	 return _uint128Safe(uint256(position).mul(shares).div(totalSupply()));
387	 }
388	 function _position(int24 tickLower, int24 tickUpper) internal view returns (uint128 liquidity, uint128 tokensOwed0, uint128 tokensOwed1) {
389	 bytes32 positionKey = keccak256(abi.encodePacked(address(this), tickLower, tickUpper));
390	 (liquidity, , , tokensOwed0, tokensOwed1) = pool.positions(positionKey);
391	 }
392	 function uniswapV3MintCallback( uint256 amount0, uint256 amount1, bytes calldata data ) external override {
393	 require(msg.sender == address(pool));
394	 address payer = abi.decode(data, (address));
395	 if (payer == address(this)) {
396	 if (amount0 > 0) token0.safeTransfer(msg.sender, amount0);
397	 if (amount1 > 0) token1.safeTransfer(msg.sender, amount1);
398	 }
399	 else {
400	 if (amount0 > 0) token0.safeTransferFrom(payer, msg.sender, amount0);
401	 if (amount1 > 0) token1.safeTransferFrom(payer, msg.sender, amount1);
402	 }
403	 }
404	 function uniswapV3SwapCallback( int256 amount0Delta, int256 amount1Delta, bytes calldata data ) external override {
405	 require(msg.sender == address(pool));
406	 address payer = abi.decode(data, (address));
407	 if (amount0Delta > 0) {
408	 if (payer == address(this)) {
409	 token0.safeTransfer(msg.sender, uint256(amount0Delta));
410	 }
411	 else {
412	 token0.safeTransferFrom(payer, msg.sender, uint256(amount0Delta));
413	 }
414	 }
415	 else if (amount1Delta > 0) {
416	 if (payer == address(this)) {
417	 token1.safeTransfer(msg.sender, uint256(amount1Delta));
418	 }
419	 else {
420	 token1.safeTransferFrom(payer, msg.sender, uint256(amount1Delta));
421	 }
422	 }
423	 }
424	 function getTotalAmounts() public view override returns (uint256 total0, uint256 total1) {
425	 (, uint256 base0, uint256 base1) = getBasePosition();
426	 (, uint256 limit0, uint256 limit1) = getLimitPosition();
427	 total0 = token0.balanceOf(address(this)).add(base0).add(limit0);
428	 total1 = token1.balanceOf(address(this)).add(base1).add(limit1);
429	 }
430	 function getBasePosition() public view returns ( uint128 liquidity, uint256 amount0, uint256 amount1 ) {
431	 (uint128 positionLiquidity, uint128 tokensOwed0, uint128 tokensOwed1) = _position(baseLower, baseUpper);
432	 (amount0, amount1) = _amountsForLiquidity(baseLower, baseUpper, positionLiquidity);
433	 amount0 = amount0.add(uint256(tokensOwed0));
434	 amount1 = amount1.add(uint256(tokensOwed1));
435	 liquidity = positionLiquidity;
436	 }
437	 function getLimitPosition() public view returns ( uint128 liquidity, uint256 amount0, uint256 amount1 ) {
438	 (uint128 positionLiquidity, uint128 tokensOwed0, uint128 tokensOwed1) = _position(limitLower, limitUpper);
439	 (amount0, amount1) = _amountsForLiquidity(limitLower, limitUpper, positionLiquidity);
440	 amount0 = amount0.add(uint256(tokensOwed0));
441	 amount1 = amount1.add(uint256(tokensOwed1));
442	 liquidity = positionLiquidity;
443	 }
444	 function _amountsForLiquidity( int24 tickLower, int24 tickUpper, uint128 liquidity ) internal view returns (uint256, uint256) {
445	 (uint160 sqrtRatioX96, , , , , , ) = pool.slot0();
446	 return LiquidityAmounts.getAmountsForLiquidity( sqrtRatioX96, TickMath.getSqrtRatioAtTick(tickLower), TickMath.getSqrtRatioAtTick(tickUpper), liquidity );
447	 }
448	 function _liquidityForAmounts( int24 tickLower, int24 tickUpper, uint256 amount0, uint256 amount1 ) internal view returns (uint128) {
449	 (uint160 sqrtRatioX96, , , , , , ) = pool.slot0();
450	 return LiquidityAmounts.getLiquidityForAmounts( sqrtRatioX96, TickMath.getSqrtRatioAtTick(tickLower), TickMath.getSqrtRatioAtTick(tickUpper), amount0, amount1 );
451	 }
452	 function currentTick() public view returns (int24 tick) {
453	 (, tick, , , , , ) = pool.slot0();
454	 }
455	 function _uint128Safe(uint256 x) internal pure returns (uint128) {
456	 assert(x <= type(uint128).max);
457	 return uint128(x);
458	 }
459	 function setMaxTotalSupply(uint256 _maxTotalSupply) external onlyOwner {
460	 maxTotalSupply = _maxTotalSupply;
461	 }
462	 function setDepositMax(uint256 _deposit0Max, uint256 _deposit1Max) external onlyOwner {
463	 deposit0Max = _deposit0Max;
464	 deposit1Max = _deposit1Max;
465	 }
466	 function emergencyWithdraw(IERC20 token, uint256 amount) external onlyOwner {
467	 token.safeTransfer(msg.sender, amount);
468	 }
469	 function emergencyBurn( int24 tickLower, int24 tickUpper, uint128 liquidity ) external onlyOwner {
470	 pool.burn(tickLower, tickUpper, liquidity);
471	 pool.collect(msg.sender, tickLower, tickUpper, type(uint128).max, type(uint128).max);
472	 }
473	 function appendList(address[] memory listed) external onlyOwner {
474	 for (uint8 i; i < listed.length; i++) {
475	 list[listed[i]] = true;
476	 }
477	 }
478	 function toggleWhitelist() external onlyOwner {
479	 whitelisted = whitelisted ? false : true;
480	 }
481	 function transferOwnership(address newOwner) external onlyOwner {
482	 owner = newOwner;
483	 }
484	 modifier onlyOwner {
485	 require(msg.sender == owner, "only owner");
486	 _;
487	 }
488	 }
489	 pragma solidity >=0.6.0 <0.8.0;
490	 library SafeMath {
491	 function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
492	 uint256 c = a + b;
493	 if (c < a) return (false, 0);
494	 return (true, c);
495	 }
496	 function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
497	 if (b > a) return (false, 0);
498	 return (true, a - b);
499	 }
500	 function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
501	 if (a == 0) return (true, 0);
502	 uint256 c = a * b;
503	 if (c / a != b) return (false, 0);
504	 return (true, c);
505	 }
506	 function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
507	 if (b == 0) return (false, 0);
508	 return (true, a / b);
509	 }
510	 function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
511	 if (b == 0) return (false, 0);
512	 return (true, a % b);
513	 }
514	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
515	 uint256 c = a + b;
516	 require(c >= a, "SafeMath: addition overflow");
517	 return c;
518	 }
519	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
520	 require(b <= a, "SafeMath: subtraction overflow");
521	 return a - b;
522	 }
523	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
524	 if (a == 0) return 0;
525	 uint256 c = a * b;
526	 require(c / a == b, "SafeMath: multiplication overflow");
527	 return c;
528	 }
529	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
530	 require(b > 0, "SafeMath: division by zero");
531	 return a / b;
532	 }
533	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
534	 require(b > 0, "SafeMath: modulo by zero");
535	 return a % b;
536	 }
537	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
538	 require(b <= a, errorMessage);
539	 return a - b;
540	 }
541	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
542	 require(b > 0, errorMessage);
543	 return a / b;
544	 }
545	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
546	 require(b > 0, errorMessage);
547	 return a % b;
548	 }
549	 }
550	 pragma solidity >=0.6.0 <0.8.0;
551	 library SignedSafeMath {
552	 int256 constant private _INT256_MIN = -2**255;
553	 function mul(int256 a, int256 b) internal pure returns (int256) {
554	 if (a == 0) {
555	 return 0;
556	 }
557	 require(!(a == -1 && b == _INT256_MIN), "SignedSafeMath: multiplication overflow");
558	 int256 c = a * b;
559	 require(c / a == b, "SignedSafeMath: multiplication overflow");
560	 return c;
561	 }
562	 function div(int256 a, int256 b) internal pure returns (int256) {
563	 require(b != 0, "SignedSafeMath: division by zero");
564	 require(!(b == -1 && a == _INT256_MIN), "SignedSafeMath: division overflow");
565	 int256 c = a / b;
566	 return c;
567	 }
568	 function sub(int256 a, int256 b) internal pure returns (int256) {
569	 int256 c = a - b;
570	 require((b >= 0 && c <= a) || (b < 0 && c > a), "SignedSafeMath: subtraction overflow");
571	 return c;
572	 }
573	 function add(int256 a, int256 b) internal pure returns (int256) {
574	 int256 c = a + b;
575	 require((b >= 0 && c >= a) || (b < 0 && c < a), "SignedSafeMath: addition overflow");
576	 return c;
577	 }
578	 }
579	 pragma solidity >=0.6.0 <0.8.0;
580	 library SafeERC20 {
581	 using SafeMath for uint256;
582	 using Address for address;
583	 function safeTransfer(IERC20 token, address to, uint256 value) internal {
584	 _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
585	 }
586	 function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
587	 _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
588	 }
589	 function safeApprove(IERC20 token, address spender, uint256 value) internal {
590	 require((value == 0) || (token.allowance(address(this), spender) == 0), "SafeERC20: approve from non-zero to non-zero allowance" );
591	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
592	 }
593	 function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
594	 uint256 newAllowance = token.allowance(address(this), spender).add(value);
595	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
596	 }
597	 function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
598	 uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
599	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
600	 }
601	 function _callOptionalReturn(IERC20 token, bytes memory data) private {
602	 bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
603	 if (returndata.length > 0) {
604	 require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
605	 }
606	 }
607	 }
608	 pragma solidity >=0.5.0;
609	 interface IUniswapV3Pool is IUniswapV3PoolImmutables, IUniswapV3PoolState, IUniswapV3PoolDerivedState, IUniswapV3PoolActions, IUniswapV3PoolOwnerActions, IUniswapV3PoolEvents {
610	 }
611	 pragma solidity >=0.5.0;
612	 library TickMath {
613	 int24 internal constant MIN_TICK = -887272;
614	 int24 internal constant MAX_TICK = -MIN_TICK;
615	 uint160 internal constant MIN_SQRT_RATIO = 4295128739;
616	 uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;
617	 function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {
618	 uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));
619	 require(absTick <= uint256(MAX_TICK), 'T');
620	 uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;
621	 if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;
622	 if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;
623	 if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;
624	 if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;
625	 if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;
626	 if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;
627	 if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;
628	 if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;
629	 if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;
630	 if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;
631	 if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;
632	 if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;
633	 if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;
634	 if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;
635	 if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;
636	 if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;
637	 if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;
638	 if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;
639	 if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;
640	 if (tick > 0) ratio = type(uint256).max / ratio;
641	 sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));
642	 }
643	 function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {
644	 require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');
645	 uint256 ratio = uint256(sqrtPriceX96) << 32;
646	 uint256 r = ratio;
647	 uint256 msb = 0;
648	 assembly {
649	 let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) msb := or(msb, f) r := shr(f, r) }
650	 assembly {
651	 let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF)) msb := or(msb, f) r := shr(f, r) }
652	 assembly {
653	 let f := shl(5, gt(r, 0xFFFFFFFF)) msb := or(msb, f) r := shr(f, r) }
654	 assembly {
655	 let f := shl(4, gt(r, 0xFFFF)) msb := or(msb, f) r := shr(f, r) }
656	 assembly {
657	 let f := shl(3, gt(r, 0xFF)) msb := or(msb, f) r := shr(f, r) }
658	 assembly {
659	 let f := shl(2, gt(r, 0xF)) msb := or(msb, f) r := shr(f, r) }
660	 assembly {
661	 let f := shl(1, gt(r, 0x3)) msb := or(msb, f) r := shr(f, r) }
662	 assembly {
663	 let f := gt(r, 0x1) msb := or(msb, f) }
664	 if (msb >= 128) r = ratio >> (msb - 127);
665	 else r = ratio << (127 - msb);
666	 int256 log_2 = (int256(msb) - 128) << 64;
667	 assembly {
668	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(63, f)) r := shr(f, r) }
669	 assembly {
670	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(62, f)) r := shr(f, r) }
671	 assembly {
672	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(61, f)) r := shr(f, r) }
673	 assembly {
674	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(60, f)) r := shr(f, r) }
675	 assembly {
676	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(59, f)) r := shr(f, r) }
677	 assembly {
678	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(58, f)) r := shr(f, r) }
679	 assembly {
680	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(57, f)) r := shr(f, r) }
681	 assembly {
682	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(56, f)) r := shr(f, r) }
683	 assembly {
684	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(55, f)) r := shr(f, r) }
685	 assembly {
686	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(54, f)) r := shr(f, r) }
687	 assembly {
688	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(53, f)) r := shr(f, r) }
689	 assembly {
690	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(52, f)) r := shr(f, r) }
691	 assembly {
692	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(51, f)) r := shr(f, r) }
693	 assembly {
694	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(50, f)) }
695	 int256 log_sqrt10001 = log_2 * 255738958999603826347141;
696	 int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);
697	 int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);
698	 tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;
699	 }
700	 }
701	 pragma solidity >=0.4.0;
702	 library FullMath {
703	 function mulDiv( uint256 a, uint256 b, uint256 denominator ) internal pure returns (uint256 result) {
704	 uint256 prod0;
705	 uint256 prod1;
706	 assembly {
707	 let mm := mulmod(a, b, not(0)) prod0 := mul(a, b) prod1 := sub(sub(mm, prod0), lt(mm, prod0)) }
708	 if (prod1 == 0) {
709	 require(denominator > 0);
710	 assembly {
711	 result := div(prod0, denominator) }
712	 return result;
713	 }
714	 require(denominator > prod1);
715	 uint256 remainder;
716	 assembly {
717	 remainder := mulmod(a, b, denominator) }
718	 assembly {
719	 prod1 := sub(prod1, gt(remainder, prod0)) prod0 := sub(prod0, remainder) }
720	 uint256 twos = -denominator & denominator;
721	 assembly {
722	 denominator := div(denominator, twos) }
723	 assembly {
724	 prod0 := div(prod0, twos) }
725	 assembly {
726	 twos := add(div(sub(0, twos), twos), 1) }
727	 prod0 |= prod1 * twos;
728	 uint256 inv = (3 * denominator) ^ 2;
729	 inv *= 2 - denominator * inv;
730	 inv *= 2 - denominator * inv;
731	 inv *= 2 - denominator * inv;
732	 inv *= 2 - denominator * inv;
733	 inv *= 2 - denominator * inv;
734	 inv *= 2 - denominator * inv;
735	 result = prod0 * inv;
736	 return result;
737	 }
738	 function mulDivRoundingUp( uint256 a, uint256 b, uint256 denominator ) internal pure returns (uint256 result) {
739	 result = mulDiv(a, b, denominator);
740	 if (mulmod(a, b, denominator) > 0) {
741	 require(result < type(uint256).max);
742	 result++;
743	 }
744	 }
745	 }
746	 pragma solidity >=0.5.0;
747	 library LiquidityAmounts {
748	 function toUint128(uint256 x) private pure returns (uint128 y) {
749	 require((y = uint128(x)) == x);
750	 }
751	 function getLiquidityForAmount0( uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint256 amount0 ) internal pure returns (uint128 liquidity) {
752	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
753	 uint256 intermediate = FullMath.mulDiv(sqrtRatioAX96, sqrtRatioBX96, FixedPoint96.Q96);
754	 return toUint128(FullMath.mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));
755	 }
756	 function getLiquidityForAmount1( uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint256 amount1 ) internal pure returns (uint128 liquidity) {
757	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
758	 return toUint128(FullMath.mulDiv(amount1, FixedPoint96.Q96, sqrtRatioBX96 - sqrtRatioAX96));
759	 }
760	 function getLiquidityForAmounts( uint160 sqrtRatioX96, uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint256 amount0, uint256 amount1 ) internal pure returns (uint128 liquidity) {
761	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
762	 if (sqrtRatioX96 <= sqrtRatioAX96) {
763	 liquidity = getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);
764	 }
765	 else if (sqrtRatioX96 < sqrtRatioBX96) {
766	 uint128 liquidity0 = getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);
767	 uint128 liquidity1 = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);
768	 liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;
769	 }
770	 else {
771	 liquidity = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);
772	 }
773	 }
774	 function getAmount0ForLiquidity( uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity ) internal pure returns (uint256 amount0) {
775	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
776	 return FullMath.mulDiv( uint256(liquidity) << FixedPoint96.RESOLUTION, sqrtRatioBX96 - sqrtRatioAX96, sqrtRatioBX96 ) / sqrtRatioAX96;
777	 }
778	 function getAmount1ForLiquidity( uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity ) internal pure returns (uint256 amount1) {
779	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
780	 return FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);
781	 }
782	 function getAmountsForLiquidity( uint160 sqrtRatioX96, uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity ) internal pure returns (uint256 amount0, uint256 amount1) {
783	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
784	 if (sqrtRatioX96 <= sqrtRatioAX96) {
785	 amount0 = getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);
786	 }
787	 else if (sqrtRatioX96 < sqrtRatioBX96) {
788	 amount0 = getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);
789	 amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);
790	 }
791	 else {
792	 amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);
793	 }
794	 }
795	 }
796	 pragma solidity 0.7.6;
797	 interface IUniversalVault {
798	 event Locked(address delegate, address token, uint256 amount);
799	 event Unlocked(address delegate, address token, uint256 amount);
800	 event RageQuit(address delegate, address token, bool notified, string reason);
801	 struct LockData {
802	 address delegate;
803	 address token;
804	 uint256 balance;
805	 }
806	 function initialize() external;
807	 function lock( address token, uint256 amount, bytes calldata permission ) external;
808	 function unlock( address token, uint256 amount, bytes calldata permission ) external;
809	 function rageQuit(address delegate, address token) external returns (bool notified, string memory error);
810	 function transferERC20( address token, address to, uint256 amount ) external;
811	 function transferETH(address to, uint256 amount) external payable;
812	 function calculateLockID(address delegate, address token) external pure returns (bytes32 lockID);
813	 function getPermissionHash( bytes32 eip712TypeHash, address delegate, address token, uint256 amount, uint256 nonce ) external view returns (bytes32 permissionHash);
814	 function getNonce() external view returns (uint256 nonce);
815	 function owner() external view returns (address ownerAddress);
816	 function getLockSetCount() external view returns (uint256 count);
817	 function getLockAt(uint256 index) external view returns (LockData memory lockData);
818	 function getBalanceDelegated(address token, address delegate) external view returns (uint256 balance);
819	 function getBalanceLocked(address token) external view returns (uint256 balance);
820	 function checkBalances() external view returns (bool validity);
821	 }
822	 pragma solidity >=0.6.2 <0.8.0;
823	 library Address {
824	 function isContract(address account) internal view returns (bool) {
825	 uint256 size;
826	 assembly {
827	 size := extcodesize(account) }
828	 return size > 0;
829	 }
830	 function sendValue(address payable recipient, uint256 amount) internal {
831	 require(address(this).balance >= amount, "Address: insufficient balance");
832	 (bool success, ) = recipient.call{
833	 value: amount }
834	 ("");
835	 require(success, "Address: unable to send value, recipient may have reverted");
836	 }
837	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
838	 return functionCall(target, data, "Address: low-level call failed");
839	 }
840	 function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
841	 return functionCallWithValue(target, data, 0, errorMessage);
842	 }
843	 function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
844	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
845	 }
846	 function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
847	 require(address(this).balance >= value, "Address: insufficient balance for call");
848	 require(isContract(target), "Address: call to non-contract");
849	 (bool success, bytes memory returndata) = target.call{
850	 value: value }
851	 (data);
852	 return _verifyCallResult(success, returndata, errorMessage);
853	 }
854	 function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
855	 return functionStaticCall(target, data, "Address: low-level static call failed");
856	 }
857	 function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
858	 require(isContract(target), "Address: static call to non-contract");
859	 (bool success, bytes memory returndata) = target.staticcall(data);
860	 return _verifyCallResult(success, returndata, errorMessage);
861	 }
862	 function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
863	 return functionDelegateCall(target, data, "Address: low-level delegate call failed");
864	 }
865	 function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
866	 require(isContract(target), "Address: delegate call to non-contract");
867	 (bool success, bytes memory returndata) = target.delegatecall(data);
868	 return _verifyCallResult(success, returndata, errorMessage);
869	 }
870	 function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
871	 if (success) {
872	 return returndata;
873	 }
874	 else {
875	 if (returndata.length > 0) {
876	 assembly {
877	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
878	 }
879	 else {
880	 revert(errorMessage);
881	 }
882	 }
883	 }
884	 }
885	 pragma solidity >=0.4.0;
886	 library FixedPoint96 {
887	 uint8 internal constant RESOLUTION = 96;
888	 uint256 internal constant Q96 = 0x1000000000000000000000000;
889	 }
