row number 
1	  pragma experimental ABIEncoderV2;
2	 pragma solidity 0.6.12;
3	 library Address {
4	 function isContract(address account) internal view returns (bool) {
5	 bytes32 codehash;
6	 bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
7	 assembly {
8	 codehash := extcodehash(account) }
9	 return (codehash != accountHash && codehash != 0x0);
10	 }
11	 function sendValue(address payable recipient, uint256 amount) internal {
12	 require(address(this).balance >= amount, "Address: insufficient balance");
13	 (bool success, ) = recipient.call{
14	 value: amount }
15	 ("");
16	 require(success, "Address: unable to send value, recipient may have reverted");
17	 }
18	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
19	 return functionCall(target, data, "Address: low-level call failed");
20	 }
21	 function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
22	 return _functionCallWithValue(target, data, 0, errorMessage);
23	 }
24	 function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
25	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
26	 }
27	 function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
28	 require(address(this).balance >= value, "Address: insufficient balance for call");
29	 return _functionCallWithValue(target, data, value, errorMessage);
30	 }
31	 function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {
32	 require(isContract(target), "Address: call to non-contract");
33	 (bool success, bytes memory returndata) = target.call{
34	 value: weiValue }
35	 (data);
36	 if (success) {
37	 return returndata;
38	 }
39	 else {
40	 if (returndata.length > 0) {
41	 assembly {
42	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
43	 }
44	 else {
45	 revert(errorMessage);
46	 }
47	 }
48	 }
49	 }
50	 interface IBaseFee {
51	 function isCurrentBaseFeeAcceptable() external view returns (bool);
52	 }
53	 interface IERC20 {
54	 function totalSupply() external view returns (uint256);
55	 function balanceOf(address account) external view returns (uint256);
56	 function transfer(address recipient, uint256 amount) external returns (bool);
57	 function allowance(address owner, address spender) external view returns (uint256);
58	 function approve(address spender, uint256 amount) external returns (bool);
59	 function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
60	 event Transfer(address indexed from, address indexed to, uint256 value);
61	 event Approval(address indexed owner, address indexed spender, uint256 value);
62	 }
63	 interface GemLike {
64	 function approve(address, uint256) external;
65	 function transfer(address, uint256) external;
66	 function transferFrom( address, address, uint256 ) external;
67	 function deposit() external payable;
68	 function withdraw(uint256) external;
69	 }
70	 interface DaiJoinLike {
71	 function vat() external returns (VatLike);
72	 function dai() external returns (GemLike);
73	 function join(address, uint256) external payable;
74	 function exit(address, uint256) external;
75	 }
76	 interface VatLike {
77	 function can(address, address) external view returns (uint256);
78	 function ilks(bytes32) external view returns ( uint256, uint256, uint256, uint256, uint256 );
79	 function dai(address) external view returns (uint256);
80	 function urns(bytes32, address) external view returns (uint256, uint256);
81	 function frob( bytes32, address, address, address, int256, int256 ) external;
82	 function hope(address) external;
83	 function move( address, address, uint256 ) external;
84	 }
85	 interface GemJoinLike {
86	 function dec() external returns (uint256);
87	 function gem() external returns (GemLike);
88	 function join(address, uint256) external payable;
89	 function exit(address, uint256) external;
90	 }
91	 interface JugLike {
92	 function drip(bytes32) external returns (uint256);
93	 }
94	 interface OasisLike {
95	 function sellAllAmount( address pay_gem, uint256 pay_amt, address buy_gem, uint256 min_fill_amount ) external returns (uint256);
96	 }
97	 interface ManagerLike {
98	 function cdpCan( address, uint256, address ) external view returns (uint256);
99	 function ilks(uint256) external view returns (bytes32);
100	 function owns(uint256) external view returns (address);
101	 function urns(uint256) external view returns (address);
102	 function vat() external view returns (address);
103	 function open(bytes32, address) external returns (uint256);
104	 function give(uint256, address) external;
105	 function cdpAllow( uint256, address, uint256 ) external;
106	 function urnAllow(address, uint256) external;
107	 function frob( uint256, int256, int256 ) external;
108	 function flux( uint256, address, uint256 ) external;
109	 function move( uint256, address, uint256 ) external;
110	 function exit( address, uint256, address, uint256 ) external;
111	 function quit(uint256, address) external;
112	 function enter(address, uint256) external;
113	 function shift(uint256, uint256) external;
114	 }
115	 interface SpotLike {
116	 function live() external view returns (uint256);
117	 function par() external view returns (uint256);
118	 function vat() external view returns (address);
119	 function ilks(bytes32) external view returns (address, uint256);
120	 }
121	 interface DssAutoLine {
122	 function exec(bytes32 _ilk) external returns (uint256);
123	 }
124	 interface OracleSecurityModule {
125	 function peek() external view returns (uint256, bool);
126	 function peep() external view returns (uint256, bool);
127	 function users(address) external view returns (bool);
128	 function bud(address) external view returns (bool);
129	 function oracle() external view returns (address);
130	 }
131	 interface IOSMedianizer {
132	 function foresight() external view returns (uint256 price, bool osm);
133	 function read() external view returns (uint256 price, bool osm);
134	 function setAuthorized(address _authorized) external;
135	 }
136	 interface IUniswapV2Pair {
137	 event Approval(address indexed owner, address indexed spender, uint value);
138	 event Transfer(address indexed from, address indexed to, uint value);
139	 function name() external pure returns (string memory);
140	 function symbol() external pure returns (string memory);
141	 function decimals() external pure returns (uint8);
142	 function totalSupply() external view returns (uint);
143	 function balanceOf(address owner) external view returns (uint);
144	 function allowance(address owner, address spender) external view returns (uint);
145	 function approve(address spender, uint value) external returns (bool);
146	 function transfer(address to, uint value) external returns (bool);
147	 function transferFrom(address from, address to, uint value) external returns (bool);
148	 function DOMAIN_SEPARATOR() external view returns (bytes32);
149	 function PERMIT_TYPEHASH() external pure returns (bytes32);
150	 function nonces(address owner) external view returns (uint);
151	 function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;
152	 event Mint(address indexed sender, uint amount0, uint amount1);
153	 event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
154	 event Swap( address indexed sender, uint amount0In, uint amount1In, uint amount0Out, uint amount1Out, address indexed to );
155	 event Sync(uint112 reserve0, uint112 reserve1);
156	 function MINIMUM_LIQUIDITY() external pure returns (uint);
157	 function factory() external view returns (address);
158	 function token0() external view returns (address);
159	 function token1() external view returns (address);
160	 function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
161	 function price0CumulativeLast() external view returns (uint);
162	 function price1CumulativeLast() external view returns (uint);
163	 function kLast() external view returns (uint);
164	 function mint(address to) external returns (uint liquidity);
165	 function burn(address to) external returns (uint amount0, uint amount1);
166	 function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
167	 function skim(address to) external;
168	 function sync() external;
169	 function initialize(address, address) external;
170	 }
171	 interface IUniswapV2Router01 {
172	 function factory() external pure returns (address);
173	 function WETH() external pure returns (address);
174	 function addLiquidity( address tokenA, address tokenB, uint256 amountADesired, uint256 amountBDesired, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline ) external returns ( uint256 amountA, uint256 amountB, uint256 liquidity );
175	 function addLiquidityETH( address token, uint256 amountTokenDesired, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline ) external payable returns ( uint256 amountToken, uint256 amountETH, uint256 liquidity );
176	 function removeLiquidity( address tokenA, address tokenB, uint256 liquidity, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline ) external returns (uint256 amountA, uint256 amountB);
177	 function removeLiquidityETH( address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline ) external returns (uint256 amountToken, uint256 amountETH);
178	 function removeLiquidityWithPermit( address tokenA, address tokenB, uint256 liquidity, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s ) external returns (uint256 amountA, uint256 amountB);
179	 function removeLiquidityETHWithPermit( address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s ) external returns (uint256 amountToken, uint256 amountETH);
180	 function swapExactTokensForTokens( uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline ) external returns (uint256[] memory amounts);
181	 function swapTokensForExactTokens( uint256 amountOut, uint256 amountInMax, address[] calldata path, address to, uint256 deadline ) external returns (uint256[] memory amounts);
182	 function swapExactETHForTokens( uint256 amountOutMin, address[] calldata path, address to, uint256 deadline ) external payable returns (uint256[] memory amounts);
183	 function swapTokensForExactETH( uint256 amountOut, uint256 amountInMax, address[] calldata path, address to, uint256 deadline ) external returns (uint256[] memory amounts);
184	 function swapExactTokensForETH( uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline ) external returns (uint256[] memory amounts);
185	 function swapETHForExactTokens( uint256 amountOut, address[] calldata path, address to, uint256 deadline ) external payable returns (uint256[] memory amounts);
186	 function quote( uint256 amountA, uint256 reserveA, uint256 reserveB ) external pure returns (uint256 amountB);
187	 function getAmountOut( uint256 amountIn, uint256 reserveIn, uint256 reserveOut ) external pure returns (uint256 amountOut);
188	 function getAmountIn( uint256 amountOut, uint256 reserveIn, uint256 reserveOut ) external pure returns (uint256 amountIn);
189	 function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);
190	 function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);
191	 }
192	 library Math {
193	 function max(uint256 a, uint256 b) internal pure returns (uint256) {
194	 return a >= b ? a : b;
195	 }
196	 function min(uint256 a, uint256 b) internal pure returns (uint256) {
197	 return a < b ? a : b;
198	 }
199	 function average(uint256 a, uint256 b) internal pure returns (uint256) {
200	 return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);
201	 }
202	 }
203	 library SafeMath {
204	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
205	 uint256 c = a + b;
206	 require(c >= a, "SafeMath: addition overflow");
207	 return c;
208	 }
209	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
210	 return sub(a, b, "SafeMath: subtraction overflow");
211	 }
212	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
213	 require(b <= a, errorMessage);
214	 uint256 c = a - b;
215	 return c;
216	 }
217	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
218	 if (a == 0) {
219	 return 0;
220	 }
221	 uint256 c = a * b;
222	 require(c / a == b, "SafeMath: multiplication overflow");
223	 return c;
224	 }
225	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
226	 return div(a, b, "SafeMath: division by zero");
227	 }
228	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
229	 require(b > 0, errorMessage);
230	 uint256 c = a / b;
231	 return c;
232	 }
233	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
234	 return mod(a, b, "SafeMath: modulo by zero");
235	 }
236	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
237	 require(b != 0, errorMessage);
238	 return a % b;
239	 }
240	 }
241	 interface IUniswapV2Router02 is IUniswapV2Router01 {
242	 function removeLiquidityETHSupportingFeeOnTransferTokens( address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline ) external returns (uint256 amountETH);
243	 function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens( address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s ) external returns (uint256 amountETH);
244	 function swapExactTokensForTokensSupportingFeeOnTransferTokens( uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline ) external;
245	 function swapExactETHForTokensSupportingFeeOnTransferTokens( uint256 amountOutMin, address[] calldata path, address to, uint256 deadline ) external payable;
246	 function swapExactTokensForETHSupportingFeeOnTransferTokens( uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline ) external;
247	 }
248	 library SafeERC20 {
249	 using SafeMath for uint256;
250	 using Address for address;
251	 function safeTransfer(IERC20 token, address to, uint256 value) internal {
252	 _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
253	 }
254	 function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
255	 _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
256	 }
257	 function safeApprove(IERC20 token, address spender, uint256 value) internal {
258	 require((value == 0) || (token.allowance(address(this), spender) == 0), "SafeERC20: approve from non-zero to non-zero allowance" );
259	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
260	 }
261	 function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
262	 uint256 newAllowance = token.allowance(address(this), spender).add(value);
263	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
264	 }
265	 function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
266	 uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
267	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
268	 }
269	 function _callOptionalReturn(IERC20 token, bytes memory data) private {
270	 bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
271	 if (returndata.length > 0) {
272	 require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
273	 }
274	 }
275	 }
276	 struct StrategyParams {
277	 uint256 performanceFee;
278	 uint256 activation;
279	 uint256 debtRatio;
280	 uint256 minDebtPerHarvest;
281	 uint256 maxDebtPerHarvest;
282	 uint256 lastReport;
283	 uint256 totalDebt;
284	 uint256 totalGain;
285	 uint256 totalLoss;
286	 }
287	 interface VaultAPI is IERC20 {
288	 function name() external view returns (string calldata);
289	 function symbol() external view returns (string calldata);
290	 function decimals() external view returns (uint256);
291	 function apiVersion() external pure returns (string memory);
292	 function permit( address owner, address spender, uint256 amount, uint256 expiry, bytes calldata signature ) external returns (bool);
293	 function deposit() external returns (uint256);
294	 function deposit(uint256 amount) external returns (uint256);
295	 function deposit(uint256 amount, address recipient) external returns (uint256);
296	 function withdraw() external returns (uint256);
297	 function withdraw(uint256 maxShares) external returns (uint256);
298	 function withdraw(uint256 maxShares, address recipient) external returns (uint256);
299	 function token() external view returns (address);
300	 function strategies(address _strategy) external view returns (StrategyParams memory);
301	 function pricePerShare() external view returns (uint256);
302	 function totalAssets() external view returns (uint256);
303	 function depositLimit() external view returns (uint256);
304	 function maxAvailableShares() external view returns (uint256);
305	 function creditAvailable() external view returns (uint256);
306	 function debtOutstanding() external view returns (uint256);
307	 function expectedReturn() external view returns (uint256);
308	 function report( uint256 _gain, uint256 _loss, uint256 _debtPayment ) external returns (uint256);
309	 function revokeStrategy() external;
310	 function governance() external view returns (address);
311	 function management() external view returns (address);
312	 function guardian() external view returns (address);
313	 }
314	 interface StrategyAPI {
315	 function name() external view returns (string memory);
316	 function vault() external view returns (address);
317	 function want() external view returns (address);
318	 function apiVersion() external pure returns (string memory);
319	 function keeper() external view returns (address);
320	 function isActive() external view returns (bool);
321	 function delegatedAssets() external view returns (uint256);
322	 function estimatedTotalAssets() external view returns (uint256);
323	 function tendTrigger(uint256 callCost) external view returns (bool);
324	 function tend() external;
325	 function harvestTrigger(uint256 callCost) external view returns (bool);
326	 function harvest() external;
327	 event Harvested(uint256 profit, uint256 loss, uint256 debtPayment, uint256 debtOutstanding);
328	 }
329	 interface HealthCheck {
330	 function check( uint256 profit, uint256 loss, uint256 debtPayment, uint256 debtOutstanding, uint256 totalDebt ) external view returns (bool);
331	 }
332	 abstract contract BaseStrategy {
333	 using SafeMath for uint256;
334	 using SafeERC20 for IERC20;
335	 string public metadataURI;
336	 bool public doHealthCheck;
337	 address public healthCheck;
338	 function apiVersion() public pure returns (string memory) {
339	 return "0.4.3";
340	 }
341	 function name() external view virtual returns (string memory);
342	 function delegatedAssets() external view virtual returns (uint256) {
343	 return 0;
344	 }
345	 VaultAPI public vault;
346	 address public strategist;
347	 address public rewards;
348	 address public keeper;
349	 IERC20 public want;
350	 event Harvested(uint256 profit, uint256 loss, uint256 debtPayment, uint256 debtOutstanding);
351	 event UpdatedStrategist(address newStrategist);
352	 event UpdatedKeeper(address newKeeper);
353	 event UpdatedRewards(address rewards);
354	 event UpdatedMinReportDelay(uint256 delay);
355	 event UpdatedMaxReportDelay(uint256 delay);
356	 event UpdatedProfitFactor(uint256 profitFactor);
357	 event UpdatedDebtThreshold(uint256 debtThreshold);
358	 event EmergencyExitEnabled();
359	 event UpdatedMetadataURI(string metadataURI);
360	 uint256 public minReportDelay;
361	 uint256 public maxReportDelay;
362	 uint256 public profitFactor;
363	 uint256 public debtThreshold;
364	 bool public emergencyExit;
365	 modifier onlyAuthorized() {
366	 require(msg.sender == strategist || msg.sender == governance(), "!authorized");
367	 _;
368	 }
369	 modifier onlyEmergencyAuthorized() {
370	 require( msg.sender == strategist || msg.sender == governance() || msg.sender == vault.guardian() || msg.sender == vault.management(), "!authorized" );
371	 _;
372	 }
373	 modifier onlyStrategist() {
374	 require(msg.sender == strategist, "!strategist");
375	 _;
376	 }
377	 modifier onlyGovernance() {
378	 require(msg.sender == governance(), "!authorized");
379	 _;
380	 }
381	 modifier onlyKeepers() {
382	 require( msg.sender == keeper || msg.sender == strategist || msg.sender == governance() || msg.sender == vault.guardian() || msg.sender == vault.management(), "!authorized" );
383	 _;
384	 }
385	 modifier onlyVaultManagers() {
386	 require(msg.sender == vault.management() || msg.sender == governance(), "!authorized");
387	 _;
388	 }
389	 constructor(address _vault) public {
390	 _initialize(_vault, msg.sender, msg.sender, msg.sender);
391	 }
392	 function _initialize( address _vault, address _strategist, address _rewards, address _keeper ) internal {
393	 require(address(want) == address(0), "Strategy already initialized");
394	 vault = VaultAPI(_vault);
395	 want = IERC20(vault.token());
396	 want.safeApprove(_vault, uint256(-1));
397	 strategist = _strategist;
398	 rewards = _rewards;
399	 keeper = _keeper;
400	 minReportDelay = 0;
401	 maxReportDelay = 86400;
402	 profitFactor = 100;
403	 debtThreshold = 0;
404	 vault.approve(rewards, uint256(-1));
405	 }
406	 function setHealthCheck(address _healthCheck) external onlyVaultManagers {
407	 healthCheck = _healthCheck;
408	 }
409	 function setDoHealthCheck(bool _doHealthCheck) external onlyVaultManagers {
410	 doHealthCheck = _doHealthCheck;
411	 }
412	 function setStrategist(address _strategist) external onlyAuthorized {
413	 require(_strategist != address(0));
414	 strategist = _strategist;
415	 emit UpdatedStrategist(_strategist);
416	 }
417	 function setKeeper(address _keeper) external onlyAuthorized {
418	 require(_keeper != address(0));
419	 keeper = _keeper;
420	 emit UpdatedKeeper(_keeper);
421	 }
422	 function setRewards(address _rewards) external onlyStrategist {
423	 require(_rewards != address(0));
424	 vault.approve(rewards, 0);
425	 rewards = _rewards;
426	 vault.approve(rewards, uint256(-1));
427	 emit UpdatedRewards(_rewards);
428	 }
429	 function setMinReportDelay(uint256 _delay) external onlyAuthorized {
430	 minReportDelay = _delay;
431	 emit UpdatedMinReportDelay(_delay);
432	 }
433	 function setMaxReportDelay(uint256 _delay) external onlyAuthorized {
434	 maxReportDelay = _delay;
435	 emit UpdatedMaxReportDelay(_delay);
436	 }
437	 function setProfitFactor(uint256 _profitFactor) external onlyAuthorized {
438	 profitFactor = _profitFactor;
439	 emit UpdatedProfitFactor(_profitFactor);
440	 }
441	 function setDebtThreshold(uint256 _debtThreshold) external onlyAuthorized {
442	 debtThreshold = _debtThreshold;
443	 emit UpdatedDebtThreshold(_debtThreshold);
444	 }
445	 function setMetadataURI(string calldata _metadataURI) external onlyAuthorized {
446	 metadataURI = _metadataURI;
447	 emit UpdatedMetadataURI(_metadataURI);
448	 }
449	 function governance() internal view returns (address) {
450	 return vault.governance();
451	 }
452	 function ethToWant(uint256 _amtInWei) public view virtual returns (uint256);
453	 function estimatedTotalAssets() public view virtual returns (uint256);
454	 function isActive() public view returns (bool) {
455	 return vault.strategies(address(this)).debtRatio > 0 || estimatedTotalAssets() > 0;
456	 }
457	 function prepareReturn(uint256 _debtOutstanding) internal virtual returns ( uint256 _profit, uint256 _loss, uint256 _debtPayment );
458	 function adjustPosition(uint256 _debtOutstanding) internal virtual;
459	 function liquidatePosition(uint256 _amountNeeded) internal virtual returns (uint256 _liquidatedAmount, uint256 _loss);
460	 function liquidateAllPositions() internal virtual returns (uint256 _amountFreed);
461	 function tendTrigger(uint256 callCostInWei) public view virtual returns (bool) {
462	 return false;
463	 }
464	 function tend() external onlyKeepers {
465	 adjustPosition(vault.debtOutstanding());
466	 }
467	 function harvestTrigger(uint256 callCostInWei) public view virtual returns (bool) {
468	 uint256 callCost = ethToWant(callCostInWei);
469	 StrategyParams memory params = vault.strategies(address(this));
470	 if (params.activation == 0) return false;
471	 if (block.timestamp.sub(params.lastReport) < minReportDelay) return false;
472	 if (block.timestamp.sub(params.lastReport) >= maxReportDelay) return true;
473	 uint256 outstanding = vault.debtOutstanding();
474	 if (outstanding > debtThreshold) return true;
475	 uint256 total = estimatedTotalAssets();
476	 if (total.add(debtThreshold) < params.totalDebt) return true;
477	 uint256 profit = 0;
478	 if (total > params.totalDebt) profit = total.sub(params.totalDebt);
479	 uint256 credit = vault.creditAvailable();
480	 return (profitFactor.mul(callCost) < credit.add(profit));
481	 }
482	 function harvest() external onlyKeepers {
483	 uint256 profit = 0;
484	 uint256 loss = 0;
485	 uint256 debtOutstanding = vault.debtOutstanding();
486	 uint256 debtPayment = 0;
487	 if (emergencyExit) {
488	 uint256 amountFreed = liquidateAllPositions();
489	 if (amountFreed < debtOutstanding) {
490	 loss = debtOutstanding.sub(amountFreed);
491	 }
492	 else if (amountFreed > debtOutstanding) {
493	 profit = amountFreed.sub(debtOutstanding);
494	 }
495	 debtPayment = debtOutstanding.sub(loss);
496	 }
497	 else {
498	 (profit, loss, debtPayment) = prepareReturn(debtOutstanding);
499	 }
500	 uint256 totalDebt = vault.strategies(address(this)).totalDebt;
501	 debtOutstanding = vault.report(profit, loss, debtPayment);
502	 adjustPosition(debtOutstanding);
503	 if (doHealthCheck && healthCheck != address(0)) {
504	 require(HealthCheck(healthCheck).check(profit, loss, debtPayment, debtOutstanding, totalDebt), "!healthcheck");
505	 }
506	 else {
507	 doHealthCheck = true;
508	 }
509	 emit Harvested(profit, loss, debtPayment, debtOutstanding);
510	 }
511	 function withdraw(uint256 _amountNeeded) external returns (uint256 _loss) {
512	 require(msg.sender == address(vault), "!vault");
513	 uint256 amountFreed;
514	 (amountFreed, _loss) = liquidatePosition(_amountNeeded);
515	 want.safeTransfer(msg.sender, amountFreed);
516	 }
517	 function prepareMigration(address _newStrategy) internal virtual;
518	 function migrate(address _newStrategy) external {
519	 require(msg.sender == address(vault));
520	 require(BaseStrategy(_newStrategy).vault() == vault);
521	 prepareMigration(_newStrategy);
522	 want.safeTransfer(_newStrategy, want.balanceOf(address(this)));
523	 }
524	 function setEmergencyExit() external onlyEmergencyAuthorized {
525	 emergencyExit = true;
526	 vault.revokeStrategy();
527	 emit EmergencyExitEnabled();
528	 }
529	 function protectedTokens() internal view virtual returns (address[] memory);
530	 function sweep(address _token) external onlyGovernance {
531	 require(_token != address(want), "!want");
532	 require(_token != address(vault), "!shares");
533	 address[] memory _protectedTokens = protectedTokens();
534	 for (uint256 i; i < _protectedTokens.length; i++) require(_token != _protectedTokens[i], "!protected");
535	 IERC20(_token).safeTransfer(governance(), IERC20(_token).balanceOf(address(this)));
536	 }
537	 }
538	 abstract contract BaseStrategyInitializable is BaseStrategy {
539	 bool public isOriginal = true;
540	 event Cloned(address indexed clone);
541	 constructor(address _vault) public BaseStrategy(_vault) {
542	 }
543	 function initialize( address _vault, address _strategist, address _rewards, address _keeper ) external virtual {
544	 _initialize(_vault, _strategist, _rewards, _keeper);
545	 }
546	 function clone(address _vault) external returns (address) {
547	 require(isOriginal, "!clone");
548	 return this.clone(_vault, msg.sender, msg.sender, msg.sender);
549	 }
550	 function clone( address _vault, address _strategist, address _rewards, address _keeper ) external returns (address newStrategy) {
551	 bytes20 addressBytes = bytes20(address(this));
552	 assembly {
553	 let clone_code := mload(0x40) mstore(clone_code, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000) mstore(add(clone_code, 0x14), addressBytes) mstore(add(clone_code, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000) newStrategy := create(0, clone_code, 0x37) }
554	 BaseStrategyInitializable(newStrategy).initialize(_vault, _strategist, _rewards, _keeper);
555	 emit Cloned(newStrategy);
556	 }
557	 }
558	 interface IVault is IERC20 {
559	 function token() external view returns (address);
560	 function decimals() external view returns (uint256);
561	 function deposit(uint256) external;
562	 function depositAll() external;
563	 function pricePerShare() external view returns (uint256);
564	 function withdraw() external returns (uint256);
565	 function withdraw(uint256 amount) external returns (uint256);
566	 function withdraw( uint256 amount, address account, uint256 maxLoss ) external returns (uint256);
567	 function availableDepositLimit() external view returns (uint256);
568	 }
569	 interface PSMLike {
570	 function gemJoin() external view returns (address);
571	 function sellGem(address usr, uint256 gemAmt) external;
572	 function buyGem(address usr, uint256 gemAmt) external;
573	 }
574	 interface IERC3156FlashLender {
575	 function maxFlashLoan( address token ) external view returns (uint256);
576	 function flashFee( address token, uint256 amount ) external view returns (uint256);
577	 function flashLoan( address receiver, address token, uint256 amount, bytes calldata data ) external returns (bool);
578	 }
579	 interface IERC3156FlashBorrower {
580	 function onFlashLoan( address initiator, address token, uint256 amount, uint256 fee, bytes calldata data ) external returns (bytes32);
581	 }
582	 library MakerDaiDelegateLib {
583	 using SafeERC20 for IERC20;
584	 using Address for address;
585	 using SafeMath for uint256;
586	 enum Action {
587	 WIND, UNWIND}
588	 IERC20 internal constant want = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);
589	 IERC20 internal constant otherToken = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
590	 uint256 public constant otherTokenTo18Conversion = 10 ** 12;
591	 IUniswapV2Pair internal constant yieldBearing = IUniswapV2Pair(0xAE461cA67B15dc8dc81CE7615e0320dA1A9aB8D5);
592	 bytes32 internal constant ilk_yieldBearing = 0x554e495632444149555344432d41000000000000000000000000000000000000;
593	 address internal constant gemJoinAdapter = 0xA81598667AC561986b70ae11bBE2dd5348ed4327;
594	 IUniswapV2Router02 public constant router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
595	 PSMLike public constant psm = PSMLike(0x89B78CfA322F6C5dE0aBcEecab66Aee45393cC5A) ;
596	 IERC20 internal constant borrowToken = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);
597	 IERC3156FlashLender public constant flashmint = IERC3156FlashLender(0x1EB4CF3A948E7D72A198fe073cCb8C7a948cD853);
598	 uint256 internal constant WAD = 10**18;
599	 uint256 internal constant RAY = 10**27;
600	 uint256 internal constant MIN_MINTABLE = 50000 * WAD;
601	 ManagerLike internal constant manager = ManagerLike(0x5ef30b9986345249bc32d8928B7ee64DE9435E39);
602	 DaiJoinLike internal constant daiJoin = DaiJoinLike(0x9759A6Ac90977b93B58547b4A71c78317f391A28);
603	 SpotLike internal constant spotter = SpotLike(0x65C79fcB50Ca1594B025960e539eD7A9a6D434A3);
604	 JugLike internal constant jug = JugLike(0x19c0976f590D67707E62397C87829d896Dc0f1F1);
605	 DssAutoLine internal constant autoLine = DssAutoLine(0xC7Bdd1F2B16447dcf3dE045C4a039A60EC2f0ba3);
606	 function openCdp(bytes32 ilk) public returns (uint256) {
607	 return manager.open(ilk, address(this));
608	 }
609	 function shiftCdp(uint256 cdpId, uint256 newCdpId) public {
610	 manager.shift(cdpId, newCdpId);
611	 }
612	 function transferCdp(uint256 cdpId, address recipient) public {
613	 manager.give(cdpId, recipient);
614	 }
615	 function allowManagingCdp( uint256 cdpId, address user, bool isAccessGranted ) public {
616	 manager.cdpAllow(cdpId, user, isAccessGranted ? 1 : 0);
617	 }
618	 function lockGemAndDraw( address gemJoin, uint256 cdpId, uint256 collateralAmount, uint256 daiToMint, uint256 totalDebt ) public {
619	 address urn = manager.urns(cdpId);
620	 VatLike vat = VatLike(manager.vat());
621	 bytes32 ilk = manager.ilks(cdpId);
622	 if (daiToMint > 0) {
623	 daiToMint = _forceMintWithinLimits(vat, ilk, daiToMint, totalDebt);
624	 }
625	 if (collateralAmount > 0) {
626	 GemJoinLike(gemJoin).join(urn, collateralAmount);
627	 }
628	 manager.frob( cdpId, int256(convertTo18(gemJoin, collateralAmount)), _getDrawDart(vat, urn, ilk, daiToMint) );
629	 manager.move(cdpId, address(this), daiToMint.mul(1e27));
630	 vat.hope(address(daiJoin));
631	 daiJoin.exit(address(this), daiToMint);
632	 }
633	 function wipeAndFreeGem( address gemJoin, uint256 cdpId, uint256 collateralAmount, uint256 daiToRepay ) public {
634	 address urn = manager.urns(cdpId);
635	 if (daiToRepay > 0) {
636	 daiJoin.join(urn, daiToRepay);
637	 }
638	 uint256 wadC = convertTo18(gemJoin, collateralAmount);
639	 manager.frob( cdpId, -int256(wadC), _getWipeDart( VatLike(manager.vat()), VatLike(manager.vat()).dai(urn), urn, manager.ilks(cdpId) ) );
640	 manager.flux(cdpId, address(this), collateralAmount);
641	 GemJoinLike(gemJoin).exit(address(this), collateralAmount);
642	 }
643	 function debtFloor(bytes32 ilk) public view returns (uint256) {
644	 (, , , , uint256 dust) = VatLike(manager.vat()).ilks(ilk);
645	 return dust.div(RAY);
646	 }
647	 function debtForCdp(uint256 cdpId, bytes32 ilk) public view returns (uint256) {
648	 address urn = manager.urns(cdpId);
649	 VatLike vat = VatLike(manager.vat());
650	 (, uint256 art) = vat.urns(ilk, urn);
651	 (, uint256 rate, , , ) = vat.ilks(ilk);
652	 return art.mul(rate).div(RAY);
653	 }
654	 function balanceOfCdp(uint256 cdpId, bytes32 ilk) public view returns (uint256) {
655	 address urn = manager.urns(cdpId);
656	 VatLike vat = VatLike(manager.vat());
657	 (uint256 ink, ) = vat.urns(ilk, urn);
658	 return ink;
659	 }
660	 function getDaiPar() public view returns (uint256) {
661	 return spotter.par();
662	 }
663	 function getLiquidationRatio(bytes32 ilk) public view returns (uint256) {
664	 (, uint256 liquidationRatio) = spotter.ilks(ilk);
665	 return liquidationRatio;
666	 }
667	 function getSpotPrice(bytes32 ilk) public view returns (uint256) {
668	 VatLike vat = VatLike(manager.vat());
669	 (, , uint256 spot, , ) = vat.ilks(ilk);
670	 uint256 liquidationRatio = getLiquidationRatio(ilk);
671	 return spot.mul(liquidationRatio).div(RAY * 1e9);
672	 }
673	 function getPessimisticRatioOfCdpWithExternalPrice( uint256 cdpId, bytes32 ilk, uint256 externalPrice, uint256 collateralizationRatioPrecision ) public view returns (uint256) {
674	 uint256 price = Math.min(getSpotPrice(ilk), externalPrice);
675	 require(price > 0);
676	 uint256 totalCollateralValue = balanceOfCdp(cdpId, ilk).mul(price).div(WAD);
677	 uint256 totalDebt = debtForCdp(cdpId, ilk);
678	 if (totalDebt == 0) {
679	 totalDebt = 1;
680	 }
681	 return totalCollateralValue.mul(collateralizationRatioPrecision).div(totalDebt);
682	 }
683	 function keepBasicMakerHygiene(bytes32 ilk) public {
684	 jug.drip(ilk);
685	 autoLine.exec(ilk);
686	 }
687	 function daiJoinAddress() public view returns (address) {
688	 return address(daiJoin);
689	 }
690	 function isDaiAvailableToMint(bytes32 ilk) public view returns (bool) {
691	 return balanceOfDaiAvailableToMint(ilk) >= MIN_MINTABLE;
692	 }
693	 function balanceOfDaiAvailableToMint(bytes32 ilk) public view returns (uint256) {
694	 VatLike vat = VatLike(manager.vat());
695	 (uint256 Art, uint256 rate, , uint256 line, ) = vat.ilks(ilk);
696	 uint256 vatDebt = Art.mul(rate);
697	 if (vatDebt >= line) {
698	 return 0;
699	 }
700	 return line.sub(vatDebt).div(RAY);
701	 }
702	 function wind( uint256 wantAmountInitial, uint256 targetCollateralizationRatio, uint256 cdpId ) public {
703	 wantAmountInitial = Math.min(wantAmountInitial, balanceOfWant());
704	 uint256 flashloanAmount = wantAmountInitial.mul(RAY).div(targetCollateralizationRatio.mul(1e9).sub(RAY));
705	 VatLike vat = VatLike(manager.vat());
706	 uint256 currentDebt = debtForCdp(cdpId, ilk_yieldBearing);
707	 flashloanAmount = Math.min(flashloanAmount, _forceMintWithinLimits(vat, ilk_yieldBearing, flashloanAmount, currentDebt));
708	 if ( (currentDebt.add(flashloanAmount)) <= debtFloor(ilk_yieldBearing).add(1e15)){
709	 return;
710	 }
711	 bytes memory data = abi.encode(Action.WIND, cdpId, wantAmountInitial, flashloanAmount, targetCollateralizationRatio);
712	 _initFlashLoan(data, flashloanAmount);
713	 }
714	 function unwind( uint256 wantAmountRequested, uint256 targetCollateralizationRatio, uint256 cdpId ) public {
715	 if (balanceOfCdp(cdpId, ilk_yieldBearing) == 0){
716	 return;
717	 }
718	 uint256 flashloanAmount = debtForCdp(cdpId, ilk_yieldBearing).add(1);
719	 bytes memory data = abi.encode(Action.UNWIND, cdpId, wantAmountRequested, flashloanAmount, targetCollateralizationRatio);
720	 _initFlashLoan(data, flashloanAmount);
721	 }
722	 function _wind(uint256 cdpId, uint256 flashloanRepayAmount, uint256 wantAmountInitial, uint256) public {
723	 uint256 yieldBearingAmountToLock = _swapWantToYieldBearing(balanceOfWant());
724	 _checkAllowance(gemJoinAdapter, address(yieldBearing), yieldBearingAmountToLock);
725	 lockGemAndDraw( gemJoinAdapter, cdpId, yieldBearingAmountToLock, flashloanRepayAmount, debtForCdp(cdpId, ilk_yieldBearing) );
726	 }
727	 function _unwind(uint256 cdpId, uint256 flashloanRepayAmount, uint256 wantAmountRequested, uint256 targetCollateralizationRatio) public {
728	 uint256 currentDebtPlusRounding = debtForCdp(cdpId, ilk_yieldBearing).add(1);
729	 _checkAllowance(daiJoinAddress(), address(borrowToken), currentDebtPlusRounding);
730	 wipeAndFreeGem(gemJoinAdapter, cdpId, balanceOfCdp(cdpId, ilk_yieldBearing), currentDebtPlusRounding);
731	 uint256 leveragePlusOne = (RAY.mul(WAD).div((targetCollateralizationRatio.mul(1e9).sub(RAY)))).add(WAD);
732	 uint256 totalRequestedInYieldBearing = wantAmountRequested.mul(leveragePlusOne).div(getWantPerYieldBearing());
733	 totalRequestedInYieldBearing = Math.min(totalRequestedInYieldBearing, balanceOfYieldBearing());
734	 _swapYieldBearingToWant(totalRequestedInYieldBearing);
735	 uint256 yieldBearingBalance = balanceOfYieldBearing();
736	 uint256 borrowTokenAmountToMint = yieldBearingBalance.mul(getWantPerYieldBearing()).div(targetCollateralizationRatio);
737	 if ( borrowTokenAmountToMint <= debtFloor(ilk_yieldBearing).add(1e15)){
738	 _swapYieldBearingToWant(balanceOfYieldBearing());
739	 yieldBearingBalance = balanceOfYieldBearing();
740	 return;
741	 }
742	 borrowTokenAmountToMint = Math.min(borrowTokenAmountToMint, flashloanRepayAmount);
743	 _checkAllowance(gemJoinAdapter, address(yieldBearing), yieldBearingBalance);
744	 lockGemAndDraw( gemJoinAdapter, cdpId, yieldBearingBalance, borrowTokenAmountToMint, debtForCdp(cdpId, ilk_yieldBearing) );
745	 }
746	 function getWantPerYieldBearing() internal view returns (uint256){
747	 (uint256 wantUnderlyingBalance, uint256 otherTokenUnderlyingBalance, ) = yieldBearing.getReserves();
748	 return (wantUnderlyingBalance.mul(WAD).add(otherTokenUnderlyingBalance.mul(WAD).mul(WAD).div(1e6))).div(yieldBearing.totalSupply());
749	 }
750	 function balanceOfWant() internal view returns (uint256) {
751	 return want.balanceOf(address(this));
752	 }
753	 function balanceOfYieldBearing() internal view returns (uint256) {
754	 return yieldBearing.balanceOf(address(this));
755	 }
756	 function balanceOfOtherToken() internal view returns (uint256) {
757	 return otherToken.balanceOf(address(this));
758	 }
759	 function _initFlashLoan(bytes memory data, uint256 amount) internal {
760	 _checkAllowance(address(flashmint), address(borrowToken), amount);
761	 flashmint.flashLoan(address(this), address(borrowToken), amount, data);
762	 }
763	 function _checkAllowance( address _contract, address _token, uint256 _amount ) internal {
764	 if (IERC20(_token).allowance(address(this), _contract) < _amount) {
765	 IERC20(_token).safeApprove(_contract, type(uint256).max);
766	 }
767	 }
768	 function _swapWantToYieldBearing(uint256 _amount) internal returns (uint256) {
769	 if (_amount == 0) {
770	 return 0;
771	 }
772	 _amount = Math.min(_amount, balanceOfWant());
773	 (uint256 wantRatio, uint256 otherTokenRatio, ) = yieldBearing.getReserves();
774	 wantRatio = wantRatio.mul(WAD).div(yieldBearing.totalSupply());
775	 otherTokenRatio = otherTokenRatio.mul(WAD).mul(otherTokenTo18Conversion).div(yieldBearing.totalSupply());
776	 uint256 wantAmountForMint = _amount.mul(wantRatio).div(wantRatio + otherTokenRatio);
777	 uint256 wantAmountToSwapToOtherTokenForMint = _amount.mul(otherTokenRatio).div(wantRatio + otherTokenRatio);
778	 _checkAllowance(address(psm), address(want), wantAmountToSwapToOtherTokenForMint);
779	 psm.buyGem(address(this), wantAmountToSwapToOtherTokenForMint.div(otherTokenTo18Conversion));
780	 wantAmountForMint = Math.min(wantAmountForMint, balanceOfWant());
781	 uint256 otherTokenBalance = balanceOfOtherToken();
782	 _checkAllowance(address(router), address(want), wantAmountForMint);
783	 _checkAllowance(address(router), address(otherToken), otherTokenBalance);
784	 (,,uint256 mintAmount) = router.addLiquidity(address(want), address(otherToken), wantAmountForMint, otherTokenBalance, 0, 0, address(this), block.timestamp);
785	 return balanceOfYieldBearing();
786	 }
787	 function _swapYieldBearingToWant(uint256 _amount) internal {
788	 if (_amount == 0) {
789	 return;
790	 }
791	 uint256 yieldBearingAmountToBurn = Math.min(_amount, balanceOfYieldBearing());
792	 _checkAllowance(address(router), address(yieldBearing), yieldBearingAmountToBurn);
793	 router.removeLiquidity(address(want), address(otherToken), yieldBearingAmountToBurn, 0, 0, address(this),block.timestamp);
794	 uint256 otherTokenBalance = balanceOfOtherToken();
795	 address psmGemJoin = psm.gemJoin();
796	 _checkAllowance(psmGemJoin, address(otherToken), otherTokenBalance);
797	 psm.sellGem(address(this), otherTokenBalance);
798	 }
799	 function _forceMintWithinLimits( VatLike vat, bytes32 ilk, uint256 desiredAmount, uint256 debtBalance ) internal view returns (uint256) {
800	 (uint256 Art, uint256 rate, , uint256 line, uint256 dust) = vat.ilks(ilk);
801	 uint256 vatDebt = Art.mul(rate);
802	 if ( vatDebt >= line || (desiredAmount.add(debtBalance) <= dust.div(RAY)) ) {
803	 return 0;
804	 }
805	 uint256 maxMintableDAI = line.sub(vatDebt).div(RAY);
806	 if (maxMintableDAI < MIN_MINTABLE) {
807	 return 0;
808	 }
809	 if (maxMintableDAI > WAD) {
810	 maxMintableDAI = maxMintableDAI - WAD;
811	 }
812	 return Math.min(maxMintableDAI, desiredAmount);
813	 }
814	 function _getDrawDart( VatLike vat, address urn, bytes32 ilk, uint256 wad ) internal returns (int256 dart) {
815	 uint256 rate = jug.drip(ilk);
816	 uint256 dai = vat.dai(urn);
817	 if (dai < wad.mul(RAY)) {
818	 dart = int256(wad.mul(RAY).sub(dai).div(rate));
819	 dart = uint256(dart).mul(rate) < wad.mul(RAY) ? dart + 1 : dart;
820	 }
821	 }
822	 function _getWipeDart( VatLike vat, uint256 dai, address urn, bytes32 ilk ) internal view returns (int256 dart) {
823	 (, uint256 rate, , , ) = vat.ilks(ilk);
824	 (, uint256 art) = vat.urns(ilk, urn);
825	 dart = int256(dai / rate);
826	 dart = uint256(dart) <= art ? -dart : -int256(art);
827	 }
828	 function convertTo18(address gemJoin, uint256 amt) internal returns (uint256 wad) {
829	 wad = amt.mul(10**(18 - GemJoinLike(gemJoin).dec()));
830	 }
831	 }
832	 contract Strategy is BaseStrategy {
833	 using Address for address;
834	 enum Action {
835	 WIND, UNWIND}
836	 IUniswapV2Pair internal constant yieldBearing = IUniswapV2Pair(0xAE461cA67B15dc8dc81CE7615e0320dA1A9aB8D5);
837	 bytes32 internal constant ilk_yieldBearing = 0x554e495632444149555344432d41000000000000000000000000000000000000;
838	 address internal constant gemJoinAdapter = 0xA81598667AC561986b70ae11bBE2dd5348ed4327;
839	 address internal constant flashmint = 0x1EB4CF3A948E7D72A198fe073cCb8C7a948cD853;
840	 IERC20 internal constant borrowToken = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);
841	 uint256 internal constant WAD = 10**18;
842	 uint256 internal constant RAY = 10**27;
843	 uint256 public cdpId;
844	 uint256 public collateralizationRatio;
845	 uint256 public lowerRebalanceTolerance;
846	 uint256 public upperRebalanceTolerance;
847	 bool internal forceHarvestTriggerOnce;
848	 uint256 public creditThreshold;
849	 uint256 public maxSingleTrade;
850	 uint256 public minSingleTrade;
851	 string internal strategyName;
852	 constructor( address _vault, string memory _strategyName ) public BaseStrategy(_vault) {
853	 _initializeThis( _strategyName );
854	 }
855	 function initialize( address _vault, string memory _strategyName ) public {
856	 address sender = msg.sender;
857	 _initialize(_vault, sender, sender, sender);
858	 _initializeThis( _strategyName );
859	 }
860	 function _initializeThis( string memory _strategyName ) internal {
861	 strategyName = _strategyName;
862	 maxSingleTrade = 10_000_000 * 1e18;
863	 minSingleTrade = 1 * 1e17;
864	 creditThreshold = 1e6 * 1e18;
865	 maxReportDelay = 21 days;
866	 healthCheck = 0xDDCea799fF1699e98EDF118e0629A974Df7DF012;
867	 cdpId = MakerDaiDelegateLib.openCdp(ilk_yieldBearing);
868	 require(cdpId > 0);
869	 upperRebalanceTolerance = (20 * WAD) / 10000;
870	 lowerRebalanceTolerance = (20 * WAD) / 10000;
871	 collateralizationRatio = (10230 * WAD) / 10000;
872	 }
873	 function setForceHarvestTriggerOnce(bool _forceHarvestTriggerOnce) external onlyVaultManagers {
874	 forceHarvestTriggerOnce = _forceHarvestTriggerOnce;
875	 }
876	 function setCreditThreshold(uint256 _creditThreshold) external onlyVaultManagers {
877	 creditThreshold = _creditThreshold;
878	 }
879	 function setMinMaxSingleTrade(uint256 _minSingleTrade, uint256 _maxSingleTrade) external onlyVaultManagers {
880	 minSingleTrade = _minSingleTrade;
881	 maxSingleTrade = _maxSingleTrade;
882	 }
883	 function setCollateralizationRatio(uint256 _collateralizationRatio) external onlyEmergencyAuthorized {
884	 require(_collateralizationRatio.sub(lowerRebalanceTolerance) > MakerDaiDelegateLib.getLiquidationRatio(ilk_yieldBearing).mul(WAD).div(RAY));
885	 collateralizationRatio = _collateralizationRatio;
886	 }
887	 function setRebalanceTolerance(uint256 _lowerRebalanceTolerance, uint256 _upperRebalanceTolerance) external onlyEmergencyAuthorized {
888	 require(collateralizationRatio.sub(_lowerRebalanceTolerance) > MakerDaiDelegateLib.getLiquidationRatio(ilk_yieldBearing).mul(WAD).div(RAY));
889	 lowerRebalanceTolerance = _lowerRebalanceTolerance;
890	 upperRebalanceTolerance = _upperRebalanceTolerance;
891	 }
892	 function shiftToCdp(uint256 newCdpId) external onlyGovernance {
893	 MakerDaiDelegateLib.shiftCdp(cdpId, newCdpId);
894	 cdpId = newCdpId;
895	 }
896	 function grantCdpManagingRightsToUser(address user, bool allow) external onlyGovernance {
897	 MakerDaiDelegateLib.allowManagingCdp(cdpId, user, allow);
898	 }
899	 function emergencyDebtRepayment(uint256 repayAmountOfWant) external onlyVaultManagers {
900	 MakerDaiDelegateLib.unwind(repayAmountOfWant, getCurrentMakerVaultRatio(), cdpId);
901	 }
902	 function name() external view override returns (string memory) {
903	 return strategyName;
904	 }
905	 function estimatedTotalAssets() public view override returns (uint256) {
906	 return balanceOfWant() .add(balanceOfYieldBearing().add(balanceOfMakerVault()).mul(getWantPerYieldBearing()).div(WAD)) .sub(balanceOfDebt());
907	 }
908	 function prepareReturn(uint256 _debtOutstanding) internal override returns ( uint256 _profit, uint256 _loss, uint256 _debtPayment ) {
909	 uint256 totalDebt = vault.strategies(address(this)).totalDebt;
910	 uint256 totalAssetsAfterProfit = estimatedTotalAssets();
911	 _profit = totalAssetsAfterProfit > ( totalDebt + minSingleTrade ) ? totalAssetsAfterProfit.sub(totalDebt) : 0;
912	 uint256 _amountFreed;
913	 (_amountFreed, _loss) = liquidatePosition(Math.min(maxSingleTrade, _debtOutstanding.add(_profit)));
914	 _debtPayment = Math.min(_debtOutstanding, _amountFreed);
915	 if (_loss > _profit) {
916	 _loss = _loss.sub(_profit);
917	 _profit = 0;
918	 }
919	 else {
920	 _profit = _profit.sub(_loss);
921	 _loss = 0;
922	 }
923	 forceHarvestTriggerOnce = false;
924	 }
925	 function adjustPosition(uint256 _debtOutstanding) internal override {
926	 MakerDaiDelegateLib.keepBasicMakerHygiene(ilk_yieldBearing);
927	 if (balanceOfWant() > _debtOutstanding.add(minSingleTrade) ) {
928	 MakerDaiDelegateLib.wind(Math.min(maxSingleTrade, balanceOfWant().sub(_debtOutstanding)), collateralizationRatio, cdpId);
929	 }
930	 else {
931	 uint256 currentRatio = getCurrentMakerVaultRatio();
932	 if (currentRatio < collateralizationRatio.sub(lowerRebalanceTolerance)) {
933	 uint256 currentCollateral = balanceOfMakerVault();
934	 uint256 yieldBearingToRepay = currentCollateral.sub( currentCollateral.mul(currentRatio).div(collateralizationRatio) );
935	 uint256 wantAmountToRepay = yieldBearingToRepay.mul(getWantPerYieldBearing()).div(WAD);
936	 MakerDaiDelegateLib.unwind(wantAmountToRepay, collateralizationRatio, cdpId);
937	 }
938	 else if (currentRatio > collateralizationRatio.add(upperRebalanceTolerance)) {
939	 _lockCollateralAndMintDai(0, _borrowTokenAmountToMint(balanceOfMakerVault()).sub(balanceOfDebt()));
940	 MakerDaiDelegateLib.wind(Math.min(maxSingleTrade, balanceOfWant().sub(_debtOutstanding)), collateralizationRatio, cdpId);
941	 }
942	 }
943	 if (balanceOfMakerVault() > 0) {
944	 require(getCurrentMakerVaultRatio() > collateralizationRatio.sub(lowerRebalanceTolerance), "unsafe collateralization");
945	 }
946	 }
947	 function liquidatePosition(uint256 _wantAmountNeeded) internal override returns (uint256 _liquidatedAmount, uint256 _loss) {
948	 uint256 wantBalance = balanceOfWant();
949	 if (wantBalance >= _wantAmountNeeded) {
950	 return (_wantAmountNeeded, 0);
951	 }
952	 MakerDaiDelegateLib.unwind(_wantAmountNeeded.sub(wantBalance), collateralizationRatio, cdpId);
953	 uint256 looseWant = balanceOfWant();
954	 if (_wantAmountNeeded > looseWant) {
955	 _liquidatedAmount = looseWant;
956	 _loss = _wantAmountNeeded.sub(looseWant);
957	 }
958	 else {
959	 _liquidatedAmount = _wantAmountNeeded;
960	 _loss = 0;
961	 }
962	 if (balanceOfMakerVault() > 0) {
963	 require(getCurrentMakerVaultRatio() > collateralizationRatio.sub(lowerRebalanceTolerance), "unsafe collateralization");
964	 }
965	 }
966	 function liquidateAllPositions() internal override returns (uint256 _amountFreed) {
967	 (_amountFreed, ) = liquidatePosition(estimatedTotalAssets());
968	 }
969	 function harvestTrigger(uint256 callCostInWei) public view override returns (bool) {
970	 if (!isActive()) {
971	 return false;
972	 }
973	 if (!isBaseFeeAcceptable()) {
974	 return false;
975	 }
976	 if (forceHarvestTriggerOnce) {
977	 return true;
978	 }
979	 StrategyParams memory params = vault.strategies(address(this));
980	 if (block.timestamp.sub(params.lastReport) > maxReportDelay) {
981	 return true;
982	 }
983	 if (vault.creditAvailable() > creditThreshold) {
984	 return true;
985	 }
986	 return false;
987	 }
988	 function tendTrigger(uint256 callCostInWei) public view override returns (bool) {
989	 if (balanceOfMakerVault() == 0) {
990	 return false;
991	 }
992	 uint256 currentRatio = getCurrentMakerVaultRatio();
993	 if (currentRatio < collateralizationRatio.sub(lowerRebalanceTolerance)) {
994	 return true;
995	 }
996	 return currentRatio > collateralizationRatio.add(upperRebalanceTolerance) && balanceOfDebt() > 0 && isBaseFeeAcceptable() && MakerDaiDelegateLib.isDaiAvailableToMint(ilk_yieldBearing);
997	 }
998	 function prepareMigration(address _newStrategy) internal override {
999	 MakerDaiDelegateLib.transferCdp(cdpId, _newStrategy);
1000	 }
1001	 function protectedTokens() internal view override returns (address[] memory) {
1002	 }
1003	 function ethToWant(uint256 _amtInWei) public view virtual override returns (uint256) {
1004	 }
1005	 function onFlashLoan( address initiator, address, uint256 amount, uint256 fee, bytes calldata data ) external returns (bytes32) {
1006	 require(msg.sender == flashmint);
1007	 require(initiator == address(this));
1008	 (Action action, uint256 _cdpId, uint256 _wantAmountInitialOrRequested, uint256 flashloanAmount, uint256 _collateralizationRatio) = abi.decode(data, (Action, uint256, uint256, uint256, uint256));
1009	 amount = amount.add(fee);
1010	 _checkAllowance(address(flashmint), address(borrowToken), amount);
1011	 if (action == Action.WIND) {
1012	 MakerDaiDelegateLib._wind(_cdpId, amount, _wantAmountInitialOrRequested, _collateralizationRatio);
1013	 }
1014	 else if (action == Action.UNWIND) {
1015	 MakerDaiDelegateLib._unwind(_cdpId, amount, _wantAmountInitialOrRequested, _collateralizationRatio);
1016	 }
1017	 return keccak256("ERC3156FlashBorrower.onFlashLoan");
1018	 }
1019	 function _borrowTokenAmountToMint(uint256 _amount) internal returns (uint256) {
1020	 return _amount.mul(getWantPerYieldBearing()).mul(WAD).div(collateralizationRatio).div(WAD);
1021	 }
1022	 function _checkAllowance( address _contract, address _token, uint256 _amount ) internal {
1023	 if (IERC20(_token).allowance(address(this), _contract) < _amount) {
1024	 IERC20(_token).safeApprove(_contract, 0);
1025	 IERC20(_token).safeApprove(_contract, type(uint256).max);
1026	 }
1027	 }
1028	 function balanceOfWant() public view returns (uint256) {
1029	 return want.balanceOf(address(this));
1030	 }
1031	 function balanceOfYieldBearing() public view returns (uint256) {
1032	 return yieldBearing.balanceOf(address(this));
1033	 }
1034	 function getWantPerYieldBearing() public view returns (uint256){
1035	 (uint256 wantUnderlyingBalance, uint256 otherTokenUnderlyingBalance, ) = yieldBearing.getReserves();
1036	 return wantUnderlyingBalance.add(otherTokenUnderlyingBalance.mul(1e12)).mul(WAD).div(yieldBearing.totalSupply());
1037	 }
1038	 function balanceOfDebt() public view returns (uint256) {
1039	 return MakerDaiDelegateLib.debtForCdp(cdpId, ilk_yieldBearing);
1040	 }
1041	 function balanceOfMakerVault() public view returns (uint256) {
1042	 return MakerDaiDelegateLib.balanceOfCdp(cdpId, ilk_yieldBearing);
1043	 }
1044	 function balanceOfDaiAvailableToMint() public view returns (uint256) {
1045	 return MakerDaiDelegateLib.balanceOfDaiAvailableToMint(ilk_yieldBearing);
1046	 }
1047	 function getCurrentMakerVaultRatio() public view returns (uint256) {
1048	 return MakerDaiDelegateLib.getPessimisticRatioOfCdpWithExternalPrice(cdpId,ilk_yieldBearing,getWantPerYieldBearing(),WAD);
1049	 }
1050	 function getHypotheticalMakerVaultRatioWithMultiplier(uint256 _wantMultiplier, uint256 _otherTokenMultiplier) public view returns (uint256) {
1051	 (uint256 wantUnderlyingBalance, uint256 otherTokenUnderlyingBalance, ) = yieldBearing.getReserves();
1052	 uint256 hypotheticalWantPerYieldBearing = wantUnderlyingBalance.mul(_wantMultiplier).div(10000).add(otherTokenUnderlyingBalance.mul(_otherTokenMultiplier).div(10000).mul(1e12)).mul(WAD).div(yieldBearing.totalSupply());
1053	 return balanceOfMakerVault().mul(hypotheticalWantPerYieldBearing).div(balanceOfDebt().mul(_wantMultiplier));
1054	 }
1055	 function isBaseFeeAcceptable() internal view returns (bool) {
1056	 return IBaseFee(0xb5e1CAcB567d98faaDB60a1fD4820720141f064F).isCurrentBaseFeeAcceptable();
1057	 }
1058	 function _lockCollateralAndMintDai( uint256 collateralAmount, uint256 daiToMint ) internal {
1059	 MakerDaiDelegateLib.lockGemAndDraw( gemJoinAdapter, cdpId, collateralAmount, daiToMint, balanceOfDebt() );
1060	 }
1061	 }
