row number 
1	  pragma abicoder v2;
2	 pragma solidity >=0.6.0 <0.8.0;
3	 interface IERC20 {
4	 function totalSupply() external view returns (uint256);
5	 function balanceOf(address account) external view returns (uint256);
6	 function transfer(address recipient, uint256 amount) external returns (bool);
7	 function allowance(address owner, address spender) external view returns (uint256);
8	 function approve(address spender, uint256 amount) external returns (bool);
9	 function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
10	 event Transfer(address indexed from, address indexed to, uint256 value);
11	 event Approval(address indexed owner, address indexed spender, uint256 value);
12	 }
13	 pragma solidity 0.7.6;
14	 interface IPermissionsV2 {
15	 function governanceManager() external returns (PendleGovernanceManager);
16	 }
17	 pragma solidity 0.7.6;
18	 abstract contract PermissionsV2 is IPermissionsV2 {
19	 PendleGovernanceManager public immutable override governanceManager;
20	 address internal initializer;
21	 constructor(address _governanceManager) {
22	 require(_governanceManager != address(0), "ZERO_ADDRESS");
23	 initializer = msg.sender;
24	 governanceManager = PendleGovernanceManager(_governanceManager);
25	 }
26	 modifier initialized() {
27	 require(initializer == address(0), "NOT_INITIALIZED");
28	 _;
29	 }
30	 modifier onlyGovernance() {
31	 require(msg.sender == _governance(), "ONLY_GOVERNANCE");
32	 _;
33	 }
34	 function _governance() internal view returns (address) {
35	 return governanceManager.governance();
36	 }
37	 }
38	 pragma solidity 0.7.6;
39	 interface IPendleBaseToken is IERC20 {
40	 function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);
41	 function start() external view returns (uint256);
42	 function expiry() external view returns (uint256);
43	 function increaseAllowance(address spender, uint256 addedValue) external returns (bool);
44	 function decimals() external view returns (uint8);
45	 function name() external view returns (string memory);
46	 function symbol() external view returns (string memory);
47	 function permit( address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s ) external;
48	 }
49	 pragma solidity 0.7.6;
50	 interface IPendleLpHolder {
51	 function underlyingYieldToken() external returns (address);
52	 function pendleMarket() external returns (address);
53	 function sendLp(address user, uint256 amount) external;
54	 function sendInterests(address user, uint256 amount) external;
55	 function redeemLpInterests() external;
56	 function setUpEmergencyMode(address spender) external;
57	 }
58	 pragma solidity 0.7.6;
59	 interface IPendleLiquidityMining {
60	 event Funded(uint256[] _rewards, uint256 numberOfEpochs);
61	 event RewardsToppedUp(uint256[] _epochIds, uint256[] _rewards);
62	 event AllocationSettingSet(uint256[] _expiries, uint256[] _allocationNumerators);
63	 event Staked(uint256 expiry, address user, uint256 amount);
64	 event Withdrawn(uint256 expiry, address user, uint256 amount);
65	 event PendleRewardsSettled(uint256 expiry, address user, uint256 amount);
66	 function fund(uint256[] calldata rewards) external;
67	 function topUpRewards(uint256[] calldata _epochIds, uint256[] calldata _rewards) external;
68	 function stake(uint256 expiry, uint256 amount) external returns (address);
69	 function stakeWithPermit( uint256 expiry, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s ) external returns (address);
70	 function withdraw(uint256 expiry, uint256 amount) external;
71	 function redeemRewards(uint256 expiry, address user) external returns (uint256 rewards);
72	 function redeemLpInterests(uint256 expiry, address user) external returns (uint256 dueInterests);
73	 function setUpEmergencyMode(uint256[] calldata expiries, address spender) external;
74	 function readUserExpiries(address user) external view returns (uint256[] memory expiries);
75	 function getBalances(uint256 expiry, address user) external view returns (uint256);
76	 function lpHolderForExpiry(uint256 expiry) external view returns (address);
77	 function startTime() external view returns (uint256);
78	 function epochDuration() external view returns (uint256);
79	 function totalRewardsForEpoch(uint256) external view returns (uint256);
80	 function numberOfEpochs() external view returns (uint256);
81	 function vestingEpochs() external view returns (uint256);
82	 function baseToken() external view returns (address);
83	 function underlyingAsset() external view returns (address);
84	 function underlyingYieldToken() external view returns (address);
85	 function pendleTokenAddress() external view returns (address);
86	 function marketFactoryId() external view returns (bytes32);
87	 function forgeId() external view returns (bytes32);
88	 function forge() external view returns (address);
89	 function readAllExpiriesLength() external view returns (uint256);
90	 }
91	 pragma solidity >=0.6.0 <0.8.0;
92	 abstract contract ReentrancyGuard {
93	 uint256 private constant _NOT_ENTERED = 1;
94	 uint256 private constant _ENTERED = 2;
95	 uint256 private _status;
96	 constructor () internal {
97	 _status = _NOT_ENTERED;
98	 }
99	 modifier nonReentrant() {
100	 require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
101	 _status = _ENTERED;
102	 _;
103	 _status = _NOT_ENTERED;
104	 }
105	 }
106	 pragma solidity 0.7.6;
107	 abstract contract WithdrawableV2 is PermissionsV2 {
108	 using SafeERC20 for IERC20;
109	 event EtherWithdraw(uint256 amount, address sendTo);
110	 event TokenWithdraw(IERC20 token, uint256 amount, address sendTo);
111	 function withdrawEther(uint256 amount, address payable sendTo) external onlyGovernance {
112	 (bool success, ) = sendTo.call{
113	 value: amount}
114	 ("");
115	 require(success, "WITHDRAW_FAILED");
116	 emit EtherWithdraw(amount, sendTo);
117	 }
118	 function withdrawToken( IERC20 token, uint256 amount, address sendTo ) external onlyGovernance {
119	 require(_allowedToWithdraw(address(token)), "TOKEN_NOT_ALLOWED");
120	 token.safeTransfer(sendTo, amount);
121	 emit TokenWithdraw(token, amount, sendTo);
122	 }
123	 function _allowedToWithdraw(address) internal view virtual returns (bool allowed);
124	 }
125	 pragma solidity 0.7.6;
126	 contract PendleRedeemProxy {
127	 IPendleRouter public immutable router;
128	 constructor(address _router) {
129	 require(_router != address(0), "ZERO_ADDRESS");
130	 router = IPendleRouter(_router);
131	 }
132	 struct Args {
133	 address[] xyts;
134	 address[] markets;
135	 address[] lmContractsForRewards;
136	 uint256[] expiriesForRewards;
137	 address[] lmContractsForInterests;
138	 uint256[] expiriesForInterests;
139	 address[] lmV2ContractsForRewards;
140	 address[] lmV2ContractsForInterests;
141	 }
142	 function redeem(Args calldata args, address user) external returns ( uint256[] memory xytInterests, uint256[] memory marketInterests, uint256[] memory lmRewards, string[] memory lmRewardsFailureReasons, uint256[] memory lmInterests, string[] memory lmInterestsFailureReasons, uint256[] memory lmV2Rewards, uint256[] memory lmV2Interests ) {
143	 xytInterests = redeemXyts(args.xyts);
144	 marketInterests = redeemMarkets(args.markets);
145	 (lmRewards, lmRewardsFailureReasons) = redeemLmRewards(args.lmContractsForRewards, args.expiriesForRewards, user);
146	 (lmInterests, lmInterestsFailureReasons) = redeemLmInterests( args.lmContractsForInterests, args.expiriesForInterests, user );
147	 lmV2Rewards = redeemLmV2Rewards(args.lmV2ContractsForRewards, user);
148	 lmV2Interests = redeemLmV2Interests(args.lmV2ContractsForInterests, user);
149	 }
150	 function redeemXyts(address[] calldata xyts) public returns (uint256[] memory xytInterests) {
151	 xytInterests = new uint256[](xyts.length);
152	 for (uint256 i = 0; i < xyts.length; i++) {
153	 IPendleYieldToken xyt = IPendleYieldToken(xyts[i]);
154	 bytes32 forgeId = IPendleForge(xyt.forge()).forgeId();
155	 address underlyingAsset = xyt.underlyingAsset();
156	 uint256 expiry = xyt.expiry();
157	 xytInterests[i] = router.redeemDueInterests( forgeId, underlyingAsset, expiry, msg.sender );
158	 }
159	 }
160	 function redeemMarkets(address[] calldata markets) public returns (uint256[] memory marketInterests) {
161	 uint256 marketCount = markets.length;
162	 marketInterests = new uint256[](marketCount);
163	 for (uint256 i = 0; i < marketCount; i++) {
164	 marketInterests[i] = router.redeemLpInterests(markets[i], msg.sender);
165	 }
166	 }
167	 function redeemLmRewards( address[] calldata lmContractsForRewards, uint256[] calldata expiriesForRewards, address user ) public returns (uint256[] memory lmRewards, string[] memory failureReasons) {
168	 uint256 count = expiriesForRewards.length;
169	 require(count == lmContractsForRewards.length, "ARRAY_LENGTH_MISMATCH");
170	 lmRewards = new uint256[](count);
171	 failureReasons = new string[](count);
172	 for (uint256 i = 0; i < count; i++) {
173	 try PendleLiquidityMiningBase(lmContractsForRewards[i]).redeemRewards( expiriesForRewards[i], user ) returns (uint256 lmReward) {
174	 lmRewards[i] = lmReward;
175	 failureReasons[i] = "";
176	 }
177	 catch Error(string memory reason) {
178	 lmRewards[i] = 0;
179	 failureReasons[i] = reason;
180	 }
181	 }
182	 }
183	 function redeemLmInterests( address[] calldata lmContractsForInterests, uint256[] calldata expiriesForInterests, address user ) public returns (uint256[] memory lmInterests, string[] memory failureReasons) {
184	 uint256 count = expiriesForInterests.length;
185	 require(count == lmContractsForInterests.length, "ARRAY_LENGTH_MISMATCH");
186	 lmInterests = new uint256[](count);
187	 failureReasons = new string[](count);
188	 for (uint256 i = 0; i < count; i++) {
189	 try IPendleLiquidityMining(lmContractsForInterests[i]).redeemLpInterests( expiriesForInterests[i], user ) returns (uint256 lmInterest) {
190	 lmInterests[i] = lmInterest;
191	 failureReasons[i] = "";
192	 }
193	 catch Error(string memory reason) {
194	 lmInterests[i] = 0;
195	 failureReasons[i] = reason;
196	 }
197	 }
198	 }
199	 function redeemLmV2Rewards(address[] calldata lmV2ContractsForRewards, address user) public returns (uint256[] memory lmV2Rewards) {
200	 uint256 count = lmV2ContractsForRewards.length;
201	 lmV2Rewards = new uint256[](count);
202	 for (uint256 i = 0; i < count; i++) {
203	 lmV2Rewards[i] = IPendleLiquidityMiningV2(lmV2ContractsForRewards[i]).redeemRewards( user );
204	 }
205	 }
206	 function redeemLmV2Interests(address[] calldata lmV2ContractsForInterests, address user) public returns (uint256[] memory lmV2Interests) {
207	 uint256 count = lmV2ContractsForInterests.length;
208	 lmV2Interests = new uint256[](count);
209	 for (uint256 i = 0; i < count; i++) {
210	 lmV2Interests[i] = IPendleLiquidityMiningV2(lmV2ContractsForInterests[i]) .redeemDueInterests(user);
211	 }
212	 }
213	 }
214	 pragma solidity 0.7.6;
215	 interface IPendleRouter {
216	 event MarketCreated( bytes32 marketFactoryId, address indexed xyt, address indexed token, address indexed market );
217	 event SwapEvent( address indexed trader, address inToken, address outToken, uint256 exactIn, uint256 exactOut, address market );
218	 event Join( address indexed sender, uint256 token0Amount, uint256 token1Amount, address market, uint256 exactOutLp );
219	 event Exit( address indexed sender, uint256 token0Amount, uint256 token1Amount, address market, uint256 exactInLp );
220	 function data() external view returns (IPendleData);
221	 function weth() external view returns (IWETH);
222	 function newYieldContracts( bytes32 forgeId, address underlyingAsset, uint256 expiry ) external returns (address ot, address xyt);
223	 function redeemAfterExpiry( bytes32 forgeId, address underlyingAsset, uint256 expiry ) external returns (uint256 redeemedAmount);
224	 function redeemDueInterests( bytes32 forgeId, address underlyingAsset, uint256 expiry, address user ) external returns (uint256 interests);
225	 function redeemUnderlying( bytes32 forgeId, address underlyingAsset, uint256 expiry, uint256 amountToRedeem ) external returns (uint256 redeemedAmount);
226	 function renewYield( bytes32 forgeId, uint256 oldExpiry, address underlyingAsset, uint256 newExpiry, uint256 renewalRate ) external returns ( uint256 redeemedAmount, uint256 amountRenewed, address ot, address xyt, uint256 amountTokenMinted );
227	 function tokenizeYield( bytes32 forgeId, address underlyingAsset, uint256 expiry, uint256 amountToTokenize, address to ) external returns ( address ot, address xyt, uint256 amountTokenMinted );
228	 function addMarketLiquidityDual( bytes32 _marketFactoryId, address _xyt, address _token, uint256 _desiredXytAmount, uint256 _desiredTokenAmount, uint256 _xytMinAmount, uint256 _tokenMinAmount ) external payable returns ( uint256 amountXytUsed, uint256 amountTokenUsed, uint256 lpOut );
229	 function addMarketLiquiditySingle( bytes32 marketFactoryId, address xyt, address token, bool forXyt, uint256 exactInAsset, uint256 minOutLp ) external payable returns (uint256 exactOutLp);
230	 function removeMarketLiquidityDual( bytes32 marketFactoryId, address xyt, address token, uint256 exactInLp, uint256 minOutXyt, uint256 minOutToken ) external returns (uint256 exactOutXyt, uint256 exactOutToken);
231	 function removeMarketLiquiditySingle( bytes32 marketFactoryId, address xyt, address token, bool forXyt, uint256 exactInLp, uint256 minOutAsset ) external returns (uint256 exactOutXyt, uint256 exactOutToken);
232	 function createMarket( bytes32 marketFactoryId, address xyt, address token ) external returns (address market);
233	 function bootstrapMarket( bytes32 marketFactoryId, address xyt, address token, uint256 initialXytLiquidity, uint256 initialTokenLiquidity ) external payable;
234	 function swapExactIn( address tokenIn, address tokenOut, uint256 inTotalAmount, uint256 minOutTotalAmount, bytes32 marketFactoryId ) external payable returns (uint256 outTotalAmount);
235	 function swapExactOut( address tokenIn, address tokenOut, uint256 outTotalAmount, uint256 maxInTotalAmount, bytes32 marketFactoryId ) external payable returns (uint256 inTotalAmount);
236	 function redeemLpInterests(address market, address user) external returns (uint256 interests);
237	 }
238	 pragma solidity 0.7.6;
239	 interface IPendleForge {
240	 event MintYieldTokens( bytes32 forgeId, address indexed underlyingAsset, uint256 indexed expiry, uint256 amountToTokenize, uint256 amountTokenMinted, address indexed user );
241	 event NewYieldContracts( bytes32 forgeId, address indexed underlyingAsset, uint256 indexed expiry, address ot, address xyt, address yieldBearingAsset );
242	 event RedeemYieldToken( bytes32 forgeId, address indexed underlyingAsset, uint256 indexed expiry, uint256 amountToRedeem, uint256 redeemedAmount, address indexed user );
243	 event DueInterestsSettled( bytes32 forgeId, address indexed underlyingAsset, uint256 indexed expiry, uint256 amount, uint256 forgeFeeAmount, address indexed user );
244	 event ForgeFeeWithdrawn( bytes32 forgeId, address indexed underlyingAsset, uint256 indexed expiry, uint256 amount );
245	 function setUpEmergencyMode( address _underlyingAsset, uint256 _expiry, address spender ) external;
246	 function newYieldContracts(address underlyingAsset, uint256 expiry) external returns (address ot, address xyt);
247	 function redeemAfterExpiry( address user, address underlyingAsset, uint256 expiry ) external returns (uint256 redeemedAmount);
248	 function redeemDueInterests( address user, address underlyingAsset, uint256 expiry ) external returns (uint256 interests);
249	 function updateDueInterests( address underlyingAsset, uint256 expiry, address user ) external;
250	 function updatePendingRewards( address _underlyingAsset, uint256 _expiry, address _user ) external;
251	 function redeemUnderlying( address user, address underlyingAsset, uint256 expiry, uint256 amountToRedeem ) external returns (uint256 redeemedAmount);
252	 function mintOtAndXyt( address underlyingAsset, uint256 expiry, uint256 amountToTokenize, address to ) external returns ( address ot, address xyt, uint256 amountTokenMinted );
253	 function withdrawForgeFee(address underlyingAsset, uint256 expiry) external;
254	 function getYieldBearingToken(address underlyingAsset) external returns (address);
255	 function router() external view returns (IPendleRouter);
256	 function data() external view returns (IPendleData);
257	 function rewardManager() external view returns (IPendleRewardManager);
258	 function yieldContractDeployer() external view returns (IPendleYieldContractDeployer);
259	 function rewardToken() external view returns (IERC20);
260	 function forgeId() external view returns (bytes32);
261	 function dueInterests( address _underlyingAsset, uint256 expiry, address _user ) external view returns (uint256);
262	 function yieldTokenHolders(address _underlyingAsset, uint256 _expiry) external view returns (address yieldTokenHolder);
263	 }
264	 pragma solidity 0.7.6;
265	 abstract contract PendleLiquidityMiningBase is IPendleLiquidityMining, WithdrawableV2, ReentrancyGuard {
266	 using Math for uint256;
267	 using SafeMath for uint256;
268	 using SafeERC20 for IERC20;
269	 struct UserExpiries {
270	 uint256[] expiries;
271	 mapping(uint256 => bool) hasExpiry;
272	 }
273	 struct EpochData {
274	 mapping(uint256 => uint256) stakeUnitsForExpiry;
275	 mapping(uint256 => uint256) lastUpdatedForExpiry;
276	 mapping(address => uint256) availableRewardsForUser;
277	 mapping(address => mapping(uint256 => uint256)) stakeUnitsForUser;
278	 uint256 settingId;
279	 uint256 totalRewards;
280	 }
281	 struct ExpiryData {
282	 mapping(address => uint256) lastTimeUserStakeUpdated;
283	 mapping(address => uint256) lastEpochClaimed;
284	 uint256 totalStakeLP;
285	 address lpHolder;
286	 mapping(address => uint256) balances;
287	 uint256 lastNYield;
288	 uint256 paramL;
289	 mapping(address => uint256) lastParamL;
290	 mapping(address => uint256) dueInterests;
291	 }
292	 struct LatestSetting {
293	 uint256 id;
294	 uint256 firstEpochToApply;
295	 }
296	 IPendleWhitelist public immutable whitelist;
297	 IPendleRouter public immutable router;
298	 IPendleData public immutable data;
299	 address public immutable override pendleTokenAddress;
300	 bytes32 public immutable override forgeId;
301	 address public immutable override forge;
302	 bytes32 public immutable override marketFactoryId;
303	 IPendlePausingManager private immutable pausingManager;
304	 address public immutable override underlyingAsset;
305	 address public immutable override underlyingYieldToken;
306	 address public immutable override baseToken;
307	 uint256 public immutable override startTime;
308	 uint256 public immutable override epochDuration;
309	 uint256 public override numberOfEpochs;
310	 uint256 public immutable override vestingEpochs;
311	 bool public funded;
312	 uint256[] public allExpiries;
313	 uint256 private constant ALLOCATION_DENOMINATOR = 1_000_000_000;
314	 uint256 internal constant MULTIPLIER = 10**20;
315	 mapping(uint256 => mapping(uint256 => uint256)) public allocationSettings;
316	 LatestSetting public latestSetting;
317	 mapping(uint256 => ExpiryData) internal expiryData;
318	 mapping(uint256 => EpochData) private epochData;
319	 mapping(address => UserExpiries) private userExpiries;
320	 modifier isFunded() {
321	 require(funded, "NOT_FUNDED");
322	 _;
323	 }
324	 modifier nonContractOrWhitelisted() {
325	 bool isEOA = !Address.isContract(msg.sender) && tx.origin == msg.sender;
326	 require(isEOA || whitelist.whitelisted(msg.sender), "CONTRACT_NOT_WHITELISTED");
327	 _;
328	 }
329	 constructor( address _governanceManager, address _pausingManager, address _whitelist, address _pendleTokenAddress, address _router, bytes32 _marketFactoryId, bytes32 _forgeId, address _underlyingAsset, address _baseToken, uint256 _startTime, uint256 _epochDuration, uint256 _vestingEpochs ) PermissionsV2(_governanceManager) {
330	 require(_startTime > block.timestamp, "START_TIME_OVER");
331	 require(IERC20(_pendleTokenAddress).totalSupply() > 0, "INVALID_ERC20");
332	 require(IERC20(_underlyingAsset).totalSupply() > 0, "INVALID_ERC20");
333	 require(IERC20(_baseToken).totalSupply() > 0, "INVALID_ERC20");
334	 require(_vestingEpochs > 0, "INVALID_VESTING_EPOCHS");
335	 pendleTokenAddress = _pendleTokenAddress;
336	 router = IPendleRouter(_router);
337	 whitelist = IPendleWhitelist(_whitelist);
338	 IPendleData _dataTemp = IPendleRouter(_router).data();
339	 data = _dataTemp;
340	 require( _dataTemp.getMarketFactoryAddress(_marketFactoryId) != address(0), "INVALID_MARKET_FACTORY_ID" );
341	 require(_dataTemp.getForgeAddress(_forgeId) != address(0), "INVALID_FORGE_ID");
342	 address _forgeTemp = _dataTemp.getForgeAddress(_forgeId);
343	 forge = _forgeTemp;
344	 underlyingYieldToken = IPendleForge(_forgeTemp).getYieldBearingToken(_underlyingAsset);
345	 pausingManager = IPendlePausingManager(_pausingManager);
346	 marketFactoryId = _marketFactoryId;
347	 forgeId = _forgeId;
348	 underlyingAsset = _underlyingAsset;
349	 baseToken = _baseToken;
350	 startTime = _startTime;
351	 epochDuration = _epochDuration;
352	 vestingEpochs = _vestingEpochs;
353	 }
354	 function setUpEmergencyMode(uint256[] calldata expiries, address spender) external override {
355	 (, bool emergencyMode) = pausingManager.checkLiqMiningStatus(address(this));
356	 require(emergencyMode, "NOT_EMERGENCY");
357	 (address liqMiningEmergencyHandler, , ) = pausingManager.liqMiningEmergencyHandler();
358	 require(msg.sender == liqMiningEmergencyHandler, "NOT_EMERGENCY_HANDLER");
359	 for (uint256 i = 0; i < expiries.length; i++) {
360	 IPendleLpHolder(expiryData[expiries[i]].lpHolder).setUpEmergencyMode(spender);
361	 }
362	 IERC20(pendleTokenAddress).approve(spender, type(uint256).max);
363	 }
364	 function fund(uint256[] calldata _rewards) external override onlyGovernance {
365	 checkNotPaused();
366	 require(latestSetting.id > 0, "NO_ALLOC_SETTING");
367	 require(_getCurrentEpochId() <= numberOfEpochs, "LAST_EPOCH_OVER");
368	 uint256 nNewEpochs = _rewards.length;
369	 uint256 totalFunded;
370	 for (uint256 i = 0; i < nNewEpochs; i++) {
371	 totalFunded = totalFunded.add(_rewards[i]);
372	 epochData[numberOfEpochs + i + 1].totalRewards = _rewards[i];
373	 }
374	 require(totalFunded > 0, "ZERO_FUND");
375	 funded = true;
376	 numberOfEpochs = numberOfEpochs.add(nNewEpochs);
377	 IERC20(pendleTokenAddress).safeTransferFrom(msg.sender, address(this), totalFunded);
378	 emit Funded(_rewards, numberOfEpochs);
379	 }
380	 function topUpRewards(uint256[] calldata _epochIds, uint256[] calldata _rewards) external override onlyGovernance isFunded {
381	 checkNotPaused();
382	 require(latestSetting.id > 0, "NO_ALLOC_SETTING");
383	 require(_epochIds.length == _rewards.length, "INVALID_ARRAYS");
384	 uint256 curEpoch = _getCurrentEpochId();
385	 uint256 endEpoch = numberOfEpochs;
386	 uint256 totalTopUp;
387	 for (uint256 i = 0; i < _epochIds.length; i++) {
388	 require(curEpoch < _epochIds[i] && _epochIds[i] <= endEpoch, "INVALID_EPOCH_ID");
389	 totalTopUp = totalTopUp.add(_rewards[i]);
390	 epochData[_epochIds[i]].totalRewards = epochData[_epochIds[i]].totalRewards.add( _rewards[i] );
391	 }
392	 require(totalTopUp > 0, "ZERO_FUND");
393	 IERC20(pendleTokenAddress).safeTransferFrom(msg.sender, address(this), totalTopUp);
394	 emit RewardsToppedUp(_epochIds, _rewards);
395	 }
396	 function setAllocationSetting( uint256[] calldata _expiries, uint256[] calldata _allocationNumerators ) external onlyGovernance {
397	 checkNotPaused();
398	 require(_expiries.length == _allocationNumerators.length, "INVALID_ALLOCATION");
399	 if (latestSetting.id == 0) {
400	 require(block.timestamp < startTime, "LATE_FIRST_ALLOCATION");
401	 }
402	 uint256 curEpoch = _getCurrentEpochId();
403	 for (uint256 i = latestSetting.firstEpochToApply; i <= curEpoch; i++) {
404	 epochData[i].settingId = latestSetting.id;
405	 }
406	 latestSetting.firstEpochToApply = curEpoch + 1;
407	 latestSetting.id++;
408	 uint256 sumAllocationNumerators;
409	 for (uint256 _i = 0; _i < _expiries.length; _i++) {
410	 allocationSettings[latestSetting.id][_expiries[_i]] = _allocationNumerators[_i];
411	 sumAllocationNumerators = sumAllocationNumerators.add(_allocationNumerators[_i]);
412	 }
413	 require(sumAllocationNumerators == ALLOCATION_DENOMINATOR, "INVALID_ALLOCATION");
414	 emit AllocationSettingSet(_expiries, _allocationNumerators);
415	 }
416	 function stake(uint256 expiry, uint256 amount) external override isFunded nonReentrant nonContractOrWhitelisted returns (address newLpHoldingContractAddress) {
417	 checkNotPaused();
418	 newLpHoldingContractAddress = _stake(expiry, amount);
419	 }
420	 function stakeWithPermit( uint256 expiry, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s ) external override isFunded nonReentrant nonContractOrWhitelisted returns (address newLpHoldingContractAddress) {
421	 checkNotPaused();
422	 address xyt = address(data.xytTokens(forgeId, underlyingAsset, expiry));
423	 address marketAddress = data.getMarket(marketFactoryId, xyt, baseToken);
424	 IPendleYieldToken(marketAddress).permit( msg.sender, address(this), amount, deadline, v, r, s );
425	 newLpHoldingContractAddress = _stake(expiry, amount);
426	 }
427	 function withdraw(uint256 expiry, uint256 amount) external override nonReentrant isFunded {
428	 checkNotPaused();
429	 uint256 curEpoch = _getCurrentEpochId();
430	 require(curEpoch > 0, "NOT_STARTED");
431	 require(amount != 0, "ZERO_AMOUNT");
432	 ExpiryData storage exd = expiryData[expiry];
433	 require(exd.balances[msg.sender] >= amount, "INSUFFICIENT_BALANCE");
434	 _pushLpToken(expiry, amount);
435	 emit Withdrawn(expiry, msg.sender, amount);
436	 }
437	 function redeemRewards(uint256 expiry, address user) external override isFunded nonReentrant returns (uint256 rewards) {
438	 checkNotPaused();
439	 uint256 curEpoch = _getCurrentEpochId();
440	 require(curEpoch > 0, "NOT_STARTED");
441	 require(user != address(0), "ZERO_ADDRESS");
442	 require(userExpiries[user].hasExpiry[expiry], "INVALID_EXPIRY");
443	 rewards = _beforeTransferPendingRewards(expiry, user);
444	 if (rewards != 0) {
445	 IERC20(pendleTokenAddress).safeTransfer(user, rewards);
446	 }
447	 }
448	 function redeemLpInterests(uint256 expiry, address user) external override nonReentrant returns (uint256 interests) {
449	 checkNotPaused();
450	 require(user != address(0), "ZERO_ADDRESS");
451	 require(userExpiries[user].hasExpiry[expiry], "INVALID_EXPIRY");
452	 interests = _beforeTransferDueInterests(expiry, user);
453	 _safeTransferYieldToken(expiry, user, interests);
454	 }
455	 function totalRewardsForEpoch(uint256 epochId) external view override returns (uint256 rewards) {
456	 rewards = epochData[epochId].totalRewards;
457	 }
458	 function readUserExpiries(address _user) external view override returns (uint256[] memory _expiries) {
459	 _expiries = userExpiries[_user].expiries;
460	 }
461	 function getBalances(uint256 expiry, address user) external view override returns (uint256) {
462	 return expiryData[expiry].balances[user];
463	 }
464	 function lpHolderForExpiry(uint256 expiry) external view override returns (address) {
465	 return expiryData[expiry].lpHolder;
466	 }
467	 function readExpiryData(uint256 expiry) external view returns ( uint256 totalStakeLP, uint256 lastNYield, uint256 paramL, address lpHolder ) {
468	 totalStakeLP = expiryData[expiry].totalStakeLP;
469	 lastNYield = expiryData[expiry].lastNYield;
470	 paramL = expiryData[expiry].paramL;
471	 lpHolder = expiryData[expiry].lpHolder;
472	 }
473	 function readUserSpecificExpiryData(uint256 expiry, address user) external view returns ( uint256 lastTimeUserStakeUpdated, uint256 lastEpochClaimed, uint256 balances, uint256 lastParamL, uint256 dueInterests ) {
474	 lastTimeUserStakeUpdated = expiryData[expiry].lastTimeUserStakeUpdated[user];
475	 lastEpochClaimed = expiryData[expiry].lastEpochClaimed[user];
476	 balances = expiryData[expiry].balances[user];
477	 lastParamL = expiryData[expiry].lastParamL[user];
478	 dueInterests = expiryData[expiry].dueInterests[user];
479	 }
480	 function readEpochData(uint256 epochId) external view returns (uint256 settingId, uint256 totalRewards) {
481	 settingId = epochData[epochId].settingId;
482	 totalRewards = epochData[epochId].totalRewards;
483	 }
484	 function readExpirySpecificEpochData(uint256 epochId, uint256 expiry) external view returns (uint256 stakeUnits, uint256 lastUpdatedForExpiry) {
485	 stakeUnits = epochData[epochId].stakeUnitsForExpiry[expiry];
486	 lastUpdatedForExpiry = epochData[epochId].lastUpdatedForExpiry[expiry];
487	 }
488	 function readAvailableRewardsForUser(uint256 epochId, address user) external view returns (uint256 availableRewardsForUser) {
489	 availableRewardsForUser = epochData[epochId].availableRewardsForUser[user];
490	 }
491	 function readStakeUnitsForUser( uint256 epochId, address user, uint256 expiry ) external view returns (uint256 stakeUnitsForUser) {
492	 stakeUnitsForUser = epochData[epochId].stakeUnitsForUser[user][expiry];
493	 }
494	 function readAllExpiriesLength() external view override returns (uint256 length) {
495	 length = allExpiries.length;
496	 }
497	 function checkNotPaused() internal {
498	 (bool paused, ) = pausingManager.checkLiqMiningStatus(address(this));
499	 require(!paused, "LIQ_MINING_PAUSED");
500	 }
501	 function _stake(uint256 expiry, uint256 amount) internal returns (address newLpHoldingContractAddress) {
502	 ExpiryData storage exd = expiryData[expiry];
503	 uint256 curEpoch = _getCurrentEpochId();
504	 require(curEpoch > 0, "NOT_STARTED");
505	 require(curEpoch <= numberOfEpochs, "INCENTIVES_PERIOD_OVER");
506	 require(amount != 0, "ZERO_AMOUNT");
507	 address xyt = address(data.xytTokens(forgeId, underlyingAsset, expiry));
508	 address marketAddress = data.getMarket(marketFactoryId, xyt, baseToken);
509	 require(xyt != address(0), "YT_NOT_FOUND");
510	 require(marketAddress != address(0), "MARKET_NOT_FOUND");
511	 if (exd.lpHolder == address(0)) {
512	 newLpHoldingContractAddress = _addNewExpiry(expiry, marketAddress);
513	 }
514	 if (!userExpiries[msg.sender].hasExpiry[expiry]) {
515	 userExpiries[msg.sender].expiries.push(expiry);
516	 userExpiries[msg.sender].hasExpiry[expiry] = true;
517	 }
518	 _pullLpToken(marketAddress, expiry, amount);
519	 emit Staked(expiry, msg.sender, amount);
520	 }
521	 function _updateStakeDataForExpiry(uint256 expiry) internal {
522	 uint256 _curEpoch = _getCurrentEpochId();
523	 for (uint256 i = Math.min(_curEpoch, numberOfEpochs); i > 0; i--) {
524	 uint256 epochEndTime = _endTimeOfEpoch(i);
525	 uint256 lastUpdatedForEpoch = epochData[i].lastUpdatedForExpiry[expiry];
526	 if (lastUpdatedForEpoch == epochEndTime) {
527	 break;
528	 }
529	 epochData[i].stakeUnitsForExpiry[expiry] = epochData[i] .stakeUnitsForExpiry[expiry] .add( _calcUnitsStakeInEpoch(expiryData[expiry].totalStakeLP, lastUpdatedForEpoch, i) );
530	 epochData[i].lastUpdatedForExpiry[expiry] = Math.min(block.timestamp, epochEndTime);
531	 }
532	 }
533	 function _updatePendingRewards(uint256 expiry, address user) internal {
534	 _updateStakeDataForExpiry(expiry);
535	 ExpiryData storage exd = expiryData[expiry];
536	 if (exd.lastTimeUserStakeUpdated[user] == 0) {
537	 exd.lastTimeUserStakeUpdated[user] = block.timestamp;
538	 return;
539	 }
540	 uint256 _curEpoch = _getCurrentEpochId();
541	 uint256 _endEpoch = Math.min(numberOfEpochs, _curEpoch);
542	 bool _isEndEpochOver = (_curEpoch > numberOfEpochs);
543	 uint256 _startEpoch = _epochOfTimestamp(exd.lastTimeUserStakeUpdated[user]);
544	 for (uint256 epochId = _startEpoch; epochId <= _endEpoch; epochId++) {
545	 if (epochData[epochId].stakeUnitsForExpiry[expiry] == 0) {
546	 if (exd.totalStakeLP == 0) break;
547	 continue;
548	 }
549	 epochData[epochId].stakeUnitsForUser[user][expiry] = epochData[epochId] .stakeUnitsForUser[user][expiry].add( _calcUnitsStakeInEpoch( exd.balances[user], exd.lastTimeUserStakeUpdated[user], epochId ) );
550	 if (epochId == _endEpoch && !_isEndEpochOver) {
551	 break;
552	 }
553	 uint256 rewardsPerVestingEpoch = _calcAmountRewardsForUserInEpoch( expiry, user, epochId );
554	 for (uint256 i = epochId + 1; i <= epochId + vestingEpochs; i++) {
555	 epochData[i].availableRewardsForUser[user] = epochData[i] .availableRewardsForUser[user] .add(rewardsPerVestingEpoch);
556	 }
557	 }
558	 exd.lastTimeUserStakeUpdated[user] = block.timestamp;
559	 }
560	 function _calcAmountRewardsForUserInEpoch( uint256 expiry, address user, uint256 epochId ) internal view returns (uint256 rewardsPerVestingEpoch) {
561	 uint256 settingId = epochId >= latestSetting.firstEpochToApply ? latestSetting.id : epochData[epochId].settingId;
562	 uint256 rewardsForThisExpiry = epochData[epochId] .totalRewards .mul(allocationSettings[settingId][expiry]) .div(ALLOCATION_DENOMINATOR);
563	 rewardsPerVestingEpoch = rewardsForThisExpiry .mul(epochData[epochId].stakeUnitsForUser[user][expiry]) .div(epochData[epochId].stakeUnitsForExpiry[expiry]) .div(vestingEpochs);
564	 }
565	 function _calcUnitsStakeInEpoch( uint256 lpAmount, uint256 _startTime, uint256 _epochId ) internal view returns (uint256 stakeUnitsForUser) {
566	 uint256 _endTime = block.timestamp;
567	 uint256 _l = Math.max(_startTime, _startTimeOfEpoch(_epochId));
568	 uint256 _r = Math.min(_endTime, _endTimeOfEpoch(_epochId));
569	 uint256 durationStakeThisEpoch = _r.subMax0(_l);
570	 return lpAmount.mul(durationStakeThisEpoch);
571	 }
572	 function _pullLpToken( address marketAddress, uint256 expiry, uint256 amount ) internal {
573	 _updatePendingRewards(expiry, msg.sender);
574	 _updateDueInterests(expiry, msg.sender);
575	 ExpiryData storage exd = expiryData[expiry];
576	 exd.balances[msg.sender] = exd.balances[msg.sender].add(amount);
577	 exd.totalStakeLP = exd.totalStakeLP.add(amount);
578	 IERC20(marketAddress).safeTransferFrom(msg.sender, expiryData[expiry].lpHolder, amount);
579	 }
580	 function _pushLpToken(uint256 expiry, uint256 amount) internal {
581	 _updatePendingRewards(expiry, msg.sender);
582	 _updateDueInterests(expiry, msg.sender);
583	 ExpiryData storage exd = expiryData[expiry];
584	 exd.balances[msg.sender] = exd.balances[msg.sender].sub(amount);
585	 exd.totalStakeLP = exd.totalStakeLP.sub(amount);
586	 IPendleLpHolder(expiryData[expiry].lpHolder).sendLp(msg.sender, amount);
587	 }
588	 function _beforeTransferDueInterests(uint256 expiry, address user) internal returns (uint256 amountOut) {
589	 ExpiryData storage exd = expiryData[expiry];
590	 _updateDueInterests(expiry, user);
591	 amountOut = exd.dueInterests[user];
592	 exd.dueInterests[user] = 0;
593	 exd.lastNYield = exd.lastNYield.subMax0(amountOut);
594	 }
595	 function _safeTransferYieldToken( uint256 _expiry, address _user, uint256 _amount ) internal {
596	 if (_amount == 0) return;
597	 _amount = Math.min( _amount, IERC20(underlyingYieldToken).balanceOf(expiryData[_expiry].lpHolder) );
598	 IPendleLpHolder(expiryData[_expiry].lpHolder).sendInterests(_user, _amount);
599	 }
600	 function _beforeTransferPendingRewards(uint256 expiry, address user) internal returns (uint256 amountOut) {
601	 _updatePendingRewards(expiry, user);
602	 uint256 _lastEpoch = Math.min(_getCurrentEpochId(), numberOfEpochs + vestingEpochs);
603	 for (uint256 i = expiryData[expiry].lastEpochClaimed[user]; i <= _lastEpoch; i++) {
604	 if (epochData[i].availableRewardsForUser[user] > 0) {
605	 amountOut = amountOut.add(epochData[i].availableRewardsForUser[user]);
606	 epochData[i].availableRewardsForUser[user] = 0;
607	 }
608	 }
609	 expiryData[expiry].lastEpochClaimed[user] = _lastEpoch;
610	 emit PendleRewardsSettled(expiry, user, amountOut);
611	 return amountOut;
612	 }
613	 function checkNeedUpdateParamL(uint256 expiry) internal returns (bool) {
614	 return _getIncomeIndexIncreaseRate(expiry) > data.interestUpdateRateDeltaForMarket();
615	 }
616	 function _updateParamL(uint256 expiry) internal {
617	 ExpiryData storage exd = expiryData[expiry];
618	 if (!checkNeedUpdateParamL(expiry)) return;
619	 IPendleLpHolder(exd.lpHolder).redeemLpInterests();
620	 uint256 currentNYield = IERC20(underlyingYieldToken).balanceOf(exd.lpHolder);
621	 (uint256 firstTerm, uint256 paramR) = _getFirstTermAndParamR(expiry, currentNYield);
622	 uint256 secondTerm;
623	 if (exd.totalStakeLP != 0) secondTerm = paramR.mul(MULTIPLIER).div(exd.totalStakeLP);
624	 exd.paramL = firstTerm.add(secondTerm);
625	 exd.lastNYield = currentNYield;
626	 }
627	 function _addNewExpiry(uint256 expiry, address marketAddress) internal returns (address newLpHoldingContractAddress) {
628	 allExpiries.push(expiry);
629	 newLpHoldingContractAddress = address( new PendleLpHolder( address(governanceManager), marketAddress, address(router), underlyingYieldToken ) );
630	 expiryData[expiry].lpHolder = newLpHoldingContractAddress;
631	 _afterAddingNewExpiry(expiry);
632	 }
633	 function _getCurrentEpochId() internal view returns (uint256) {
634	 return _epochOfTimestamp(block.timestamp);
635	 }
636	 function _epochOfTimestamp(uint256 t) internal view returns (uint256) {
637	 if (t < startTime) return 0;
638	 return (t.sub(startTime)).div(epochDuration).add(1);
639	 }
640	 function _startTimeOfEpoch(uint256 t) internal view returns (uint256) {
641	 return startTime.add((t.sub(1)).mul(epochDuration));
642	 }
643	 function _endTimeOfEpoch(uint256 t) internal view returns (uint256) {
644	 return startTime.add(t.mul(epochDuration));
645	 }
646	 function _allowedToWithdraw(address _token) internal view override returns (bool allowed) {
647	 allowed = _token != pendleTokenAddress;
648	 }
649	 function _updateDueInterests(uint256 expiry, address user) internal virtual;
650	 function _getFirstTermAndParamR(uint256 expiry, uint256 currentNYield) internal virtual returns (uint256 firstTerm, uint256 paramR);
651	 function _afterAddingNewExpiry(uint256 expiry) internal virtual;
652	 function _getIncomeIndexIncreaseRate(uint256 expiry) internal virtual returns (uint256 increaseRate);
653	 }
654	 pragma solidity 0.7.6;
655	 interface IPendleLiquidityMiningV2 {
656	 event Funded(uint256[] rewards, uint256 numberOfEpochs);
657	 event RewardsToppedUp(uint256[] epochIds, uint256[] rewards);
658	 event Staked(address user, uint256 amount);
659	 event Withdrawn(address user, uint256 amount);
660	 event PendleRewardsSettled(address user, uint256 amount);
661	 function fund(uint256[] calldata rewards) external;
662	 function topUpRewards(uint256[] calldata epochIds, uint256[] calldata rewards) external;
663	 function stake(address forAddr, uint256 amount) external;
664	 function withdraw(address toAddr, uint256 amount) external;
665	 function redeemRewards(address user) external returns (uint256 rewards);
666	 function redeemDueInterests(address user) external returns (uint256 amountOut);
667	 function setUpEmergencyMode(address spender, bool) external;
668	 function updateAndReadEpochData(uint256 epochId, address user) external returns ( uint256 totalStakeUnits, uint256 totalRewards, uint256 lastUpdated, uint256 stakeUnitsForUser, uint256 availableRewardsForUser );
669	 function balances(address user) external view returns (uint256);
670	 function startTime() external view returns (uint256);
671	 function epochDuration() external view returns (uint256);
672	 function readEpochData(uint256 epochId, address user) external view returns ( uint256 totalStakeUnits, uint256 totalRewards, uint256 lastUpdated, uint256 stakeUnitsForUser, uint256 availableRewardsForUser );
673	 function numberOfEpochs() external view returns (uint256);
674	 function vestingEpochs() external view returns (uint256);
675	 function stakeToken() external view returns (address);
676	 function yieldToken() external view returns (address);
677	 function pendleTokenAddress() external view returns (address);
678	 function totalStake() external view returns (uint256);
679	 function dueInterests(address) external view returns (uint256);
680	 function lastParamL(address) external view returns (uint256);
681	 function lastNYield() external view returns (uint256);
682	 function paramL() external view returns (uint256);
683	 }
684	 pragma solidity 0.7.6;
685	 interface IPendleYieldToken is IERC20, IPendleBaseToken {
686	 event Burn(address indexed user, uint256 amount);
687	 event Mint(address indexed user, uint256 amount);
688	 function burn(address user, uint256 amount) external;
689	 function mint(address user, uint256 amount) external;
690	 function forge() external view returns (IPendleForge);
691	 function underlyingAsset() external view returns (address);
692	 function underlyingYieldToken() external view returns (address);
693	 function approveRouter(address user) external;
694	 }
695	 pragma solidity >= 0.4.22 <0.9.0;
696	 library console {
697	 address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);
698	 function _sendLogPayload(bytes memory payload) private view {
699	 uint256 payloadLength = payload.length;
700	 address consoleAddress = CONSOLE_ADDRESS;
701	 assembly {
702	 let payloadStart := add(payload, 32) let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0) }
703	 }
704	 function log() internal view {
705	 _sendLogPayload(abi.encodeWithSignature("log()"));
706	 }
707	 function logInt(int p0) internal view {
708	 _sendLogPayload(abi.encodeWithSignature("log(int)", p0));
709	 }
710	 function logUint(uint p0) internal view {
711	 _sendLogPayload(abi.encodeWithSignature("log(uint)", p0));
712	 }
713	 function logString(string memory p0) internal view {
714	 _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
715	 }
716	 function logBool(bool p0) internal view {
717	 _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
718	 }
719	 function logAddress(address p0) internal view {
720	 _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
721	 }
722	 function logBytes(bytes memory p0) internal view {
723	 _sendLogPayload(abi.encodeWithSignature("log(bytes)", p0));
724	 }
725	 function logBytes1(bytes1 p0) internal view {
726	 _sendLogPayload(abi.encodeWithSignature("log(bytes1)", p0));
727	 }
728	 function logBytes2(bytes2 p0) internal view {
729	 _sendLogPayload(abi.encodeWithSignature("log(bytes2)", p0));
730	 }
731	 function logBytes3(bytes3 p0) internal view {
732	 _sendLogPayload(abi.encodeWithSignature("log(bytes3)", p0));
733	 }
734	 function logBytes4(bytes4 p0) internal view {
735	 _sendLogPayload(abi.encodeWithSignature("log(bytes4)", p0));
736	 }
737	 function logBytes5(bytes5 p0) internal view {
738	 _sendLogPayload(abi.encodeWithSignature("log(bytes5)", p0));
739	 }
740	 function logBytes6(bytes6 p0) internal view {
741	 _sendLogPayload(abi.encodeWithSignature("log(bytes6)", p0));
742	 }
743	 function logBytes7(bytes7 p0) internal view {
744	 _sendLogPayload(abi.encodeWithSignature("log(bytes7)", p0));
745	 }
746	 function logBytes8(bytes8 p0) internal view {
747	 _sendLogPayload(abi.encodeWithSignature("log(bytes8)", p0));
748	 }
749	 function logBytes9(bytes9 p0) internal view {
750	 _sendLogPayload(abi.encodeWithSignature("log(bytes9)", p0));
751	 }
752	 function logBytes10(bytes10 p0) internal view {
753	 _sendLogPayload(abi.encodeWithSignature("log(bytes10)", p0));
754	 }
755	 function logBytes11(bytes11 p0) internal view {
756	 _sendLogPayload(abi.encodeWithSignature("log(bytes11)", p0));
757	 }
758	 function logBytes12(bytes12 p0) internal view {
759	 _sendLogPayload(abi.encodeWithSignature("log(bytes12)", p0));
760	 }
761	 function logBytes13(bytes13 p0) internal view {
762	 _sendLogPayload(abi.encodeWithSignature("log(bytes13)", p0));
763	 }
764	 function logBytes14(bytes14 p0) internal view {
765	 _sendLogPayload(abi.encodeWithSignature("log(bytes14)", p0));
766	 }
767	 function logBytes15(bytes15 p0) internal view {
768	 _sendLogPayload(abi.encodeWithSignature("log(bytes15)", p0));
769	 }
770	 function logBytes16(bytes16 p0) internal view {
771	 _sendLogPayload(abi.encodeWithSignature("log(bytes16)", p0));
772	 }
773	 function logBytes17(bytes17 p0) internal view {
774	 _sendLogPayload(abi.encodeWithSignature("log(bytes17)", p0));
775	 }
776	 function logBytes18(bytes18 p0) internal view {
777	 _sendLogPayload(abi.encodeWithSignature("log(bytes18)", p0));
778	 }
779	 function logBytes19(bytes19 p0) internal view {
780	 _sendLogPayload(abi.encodeWithSignature("log(bytes19)", p0));
781	 }
782	 function logBytes20(bytes20 p0) internal view {
783	 _sendLogPayload(abi.encodeWithSignature("log(bytes20)", p0));
784	 }
785	 function logBytes21(bytes21 p0) internal view {
786	 _sendLogPayload(abi.encodeWithSignature("log(bytes21)", p0));
787	 }
788	 function logBytes22(bytes22 p0) internal view {
789	 _sendLogPayload(abi.encodeWithSignature("log(bytes22)", p0));
790	 }
791	 function logBytes23(bytes23 p0) internal view {
792	 _sendLogPayload(abi.encodeWithSignature("log(bytes23)", p0));
793	 }
794	 function logBytes24(bytes24 p0) internal view {
795	 _sendLogPayload(abi.encodeWithSignature("log(bytes24)", p0));
796	 }
797	 function logBytes25(bytes25 p0) internal view {
798	 _sendLogPayload(abi.encodeWithSignature("log(bytes25)", p0));
799	 }
800	 function logBytes26(bytes26 p0) internal view {
801	 _sendLogPayload(abi.encodeWithSignature("log(bytes26)", p0));
802	 }
803	 function logBytes27(bytes27 p0) internal view {
804	 _sendLogPayload(abi.encodeWithSignature("log(bytes27)", p0));
805	 }
806	 function logBytes28(bytes28 p0) internal view {
807	 _sendLogPayload(abi.encodeWithSignature("log(bytes28)", p0));
808	 }
809	 function logBytes29(bytes29 p0) internal view {
810	 _sendLogPayload(abi.encodeWithSignature("log(bytes29)", p0));
811	 }
812	 function logBytes30(bytes30 p0) internal view {
813	 _sendLogPayload(abi.encodeWithSignature("log(bytes30)", p0));
814	 }
815	 function logBytes31(bytes31 p0) internal view {
816	 _sendLogPayload(abi.encodeWithSignature("log(bytes31)", p0));
817	 }
818	 function logBytes32(bytes32 p0) internal view {
819	 _sendLogPayload(abi.encodeWithSignature("log(bytes32)", p0));
820	 }
821	 function log(uint p0) internal view {
822	 _sendLogPayload(abi.encodeWithSignature("log(uint)", p0));
823	 }
824	 function log(string memory p0) internal view {
825	 _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
826	 }
827	 function log(bool p0) internal view {
828	 _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
829	 }
830	 function log(address p0) internal view {
831	 _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
832	 }
833	 function log(uint p0, uint p1) internal view {
834	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint)", p0, p1));
835	 }
836	 function log(uint p0, string memory p1) internal view {
837	 _sendLogPayload(abi.encodeWithSignature("log(uint,string)", p0, p1));
838	 }
839	 function log(uint p0, bool p1) internal view {
840	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool)", p0, p1));
841	 }
842	 function log(uint p0, address p1) internal view {
843	 _sendLogPayload(abi.encodeWithSignature("log(uint,address)", p0, p1));
844	 }
845	 function log(string memory p0, uint p1) internal view {
846	 _sendLogPayload(abi.encodeWithSignature("log(string,uint)", p0, p1));
847	 }
848	 function log(string memory p0, string memory p1) internal view {
849	 _sendLogPayload(abi.encodeWithSignature("log(string,string)", p0, p1));
850	 }
851	 function log(string memory p0, bool p1) internal view {
852	 _sendLogPayload(abi.encodeWithSignature("log(string,bool)", p0, p1));
853	 }
854	 function log(string memory p0, address p1) internal view {
855	 _sendLogPayload(abi.encodeWithSignature("log(string,address)", p0, p1));
856	 }
857	 function log(bool p0, uint p1) internal view {
858	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint)", p0, p1));
859	 }
860	 function log(bool p0, string memory p1) internal view {
861	 _sendLogPayload(abi.encodeWithSignature("log(bool,string)", p0, p1));
862	 }
863	 function log(bool p0, bool p1) internal view {
864	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool)", p0, p1));
865	 }
866	 function log(bool p0, address p1) internal view {
867	 _sendLogPayload(abi.encodeWithSignature("log(bool,address)", p0, p1));
868	 }
869	 function log(address p0, uint p1) internal view {
870	 _sendLogPayload(abi.encodeWithSignature("log(address,uint)", p0, p1));
871	 }
872	 function log(address p0, string memory p1) internal view {
873	 _sendLogPayload(abi.encodeWithSignature("log(address,string)", p0, p1));
874	 }
875	 function log(address p0, bool p1) internal view {
876	 _sendLogPayload(abi.encodeWithSignature("log(address,bool)", p0, p1));
877	 }
878	 function log(address p0, address p1) internal view {
879	 _sendLogPayload(abi.encodeWithSignature("log(address,address)", p0, p1));
880	 }
881	 function log(uint p0, uint p1, uint p2) internal view {
882	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint)", p0, p1, p2));
883	 }
884	 function log(uint p0, uint p1, string memory p2) internal view {
885	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string)", p0, p1, p2));
886	 }
887	 function log(uint p0, uint p1, bool p2) internal view {
888	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool)", p0, p1, p2));
889	 }
890	 function log(uint p0, uint p1, address p2) internal view {
891	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address)", p0, p1, p2));
892	 }
893	 function log(uint p0, string memory p1, uint p2) internal view {
894	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint)", p0, p1, p2));
895	 }
896	 function log(uint p0, string memory p1, string memory p2) internal view {
897	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,string)", p0, p1, p2));
898	 }
899	 function log(uint p0, string memory p1, bool p2) internal view {
900	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool)", p0, p1, p2));
901	 }
902	 function log(uint p0, string memory p1, address p2) internal view {
903	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,address)", p0, p1, p2));
904	 }
905	 function log(uint p0, bool p1, uint p2) internal view {
906	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint)", p0, p1, p2));
907	 }
908	 function log(uint p0, bool p1, string memory p2) internal view {
909	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string)", p0, p1, p2));
910	 }
911	 function log(uint p0, bool p1, bool p2) internal view {
912	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool)", p0, p1, p2));
913	 }
914	 function log(uint p0, bool p1, address p2) internal view {
915	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address)", p0, p1, p2));
916	 }
917	 function log(uint p0, address p1, uint p2) internal view {
918	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint)", p0, p1, p2));
919	 }
920	 function log(uint p0, address p1, string memory p2) internal view {
921	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,string)", p0, p1, p2));
922	 }
923	 function log(uint p0, address p1, bool p2) internal view {
924	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool)", p0, p1, p2));
925	 }
926	 function log(uint p0, address p1, address p2) internal view {
927	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,address)", p0, p1, p2));
928	 }
929	 function log(string memory p0, uint p1, uint p2) internal view {
930	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint)", p0, p1, p2));
931	 }
932	 function log(string memory p0, uint p1, string memory p2) internal view {
933	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,string)", p0, p1, p2));
934	 }
935	 function log(string memory p0, uint p1, bool p2) internal view {
936	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool)", p0, p1, p2));
937	 }
938	 function log(string memory p0, uint p1, address p2) internal view {
939	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,address)", p0, p1, p2));
940	 }
941	 function log(string memory p0, string memory p1, uint p2) internal view {
942	 _sendLogPayload(abi.encodeWithSignature("log(string,string,uint)", p0, p1, p2));
943	 }
944	 function log(string memory p0, string memory p1, string memory p2) internal view {
945	 _sendLogPayload(abi.encodeWithSignature("log(string,string,string)", p0, p1, p2));
946	 }
947	 function log(string memory p0, string memory p1, bool p2) internal view {
948	 _sendLogPayload(abi.encodeWithSignature("log(string,string,bool)", p0, p1, p2));
949	 }
950	 function log(string memory p0, string memory p1, address p2) internal view {
951	 _sendLogPayload(abi.encodeWithSignature("log(string,string,address)", p0, p1, p2));
952	 }
953	 function log(string memory p0, bool p1, uint p2) internal view {
954	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint)", p0, p1, p2));
955	 }
956	 function log(string memory p0, bool p1, string memory p2) internal view {
957	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,string)", p0, p1, p2));
958	 }
959	 function log(string memory p0, bool p1, bool p2) internal view {
960	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool)", p0, p1, p2));
961	 }
962	 function log(string memory p0, bool p1, address p2) internal view {
963	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,address)", p0, p1, p2));
964	 }
965	 function log(string memory p0, address p1, uint p2) internal view {
966	 _sendLogPayload(abi.encodeWithSignature("log(string,address,uint)", p0, p1, p2));
967	 }
968	 function log(string memory p0, address p1, string memory p2) internal view {
969	 _sendLogPayload(abi.encodeWithSignature("log(string,address,string)", p0, p1, p2));
970	 }
971	 function log(string memory p0, address p1, bool p2) internal view {
972	 _sendLogPayload(abi.encodeWithSignature("log(string,address,bool)", p0, p1, p2));
973	 }
974	 function log(string memory p0, address p1, address p2) internal view {
975	 _sendLogPayload(abi.encodeWithSignature("log(string,address,address)", p0, p1, p2));
976	 }
977	 function log(bool p0, uint p1, uint p2) internal view {
978	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint)", p0, p1, p2));
979	 }
980	 function log(bool p0, uint p1, string memory p2) internal view {
981	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string)", p0, p1, p2));
982	 }
983	 function log(bool p0, uint p1, bool p2) internal view {
984	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool)", p0, p1, p2));
985	 }
986	 function log(bool p0, uint p1, address p2) internal view {
987	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address)", p0, p1, p2));
988	 }
989	 function log(bool p0, string memory p1, uint p2) internal view {
990	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint)", p0, p1, p2));
991	 }
992	 function log(bool p0, string memory p1, string memory p2) internal view {
993	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,string)", p0, p1, p2));
994	 }
995	 function log(bool p0, string memory p1, bool p2) internal view {
996	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool)", p0, p1, p2));
997	 }
998	 function log(bool p0, string memory p1, address p2) internal view {
999	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,address)", p0, p1, p2));
1000	 }
1001	 function log(bool p0, bool p1, uint p2) internal view {
1002	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint)", p0, p1, p2));
1003	 }
1004	 function log(bool p0, bool p1, string memory p2) internal view {
1005	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string)", p0, p1, p2));
1006	 }
1007	 function log(bool p0, bool p1, bool p2) internal view {
1008	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool)", p0, p1, p2));
1009	 }
1010	 function log(bool p0, bool p1, address p2) internal view {
1011	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address)", p0, p1, p2));
1012	 }
1013	 function log(bool p0, address p1, uint p2) internal view {
1014	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint)", p0, p1, p2));
1015	 }
1016	 function log(bool p0, address p1, string memory p2) internal view {
1017	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,string)", p0, p1, p2));
1018	 }
1019	 function log(bool p0, address p1, bool p2) internal view {
1020	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool)", p0, p1, p2));
1021	 }
1022	 function log(bool p0, address p1, address p2) internal view {
1023	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,address)", p0, p1, p2));
1024	 }
1025	 function log(address p0, uint p1, uint p2) internal view {
1026	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint)", p0, p1, p2));
1027	 }
1028	 function log(address p0, uint p1, string memory p2) internal view {
1029	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,string)", p0, p1, p2));
1030	 }
1031	 function log(address p0, uint p1, bool p2) internal view {
1032	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool)", p0, p1, p2));
1033	 }
1034	 function log(address p0, uint p1, address p2) internal view {
1035	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,address)", p0, p1, p2));
1036	 }
1037	 function log(address p0, string memory p1, uint p2) internal view {
1038	 _sendLogPayload(abi.encodeWithSignature("log(address,string,uint)", p0, p1, p2));
1039	 }
1040	 function log(address p0, string memory p1, string memory p2) internal view {
1041	 _sendLogPayload(abi.encodeWithSignature("log(address,string,string)", p0, p1, p2));
1042	 }
1043	 function log(address p0, string memory p1, bool p2) internal view {
1044	 _sendLogPayload(abi.encodeWithSignature("log(address,string,bool)", p0, p1, p2));
1045	 }
1046	 function log(address p0, string memory p1, address p2) internal view {
1047	 _sendLogPayload(abi.encodeWithSignature("log(address,string,address)", p0, p1, p2));
1048	 }
1049	 function log(address p0, bool p1, uint p2) internal view {
1050	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint)", p0, p1, p2));
1051	 }
1052	 function log(address p0, bool p1, string memory p2) internal view {
1053	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,string)", p0, p1, p2));
1054	 }
1055	 function log(address p0, bool p1, bool p2) internal view {
1056	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool)", p0, p1, p2));
1057	 }
1058	 function log(address p0, bool p1, address p2) internal view {
1059	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,address)", p0, p1, p2));
1060	 }
1061	 function log(address p0, address p1, uint p2) internal view {
1062	 _sendLogPayload(abi.encodeWithSignature("log(address,address,uint)", p0, p1, p2));
1063	 }
1064	 function log(address p0, address p1, string memory p2) internal view {
1065	 _sendLogPayload(abi.encodeWithSignature("log(address,address,string)", p0, p1, p2));
1066	 }
1067	 function log(address p0, address p1, bool p2) internal view {
1068	 _sendLogPayload(abi.encodeWithSignature("log(address,address,bool)", p0, p1, p2));
1069	 }
1070	 function log(address p0, address p1, address p2) internal view {
1071	 _sendLogPayload(abi.encodeWithSignature("log(address,address,address)", p0, p1, p2));
1072	 }
1073	 function log(uint p0, uint p1, uint p2, uint p3) internal view {
1074	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,uint)", p0, p1, p2, p3));
1075	 }
1076	 function log(uint p0, uint p1, uint p2, string memory p3) internal view {
1077	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,string)", p0, p1, p2, p3));
1078	 }
1079	 function log(uint p0, uint p1, uint p2, bool p3) internal view {
1080	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,bool)", p0, p1, p2, p3));
1081	 }
1082	 function log(uint p0, uint p1, uint p2, address p3) internal view {
1083	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,address)", p0, p1, p2, p3));
1084	 }
1085	 function log(uint p0, uint p1, string memory p2, uint p3) internal view {
1086	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,uint)", p0, p1, p2, p3));
1087	 }
1088	 function log(uint p0, uint p1, string memory p2, string memory p3) internal view {
1089	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,string)", p0, p1, p2, p3));
1090	 }
1091	 function log(uint p0, uint p1, string memory p2, bool p3) internal view {
1092	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,bool)", p0, p1, p2, p3));
1093	 }
1094	 function log(uint p0, uint p1, string memory p2, address p3) internal view {
1095	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,address)", p0, p1, p2, p3));
1096	 }
1097	 function log(uint p0, uint p1, bool p2, uint p3) internal view {
1098	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,uint)", p0, p1, p2, p3));
1099	 }
1100	 function log(uint p0, uint p1, bool p2, string memory p3) internal view {
1101	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,string)", p0, p1, p2, p3));
1102	 }
1103	 function log(uint p0, uint p1, bool p2, bool p3) internal view {
1104	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,bool)", p0, p1, p2, p3));
1105	 }
1106	 function log(uint p0, uint p1, bool p2, address p3) internal view {
1107	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,address)", p0, p1, p2, p3));
1108	 }
1109	 function log(uint p0, uint p1, address p2, uint p3) internal view {
1110	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,uint)", p0, p1, p2, p3));
1111	 }
1112	 function log(uint p0, uint p1, address p2, string memory p3) internal view {
1113	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,string)", p0, p1, p2, p3));
1114	 }
1115	 function log(uint p0, uint p1, address p2, bool p3) internal view {
1116	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,bool)", p0, p1, p2, p3));
1117	 }
1118	 function log(uint p0, uint p1, address p2, address p3) internal view {
1119	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,address)", p0, p1, p2, p3));
1120	 }
1121	 function log(uint p0, string memory p1, uint p2, uint p3) internal view {
1122	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,uint)", p0, p1, p2, p3));
1123	 }
1124	 function log(uint p0, string memory p1, uint p2, string memory p3) internal view {
1125	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,string)", p0, p1, p2, p3));
1126	 }
1127	 function log(uint p0, string memory p1, uint p2, bool p3) internal view {
1128	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,bool)", p0, p1, p2, p3));
1129	 }
1130	 function log(uint p0, string memory p1, uint p2, address p3) internal view {
1131	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,address)", p0, p1, p2, p3));
1132	 }
1133	 function log(uint p0, string memory p1, string memory p2, uint p3) internal view {
1134	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,uint)", p0, p1, p2, p3));
1135	 }
1136	 function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {
1137	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,string)", p0, p1, p2, p3));
1138	 }
1139	 function log(uint p0, string memory p1, string memory p2, bool p3) internal view {
1140	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,bool)", p0, p1, p2, p3));
1141	 }
1142	 function log(uint p0, string memory p1, string memory p2, address p3) internal view {
1143	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,address)", p0, p1, p2, p3));
1144	 }
1145	 function log(uint p0, string memory p1, bool p2, uint p3) internal view {
1146	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,uint)", p0, p1, p2, p3));
1147	 }
1148	 function log(uint p0, string memory p1, bool p2, string memory p3) internal view {
1149	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,string)", p0, p1, p2, p3));
1150	 }
1151	 function log(uint p0, string memory p1, bool p2, bool p3) internal view {
1152	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,bool)", p0, p1, p2, p3));
1153	 }
1154	 function log(uint p0, string memory p1, bool p2, address p3) internal view {
1155	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,address)", p0, p1, p2, p3));
1156	 }
1157	 function log(uint p0, string memory p1, address p2, uint p3) internal view {
1158	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,uint)", p0, p1, p2, p3));
1159	 }
1160	 function log(uint p0, string memory p1, address p2, string memory p3) internal view {
1161	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,string)", p0, p1, p2, p3));
1162	 }
1163	 function log(uint p0, string memory p1, address p2, bool p3) internal view {
1164	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,bool)", p0, p1, p2, p3));
1165	 }
1166	 function log(uint p0, string memory p1, address p2, address p3) internal view {
1167	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,address)", p0, p1, p2, p3));
1168	 }
1169	 function log(uint p0, bool p1, uint p2, uint p3) internal view {
1170	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,uint)", p0, p1, p2, p3));
1171	 }
1172	 function log(uint p0, bool p1, uint p2, string memory p3) internal view {
1173	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,string)", p0, p1, p2, p3));
1174	 }
1175	 function log(uint p0, bool p1, uint p2, bool p3) internal view {
1176	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,bool)", p0, p1, p2, p3));
1177	 }
1178	 function log(uint p0, bool p1, uint p2, address p3) internal view {
1179	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,address)", p0, p1, p2, p3));
1180	 }
1181	 function log(uint p0, bool p1, string memory p2, uint p3) internal view {
1182	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,uint)", p0, p1, p2, p3));
1183	 }
1184	 function log(uint p0, bool p1, string memory p2, string memory p3) internal view {
1185	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,string)", p0, p1, p2, p3));
1186	 }
1187	 function log(uint p0, bool p1, string memory p2, bool p3) internal view {
1188	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,bool)", p0, p1, p2, p3));
1189	 }
1190	 function log(uint p0, bool p1, string memory p2, address p3) internal view {
1191	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,address)", p0, p1, p2, p3));
1192	 }
1193	 function log(uint p0, bool p1, bool p2, uint p3) internal view {
1194	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,uint)", p0, p1, p2, p3));
1195	 }
1196	 function log(uint p0, bool p1, bool p2, string memory p3) internal view {
1197	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,string)", p0, p1, p2, p3));
1198	 }
1199	 function log(uint p0, bool p1, bool p2, bool p3) internal view {
1200	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,bool)", p0, p1, p2, p3));
1201	 }
1202	 function log(uint p0, bool p1, bool p2, address p3) internal view {
1203	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,address)", p0, p1, p2, p3));
1204	 }
1205	 function log(uint p0, bool p1, address p2, uint p3) internal view {
1206	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,uint)", p0, p1, p2, p3));
1207	 }
1208	 function log(uint p0, bool p1, address p2, string memory p3) internal view {
1209	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,string)", p0, p1, p2, p3));
1210	 }
1211	 function log(uint p0, bool p1, address p2, bool p3) internal view {
1212	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,bool)", p0, p1, p2, p3));
1213	 }
1214	 function log(uint p0, bool p1, address p2, address p3) internal view {
1215	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,address)", p0, p1, p2, p3));
1216	 }
1217	 function log(uint p0, address p1, uint p2, uint p3) internal view {
1218	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,uint)", p0, p1, p2, p3));
1219	 }
1220	 function log(uint p0, address p1, uint p2, string memory p3) internal view {
1221	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,string)", p0, p1, p2, p3));
1222	 }
1223	 function log(uint p0, address p1, uint p2, bool p3) internal view {
1224	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,bool)", p0, p1, p2, p3));
1225	 }
1226	 function log(uint p0, address p1, uint p2, address p3) internal view {
1227	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,address)", p0, p1, p2, p3));
1228	 }
1229	 function log(uint p0, address p1, string memory p2, uint p3) internal view {
1230	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,uint)", p0, p1, p2, p3));
1231	 }
1232	 function log(uint p0, address p1, string memory p2, string memory p3) internal view {
1233	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,string)", p0, p1, p2, p3));
1234	 }
1235	 function log(uint p0, address p1, string memory p2, bool p3) internal view {
1236	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,bool)", p0, p1, p2, p3));
1237	 }
1238	 function log(uint p0, address p1, string memory p2, address p3) internal view {
1239	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,address)", p0, p1, p2, p3));
1240	 }
1241	 function log(uint p0, address p1, bool p2, uint p3) internal view {
1242	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,uint)", p0, p1, p2, p3));
1243	 }
1244	 function log(uint p0, address p1, bool p2, string memory p3) internal view {
1245	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,string)", p0, p1, p2, p3));
1246	 }
1247	 function log(uint p0, address p1, bool p2, bool p3) internal view {
1248	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,bool)", p0, p1, p2, p3));
1249	 }
1250	 function log(uint p0, address p1, bool p2, address p3) internal view {
1251	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,address)", p0, p1, p2, p3));
1252	 }
1253	 function log(uint p0, address p1, address p2, uint p3) internal view {
1254	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,uint)", p0, p1, p2, p3));
1255	 }
1256	 function log(uint p0, address p1, address p2, string memory p3) internal view {
1257	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,string)", p0, p1, p2, p3));
1258	 }
1259	 function log(uint p0, address p1, address p2, bool p3) internal view {
1260	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,bool)", p0, p1, p2, p3));
1261	 }
1262	 function log(uint p0, address p1, address p2, address p3) internal view {
1263	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,address)", p0, p1, p2, p3));
1264	 }
1265	 function log(string memory p0, uint p1, uint p2, uint p3) internal view {
1266	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,uint)", p0, p1, p2, p3));
1267	 }
1268	 function log(string memory p0, uint p1, uint p2, string memory p3) internal view {
1269	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,string)", p0, p1, p2, p3));
1270	 }
1271	 function log(string memory p0, uint p1, uint p2, bool p3) internal view {
1272	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,bool)", p0, p1, p2, p3));
1273	 }
1274	 function log(string memory p0, uint p1, uint p2, address p3) internal view {
1275	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,address)", p0, p1, p2, p3));
1276	 }
1277	 function log(string memory p0, uint p1, string memory p2, uint p3) internal view {
1278	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,uint)", p0, p1, p2, p3));
1279	 }
1280	 function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {
1281	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,string)", p0, p1, p2, p3));
1282	 }
1283	 function log(string memory p0, uint p1, string memory p2, bool p3) internal view {
1284	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,bool)", p0, p1, p2, p3));
1285	 }
1286	 function log(string memory p0, uint p1, string memory p2, address p3) internal view {
1287	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,address)", p0, p1, p2, p3));
1288	 }
1289	 function log(string memory p0, uint p1, bool p2, uint p3) internal view {
1290	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,uint)", p0, p1, p2, p3));
1291	 }
1292	 function log(string memory p0, uint p1, bool p2, string memory p3) internal view {
1293	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,string)", p0, p1, p2, p3));
1294	 }
1295	 function log(string memory p0, uint p1, bool p2, bool p3) internal view {
1296	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,bool)", p0, p1, p2, p3));
1297	 }
1298	 function log(string memory p0, uint p1, bool p2, address p3) internal view {
1299	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,address)", p0, p1, p2, p3));
1300	 }
1301	 function log(string memory p0, uint p1, address p2, uint p3) internal view {
1302	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,uint)", p0, p1, p2, p3));
1303	 }
1304	 function log(string memory p0, uint p1, address p2, string memory p3) internal view {
1305	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,string)", p0, p1, p2, p3));
1306	 }
1307	 function log(string memory p0, uint p1, address p2, bool p3) internal view {
1308	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,bool)", p0, p1, p2, p3));
1309	 }
1310	 function log(string memory p0, uint p1, address p2, address p3) internal view {
1311	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,address)", p0, p1, p2, p3));
1312	 }
1313	 function log(string memory p0, string memory p1, uint p2, uint p3) internal view {
1314	 _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,uint)", p0, p1, p2, p3));
1315	 }
1316	 function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {
1317	 _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,string)", p0, p1, p2, p3));
1318	 }
1319	 function log(string memory p0, string memory p1, uint p2, bool p3) internal view {
1320	 _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,bool)", p0, p1, p2, p3));
1321	 }
1322	 function log(string memory p0, string memory p1, uint p2, address p3) internal view {
1323	 _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,address)", p0, p1, p2, p3));
1324	 }
1325	 function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {
1326	 _sendLogPayload(abi.encodeWithSignature("log(string,string,string,uint)", p0, p1, p2, p3));
1327	 }
1328	 function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {
1329	 _sendLogPayload(abi.encodeWithSignature("log(string,string,string,string)", p0, p1, p2, p3));
1330	 }
1331	 function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {
1332	 _sendLogPayload(abi.encodeWithSignature("log(string,string,string,bool)", p0, p1, p2, p3));
1333	 }
1334	 function log(string memory p0, string memory p1, string memory p2, address p3) internal view {
1335	 _sendLogPayload(abi.encodeWithSignature("log(string,string,string,address)", p0, p1, p2, p3));
1336	 }
1337	 function log(string memory p0, string memory p1, bool p2, uint p3) internal view {
1338	 _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,uint)", p0, p1, p2, p3));
1339	 }
1340	 function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {
1341	 _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,string)", p0, p1, p2, p3));
1342	 }
1343	 function log(string memory p0, string memory p1, bool p2, bool p3) internal view {
1344	 _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,bool)", p0, p1, p2, p3));
1345	 }
1346	 function log(string memory p0, string memory p1, bool p2, address p3) internal view {
1347	 _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,address)", p0, p1, p2, p3));
1348	 }
1349	 function log(string memory p0, string memory p1, address p2, uint p3) internal view {
1350	 _sendLogPayload(abi.encodeWithSignature("log(string,string,address,uint)", p0, p1, p2, p3));
1351	 }
1352	 function log(string memory p0, string memory p1, address p2, string memory p3) internal view {
1353	 _sendLogPayload(abi.encodeWithSignature("log(string,string,address,string)", p0, p1, p2, p3));
1354	 }
1355	 function log(string memory p0, string memory p1, address p2, bool p3) internal view {
1356	 _sendLogPayload(abi.encodeWithSignature("log(string,string,address,bool)", p0, p1, p2, p3));
1357	 }
1358	 function log(string memory p0, string memory p1, address p2, address p3) internal view {
1359	 _sendLogPayload(abi.encodeWithSignature("log(string,string,address,address)", p0, p1, p2, p3));
1360	 }
1361	 function log(string memory p0, bool p1, uint p2, uint p3) internal view {
1362	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,uint)", p0, p1, p2, p3));
1363	 }
1364	 function log(string memory p0, bool p1, uint p2, string memory p3) internal view {
1365	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,string)", p0, p1, p2, p3));
1366	 }
1367	 function log(string memory p0, bool p1, uint p2, bool p3) internal view {
1368	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,bool)", p0, p1, p2, p3));
1369	 }
1370	 function log(string memory p0, bool p1, uint p2, address p3) internal view {
1371	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,address)", p0, p1, p2, p3));
1372	 }
1373	 function log(string memory p0, bool p1, string memory p2, uint p3) internal view {
1374	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,uint)", p0, p1, p2, p3));
1375	 }
1376	 function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {
1377	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,string)", p0, p1, p2, p3));
1378	 }
1379	 function log(string memory p0, bool p1, string memory p2, bool p3) internal view {
1380	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,bool)", p0, p1, p2, p3));
1381	 }
1382	 function log(string memory p0, bool p1, string memory p2, address p3) internal view {
1383	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,address)", p0, p1, p2, p3));
1384	 }
1385	 function log(string memory p0, bool p1, bool p2, uint p3) internal view {
1386	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,uint)", p0, p1, p2, p3));
1387	 }
1388	 function log(string memory p0, bool p1, bool p2, string memory p3) internal view {
1389	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,string)", p0, p1, p2, p3));
1390	 }
1391	 function log(string memory p0, bool p1, bool p2, bool p3) internal view {
1392	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,bool)", p0, p1, p2, p3));
1393	 }
1394	 function log(string memory p0, bool p1, bool p2, address p3) internal view {
1395	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,address)", p0, p1, p2, p3));
1396	 }
1397	 function log(string memory p0, bool p1, address p2, uint p3) internal view {
1398	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,uint)", p0, p1, p2, p3));
1399	 }
1400	 function log(string memory p0, bool p1, address p2, string memory p3) internal view {
1401	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,string)", p0, p1, p2, p3));
1402	 }
1403	 function log(string memory p0, bool p1, address p2, bool p3) internal view {
1404	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,bool)", p0, p1, p2, p3));
1405	 }
1406	 function log(string memory p0, bool p1, address p2, address p3) internal view {
1407	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,address)", p0, p1, p2, p3));
1408	 }
1409	 function log(string memory p0, address p1, uint p2, uint p3) internal view {
1410	 _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,uint)", p0, p1, p2, p3));
1411	 }
1412	 function log(string memory p0, address p1, uint p2, string memory p3) internal view {
1413	 _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,string)", p0, p1, p2, p3));
1414	 }
1415	 function log(string memory p0, address p1, uint p2, bool p3) internal view {
1416	 _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,bool)", p0, p1, p2, p3));
1417	 }
1418	 function log(string memory p0, address p1, uint p2, address p3) internal view {
1419	 _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,address)", p0, p1, p2, p3));
1420	 }
1421	 function log(string memory p0, address p1, string memory p2, uint p3) internal view {
1422	 _sendLogPayload(abi.encodeWithSignature("log(string,address,string,uint)", p0, p1, p2, p3));
1423	 }
1424	 function log(string memory p0, address p1, string memory p2, string memory p3) internal view {
1425	 _sendLogPayload(abi.encodeWithSignature("log(string,address,string,string)", p0, p1, p2, p3));
1426	 }
1427	 function log(string memory p0, address p1, string memory p2, bool p3) internal view {
1428	 _sendLogPayload(abi.encodeWithSignature("log(string,address,string,bool)", p0, p1, p2, p3));
1429	 }
1430	 function log(string memory p0, address p1, string memory p2, address p3) internal view {
1431	 _sendLogPayload(abi.encodeWithSignature("log(string,address,string,address)", p0, p1, p2, p3));
1432	 }
1433	 function log(string memory p0, address p1, bool p2, uint p3) internal view {
1434	 _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,uint)", p0, p1, p2, p3));
1435	 }
1436	 function log(string memory p0, address p1, bool p2, string memory p3) internal view {
1437	 _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,string)", p0, p1, p2, p3));
1438	 }
1439	 function log(string memory p0, address p1, bool p2, bool p3) internal view {
1440	 _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,bool)", p0, p1, p2, p3));
1441	 }
1442	 function log(string memory p0, address p1, bool p2, address p3) internal view {
1443	 _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,address)", p0, p1, p2, p3));
1444	 }
1445	 function log(string memory p0, address p1, address p2, uint p3) internal view {
1446	 _sendLogPayload(abi.encodeWithSignature("log(string,address,address,uint)", p0, p1, p2, p3));
1447	 }
1448	 function log(string memory p0, address p1, address p2, string memory p3) internal view {
1449	 _sendLogPayload(abi.encodeWithSignature("log(string,address,address,string)", p0, p1, p2, p3));
1450	 }
1451	 function log(string memory p0, address p1, address p2, bool p3) internal view {
1452	 _sendLogPayload(abi.encodeWithSignature("log(string,address,address,bool)", p0, p1, p2, p3));
1453	 }
1454	 function log(string memory p0, address p1, address p2, address p3) internal view {
1455	 _sendLogPayload(abi.encodeWithSignature("log(string,address,address,address)", p0, p1, p2, p3));
1456	 }
1457	 function log(bool p0, uint p1, uint p2, uint p3) internal view {
1458	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,uint)", p0, p1, p2, p3));
1459	 }
1460	 function log(bool p0, uint p1, uint p2, string memory p3) internal view {
1461	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,string)", p0, p1, p2, p3));
1462	 }
1463	 function log(bool p0, uint p1, uint p2, bool p3) internal view {
1464	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,bool)", p0, p1, p2, p3));
1465	 }
1466	 function log(bool p0, uint p1, uint p2, address p3) internal view {
1467	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,address)", p0, p1, p2, p3));
1468	 }
1469	 function log(bool p0, uint p1, string memory p2, uint p3) internal view {
1470	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,uint)", p0, p1, p2, p3));
1471	 }
1472	 function log(bool p0, uint p1, string memory p2, string memory p3) internal view {
1473	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,string)", p0, p1, p2, p3));
1474	 }
1475	 function log(bool p0, uint p1, string memory p2, bool p3) internal view {
1476	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,bool)", p0, p1, p2, p3));
1477	 }
1478	 function log(bool p0, uint p1, string memory p2, address p3) internal view {
1479	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,address)", p0, p1, p2, p3));
1480	 }
1481	 function log(bool p0, uint p1, bool p2, uint p3) internal view {
1482	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,uint)", p0, p1, p2, p3));
1483	 }
1484	 function log(bool p0, uint p1, bool p2, string memory p3) internal view {
1485	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,string)", p0, p1, p2, p3));
1486	 }
1487	 function log(bool p0, uint p1, bool p2, bool p3) internal view {
1488	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,bool)", p0, p1, p2, p3));
1489	 }
1490	 function log(bool p0, uint p1, bool p2, address p3) internal view {
1491	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,address)", p0, p1, p2, p3));
1492	 }
1493	 function log(bool p0, uint p1, address p2, uint p3) internal view {
1494	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,uint)", p0, p1, p2, p3));
1495	 }
1496	 function log(bool p0, uint p1, address p2, string memory p3) internal view {
1497	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,string)", p0, p1, p2, p3));
1498	 }
1499	 function log(bool p0, uint p1, address p2, bool p3) internal view {
1500	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,bool)", p0, p1, p2, p3));
1501	 }
1502	 function log(bool p0, uint p1, address p2, address p3) internal view {
1503	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,address)", p0, p1, p2, p3));
1504	 }
1505	 function log(bool p0, string memory p1, uint p2, uint p3) internal view {
1506	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,uint)", p0, p1, p2, p3));
1507	 }
1508	 function log(bool p0, string memory p1, uint p2, string memory p3) internal view {
1509	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,string)", p0, p1, p2, p3));
1510	 }
1511	 function log(bool p0, string memory p1, uint p2, bool p3) internal view {
1512	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,bool)", p0, p1, p2, p3));
1513	 }
1514	 function log(bool p0, string memory p1, uint p2, address p3) internal view {
1515	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,address)", p0, p1, p2, p3));
1516	 }
1517	 function log(bool p0, string memory p1, string memory p2, uint p3) internal view {
1518	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,uint)", p0, p1, p2, p3));
1519	 }
1520	 function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {
1521	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,string)", p0, p1, p2, p3));
1522	 }
1523	 function log(bool p0, string memory p1, string memory p2, bool p3) internal view {
1524	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,bool)", p0, p1, p2, p3));
1525	 }
1526	 function log(bool p0, string memory p1, string memory p2, address p3) internal view {
1527	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,address)", p0, p1, p2, p3));
1528	 }
1529	 function log(bool p0, string memory p1, bool p2, uint p3) internal view {
1530	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,uint)", p0, p1, p2, p3));
1531	 }
1532	 function log(bool p0, string memory p1, bool p2, string memory p3) internal view {
1533	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,string)", p0, p1, p2, p3));
1534	 }
1535	 function log(bool p0, string memory p1, bool p2, bool p3) internal view {
1536	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,bool)", p0, p1, p2, p3));
1537	 }
1538	 function log(bool p0, string memory p1, bool p2, address p3) internal view {
1539	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,address)", p0, p1, p2, p3));
1540	 }
1541	 function log(bool p0, string memory p1, address p2, uint p3) internal view {
1542	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,uint)", p0, p1, p2, p3));
1543	 }
1544	 function log(bool p0, string memory p1, address p2, string memory p3) internal view {
1545	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,string)", p0, p1, p2, p3));
1546	 }
1547	 function log(bool p0, string memory p1, address p2, bool p3) internal view {
1548	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,bool)", p0, p1, p2, p3));
1549	 }
1550	 function log(bool p0, string memory p1, address p2, address p3) internal view {
1551	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,address)", p0, p1, p2, p3));
1552	 }
1553	 function log(bool p0, bool p1, uint p2, uint p3) internal view {
1554	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,uint)", p0, p1, p2, p3));
1555	 }
1556	 function log(bool p0, bool p1, uint p2, string memory p3) internal view {
1557	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,string)", p0, p1, p2, p3));
1558	 }
1559	 function log(bool p0, bool p1, uint p2, bool p3) internal view {
1560	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,bool)", p0, p1, p2, p3));
1561	 }
1562	 function log(bool p0, bool p1, uint p2, address p3) internal view {
1563	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,address)", p0, p1, p2, p3));
1564	 }
1565	 function log(bool p0, bool p1, string memory p2, uint p3) internal view {
1566	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,uint)", p0, p1, p2, p3));
1567	 }
1568	 function log(bool p0, bool p1, string memory p2, string memory p3) internal view {
1569	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,string)", p0, p1, p2, p3));
1570	 }
1571	 function log(bool p0, bool p1, string memory p2, bool p3) internal view {
1572	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,bool)", p0, p1, p2, p3));
1573	 }
1574	 function log(bool p0, bool p1, string memory p2, address p3) internal view {
1575	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,address)", p0, p1, p2, p3));
1576	 }
1577	 function log(bool p0, bool p1, bool p2, uint p3) internal view {
1578	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,uint)", p0, p1, p2, p3));
1579	 }
1580	 function log(bool p0, bool p1, bool p2, string memory p3) internal view {
1581	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,string)", p0, p1, p2, p3));
1582	 }
1583	 function log(bool p0, bool p1, bool p2, bool p3) internal view {
1584	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,bool)", p0, p1, p2, p3));
1585	 }
1586	 function log(bool p0, bool p1, bool p2, address p3) internal view {
1587	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,address)", p0, p1, p2, p3));
1588	 }
1589	 function log(bool p0, bool p1, address p2, uint p3) internal view {
1590	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,uint)", p0, p1, p2, p3));
1591	 }
1592	 function log(bool p0, bool p1, address p2, string memory p3) internal view {
1593	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,string)", p0, p1, p2, p3));
1594	 }
1595	 function log(bool p0, bool p1, address p2, bool p3) internal view {
1596	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,bool)", p0, p1, p2, p3));
1597	 }
1598	 function log(bool p0, bool p1, address p2, address p3) internal view {
1599	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,address)", p0, p1, p2, p3));
1600	 }
1601	 function log(bool p0, address p1, uint p2, uint p3) internal view {
1602	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,uint)", p0, p1, p2, p3));
1603	 }
1604	 function log(bool p0, address p1, uint p2, string memory p3) internal view {
1605	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,string)", p0, p1, p2, p3));
1606	 }
1607	 function log(bool p0, address p1, uint p2, bool p3) internal view {
1608	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,bool)", p0, p1, p2, p3));
1609	 }
1610	 function log(bool p0, address p1, uint p2, address p3) internal view {
1611	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,address)", p0, p1, p2, p3));
1612	 }
1613	 function log(bool p0, address p1, string memory p2, uint p3) internal view {
1614	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,uint)", p0, p1, p2, p3));
1615	 }
1616	 function log(bool p0, address p1, string memory p2, string memory p3) internal view {
1617	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,string)", p0, p1, p2, p3));
1618	 }
1619	 function log(bool p0, address p1, string memory p2, bool p3) internal view {
1620	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,bool)", p0, p1, p2, p3));
1621	 }
1622	 function log(bool p0, address p1, string memory p2, address p3) internal view {
1623	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,address)", p0, p1, p2, p3));
1624	 }
1625	 function log(bool p0, address p1, bool p2, uint p3) internal view {
1626	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,uint)", p0, p1, p2, p3));
1627	 }
1628	 function log(bool p0, address p1, bool p2, string memory p3) internal view {
1629	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,string)", p0, p1, p2, p3));
1630	 }
1631	 function log(bool p0, address p1, bool p2, bool p3) internal view {
1632	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,bool)", p0, p1, p2, p3));
1633	 }
1634	 function log(bool p0, address p1, bool p2, address p3) internal view {
1635	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,address)", p0, p1, p2, p3));
1636	 }
1637	 function log(bool p0, address p1, address p2, uint p3) internal view {
1638	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,uint)", p0, p1, p2, p3));
1639	 }
1640	 function log(bool p0, address p1, address p2, string memory p3) internal view {
1641	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,string)", p0, p1, p2, p3));
1642	 }
1643	 function log(bool p0, address p1, address p2, bool p3) internal view {
1644	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,bool)", p0, p1, p2, p3));
1645	 }
1646	 function log(bool p0, address p1, address p2, address p3) internal view {
1647	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,address)", p0, p1, p2, p3));
1648	 }
1649	 function log(address p0, uint p1, uint p2, uint p3) internal view {
1650	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,uint)", p0, p1, p2, p3));
1651	 }
1652	 function log(address p0, uint p1, uint p2, string memory p3) internal view {
1653	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,string)", p0, p1, p2, p3));
1654	 }
1655	 function log(address p0, uint p1, uint p2, bool p3) internal view {
1656	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,bool)", p0, p1, p2, p3));
1657	 }
1658	 function log(address p0, uint p1, uint p2, address p3) internal view {
1659	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,address)", p0, p1, p2, p3));
1660	 }
1661	 function log(address p0, uint p1, string memory p2, uint p3) internal view {
1662	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,uint)", p0, p1, p2, p3));
1663	 }
1664	 function log(address p0, uint p1, string memory p2, string memory p3) internal view {
1665	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,string)", p0, p1, p2, p3));
1666	 }
1667	 function log(address p0, uint p1, string memory p2, bool p3) internal view {
1668	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,bool)", p0, p1, p2, p3));
1669	 }
1670	 function log(address p0, uint p1, string memory p2, address p3) internal view {
1671	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,address)", p0, p1, p2, p3));
1672	 }
1673	 function log(address p0, uint p1, bool p2, uint p3) internal view {
1674	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,uint)", p0, p1, p2, p3));
1675	 }
1676	 function log(address p0, uint p1, bool p2, string memory p3) internal view {
1677	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,string)", p0, p1, p2, p3));
1678	 }
1679	 function log(address p0, uint p1, bool p2, bool p3) internal view {
1680	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,bool)", p0, p1, p2, p3));
1681	 }
1682	 function log(address p0, uint p1, bool p2, address p3) internal view {
1683	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,address)", p0, p1, p2, p3));
1684	 }
1685	 function log(address p0, uint p1, address p2, uint p3) internal view {
1686	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,uint)", p0, p1, p2, p3));
1687	 }
1688	 function log(address p0, uint p1, address p2, string memory p3) internal view {
1689	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,string)", p0, p1, p2, p3));
1690	 }
1691	 function log(address p0, uint p1, address p2, bool p3) internal view {
1692	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,bool)", p0, p1, p2, p3));
1693	 }
1694	 function log(address p0, uint p1, address p2, address p3) internal view {
1695	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,address)", p0, p1, p2, p3));
1696	 }
1697	 function log(address p0, string memory p1, uint p2, uint p3) internal view {
1698	 _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,uint)", p0, p1, p2, p3));
1699	 }
1700	 function log(address p0, string memory p1, uint p2, string memory p3) internal view {
1701	 _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,string)", p0, p1, p2, p3));
1702	 }
1703	 function log(address p0, string memory p1, uint p2, bool p3) internal view {
1704	 _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,bool)", p0, p1, p2, p3));
1705	 }
1706	 function log(address p0, string memory p1, uint p2, address p3) internal view {
1707	 _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,address)", p0, p1, p2, p3));
1708	 }
1709	 function log(address p0, string memory p1, string memory p2, uint p3) internal view {
1710	 _sendLogPayload(abi.encodeWithSignature("log(address,string,string,uint)", p0, p1, p2, p3));
1711	 }
1712	 function log(address p0, string memory p1, string memory p2, string memory p3) internal view {
1713	 _sendLogPayload(abi.encodeWithSignature("log(address,string,string,string)", p0, p1, p2, p3));
1714	 }
1715	 function log(address p0, string memory p1, string memory p2, bool p3) internal view {
1716	 _sendLogPayload(abi.encodeWithSignature("log(address,string,string,bool)", p0, p1, p2, p3));
1717	 }
1718	 function log(address p0, string memory p1, string memory p2, address p3) internal view {
1719	 _sendLogPayload(abi.encodeWithSignature("log(address,string,string,address)", p0, p1, p2, p3));
1720	 }
1721	 function log(address p0, string memory p1, bool p2, uint p3) internal view {
1722	 _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,uint)", p0, p1, p2, p3));
1723	 }
1724	 function log(address p0, string memory p1, bool p2, string memory p3) internal view {
1725	 _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,string)", p0, p1, p2, p3));
1726	 }
1727	 function log(address p0, string memory p1, bool p2, bool p3) internal view {
1728	 _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,bool)", p0, p1, p2, p3));
1729	 }
1730	 function log(address p0, string memory p1, bool p2, address p3) internal view {
1731	 _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,address)", p0, p1, p2, p3));
1732	 }
1733	 function log(address p0, string memory p1, address p2, uint p3) internal view {
1734	 _sendLogPayload(abi.encodeWithSignature("log(address,string,address,uint)", p0, p1, p2, p3));
1735	 }
1736	 function log(address p0, string memory p1, address p2, string memory p3) internal view {
1737	 _sendLogPayload(abi.encodeWithSignature("log(address,string,address,string)", p0, p1, p2, p3));
1738	 }
1739	 function log(address p0, string memory p1, address p2, bool p3) internal view {
1740	 _sendLogPayload(abi.encodeWithSignature("log(address,string,address,bool)", p0, p1, p2, p3));
1741	 }
1742	 function log(address p0, string memory p1, address p2, address p3) internal view {
1743	 _sendLogPayload(abi.encodeWithSignature("log(address,string,address,address)", p0, p1, p2, p3));
1744	 }
1745	 function log(address p0, bool p1, uint p2, uint p3) internal view {
1746	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,uint)", p0, p1, p2, p3));
1747	 }
1748	 function log(address p0, bool p1, uint p2, string memory p3) internal view {
1749	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,string)", p0, p1, p2, p3));
1750	 }
1751	 function log(address p0, bool p1, uint p2, bool p3) internal view {
1752	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,bool)", p0, p1, p2, p3));
1753	 }
1754	 function log(address p0, bool p1, uint p2, address p3) internal view {
1755	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,address)", p0, p1, p2, p3));
1756	 }
1757	 function log(address p0, bool p1, string memory p2, uint p3) internal view {
1758	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,uint)", p0, p1, p2, p3));
1759	 }
1760	 function log(address p0, bool p1, string memory p2, string memory p3) internal view {
1761	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,string)", p0, p1, p2, p3));
1762	 }
1763	 function log(address p0, bool p1, string memory p2, bool p3) internal view {
1764	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,bool)", p0, p1, p2, p3));
1765	 }
1766	 function log(address p0, bool p1, string memory p2, address p3) internal view {
1767	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,address)", p0, p1, p2, p3));
1768	 }
1769	 function log(address p0, bool p1, bool p2, uint p3) internal view {
1770	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,uint)", p0, p1, p2, p3));
1771	 }
1772	 function log(address p0, bool p1, bool p2, string memory p3) internal view {
1773	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,string)", p0, p1, p2, p3));
1774	 }
1775	 function log(address p0, bool p1, bool p2, bool p3) internal view {
1776	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,bool)", p0, p1, p2, p3));
1777	 }
1778	 function log(address p0, bool p1, bool p2, address p3) internal view {
1779	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,address)", p0, p1, p2, p3));
1780	 }
1781	 function log(address p0, bool p1, address p2, uint p3) internal view {
1782	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,uint)", p0, p1, p2, p3));
1783	 }
1784	 function log(address p0, bool p1, address p2, string memory p3) internal view {
1785	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,string)", p0, p1, p2, p3));
1786	 }
1787	 function log(address p0, bool p1, address p2, bool p3) internal view {
1788	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,bool)", p0, p1, p2, p3));
1789	 }
1790	 function log(address p0, bool p1, address p2, address p3) internal view {
1791	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,address)", p0, p1, p2, p3));
1792	 }
1793	 function log(address p0, address p1, uint p2, uint p3) internal view {
1794	 _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,uint)", p0, p1, p2, p3));
1795	 }
1796	 function log(address p0, address p1, uint p2, string memory p3) internal view {
1797	 _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,string)", p0, p1, p2, p3));
1798	 }
1799	 function log(address p0, address p1, uint p2, bool p3) internal view {
1800	 _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,bool)", p0, p1, p2, p3));
1801	 }
1802	 function log(address p0, address p1, uint p2, address p3) internal view {
1803	 _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,address)", p0, p1, p2, p3));
1804	 }
1805	 function log(address p0, address p1, string memory p2, uint p3) internal view {
1806	 _sendLogPayload(abi.encodeWithSignature("log(address,address,string,uint)", p0, p1, p2, p3));
1807	 }
1808	 function log(address p0, address p1, string memory p2, string memory p3) internal view {
1809	 _sendLogPayload(abi.encodeWithSignature("log(address,address,string,string)", p0, p1, p2, p3));
1810	 }
1811	 function log(address p0, address p1, string memory p2, bool p3) internal view {
1812	 _sendLogPayload(abi.encodeWithSignature("log(address,address,string,bool)", p0, p1, p2, p3));
1813	 }
1814	 function log(address p0, address p1, string memory p2, address p3) internal view {
1815	 _sendLogPayload(abi.encodeWithSignature("log(address,address,string,address)", p0, p1, p2, p3));
1816	 }
1817	 function log(address p0, address p1, bool p2, uint p3) internal view {
1818	 _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,uint)", p0, p1, p2, p3));
1819	 }
1820	 function log(address p0, address p1, bool p2, string memory p3) internal view {
1821	 _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,string)", p0, p1, p2, p3));
1822	 }
1823	 function log(address p0, address p1, bool p2, bool p3) internal view {
1824	 _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,bool)", p0, p1, p2, p3));
1825	 }
1826	 function log(address p0, address p1, bool p2, address p3) internal view {
1827	 _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,address)", p0, p1, p2, p3));
1828	 }
1829	 function log(address p0, address p1, address p2, uint p3) internal view {
1830	 _sendLogPayload(abi.encodeWithSignature("log(address,address,address,uint)", p0, p1, p2, p3));
1831	 }
1832	 function log(address p0, address p1, address p2, string memory p3) internal view {
1833	 _sendLogPayload(abi.encodeWithSignature("log(address,address,address,string)", p0, p1, p2, p3));
1834	 }
1835	 function log(address p0, address p1, address p2, bool p3) internal view {
1836	 _sendLogPayload(abi.encodeWithSignature("log(address,address,address,bool)", p0, p1, p2, p3));
1837	 }
1838	 function log(address p0, address p1, address p2, address p3) internal view {
1839	 _sendLogPayload(abi.encodeWithSignature("log(address,address,address,address)", p0, p1, p2, p3));
1840	 }
1841	 }
1842	 pragma solidity 0.7.6;
1843	 interface IWETH is IERC20 {
1844	 function deposit() external payable;
1845	 function withdraw(uint256 wad) external;
1846	 }
1847	 pragma solidity 0.7.6;
1848	 interface IPendleData {
1849	 event ForgeFactoryValiditySet(bytes32 _forgeId, bytes32 _marketFactoryId, bool _valid);
1850	 event TreasurySet(address treasury);
1851	 event LockParamsSet(uint256 lockNumerator, uint256 lockDenominator);
1852	 event ExpiryDivisorSet(uint256 expiryDivisor);
1853	 event ForgeFeeSet(uint256 forgeFee);
1854	 event InterestUpdateRateDeltaForMarketSet(uint256 interestUpdateRateDeltaForMarket);
1855	 event MarketFeesSet(uint256 _swapFee, uint256 _protocolSwapFee);
1856	 event CurveShiftBlockDeltaSet(uint256 _blockDelta);
1857	 event NewMarketFactory(bytes32 indexed marketFactoryId, address indexed marketFactoryAddress);
1858	 function setForgeFactoryValidity( bytes32 _forgeId, bytes32 _marketFactoryId, bool _valid ) external;
1859	 function setTreasury(address newTreasury) external;
1860	 function router() external view returns (IPendleRouter);
1861	 function pausingManager() external view returns (IPendlePausingManager);
1862	 function treasury() external view returns (address);
1863	 event ForgeAdded(bytes32 indexed forgeId, address indexed forgeAddress);
1864	 function addForge(bytes32 forgeId, address forgeAddress) external;
1865	 function storeTokens( bytes32 forgeId, address ot, address xyt, address underlyingAsset, uint256 expiry ) external;
1866	 function setForgeFee(uint256 _forgeFee) external;
1867	 function getPendleYieldTokens( bytes32 forgeId, address underlyingYieldToken, uint256 expiry ) external view returns (IPendleYieldToken ot, IPendleYieldToken xyt);
1868	 function getForgeAddress(bytes32 forgeId) external view returns (address forgeAddress);
1869	 function isValidXYT( bytes32 forgeId, address underlyingAsset, uint256 expiry ) external view returns (bool);
1870	 function isValidOT( bytes32 forgeId, address underlyingAsset, uint256 expiry ) external view returns (bool);
1871	 function validForgeFactoryPair(bytes32 _forgeId, bytes32 _marketFactoryId) external view returns (bool);
1872	 function otTokens( bytes32 forgeId, address underlyingYieldToken, uint256 expiry ) external view returns (IPendleYieldToken ot);
1873	 function xytTokens( bytes32 forgeId, address underlyingAsset, uint256 expiry ) external view returns (IPendleYieldToken xyt);
1874	 event MarketPairAdded(address indexed market, address indexed xyt, address indexed token);
1875	 function addMarketFactory(bytes32 marketFactoryId, address marketFactoryAddress) external;
1876	 function isMarket(address _addr) external view returns (bool result);
1877	 function isXyt(address _addr) external view returns (bool result);
1878	 function addMarket( bytes32 marketFactoryId, address xyt, address token, address market ) external;
1879	 function setMarketFees(uint256 _swapFee, uint256 _protocolSwapFee) external;
1880	 function setInterestUpdateRateDeltaForMarket(uint256 _interestUpdateRateDeltaForMarket) external;
1881	 function setLockParams(uint256 _lockNumerator, uint256 _lockDenominator) external;
1882	 function setExpiryDivisor(uint256 _expiryDivisor) external;
1883	 function setCurveShiftBlockDelta(uint256 _blockDelta) external;
1884	 function allMarketsLength() external view returns (uint256);
1885	 function forgeFee() external view returns (uint256);
1886	 function interestUpdateRateDeltaForMarket() external view returns (uint256);
1887	 function expiryDivisor() external view returns (uint256);
1888	 function lockNumerator() external view returns (uint256);
1889	 function lockDenominator() external view returns (uint256);
1890	 function swapFee() external view returns (uint256);
1891	 function protocolSwapFee() external view returns (uint256);
1892	 function curveShiftBlockDelta() external view returns (uint256);
1893	 function getMarketByIndex(uint256 index) external view returns (address market);
1894	 function getMarket( bytes32 marketFactoryId, address xyt, address token ) external view returns (address market);
1895	 function getMarketFactoryAddress(bytes32 marketFactoryId) external view returns (address marketFactoryAddress);
1896	 function getMarketFromKey( address xyt, address token, bytes32 marketFactoryId ) external view returns (address market);
1897	 }
1898	 pragma solidity 0.7.6;
1899	 struct TokenReserve {
1900	 uint256 weight;
1901	 uint256 balance;
1902	 }
1903	 struct PendingTransfer {
1904	 uint256 amount;
1905	 bool isOut;
1906	 }
1907	 pragma solidity 0.7.6;
1908	 interface IPendleMarketFactory {
1909	 function createMarket(address xyt, address token) external returns (address market);
1910	 function router() external view returns (IPendleRouter);
1911	 function marketFactoryId() external view returns (bytes32);
1912	 }
1913	 pragma solidity 0.7.6;
1914	 interface IPendlePausingManager {
1915	 event AddPausingAdmin(address admin);
1916	 event RemovePausingAdmin(address admin);
1917	 event PendingForgeEmergencyHandler(address _pendingForgeHandler);
1918	 event PendingMarketEmergencyHandler(address _pendingMarketHandler);
1919	 event PendingLiqMiningEmergencyHandler(address _pendingLiqMiningHandler);
1920	 event ForgeEmergencyHandlerSet(address forgeEmergencyHandler);
1921	 event MarketEmergencyHandlerSet(address marketEmergencyHandler);
1922	 event LiqMiningEmergencyHandlerSet(address liqMiningEmergencyHandler);
1923	 event PausingManagerLocked();
1924	 event ForgeHandlerLocked();
1925	 event MarketHandlerLocked();
1926	 event LiqMiningHandlerLocked();
1927	 event SetForgePaused(bytes32 forgeId, bool settingToPaused);
1928	 event SetForgeAssetPaused(bytes32 forgeId, address underlyingAsset, bool settingToPaused);
1929	 event SetForgeAssetExpiryPaused( bytes32 forgeId, address underlyingAsset, uint256 expiry, bool settingToPaused );
1930	 event SetForgeLocked(bytes32 forgeId);
1931	 event SetForgeAssetLocked(bytes32 forgeId, address underlyingAsset);
1932	 event SetForgeAssetExpiryLocked(bytes32 forgeId, address underlyingAsset, uint256 expiry);
1933	 event SetMarketFactoryPaused(bytes32 marketFactoryId, bool settingToPaused);
1934	 event SetMarketPaused(bytes32 marketFactoryId, address market, bool settingToPaused);
1935	 event SetMarketFactoryLocked(bytes32 marketFactoryId);
1936	 event SetMarketLocked(bytes32 marketFactoryId, address market);
1937	 event SetLiqMiningPaused(address liqMiningContract, bool settingToPaused);
1938	 event SetLiqMiningLocked(address liqMiningContract);
1939	 function forgeEmergencyHandler() external view returns ( address handler, address pendingHandler, uint256 timelockDeadline );
1940	 function marketEmergencyHandler() external view returns ( address handler, address pendingHandler, uint256 timelockDeadline );
1941	 function liqMiningEmergencyHandler() external view returns ( address handler, address pendingHandler, uint256 timelockDeadline );
1942	 function permLocked() external view returns (bool);
1943	 function permForgeHandlerLocked() external view returns (bool);
1944	 function permMarketHandlerLocked() external view returns (bool);
1945	 function permLiqMiningHandlerLocked() external view returns (bool);
1946	 function isPausingAdmin(address) external view returns (bool);
1947	 function setPausingAdmin(address admin, bool isAdmin) external;
1948	 function requestForgeHandlerChange(address _pendingForgeHandler) external;
1949	 function requestMarketHandlerChange(address _pendingMarketHandler) external;
1950	 function requestLiqMiningHandlerChange(address _pendingLiqMiningHandler) external;
1951	 function applyForgeHandlerChange() external;
1952	 function applyMarketHandlerChange() external;
1953	 function applyLiqMiningHandlerChange() external;
1954	 function lockPausingManagerPermanently() external;
1955	 function lockForgeHandlerPermanently() external;
1956	 function lockMarketHandlerPermanently() external;
1957	 function lockLiqMiningHandlerPermanently() external;
1958	 function setForgePaused(bytes32 forgeId, bool paused) external;
1959	 function setForgeAssetPaused( bytes32 forgeId, address underlyingAsset, bool paused ) external;
1960	 function setForgeAssetExpiryPaused( bytes32 forgeId, address underlyingAsset, uint256 expiry, bool paused ) external;
1961	 function setForgeLocked(bytes32 forgeId) external;
1962	 function setForgeAssetLocked(bytes32 forgeId, address underlyingAsset) external;
1963	 function setForgeAssetExpiryLocked( bytes32 forgeId, address underlyingAsset, uint256 expiry ) external;
1964	 function checkYieldContractStatus( bytes32 forgeId, address underlyingAsset, uint256 expiry ) external returns (bool _paused, bool _locked);
1965	 function setMarketFactoryPaused(bytes32 marketFactoryId, bool paused) external;
1966	 function setMarketPaused( bytes32 marketFactoryId, address market, bool paused ) external;
1967	 function setMarketFactoryLocked(bytes32 marketFactoryId) external;
1968	 function setMarketLocked(bytes32 marketFactoryId, address market) external;
1969	 function checkMarketStatus(bytes32 marketFactoryId, address market) external returns (bool _paused, bool _locked);
1970	 function setLiqMiningPaused(address liqMiningContract, bool settingToPaused) external;
1971	 function setLiqMiningLocked(address liqMiningContract) external;
1972	 function checkLiqMiningStatus(address liqMiningContract) external returns (bool _paused, bool _locked);
1973	 }
1974	 pragma solidity 0.7.6;
1975	 interface IPendleMarket is IERC20 {
1976	 event Sync(uint256 reserve0, uint256 weight0, uint256 reserve1);
1977	 function setUpEmergencyMode(address spender) external;
1978	 function bootstrap( address user, uint256 initialXytLiquidity, uint256 initialTokenLiquidity ) external returns (PendingTransfer[2] memory transfers, uint256 exactOutLp);
1979	 function addMarketLiquiditySingle( address user, address inToken, uint256 inAmount, uint256 minOutLp ) external returns (PendingTransfer[2] memory transfers, uint256 exactOutLp);
1980	 function addMarketLiquidityDual( address user, uint256 _desiredXytAmount, uint256 _desiredTokenAmount, uint256 _xytMinAmount, uint256 _tokenMinAmount ) external returns (PendingTransfer[2] memory transfers, uint256 lpOut);
1981	 function removeMarketLiquidityDual( address user, uint256 inLp, uint256 minOutXyt, uint256 minOutToken ) external returns (PendingTransfer[2] memory transfers);
1982	 function removeMarketLiquiditySingle( address user, address outToken, uint256 exactInLp, uint256 minOutToken ) external returns (PendingTransfer[2] memory transfers);
1983	 function swapExactIn( address inToken, uint256 inAmount, address outToken, uint256 minOutAmount ) external returns (uint256 outAmount, PendingTransfer[2] memory transfers);
1984	 function swapExactOut( address inToken, uint256 maxInAmount, address outToken, uint256 outAmount ) external returns (uint256 inAmount, PendingTransfer[2] memory transfers);
1985	 function redeemLpInterests(address user) external returns (uint256 interests);
1986	 function getReserves() external view returns ( uint256 xytBalance, uint256 xytWeight, uint256 tokenBalance, uint256 tokenWeight, uint256 currentBlock );
1987	 function factoryId() external view returns (bytes32);
1988	 function token() external view returns (address);
1989	 function xyt() external view returns (address);
1990	 }
1991	 pragma solidity 0.7.6;
1992	 interface IPendleRewardManager {
1993	 event UpdateFrequencySet(address[], uint256[]);
1994	 event SkippingRewardsSet(bool);
1995	 event DueRewardsSettled( bytes32 forgeId, address underlyingAsset, uint256 expiry, uint256 amountOut, address user );
1996	 function redeemRewards( address _underlyingAsset, uint256 _expiry, address _user ) external returns (uint256 dueRewards);
1997	 function updatePendingRewards( address _underlyingAsset, uint256 _expiry, address _user ) external;
1998	 function updateParamLManual(address _underlyingAsset, uint256 _expiry) external;
1999	 function setUpdateFrequency( address[] calldata underlyingAssets, uint256[] calldata frequencies ) external;
2000	 function setSkippingRewards(bool skippingRewards) external;
2001	 function forgeId() external returns (bytes32);
2002	 }
2003	 pragma solidity 0.7.6;
2004	 interface IPendleYieldContractDeployer {
2005	 function forgeId() external returns (bytes32);
2006	 function forgeOwnershipToken( address _underlyingAsset, string memory _name, string memory _symbol, uint8 _decimals, uint256 _expiry ) external returns (address ot);
2007	 function forgeFutureYieldToken( address _underlyingAsset, string memory _name, string memory _symbol, uint8 _decimals, uint256 _expiry ) external returns (address xyt);
2008	 function deployYieldTokenHolder(address yieldToken, uint256 expiry) external returns (address yieldTokenHolder);
2009	 }
2010	 pragma solidity ^0.7.0;
2011	 library Math {
2012	 using SafeMath for uint256;
2013	 uint256 internal constant BIG_NUMBER = (uint256(1) << uint256(200));
2014	 uint256 internal constant PRECISION_BITS = 40;
2015	 uint256 internal constant RONE = uint256(1) << PRECISION_BITS;
2016	 uint256 internal constant PI = (314 * RONE) / 10**2;
2017	 uint256 internal constant PI_PLUSONE = (414 * RONE) / 10**2;
2018	 uint256 internal constant PRECISION_POW = 1e2;
2019	 function checkMultOverflow(uint256 _x, uint256 _y) internal pure returns (bool) {
2020	 if (_y == 0) return false;
2021	 return (((_x * _y) / _y) != _x);
2022	 }
2023	 function log2Int(uint256 _p, uint256 _q) internal pure returns (uint256) {
2024	 uint256 res = 0;
2025	 uint256 remain = _p / _q;
2026	 while (remain > 0) {
2027	 res++;
2028	 remain /= 2;
2029	 }
2030	 return res - 1;
2031	 }
2032	 function log2ForSmallNumber(uint256 _x) internal pure returns (uint256) {
2033	 uint256 res = 0;
2034	 uint256 one = (uint256(1) << PRECISION_BITS);
2035	 uint256 two = 2 * one;
2036	 uint256 addition = one;
2037	 require((_x >= one) && (_x < two), "MATH_ERROR");
2038	 require(PRECISION_BITS < 125, "MATH_ERROR");
2039	 for (uint256 i = PRECISION_BITS; i > 0; i--) {
2040	 _x = (_x * _x) / one;
2041	 addition = addition / 2;
2042	 if (_x >= two) {
2043	 _x = _x / 2;
2044	 res += addition;
2045	 }
2046	 }
2047	 return res;
2048	 }
2049	 function logBase2(uint256 _p, uint256 _q) internal pure returns (uint256) {
2050	 uint256 n = 0;
2051	 if (_p > _q) {
2052	 n = log2Int(_p, _q);
2053	 }
2054	 require(n * RONE <= BIG_NUMBER, "MATH_ERROR");
2055	 require(!checkMultOverflow(_p, RONE), "MATH_ERROR");
2056	 require(!checkMultOverflow(n, RONE), "MATH_ERROR");
2057	 require(!checkMultOverflow(uint256(1) << n, _q), "MATH_ERROR");
2058	 uint256 y = (_p * RONE) / (_q * (uint256(1) << n));
2059	 uint256 log2Small = log2ForSmallNumber(y);
2060	 assert(log2Small <= BIG_NUMBER);
2061	 return n * RONE + log2Small;
2062	 }
2063	 function ln(uint256 p, uint256 q) internal pure returns (uint256) {
2064	 uint256 ln2Numerator = 6931471805599453094172;
2065	 uint256 ln2Denomerator = 10000000000000000000000;
2066	 uint256 log2x = logBase2(p, q);
2067	 require(!checkMultOverflow(ln2Numerator, log2x), "MATH_ERROR");
2068	 return (ln2Numerator * log2x) / ln2Denomerator;
2069	 }
2070	 function fpart(uint256 value) internal pure returns (uint256) {
2071	 return value % RONE;
2072	 }
2073	 function toInt(uint256 value) internal pure returns (uint256) {
2074	 return value / RONE;
2075	 }
2076	 function toFP(uint256 value) internal pure returns (uint256) {
2077	 return value * RONE;
2078	 }
2079	 function rpowe(uint256 exp) internal pure returns (uint256) {
2080	 uint256 res = 0;
2081	 uint256 curTerm = RONE;
2082	 for (uint256 n = 0; ; n++) {
2083	 res += curTerm;
2084	 curTerm = rmul(curTerm, rdiv(exp, toFP(n + 1)));
2085	 if (curTerm == 0) {
2086	 break;
2087	 }
2088	 if (n == 500) {
2089	 revert("RPOWE_SLOW_CONVERGE");
2090	 }
2091	 }
2092	 return res;
2093	 }
2094	 function rpow(uint256 base, uint256 exp) internal pure returns (uint256) {
2095	 if (exp == 0) {
2096	 return RONE;
2097	 }
2098	 if (base == 0) {
2099	 return 0;
2100	 }
2101	 uint256 frac = fpart(exp);
2102	 uint256 whole = exp - frac;
2103	 uint256 wholePow = rpowi(base, toInt(whole));
2104	 uint256 fracPow;
2105	 if (base < RONE) {
2106	 uint256 newExp = rmul(frac, ln(rdiv(RONE, base), RONE));
2107	 fracPow = rdiv(RONE, rpowe(newExp));
2108	 }
2109	 else {
2110	 uint256 newExp = rmul(frac, ln(base, RONE));
2111	 fracPow = rpowe(newExp);
2112	 }
2113	 return rmul(wholePow, fracPow);
2114	 }
2115	 function rpowi(uint256 base, uint256 exp) internal pure returns (uint256) {
2116	 uint256 res = exp % 2 != 0 ? base : RONE;
2117	 for (exp /= 2; exp != 0; exp /= 2) {
2118	 base = rmul(base, base);
2119	 if (exp % 2 != 0) {
2120	 res = rmul(res, base);
2121	 }
2122	 }
2123	 return res;
2124	 }
2125	 function sqrt(uint256 y) internal pure returns (uint256 z) {
2126	 if (y > 3) {
2127	 z = y;
2128	 uint256 x = y / 2 + 1;
2129	 while (x < z) {
2130	 z = x;
2131	 x = (y / x + x) / 2;
2132	 }
2133	 }
2134	 else if (y != 0) {
2135	 z = 1;
2136	 }
2137	 }
2138	 function rdiv(uint256 x, uint256 y) internal pure returns (uint256) {
2139	 return (y / 2).add(x.mul(RONE)).div(y);
2140	 }
2141	 function rmul(uint256 x, uint256 y) internal pure returns (uint256) {
2142	 return (RONE / 2).add(x.mul(y)).div(RONE);
2143	 }
2144	 function max(uint256 a, uint256 b) internal pure returns (uint256) {
2145	 return a >= b ? a : b;
2146	 }
2147	 function min(uint256 a, uint256 b) internal pure returns (uint256) {
2148	 return a < b ? a : b;
2149	 }
2150	 function subMax0(uint256 a, uint256 b) internal pure returns (uint256) {
2151	 return a >= b ? a - b : 0;
2152	 }
2153	 }
2154	 pragma solidity >=0.6.0 <0.8.0;
2155	 library SafeMath {
2156	 function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
2157	 uint256 c = a + b;
2158	 if (c < a) return (false, 0);
2159	 return (true, c);
2160	 }
2161	 function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
2162	 if (b > a) return (false, 0);
2163	 return (true, a - b);
2164	 }
2165	 function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
2166	 if (a == 0) return (true, 0);
2167	 uint256 c = a * b;
2168	 if (c / a != b) return (false, 0);
2169	 return (true, c);
2170	 }
2171	 function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
2172	 if (b == 0) return (false, 0);
2173	 return (true, a / b);
2174	 }
2175	 function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
2176	 if (b == 0) return (false, 0);
2177	 return (true, a % b);
2178	 }
2179	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
2180	 uint256 c = a + b;
2181	 require(c >= a, "SafeMath: addition overflow");
2182	 return c;
2183	 }
2184	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
2185	 require(b <= a, "SafeMath: subtraction overflow");
2186	 return a - b;
2187	 }
2188	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
2189	 if (a == 0) return 0;
2190	 uint256 c = a * b;
2191	 require(c / a == b, "SafeMath: multiplication overflow");
2192	 return c;
2193	 }
2194	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
2195	 require(b > 0, "SafeMath: division by zero");
2196	 return a / b;
2197	 }
2198	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
2199	 require(b > 0, "SafeMath: modulo by zero");
2200	 return a % b;
2201	 }
2202	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
2203	 require(b <= a, errorMessage);
2204	 return a - b;
2205	 }
2206	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
2207	 require(b > 0, errorMessage);
2208	 return a / b;
2209	 }
2210	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
2211	 require(b > 0, errorMessage);
2212	 return a % b;
2213	 }
2214	 }
2215	 pragma solidity 0.7.6;
2216	 contract PendleLpHolder is IPendleLpHolder, WithdrawableV2 {
2217	 using SafeERC20 for IERC20;
2218	 address private immutable pendleLiquidityMining;
2219	 address public immutable override underlyingYieldToken;
2220	 address public immutable override pendleMarket;
2221	 address private immutable router;
2222	 modifier onlyLiquidityMining() {
2223	 require(msg.sender == pendleLiquidityMining, "ONLY_LIQUIDITY_MINING");
2224	 _;
2225	 }
2226	 constructor( address _governanceManager, address _pendleMarket, address _router, address _underlyingYieldToken ) PermissionsV2(_governanceManager) {
2227	 require( _pendleMarket != address(0) && _router != address(0) && _underlyingYieldToken != address(0), "ZERO_ADDRESS" );
2228	 pendleMarket = _pendleMarket;
2229	 router = _router;
2230	 pendleLiquidityMining = msg.sender;
2231	 underlyingYieldToken = _underlyingYieldToken;
2232	 }
2233	 function sendLp(address user, uint256 amount) external override onlyLiquidityMining {
2234	 IERC20(pendleMarket).safeTransfer(user, amount);
2235	 }
2236	 function sendInterests(address user, uint256 amount) external override onlyLiquidityMining {
2237	 IERC20(underlyingYieldToken).safeTransfer(user, amount);
2238	 }
2239	 function redeemLpInterests() external override onlyLiquidityMining {
2240	 IPendleRouter(router).redeemLpInterests(pendleMarket, address(this));
2241	 }
2242	 function _allowedToWithdraw(address _token) internal view override returns (bool allowed) {
2243	 allowed = _token != underlyingYieldToken && _token != pendleMarket;
2244	 }
2245	 function setUpEmergencyMode(address spender) external override onlyLiquidityMining {
2246	 IERC20(underlyingYieldToken).safeApprove(spender, type(uint256).max);
2247	 IERC20(pendleMarket).safeApprove(spender, type(uint256).max);
2248	 }
2249	 }
2250	 pragma solidity 0.7.6;
2251	 interface IPendleWhitelist {
2252	 event AddedToWhiteList(address);
2253	 event RemovedFromWhiteList(address);
2254	 function whitelisted(address) external view returns (bool);
2255	 function addToWhitelist(address[] calldata _addresses) external;
2256	 function removeFromWhitelist(address[] calldata _addresses) external;
2257	 function getWhitelist() external view returns (address[] memory list);
2258	 }
2259	 pragma solidity >=0.6.0 <0.8.0;
2260	 library SafeERC20 {
2261	 using SafeMath for uint256;
2262	 using Address for address;
2263	 function safeTransfer(IERC20 token, address to, uint256 value) internal {
2264	 _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
2265	 }
2266	 function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
2267	 _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
2268	 }
2269	 function safeApprove(IERC20 token, address spender, uint256 value) internal {
2270	 require((value == 0) || (token.allowance(address(this), spender) == 0), "SafeERC20: approve from non-zero to non-zero allowance" );
2271	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
2272	 }
2273	 function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
2274	 uint256 newAllowance = token.allowance(address(this), spender).add(value);
2275	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
2276	 }
2277	 function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
2278	 uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
2279	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
2280	 }
2281	 function _callOptionalReturn(IERC20 token, bytes memory data) private {
2282	 bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
2283	 if (returndata.length > 0) {
2284	 require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
2285	 }
2286	 }
2287	 }
2288	 pragma solidity >=0.6.2 <0.8.0;
2289	 library Address {
2290	 function isContract(address account) internal view returns (bool) {
2291	 uint256 size;
2292	 assembly {
2293	 size := extcodesize(account) }
2294	 return size > 0;
2295	 }
2296	 function sendValue(address payable recipient, uint256 amount) internal {
2297	 require(address(this).balance >= amount, "Address: insufficient balance");
2298	 (bool success, ) = recipient.call{
2299	 value: amount }
2300	 ("");
2301	 require(success, "Address: unable to send value, recipient may have reverted");
2302	 }
2303	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
2304	 return functionCall(target, data, "Address: low-level call failed");
2305	 }
2306	 function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
2307	 return functionCallWithValue(target, data, 0, errorMessage);
2308	 }
2309	 function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
2310	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
2311	 }
2312	 function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
2313	 require(address(this).balance >= value, "Address: insufficient balance for call");
2314	 require(isContract(target), "Address: call to non-contract");
2315	 (bool success, bytes memory returndata) = target.call{
2316	 value: value }
2317	 (data);
2318	 return _verifyCallResult(success, returndata, errorMessage);
2319	 }
2320	 function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
2321	 return functionStaticCall(target, data, "Address: low-level static call failed");
2322	 }
2323	 function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
2324	 require(isContract(target), "Address: static call to non-contract");
2325	 (bool success, bytes memory returndata) = target.staticcall(data);
2326	 return _verifyCallResult(success, returndata, errorMessage);
2327	 }
2328	 function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
2329	 return functionDelegateCall(target, data, "Address: low-level delegate call failed");
2330	 }
2331	 function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
2332	 require(isContract(target), "Address: delegate call to non-contract");
2333	 (bool success, bytes memory returndata) = target.delegatecall(data);
2334	 return _verifyCallResult(success, returndata, errorMessage);
2335	 }
2336	 function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
2337	 if (success) {
2338	 return returndata;
2339	 }
2340	 else {
2341	 if (returndata.length > 0) {
2342	 assembly {
2343	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
2344	 }
2345	 else {
2346	 revert(errorMessage);
2347	 }
2348	 }
2349	 }
2350	 }
2351	 pragma solidity 0.7.6;
2352	 contract PendleGovernanceManager {
2353	 address public governance;
2354	 address public pendingGovernance;
2355	 event GovernanceClaimed(address newGovernance, address previousGovernance);
2356	 event TransferGovernancePending(address pendingGovernance);
2357	 constructor(address _governance) {
2358	 require(_governance != address(0), "ZERO_ADDRESS");
2359	 governance = _governance;
2360	 }
2361	 modifier onlyGovernance() {
2362	 require(msg.sender == governance, "ONLY_GOVERNANCE");
2363	 _;
2364	 }
2365	 function claimGovernance() external {
2366	 require(pendingGovernance == msg.sender, "WRONG_GOVERNANCE");
2367	 emit GovernanceClaimed(pendingGovernance, governance);
2368	 governance = pendingGovernance;
2369	 pendingGovernance = address(0);
2370	 }
2371	 function transferGovernance(address _governance) external onlyGovernance {
2372	 require(_governance != address(0), "ZERO_ADDRESS");
2373	 pendingGovernance = _governance;
2374	 emit TransferGovernancePending(pendingGovernance);
2375	 }
2376	 }
