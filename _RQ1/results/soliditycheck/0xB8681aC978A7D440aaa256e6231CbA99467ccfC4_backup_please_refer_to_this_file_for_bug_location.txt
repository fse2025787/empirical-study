row number 
1	         pragma solidity ^0.8.0;
2	 interface IERC165 {
3	 function supportsInterface(bytes4 interfaceId) external view returns (bool);
4	 }
5	 pragma solidity ^0.8.0;
6	 interface IERC20 {
7	 function totalSupply() external view returns (uint256);
8	 function balanceOf(address account) external view returns (uint256);
9	 function transfer(address recipient, uint256 amount) external returns (bool);
10	 function allowance(address owner, address spender) external view returns (uint256);
11	 function approve(address spender, uint256 amount) external returns (bool);
12	 function transferFrom( address sender, address recipient, uint256 amount ) external returns (bool);
13	 event Transfer(address indexed from, address indexed to, uint256 value);
14	 event Approval(address indexed owner, address indexed spender, uint256 value);
15	 }
16	 pragma solidity ^0.8.0;
17	 interface IAccessControl {
18	 event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
19	 event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
20	 event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
21	 function hasRole(bytes32 role, address account) external view returns (bool);
22	 function getRoleAdmin(bytes32 role) external view returns (bytes32);
23	 function grantRole(bytes32 role, address account) external;
24	 function revokeRole(bytes32 role, address account) external;
25	 function renounceRole(bytes32 role, address account) external;
26	 }
27	 pragma solidity ^0.8.0;
28	 abstract contract ERC165 is IERC165 {
29	 function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
30	 return interfaceId == type(IERC165).interfaceId;
31	 }
32	 }
33	 pragma solidity ^0.8.0;
34	 abstract contract Context {
35	 function _msgSender() internal view virtual returns (address) {
36	 return msg.sender;
37	 }
38	 function _msgData() internal view virtual returns (bytes calldata) {
39	 return msg.data;
40	 }
41	 }
42	 pragma solidity ^0.8.0;
43	 interface IERC20Metadata is IERC20 {
44	 function name() external view returns (string memory);
45	 function symbol() external view returns (string memory);
46	 function decimals() external view returns (uint8);
47	 }
48	 pragma solidity ^0.8.0;
49	 abstract contract EIP712 {
50	 bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;
51	 uint256 private immutable _CACHED_CHAIN_ID;
52	 bytes32 private immutable _HASHED_NAME;
53	 bytes32 private immutable _HASHED_VERSION;
54	 bytes32 private immutable _TYPE_HASH;
55	 constructor(string memory name, string memory version) {
56	 bytes32 hashedName = keccak256(bytes(name));
57	 bytes32 hashedVersion = keccak256(bytes(version));
58	 bytes32 typeHash = keccak256( "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)" );
59	 _HASHED_NAME = hashedName;
60	 _HASHED_VERSION = hashedVersion;
61	 _CACHED_CHAIN_ID = block.chainid;
62	 _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);
63	 _TYPE_HASH = typeHash;
64	 }
65	 function _domainSeparatorV4() internal view returns (bytes32) {
66	 if (block.chainid == _CACHED_CHAIN_ID) {
67	 return _CACHED_DOMAIN_SEPARATOR;
68	 }
69	 else {
70	 return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);
71	 }
72	 }
73	 function _buildDomainSeparator( bytes32 typeHash, bytes32 nameHash, bytes32 versionHash ) private view returns (bytes32) {
74	 return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));
75	 }
76	 function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {
77	 return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);
78	 }
79	 }
80	 pragma solidity ^0.8.0;
81	 interface IERC20Permit {
82	 function permit( address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s ) external;
83	 function nonces(address owner) external view returns (uint256);
84	 function DOMAIN_SEPARATOR() external view returns (bytes32);
85	 }
86	 pragma solidity ^0.8.0;
87	 contract ERC20 is Context, IERC20, IERC20Metadata {
88	 mapping(address => uint256) private _balances;
89	 mapping(address => mapping(address => uint256)) private _allowances;
90	 uint256 private _totalSupply;
91	 string private _name;
92	 string private _symbol;
93	 constructor(string memory name_, string memory symbol_) {
94	 _name = name_;
95	 _symbol = symbol_;
96	 }
97	 function name() public view virtual override returns (string memory) {
98	 return _name;
99	 }
100	 function symbol() public view virtual override returns (string memory) {
101	 return _symbol;
102	 }
103	 function decimals() public view virtual override returns (uint8) {
104	 return 18;
105	 }
106	 function totalSupply() public view virtual override returns (uint256) {
107	 return _totalSupply;
108	 }
109	 function balanceOf(address account) public view virtual override returns (uint256) {
110	 return _balances[account];
111	 }
112	 function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
113	 _transfer(_msgSender(), recipient, amount);
114	 return true;
115	 }
116	 function allowance(address owner, address spender) public view virtual override returns (uint256) {
117	 return _allowances[owner][spender];
118	 }
119	 function approve(address spender, uint256 amount) public virtual override returns (bool) {
120	 _approve(_msgSender(), spender, amount);
121	 return true;
122	 }
123	 function transferFrom( address sender, address recipient, uint256 amount ) public virtual override returns (bool) {
124	 _transfer(sender, recipient, amount);
125	 uint256 currentAllowance = _allowances[sender][_msgSender()];
126	 require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");
127	 unchecked {
128	 _approve(sender, _msgSender(), currentAllowance - amount);
129	 }
130	 return true;
131	 }
132	 function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
133	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);
134	 return true;
135	 }
136	 function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
137	 uint256 currentAllowance = _allowances[_msgSender()][spender];
138	 require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
139	 unchecked {
140	 _approve(_msgSender(), spender, currentAllowance - subtractedValue);
141	 }
142	 return true;
143	 }
144	 function _transfer( address sender, address recipient, uint256 amount ) internal virtual {
145	 require(sender != address(0), "ERC20: transfer from the zero address");
146	 require(recipient != address(0), "ERC20: transfer to the zero address");
147	 _beforeTokenTransfer(sender, recipient, amount);
148	 uint256 senderBalance = _balances[sender];
149	 require(senderBalance >= amount, "ERC20: transfer amount exceeds balance");
150	 unchecked {
151	 _balances[sender] = senderBalance - amount;
152	 }
153	 _balances[recipient] += amount;
154	 emit Transfer(sender, recipient, amount);
155	 _afterTokenTransfer(sender, recipient, amount);
156	 }
157	 function _mint(address account, uint256 amount) internal virtual {
158	 require(account != address(0), "ERC20: mint to the zero address");
159	 _beforeTokenTransfer(address(0), account, amount);
160	 _totalSupply += amount;
161	 _balances[account] += amount;
162	 emit Transfer(address(0), account, amount);
163	 _afterTokenTransfer(address(0), account, amount);
164	 }
165	 function _burn(address account, uint256 amount) internal virtual {
166	 require(account != address(0), "ERC20: burn from the zero address");
167	 _beforeTokenTransfer(account, address(0), amount);
168	 uint256 accountBalance = _balances[account];
169	 require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
170	 unchecked {
171	 _balances[account] = accountBalance - amount;
172	 }
173	 _totalSupply -= amount;
174	 emit Transfer(account, address(0), amount);
175	 _afterTokenTransfer(account, address(0), amount);
176	 }
177	 function _approve( address owner, address spender, uint256 amount ) internal virtual {
178	 require(owner != address(0), "ERC20: approve from the zero address");
179	 require(spender != address(0), "ERC20: approve to the zero address");
180	 _allowances[owner][spender] = amount;
181	 emit Approval(owner, spender, amount);
182	 }
183	 function _beforeTokenTransfer( address from, address to, uint256 amount ) internal virtual {
184	 }
185	 function _afterTokenTransfer( address from, address to, uint256 amount ) internal virtual {
186	 }
187	 }
188	 pragma solidity ^0.8.0;
189	 interface IAccessControlEnumerable is IAccessControl {
190	 function getRoleMember(bytes32 role, uint256 index) external view returns (address);
191	 function getRoleMemberCount(bytes32 role) external view returns (uint256);
192	 }
193	 pragma solidity ^0.8.0;
194	 abstract contract AccessControl is Context, IAccessControl, ERC165 {
195	 struct RoleData {
196	 mapping(address => bool) members;
197	 bytes32 adminRole;
198	 }
199	 mapping(bytes32 => RoleData) private _roles;
200	 bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;
201	 modifier onlyRole(bytes32 role) {
202	 _checkRole(role, _msgSender());
203	 _;
204	 }
205	 function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
206	 return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);
207	 }
208	 function hasRole(bytes32 role, address account) public view override returns (bool) {
209	 return _roles[role].members[account];
210	 }
211	 function _checkRole(bytes32 role, address account) internal view {
212	 if (!hasRole(role, account)) {
213	 revert( string( abi.encodePacked( "AccessControl: account ", Strings.toHexString(uint160(account), 20), " is missing role ", Strings.toHexString(uint256(role), 32) ) ) );
214	 }
215	 }
216	 function getRoleAdmin(bytes32 role) public view override returns (bytes32) {
217	 return _roles[role].adminRole;
218	 }
219	 function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {
220	 _grantRole(role, account);
221	 }
222	 function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {
223	 _revokeRole(role, account);
224	 }
225	 function renounceRole(bytes32 role, address account) public virtual override {
226	 require(account == _msgSender(), "AccessControl: can only renounce roles for self");
227	 _revokeRole(role, account);
228	 }
229	 function _setupRole(bytes32 role, address account) internal virtual {
230	 _grantRole(role, account);
231	 }
232	 function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
233	 bytes32 previousAdminRole = getRoleAdmin(role);
234	 _roles[role].adminRole = adminRole;
235	 emit RoleAdminChanged(role, previousAdminRole, adminRole);
236	 }
237	 function _grantRole(bytes32 role, address account) private {
238	 if (!hasRole(role, account)) {
239	 _roles[role].members[account] = true;
240	 emit RoleGranted(role, account, _msgSender());
241	 }
242	 }
243	 function _revokeRole(bytes32 role, address account) private {
244	 if (hasRole(role, account)) {
245	 _roles[role].members[account] = false;
246	 emit RoleRevoked(role, account, _msgSender());
247	 }
248	 }
249	 }
250	 pragma solidity ^0.8.0;
251	 abstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {
252	 using Counters for Counters.Counter;
253	 mapping(address => Counters.Counter) private _nonces;
254	 bytes32 private immutable _PERMIT_TYPEHASH = keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");
255	 constructor(string memory name) EIP712(name, "1") {
256	 }
257	 function permit( address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s ) public virtual override {
258	 require(block.timestamp <= deadline, "ERC20Permit: expired deadline");
259	 bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));
260	 bytes32 hash = _hashTypedDataV4(structHash);
261	 address signer = ECDSA.recover(hash, v, r, s);
262	 require(signer == owner, "ERC20Permit: invalid signature");
263	 _approve(owner, spender, value);
264	 }
265	 function nonces(address owner) public view virtual override returns (uint256) {
266	 return _nonces[owner].current();
267	 }
268	 function DOMAIN_SEPARATOR() external view override returns (bytes32) {
269	 return _domainSeparatorV4();
270	 }
271	 function _useNonce(address owner) internal virtual returns (uint256 current) {
272	 Counters.Counter storage nonce = _nonces[owner];
273	 current = nonce.current();
274	 nonce.increment();
275	 }
276	 }
277	 pragma solidity ^0.8.0;
278	 abstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {
279	 using EnumerableSet for EnumerableSet.AddressSet;
280	 mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;
281	 function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
282	 return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);
283	 }
284	 function getRoleMember(bytes32 role, uint256 index) public view override returns (address) {
285	 return _roleMembers[role].at(index);
286	 }
287	 function getRoleMemberCount(bytes32 role) public view override returns (uint256) {
288	 return _roleMembers[role].length();
289	 }
290	 function grantRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {
291	 super.grantRole(role, account);
292	 _roleMembers[role].add(account);
293	 }
294	 function revokeRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {
295	 super.revokeRole(role, account);
296	 _roleMembers[role].remove(account);
297	 }
298	 function renounceRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {
299	 super.renounceRole(role, account);
300	 _roleMembers[role].remove(account);
301	 }
302	 function _setupRole(bytes32 role, address account) internal virtual override {
303	 super._setupRole(role, account);
304	 _roleMembers[role].add(account);
305	 }
306	 }
307	 pragma solidity 0.8.7;
308	 interface IAbstractRewards {
309	 function withdrawableRewardsOf(address account) external view returns (uint256);
310	 function withdrawnRewardsOf(address account) external view returns (uint256);
311	 function cumulativeRewardsOf(address account) external view returns (uint256);
312	 event RewardsDistributed(address indexed by, uint256 rewardsDistributed);
313	 event RewardsWithdrawn(address indexed by, uint256 fundsWithdrawn);
314	 }
315	 pragma solidity ^0.8.0;
316	 abstract contract ERC20Votes is ERC20Permit {
317	 struct Checkpoint {
318	 uint32 fromBlock;
319	 uint224 votes;
320	 }
321	 bytes32 private constant _DELEGATION_TYPEHASH = keccak256("Delegation(address delegatee,uint256 nonce,uint256 expiry)");
322	 mapping(address => address) private _delegates;
323	 mapping(address => Checkpoint[]) private _checkpoints;
324	 Checkpoint[] private _totalSupplyCheckpoints;
325	 event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
326	 event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);
327	 function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {
328	 return _checkpoints[account][pos];
329	 }
330	 function numCheckpoints(address account) public view virtual returns (uint32) {
331	 return SafeCast.toUint32(_checkpoints[account].length);
332	 }
333	 function delegates(address account) public view virtual returns (address) {
334	 return _delegates[account];
335	 }
336	 function getVotes(address account) public view returns (uint256) {
337	 uint256 pos = _checkpoints[account].length;
338	 return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;
339	 }
340	 function getPastVotes(address account, uint256 blockNumber) public view returns (uint256) {
341	 require(blockNumber < block.number, "ERC20Votes: block not yet mined");
342	 return _checkpointsLookup(_checkpoints[account], blockNumber);
343	 }
344	 function getPastTotalSupply(uint256 blockNumber) public view returns (uint256) {
345	 require(blockNumber < block.number, "ERC20Votes: block not yet mined");
346	 return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);
347	 }
348	 function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {
349	 uint256 high = ckpts.length;
350	 uint256 low = 0;
351	 while (low < high) {
352	 uint256 mid = Math.average(low, high);
353	 if (ckpts[mid].fromBlock > blockNumber) {
354	 high = mid;
355	 }
356	 else {
357	 low = mid + 1;
358	 }
359	 }
360	 return high == 0 ? 0 : ckpts[high - 1].votes;
361	 }
362	 function delegate(address delegatee) public virtual {
363	 return _delegate(_msgSender(), delegatee);
364	 }
365	 function delegateBySig( address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s ) public virtual {
366	 require(block.timestamp <= expiry, "ERC20Votes: signature expired");
367	 address signer = ECDSA.recover( _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))), v, r, s );
368	 require(nonce == _useNonce(signer), "ERC20Votes: invalid nonce");
369	 return _delegate(signer, delegatee);
370	 }
371	 function _maxSupply() internal view virtual returns (uint224) {
372	 return type(uint224).max;
373	 }
374	 function _mint(address account, uint256 amount) internal virtual override {
375	 super._mint(account, amount);
376	 require(totalSupply() <= _maxSupply(), "ERC20Votes: total supply risks overflowing votes");
377	 _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);
378	 }
379	 function _burn(address account, uint256 amount) internal virtual override {
380	 super._burn(account, amount);
381	 _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);
382	 }
383	 function _afterTokenTransfer( address from, address to, uint256 amount ) internal virtual override {
384	 super._afterTokenTransfer(from, to, amount);
385	 _moveVotingPower(delegates(from), delegates(to), amount);
386	 }
387	 function _delegate(address delegator, address delegatee) internal virtual {
388	 address currentDelegate = delegates(delegator);
389	 uint256 delegatorBalance = balanceOf(delegator);
390	 _delegates[delegator] = delegatee;
391	 emit DelegateChanged(delegator, currentDelegate, delegatee);
392	 _moveVotingPower(currentDelegate, delegatee, delegatorBalance);
393	 }
394	 function _moveVotingPower( address src, address dst, uint256 amount ) private {
395	 if (src != dst && amount > 0) {
396	 if (src != address(0)) {
397	 (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);
398	 emit DelegateVotesChanged(src, oldWeight, newWeight);
399	 }
400	 if (dst != address(0)) {
401	 (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);
402	 emit DelegateVotesChanged(dst, oldWeight, newWeight);
403	 }
404	 }
405	 }
406	 function _writeCheckpoint( Checkpoint[] storage ckpts, function(uint256, uint256) view returns (uint256) op, uint256 delta ) private returns (uint256 oldWeight, uint256 newWeight) {
407	 uint256 pos = ckpts.length;
408	 oldWeight = pos == 0 ? 0 : ckpts[pos - 1].votes;
409	 newWeight = op(oldWeight, delta);
410	 if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) {
411	 ckpts[pos - 1].votes = SafeCast.toUint224(newWeight);
412	 }
413	 else {
414	 ckpts.push(Checkpoint({
415	 fromBlock: SafeCast.toUint32(block.number), votes: SafeCast.toUint224(newWeight)}
416	 ));
417	 }
418	 }
419	 function _add(uint256 a, uint256 b) private pure returns (uint256) {
420	 return a + b;
421	 }
422	 function _subtract(uint256 a, uint256 b) private pure returns (uint256) {
423	 return a - b;
424	 }
425	 }
426	 pragma solidity 0.8.7;
427	 interface IBasePool {
428	 function distributeRewards(uint256 _amount) external;
429	 }
430	 pragma solidity 0.8.7;
431	 contract TokenSaver is AccessControlEnumerable {
432	 using SafeERC20 for IERC20;
433	 bytes32 public constant TOKEN_SAVER_ROLE = keccak256("TOKEN_SAVER_ROLE");
434	 event TokenSaved(address indexed by, address indexed receiver, address indexed token, uint256 amount);
435	 modifier onlyTokenSaver() {
436	 require(hasRole(TOKEN_SAVER_ROLE, _msgSender()), "TokenSaver.onlyTokenSaver: permission denied");
437	 _;
438	 }
439	 constructor() {
440	 _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
441	 }
442	 function saveToken(address _token, address _receiver, uint256 _amount) external onlyTokenSaver {
443	 IERC20(_token).safeTransfer(_receiver, _amount);
444	 emit TokenSaved(_msgSender(), _receiver, _token, _amount);
445	 }
446	 }
447	 pragma solidity 0.8.7;
448	 abstract contract AbstractRewards is IAbstractRewards {
449	 using SafeCast for uint128;
450	 using SafeCast for uint256;
451	 using SafeCast for int256;
452	 uint128 public constant POINTS_MULTIPLIER = type(uint128).max;
453	 function(address) view returns (uint256) private immutable getSharesOf;
454	 function() view returns (uint256) private immutable getTotalShares;
455	 uint256 public pointsPerShare;
456	 mapping(address => int256) public pointsCorrection;
457	 mapping(address => uint256) public withdrawnRewards;
458	 constructor( function(address) view returns (uint256) getSharesOf_, function() view returns (uint256) getTotalShares_ ) {
459	 getSharesOf = getSharesOf_;
460	 getTotalShares = getTotalShares_;
461	 }
462	 function withdrawableRewardsOf(address _account) public view override returns (uint256) {
463	 return cumulativeRewardsOf(_account) - withdrawnRewards[_account];
464	 }
465	 function withdrawnRewardsOf(address _account) public view override returns (uint256) {
466	 return withdrawnRewards[_account];
467	 }
468	 function cumulativeRewardsOf(address _account) public view override returns (uint256) {
469	 return ((pointsPerShare * getSharesOf(_account)).toInt256() + pointsCorrection[_account]).toUint256() / POINTS_MULTIPLIER;
470	 }
471	 function _distributeRewards(uint256 _amount) internal {
472	 uint256 shares = getTotalShares();
473	 require(shares > 0, "AbstractRewards._distributeRewards: total share supply is zero");
474	 if (_amount > 0) {
475	 pointsPerShare = pointsPerShare + (_amount * POINTS_MULTIPLIER / shares);
476	 emit RewardsDistributed(msg.sender, _amount);
477	 }
478	 }
479	 function _prepareCollect(address _account) internal returns (uint256) {
480	 uint256 _withdrawableDividend = withdrawableRewardsOf(_account);
481	 if (_withdrawableDividend > 0) {
482	 withdrawnRewards[_account] = withdrawnRewards[_account] + _withdrawableDividend;
483	 emit RewardsWithdrawn(_account, _withdrawableDividend);
484	 }
485	 return _withdrawableDividend;
486	 }
487	 function _correctPointsForTransfer(address _from, address _to, uint256 _shares) internal {
488	 int256 _magCorrection = (pointsPerShare * _shares).toInt256();
489	 pointsCorrection[_from] = pointsCorrection[_from] + _magCorrection;
490	 pointsCorrection[_to] = pointsCorrection[_to] - _magCorrection;
491	 }
492	 function _correctPoints(address _account, int256 _shares) internal {
493	 pointsCorrection[_account] = pointsCorrection[_account] + (_shares * (int256(pointsPerShare)));
494	 }
495	 }
496	 pragma solidity 0.8.7;
497	 interface ITimeLockPool {
498	 function deposit(uint256 _amount, uint256 _duration, address _receiver) external;
499	 }
500	 pragma solidity 0.8.7;
501	 abstract contract BasePool is ERC20Votes, AbstractRewards, IBasePool, TokenSaver {
502	 using SafeERC20 for IERC20;
503	 using SafeCast for uint256;
504	 using SafeCast for int256;
505	 IERC20 public immutable depositToken;
506	 IERC20 public immutable rewardToken;
507	 ITimeLockPool public immutable escrowPool;
508	 uint256 public immutable escrowPortion;
509	 uint256 public immutable escrowDuration;
510	 event RewardsClaimed(address indexed _from, address indexed _receiver, uint256 _escrowedAmount, uint256 _nonEscrowedAmount);
511	 constructor( string memory _name, string memory _symbol, address _depositToken, address _rewardToken, address _escrowPool, uint256 _escrowPortion, uint256 _escrowDuration ) ERC20Permit(_name) ERC20(_name, _symbol) AbstractRewards(balanceOf, totalSupply) {
512	 require(_escrowPortion <= 1e18, "BasePool.constructor: Cannot escrow more than 100%");
513	 require(_depositToken != address(0), "BasePool.constructor: Deposit token must be set");
514	 require(_rewardToken != address(0), "BasePool.constructor: Reward token must be set");
515	 depositToken = IERC20(_depositToken);
516	 rewardToken = IERC20(_rewardToken);
517	 escrowPool = ITimeLockPool(_escrowPool);
518	 escrowPortion = _escrowPortion;
519	 escrowDuration = _escrowDuration;
520	 if(_escrowPool != address(0)) {
521	 IERC20(_rewardToken).safeApprove(_escrowPool, type(uint256).max);
522	 }
523	 }
524	 function _mint(address _account, uint256 _amount) internal virtual override {
525	 super._mint(_account, _amount);
526	 _correctPoints(_account, -(_amount.toInt256()));
527	 }
528	 function _burn(address _account, uint256 _amount) internal virtual override {
529	 super._burn(_account, _amount);
530	 _correctPoints(_account, _amount.toInt256());
531	 }
532	 function _transfer(address _from, address _to, uint256 _value) internal virtual override {
533	 super._transfer(_from, _to, _value);
534	 _correctPointsForTransfer(_from, _to, _value);
535	 }
536	 function distributeRewards(uint256 _amount) external override {
537	 rewardToken.safeTransferFrom(_msgSender(), address(this), _amount);
538	 _distributeRewards(_amount);
539	 }
540	 function claimRewards(address _receiver) external {
541	 uint256 rewardAmount = _prepareCollect(_msgSender());
542	 uint256 escrowedRewardAmount = rewardAmount * escrowPortion / 1e18;
543	 uint256 nonEscrowedRewardAmount = rewardAmount - escrowedRewardAmount;
544	 if(escrowedRewardAmount != 0 && address(escrowPool) != address(0)) {
545	 escrowPool.deposit(escrowedRewardAmount, escrowDuration, _receiver);
546	 }
547	 if(nonEscrowedRewardAmount > 1) {
548	 rewardToken.safeTransfer(_receiver, nonEscrowedRewardAmount);
549	 }
550	 emit RewardsClaimed(_msgSender(), _receiver, escrowedRewardAmount, nonEscrowedRewardAmount);
551	 }
552	 }
553	 pragma solidity 0.8.7;
554	 contract TimeLockPool is BasePool, ITimeLockPool {
555	 using Math for uint256;
556	 using SafeERC20 for IERC20;
557	 uint256 public immutable maxBonus;
558	 uint256 public immutable maxLockDuration;
559	 uint256 public constant MIN_LOCK_DURATION = 10 minutes;
560	 mapping(address => Deposit[]) public depositsOf;
561	 struct Deposit {
562	 uint256 amount;
563	 uint64 start;
564	 uint64 end;
565	 }
566	 event Deposited(uint256 amount, uint256 duration, address indexed receiver, address indexed from);
567	 event Withdrawn(uint256 indexed depositId, address indexed receiver, address indexed from, uint256 amount);
568	 constructor( string memory _name, string memory _symbol, address _depositToken, address _rewardToken, address _escrowPool, uint256 _escrowPortion, uint256 _escrowDuration, uint256 _maxBonus, uint256 _maxLockDuration ) BasePool(_name, _symbol, _depositToken, _rewardToken, _escrowPool, _escrowPortion, _escrowDuration) {
569	 require(_maxLockDuration >= MIN_LOCK_DURATION, "TimeLockPool.constructor: max lock duration must be greater or equal to mininmum lock duration");
570	 maxBonus = _maxBonus;
571	 maxLockDuration = _maxLockDuration;
572	 }
573	 function deposit(uint256 _amount, uint256 _duration, address _receiver) external override {
574	 require(_amount > 0, "TimeLockPool.deposit: cannot deposit 0");
575	 uint256 duration = _duration.min(maxLockDuration);
576	 duration = duration.max(MIN_LOCK_DURATION);
577	 depositToken.safeTransferFrom(_msgSender(), address(this), _amount);
578	 depositsOf[_receiver].push(Deposit({
579	 amount: _amount, start: uint64(block.timestamp), end: uint64(block.timestamp) + uint64(duration) }
580	 ));
581	 uint256 mintAmount = _amount * getMultiplier(duration) / 1e18;
582	 _mint(_receiver, mintAmount);
583	 emit Deposited(_amount, duration, _receiver, _msgSender());
584	 }
585	 function withdraw(uint256 _depositId, address _receiver) external {
586	 require(_depositId < depositsOf[_msgSender()].length, "TimeLockPool.withdraw: Deposit does not exist");
587	 Deposit memory userDeposit = depositsOf[_msgSender()][_depositId];
588	 require(block.timestamp >= userDeposit.end, "TimeLockPool.withdraw: too soon");
589	 uint256 shareAmount = userDeposit.amount * getMultiplier(uint256(userDeposit.end - userDeposit.start)) / 1e18;
590	 depositsOf[_msgSender()][_depositId] = depositsOf[_msgSender()][depositsOf[_msgSender()].length - 1];
591	 depositsOf[_msgSender()].pop();
592	 _burn(_msgSender(), shareAmount);
593	 depositToken.safeTransfer(_receiver, userDeposit.amount);
594	 emit Withdrawn(_depositId, _receiver, _msgSender(), userDeposit.amount);
595	 }
596	 function getMultiplier(uint256 _lockDuration) public view returns(uint256) {
597	 return 1e18 + (maxBonus * _lockDuration / maxLockDuration);
598	 }
599	 function getTotalDeposit(address _account) public view returns(uint256) {
600	 uint256 total;
601	 for(uint256 i = 0; i < depositsOf[_account].length; i++) {
602	 total += depositsOf[_account][i].amount;
603	 }
604	 return total;
605	 }
606	 function getDepositsOf(address _account) public view returns(Deposit[] memory) {
607	 return depositsOf[_account];
608	 }
609	 function getDepositsOfLength(address _account) public view returns(uint256) {
610	 return depositsOf[_account].length;
611	 }
612	 }
613	 pragma solidity 0.8.7;
614	 contract TimeLockNonTransferablePool is TimeLockPool {
615	 constructor( string memory _name, string memory _symbol, address _depositToken, address _rewardToken, address _escrowPool, uint256 _escrowPortion, uint256 _escrowDuration, uint256 _maxBonus, uint256 _maxLockDuration ) TimeLockPool(_name, _symbol, _depositToken, _rewardToken, _escrowPool, _escrowPortion, _escrowDuration, _maxBonus, _maxLockDuration) {
616	 }
617	 function _transfer(address _from, address _to, uint256 _amount) internal pure override {
618	 revert("NON_TRANSFERABLE");
619	 }
620	 }
621	 pragma solidity ^0.8.0;
622	 library EnumerableSet {
623	 struct Set {
624	 bytes32[] _values;
625	 mapping(bytes32 => uint256) _indexes;
626	 }
627	 function _add(Set storage set, bytes32 value) private returns (bool) {
628	 if (!_contains(set, value)) {
629	 set._values.push(value);
630	 set._indexes[value] = set._values.length;
631	 return true;
632	 }
633	 else {
634	 return false;
635	 }
636	 }
637	 function _remove(Set storage set, bytes32 value) private returns (bool) {
638	 uint256 valueIndex = set._indexes[value];
639	 if (valueIndex != 0) {
640	 uint256 toDeleteIndex = valueIndex - 1;
641	 uint256 lastIndex = set._values.length - 1;
642	 if (lastIndex != toDeleteIndex) {
643	 bytes32 lastvalue = set._values[lastIndex];
644	 set._values[toDeleteIndex] = lastvalue;
645	 set._indexes[lastvalue] = valueIndex;
646	 }
647	 set._values.pop();
648	 delete set._indexes[value];
649	 return true;
650	 }
651	 else {
652	 return false;
653	 }
654	 }
655	 function _contains(Set storage set, bytes32 value) private view returns (bool) {
656	 return set._indexes[value] != 0;
657	 }
658	 function _length(Set storage set) private view returns (uint256) {
659	 return set._values.length;
660	 }
661	 function _at(Set storage set, uint256 index) private view returns (bytes32) {
662	 return set._values[index];
663	 }
664	 function _values(Set storage set) private view returns (bytes32[] memory) {
665	 return set._values;
666	 }
667	 struct Bytes32Set {
668	 Set _inner;
669	 }
670	 function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {
671	 return _add(set._inner, value);
672	 }
673	 function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {
674	 return _remove(set._inner, value);
675	 }
676	 function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {
677	 return _contains(set._inner, value);
678	 }
679	 function length(Bytes32Set storage set) internal view returns (uint256) {
680	 return _length(set._inner);
681	 }
682	 function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {
683	 return _at(set._inner, index);
684	 }
685	 function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {
686	 return _values(set._inner);
687	 }
688	 struct AddressSet {
689	 Set _inner;
690	 }
691	 function add(AddressSet storage set, address value) internal returns (bool) {
692	 return _add(set._inner, bytes32(uint256(uint160(value))));
693	 }
694	 function remove(AddressSet storage set, address value) internal returns (bool) {
695	 return _remove(set._inner, bytes32(uint256(uint160(value))));
696	 }
697	 function contains(AddressSet storage set, address value) internal view returns (bool) {
698	 return _contains(set._inner, bytes32(uint256(uint160(value))));
699	 }
700	 function length(AddressSet storage set) internal view returns (uint256) {
701	 return _length(set._inner);
702	 }
703	 function at(AddressSet storage set, uint256 index) internal view returns (address) {
704	 return address(uint160(uint256(_at(set._inner, index))));
705	 }
706	 function values(AddressSet storage set) internal view returns (address[] memory) {
707	 bytes32[] memory store = _values(set._inner);
708	 address[] memory result;
709	 assembly {
710	 result := store }
711	 return result;
712	 }
713	 struct UintSet {
714	 Set _inner;
715	 }
716	 function add(UintSet storage set, uint256 value) internal returns (bool) {
717	 return _add(set._inner, bytes32(value));
718	 }
719	 function remove(UintSet storage set, uint256 value) internal returns (bool) {
720	 return _remove(set._inner, bytes32(value));
721	 }
722	 function contains(UintSet storage set, uint256 value) internal view returns (bool) {
723	 return _contains(set._inner, bytes32(value));
724	 }
725	 function length(UintSet storage set) internal view returns (uint256) {
726	 return _length(set._inner);
727	 }
728	 function at(UintSet storage set, uint256 index) internal view returns (uint256) {
729	 return uint256(_at(set._inner, index));
730	 }
731	 function values(UintSet storage set) internal view returns (uint256[] memory) {
732	 bytes32[] memory store = _values(set._inner);
733	 uint256[] memory result;
734	 assembly {
735	 result := store }
736	 return result;
737	 }
738	 }
739	 pragma solidity ^0.8.0;
740	 library SafeCast {
741	 function toUint224(uint256 value) internal pure returns (uint224) {
742	 require(value <= type(uint224).max, "SafeCast: value doesn't fit in 224 bits");
743	 return uint224(value);
744	 }
745	 function toUint128(uint256 value) internal pure returns (uint128) {
746	 require(value <= type(uint128).max, "SafeCast: value doesn't fit in 128 bits");
747	 return uint128(value);
748	 }
749	 function toUint96(uint256 value) internal pure returns (uint96) {
750	 require(value <= type(uint96).max, "SafeCast: value doesn't fit in 96 bits");
751	 return uint96(value);
752	 }
753	 function toUint64(uint256 value) internal pure returns (uint64) {
754	 require(value <= type(uint64).max, "SafeCast: value doesn't fit in 64 bits");
755	 return uint64(value);
756	 }
757	 function toUint32(uint256 value) internal pure returns (uint32) {
758	 require(value <= type(uint32).max, "SafeCast: value doesn't fit in 32 bits");
759	 return uint32(value);
760	 }
761	 function toUint16(uint256 value) internal pure returns (uint16) {
762	 require(value <= type(uint16).max, "SafeCast: value doesn't fit in 16 bits");
763	 return uint16(value);
764	 }
765	 function toUint8(uint256 value) internal pure returns (uint8) {
766	 require(value <= type(uint8).max, "SafeCast: value doesn't fit in 8 bits");
767	 return uint8(value);
768	 }
769	 function toUint256(int256 value) internal pure returns (uint256) {
770	 require(value >= 0, "SafeCast: value must be positive");
771	 return uint256(value);
772	 }
773	 function toInt128(int256 value) internal pure returns (int128) {
774	 require(value >= type(int128).min && value <= type(int128).max, "SafeCast: value doesn't fit in 128 bits");
775	 return int128(value);
776	 }
777	 function toInt64(int256 value) internal pure returns (int64) {
778	 require(value >= type(int64).min && value <= type(int64).max, "SafeCast: value doesn't fit in 64 bits");
779	 return int64(value);
780	 }
781	 function toInt32(int256 value) internal pure returns (int32) {
782	 require(value >= type(int32).min && value <= type(int32).max, "SafeCast: value doesn't fit in 32 bits");
783	 return int32(value);
784	 }
785	 function toInt16(int256 value) internal pure returns (int16) {
786	 require(value >= type(int16).min && value <= type(int16).max, "SafeCast: value doesn't fit in 16 bits");
787	 return int16(value);
788	 }
789	 function toInt8(int256 value) internal pure returns (int8) {
790	 require(value >= type(int8).min && value <= type(int8).max, "SafeCast: value doesn't fit in 8 bits");
791	 return int8(value);
792	 }
793	 function toInt256(uint256 value) internal pure returns (int256) {
794	 require(value <= uint256(type(int256).max), "SafeCast: value doesn't fit in an int256");
795	 return int256(value);
796	 }
797	 }
798	 pragma solidity ^0.8.0;
799	 library Math {
800	 function max(uint256 a, uint256 b) internal pure returns (uint256) {
801	 return a >= b ? a : b;
802	 }
803	 function min(uint256 a, uint256 b) internal pure returns (uint256) {
804	 return a < b ? a : b;
805	 }
806	 function average(uint256 a, uint256 b) internal pure returns (uint256) {
807	 return (a & b) + (a ^ b) / 2;
808	 }
809	 function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
810	 return a / b + (a % b == 0 ? 0 : 1);
811	 }
812	 }
813	 pragma solidity ^0.8.0;
814	 library ECDSA {
815	 enum RecoverError {
816	 NoError, InvalidSignature, InvalidSignatureLength, InvalidSignatureS, InvalidSignatureV }
817	 function _throwError(RecoverError error) private pure {
818	 if (error == RecoverError.NoError) {
819	 return;
820	 }
821	 else if (error == RecoverError.InvalidSignature) {
822	 revert("ECDSA: invalid signature");
823	 }
824	 else if (error == RecoverError.InvalidSignatureLength) {
825	 revert("ECDSA: invalid signature length");
826	 }
827	 else if (error == RecoverError.InvalidSignatureS) {
828	 revert("ECDSA: invalid signature 's' value");
829	 }
830	 else if (error == RecoverError.InvalidSignatureV) {
831	 revert("ECDSA: invalid signature 'v' value");
832	 }
833	 }
834	 function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {
835	 if (signature.length == 65) {
836	 bytes32 r;
837	 bytes32 s;
838	 uint8 v;
839	 assembly {
840	 r := mload(add(signature, 0x20)) s := mload(add(signature, 0x40)) v := byte(0, mload(add(signature, 0x60))) }
841	 return tryRecover(hash, v, r, s);
842	 }
843	 else if (signature.length == 64) {
844	 bytes32 r;
845	 bytes32 vs;
846	 assembly {
847	 r := mload(add(signature, 0x20)) vs := mload(add(signature, 0x40)) }
848	 return tryRecover(hash, r, vs);
849	 }
850	 else {
851	 return (address(0), RecoverError.InvalidSignatureLength);
852	 }
853	 }
854	 function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {
855	 (address recovered, RecoverError error) = tryRecover(hash, signature);
856	 _throwError(error);
857	 return recovered;
858	 }
859	 function tryRecover( bytes32 hash, bytes32 r, bytes32 vs ) internal pure returns (address, RecoverError) {
860	 bytes32 s;
861	 uint8 v;
862	 assembly {
863	 s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) v := add(shr(255, vs), 27) }
864	 return tryRecover(hash, v, r, s);
865	 }
866	 function recover( bytes32 hash, bytes32 r, bytes32 vs ) internal pure returns (address) {
867	 (address recovered, RecoverError error) = tryRecover(hash, r, vs);
868	 _throwError(error);
869	 return recovered;
870	 }
871	 function tryRecover( bytes32 hash, uint8 v, bytes32 r, bytes32 s ) internal pure returns (address, RecoverError) {
872	 if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {
873	 return (address(0), RecoverError.InvalidSignatureS);
874	 }
875	 if (v != 27 && v != 28) {
876	 return (address(0), RecoverError.InvalidSignatureV);
877	 }
878	 address signer = ecrecover(hash, v, r, s);
879	 if (signer == address(0)) {
880	 return (address(0), RecoverError.InvalidSignature);
881	 }
882	 return (signer, RecoverError.NoError);
883	 }
884	 function recover( bytes32 hash, uint8 v, bytes32 r, bytes32 s ) internal pure returns (address) {
885	 (address recovered, RecoverError error) = tryRecover(hash, v, r, s);
886	 _throwError(error);
887	 return recovered;
888	 }
889	 function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {
890	 return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
891	 }
892	 function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {
893	 return keccak256(abi.encodePacked("\x19\x01", domainSeparator, structHash));
894	 }
895	 }
896	 pragma solidity ^0.8.0;
897	 library Strings {
898	 bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";
899	 function toString(uint256 value) internal pure returns (string memory) {
900	 if (value == 0) {
901	 return "0";
902	 }
903	 uint256 temp = value;
904	 uint256 digits;
905	 while (temp != 0) {
906	 digits++;
907	 temp /= 10;
908	 }
909	 bytes memory buffer = new bytes(digits);
910	 while (value != 0) {
911	 digits -= 1;
912	 buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
913	 value /= 10;
914	 }
915	 return string(buffer);
916	 }
917	 function toHexString(uint256 value) internal pure returns (string memory) {
918	 if (value == 0) {
919	 return "0x00";
920	 }
921	 uint256 temp = value;
922	 uint256 length = 0;
923	 while (temp != 0) {
924	 length++;
925	 temp >>= 8;
926	 }
927	 return toHexString(value, length);
928	 }
929	 function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
930	 bytes memory buffer = new bytes(2 * length + 2);
931	 buffer[0] = "0";
932	 buffer[1] = "x";
933	 for (uint256 i = 2 * length + 1; i > 1; --i) {
934	 buffer[i] = _HEX_SYMBOLS[value & 0xf];
935	 value >>= 4;
936	 }
937	 require(value == 0, "Strings: hex length insufficient");
938	 return string(buffer);
939	 }
940	 }
941	 pragma solidity ^0.8.0;
942	 library Counters {
943	 struct Counter {
944	 uint256 _value;
945	 }
946	 function current(Counter storage counter) internal view returns (uint256) {
947	 return counter._value;
948	 }
949	 function increment(Counter storage counter) internal {
950	 unchecked {
951	 counter._value += 1;
952	 }
953	 }
954	 function decrement(Counter storage counter) internal {
955	 uint256 value = counter._value;
956	 require(value > 0, "Counter: decrement overflow");
957	 unchecked {
958	 counter._value = value - 1;
959	 }
960	 }
961	 function reset(Counter storage counter) internal {
962	 counter._value = 0;
963	 }
964	 }
965	 pragma solidity ^0.8.0;
966	 library Address {
967	 function isContract(address account) internal view returns (bool) {
968	 uint256 size;
969	 assembly {
970	 size := extcodesize(account) }
971	 return size > 0;
972	 }
973	 function sendValue(address payable recipient, uint256 amount) internal {
974	 require(address(this).balance >= amount, "Address: insufficient balance");
975	 (bool success, ) = recipient.call{
976	 value: amount}
977	 ("");
978	 require(success, "Address: unable to send value, recipient may have reverted");
979	 }
980	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
981	 return functionCall(target, data, "Address: low-level call failed");
982	 }
983	 function functionCall( address target, bytes memory data, string memory errorMessage ) internal returns (bytes memory) {
984	 return functionCallWithValue(target, data, 0, errorMessage);
985	 }
986	 function functionCallWithValue( address target, bytes memory data, uint256 value ) internal returns (bytes memory) {
987	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
988	 }
989	 function functionCallWithValue( address target, bytes memory data, uint256 value, string memory errorMessage ) internal returns (bytes memory) {
990	 require(address(this).balance >= value, "Address: insufficient balance for call");
991	 require(isContract(target), "Address: call to non-contract");
992	 (bool success, bytes memory returndata) = target.call{
993	 value: value}
994	 (data);
995	 return verifyCallResult(success, returndata, errorMessage);
996	 }
997	 function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
998	 return functionStaticCall(target, data, "Address: low-level static call failed");
999	 }
1000	 function functionStaticCall( address target, bytes memory data, string memory errorMessage ) internal view returns (bytes memory) {
1001	 require(isContract(target), "Address: static call to non-contract");
1002	 (bool success, bytes memory returndata) = target.staticcall(data);
1003	 return verifyCallResult(success, returndata, errorMessage);
1004	 }
1005	 function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
1006	 return functionDelegateCall(target, data, "Address: low-level delegate call failed");
1007	 }
1008	 function functionDelegateCall( address target, bytes memory data, string memory errorMessage ) internal returns (bytes memory) {
1009	 require(isContract(target), "Address: delegate call to non-contract");
1010	 (bool success, bytes memory returndata) = target.delegatecall(data);
1011	 return verifyCallResult(success, returndata, errorMessage);
1012	 }
1013	 function verifyCallResult( bool success, bytes memory returndata, string memory errorMessage ) internal pure returns (bytes memory) {
1014	 if (success) {
1015	 return returndata;
1016	 }
1017	 else {
1018	 if (returndata.length > 0) {
1019	 assembly {
1020	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
1021	 }
1022	 else {
1023	 revert(errorMessage);
1024	 }
1025	 }
1026	 }
1027	 }
1028	 pragma solidity ^0.8.0;
1029	 library SafeERC20 {
1030	 using Address for address;
1031	 function safeTransfer( IERC20 token, address to, uint256 value ) internal {
1032	 _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
1033	 }
1034	 function safeTransferFrom( IERC20 token, address from, address to, uint256 value ) internal {
1035	 _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
1036	 }
1037	 function safeApprove( IERC20 token, address spender, uint256 value ) internal {
1038	 require( (value == 0) || (token.allowance(address(this), spender) == 0), "SafeERC20: approve from non-zero to non-zero allowance" );
1039	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
1040	 }
1041	 function safeIncreaseAllowance( IERC20 token, address spender, uint256 value ) internal {
1042	 uint256 newAllowance = token.allowance(address(this), spender) + value;
1043	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
1044	 }
1045	 function safeDecreaseAllowance( IERC20 token, address spender, uint256 value ) internal {
1046	 unchecked {
1047	 uint256 oldAllowance = token.allowance(address(this), spender);
1048	 require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");
1049	 uint256 newAllowance = oldAllowance - value;
1050	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
1051	 }
1052	 }
1053	 function _callOptionalReturn(IERC20 token, bytes memory data) private {
1054	 bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
1055	 if (returndata.length > 0) {
1056	 require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
1057	 }
1058	 }
1059	 }
