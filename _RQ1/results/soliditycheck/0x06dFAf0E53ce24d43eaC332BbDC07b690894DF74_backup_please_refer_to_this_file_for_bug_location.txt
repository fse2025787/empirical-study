row number 
1	  pragma abicoder v2;
2	 pragma solidity >=0.4.24 <0.8.0;
3	 abstract contract Initializable {
4	 bool private _initialized;
5	 bool private _initializing;
6	 modifier initializer() {
7	 require(_initializing || _isConstructor() || !_initialized, "Initializable: contract is already initialized");
8	 bool isTopLevelCall = !_initializing;
9	 if (isTopLevelCall) {
10	 _initializing = true;
11	 _initialized = true;
12	 }
13	 _;
14	 if (isTopLevelCall) {
15	 _initializing = false;
16	 }
17	 }
18	 function _isConstructor() private view returns (bool) {
19	 return !AddressUpgradeable.isContract(address(this));
20	 }
21	 }
22	 pragma solidity >=0.6.0 <0.8.0;
23	 abstract contract ContextUpgradeable is Initializable {
24	 function __Context_init() internal initializer {
25	 __Context_init_unchained();
26	 }
27	 function __Context_init_unchained() internal initializer {
28	 }
29	 function _msgSender() internal view virtual returns (address payable) {
30	 return msg.sender;
31	 }
32	 function _msgData() internal view virtual returns (bytes memory) {
33	 this;
34	 return msg.data;
35	 }
36	 uint256[50] private __gap;
37	 }
38	 pragma solidity ^0.7.6;
39	 abstract contract FeeCustomization {
40	 event CustomizeFee(bytes32 _feeType, address _user, uint256 _rate);
41	 event CancleCustomizeFee(bytes32 _feeType, address _user);
42	 uint256 internal constant FEE_PRECISION = 1e9;
43	 bytes32 private constant SALT = keccak256("FeeCustomization");
44	 function getFeeRate(bytes32 _feeType, address _user) public view returns (uint256 rate) {
45	 rate = _defaultFeeRate(_feeType);
46	 (uint8 _customized, uint32 _rate) = _loadFeeCustomization(_feeType, _user);
47	 if (_customized == 1) {
48	 rate = _rate;
49	 }
50	 }
51	 function _setFeeCustomization( bytes32 _feeType, address _user, uint32 _rate ) internal {
52	 require(_rate <= FEE_PRECISION, "rate too large");
53	 uint256 _slot = _computeStorageSlot(_feeType, _user);
54	 uint256 _encoded = _encode(1, _rate);
55	 assembly {
56	 sstore(_slot, _encoded) }
57	 emit CustomizeFee(_feeType, _user, _rate);
58	 }
59	 function _cancleFeeCustomization(bytes32 _feeType, address _user) internal {
60	 uint256 _slot = _computeStorageSlot(_feeType, _user);
61	 assembly {
62	 sstore(_slot, 0) }
63	 emit CancleCustomizeFee(_feeType, _user);
64	 }
65	 function _defaultFeeRate(bytes32 _feeType) internal view virtual returns (uint256 rate);
66	 function _loadFeeCustomization(bytes32 _feeType, address _user) private view returns (uint8 customized, uint32 rate) {
67	 uint256 _slot = _computeStorageSlot(_feeType, _user);
68	 uint256 _encoded;
69	 assembly {
70	 _encoded := sload(_slot) }
71	 (customized, rate) = _decode(_encoded);
72	 }
73	 function _computeStorageSlot(bytes32 _feeType, address _user) private pure returns (uint256 slot) {
74	 bytes32 salt = SALT;
75	 assembly {
76	 mstore(0x00, _feeType) mstore(0x20, xor(_user, salt)) slot := keccak256(0x00, 0x40) }
77	 }
78	 function _encode(uint8 customized, uint32 rate) private pure returns (uint256 encoded) {
79	 encoded = (uint256(rate) << 8) | uint256(customized);
80	 }
81	 function _decode(uint256 _encoded) private pure returns (uint8 customized, uint32 rate) {
82	 customized = uint8(_encoded & 0xff);
83	 rate = uint32((_encoded >> 8) & 0xffffffff);
84	 }
85	 }
86	 pragma solidity ^0.7.6;
87	 interface IConcentratorGeneralVault {
88	 event Approval(uint256 indexed pid, address indexed owner, address indexed spender, uint256 value);
89	 event Deposit( uint256 indexed pid, address indexed sender, address indexed recipient, uint256 assetsIn, uint256 sharesOut );
90	 event Withdraw( uint256 indexed pid, address indexed sender, address indexed owner, address recipient, uint256 sharesIn, uint256 assetsOut );
91	 event Claim(uint256 indexed pid, address indexed sender, address indexed recipient, uint256 rewards);
92	 event Harvest( uint256 indexed pid, address indexed caller, address indexed recipient, uint256 rewards, uint256 platformFee, uint256 harvestBounty );
93	 function rewardToken() external view returns (address);
94	 function pendingReward(uint256 pid, address account) external view returns (uint256);
95	 function pendingRewardAll(address account) external view returns (uint256);
96	 function getUserShare(uint256 pid, address account) external view returns (uint256);
97	 function underlying(uint256 pid) external view returns (address);
98	 function getTotalUnderlying(uint256 pid) external view returns (uint256);
99	 function getTotalShare(uint256 pid) external view returns (uint256);
100	 function allowance( uint256 pid, address owner, address spender ) external view returns (uint256);
101	 function approve( uint256 pid, address spender, uint256 amount ) external;
102	 function deposit( uint256 pid, address recipient, uint256 assets ) external returns (uint256 share);
103	 function withdraw( uint256 pid, uint256 shares, address recipient, address owner ) external returns (uint256 assets);
104	 function claim( uint256 pid, address recipient, uint256 minOut, address claimAsToken ) external returns (uint256 claimed);
105	 function claimMulti( uint256[] memory pids, address recipient, uint256 minOut, address claimAsToken ) external returns (uint256 claimed);
106	 function claimAll( uint256 minOut, address recipient, address claimAsToken ) external returns (uint256 claimed);
107	 function harvest( uint256 pid, address recipient, uint256 minOut ) external returns (uint256 harvested);
108	 }
109	 pragma solidity ^0.7.0;
110	 abstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {
111	 address private _owner;
112	 event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
113	 function __Ownable_init() internal initializer {
114	 __Context_init_unchained();
115	 __Ownable_init_unchained();
116	 }
117	 function __Ownable_init_unchained() internal initializer {
118	 address msgSender = _msgSender();
119	 _owner = msgSender;
120	 emit OwnershipTransferred(address(0), msgSender);
121	 }
122	 function owner() public view virtual returns (address) {
123	 return _owner;
124	 }
125	 modifier onlyOwner() {
126	 require(owner() == _msgSender(), "Ownable: caller is not the owner");
127	 _;
128	 }
129	 function renounceOwnership() public virtual onlyOwner {
130	 emit OwnershipTransferred(_owner, address(0));
131	 _owner = address(0);
132	 }
133	 function transferOwnership(address newOwner) public virtual onlyOwner {
134	 require(newOwner != address(0), "Ownable: new owner is the zero address");
135	 emit OwnershipTransferred(_owner, newOwner);
136	 _owner = newOwner;
137	 }
138	 uint256[49] private __gap;
139	 }
140	 pragma solidity ^0.7.0;
141	 abstract contract ReentrancyGuardUpgradeable is Initializable {
142	 uint256 private constant _NOT_ENTERED = 1;
143	 uint256 private constant _ENTERED = 2;
144	 uint256 private _status;
145	 function __ReentrancyGuard_init() internal initializer {
146	 __ReentrancyGuard_init_unchained();
147	 }
148	 function __ReentrancyGuard_init_unchained() internal initializer {
149	 _status = _NOT_ENTERED;
150	 }
151	 modifier nonReentrant() {
152	 require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
153	 _status = _ENTERED;
154	 _;
155	 _status = _NOT_ENTERED;
156	 }
157	 uint256[49] private __gap;
158	 }
159	 pragma solidity ^0.7.6;
160	 abstract contract ConcentratorGeneralVault is OwnableUpgradeable, ReentrancyGuardUpgradeable, FeeCustomization, IConcentratorGeneralVault {
161	 using SafeMathUpgradeable for uint256;
162	 using SafeERC20Upgradeable for IERC20Upgradeable;
163	 event UpdatePoolFeeRatio( uint256 indexed _pid, uint32 _withdrawFeeRatio, uint32 _platformFeeRatio, uint32 _harvestBountyRatio );
164	 event UpdatePlatform(address indexed _platform);
165	 event UpdateZap(address indexed _zap);
166	 event Migrate(uint256 indexed _pid, address _oldStrategy, address _newStrategy);
167	 event UpdateRewardPeriod(uint256 indexed _pid, uint32 _period);
168	 event UpdatePoolRewardTokens(uint256 indexed _pid, address[] _rewardTokens);
169	 event AddPool(uint256 indexed _pid, address _underlying, address _strategy);
170	 event PausePoolDeposit(uint256 indexed _pid, bool _status);
171	 event PausePoolWithdraw(uint256 indexed _pid, bool _status);
172	 struct PoolRewardInfo {
173	 uint128 rate;
174	 uint32 periodLength;
175	 uint48 lastUpdate;
176	 uint48 finishAt;
177	 uint256 accRewardPerShare;
178	 }
179	 struct PoolSupplyInfo {
180	 uint128 totalUnderlying;
181	 uint128 totalShare;
182	 }
183	 struct PoolFeeInfo {
184	 uint32 withdrawFeeRatio;
185	 uint32 platformFeeRatio;
186	 uint32 harvestBountyRatio;
187	 uint160 reserved;
188	 }
189	 struct PoolStrategyInfo {
190	 address token;
191	 address strategy;
192	 bool pauseDeposit;
193	 bool pauseWithdraw;
194	 }
195	 struct PoolInfo {
196	 PoolSupplyInfo supply;
197	 PoolStrategyInfo strategy;
198	 PoolRewardInfo reward;
199	 PoolFeeInfo fee;
200	 }
201	 struct UserInfo {
202	 uint128 shares;
203	 uint128 rewards;
204	 uint256 rewardPerSharePaid;
205	 mapping(address => uint256) allowances;
206	 }
207	 bytes32 internal constant WITHDRAW_FEE_TYPE = keccak256("ConcentratorGeneralVault.WithdrawFee");
208	 uint256 internal constant REWARD_PRECISION = 1e18;
209	 uint256 internal constant MAX_WITHDRAW_FEE = 1e8;
210	 uint256 internal constant MAX_PLATFORM_FEE = 2e8;
211	 uint256 internal constant MAX_HARVEST_BOUNTY = 1e8;
212	 uint256 internal constant WEEK = 86400 * 7;
213	 mapping(uint256 => PoolInfo) public poolInfo;
214	 mapping(uint256 => mapping(address => UserInfo)) public userInfo;
215	 uint256 private poolIndex;
216	 address public platform;
217	 address public zap;
218	 uint256[45] private __gap;
219	 modifier onlyExistPool(uint256 _pid) {
220	 require(_pid < poolIndex, "Concentrator: pool not exist");
221	 _;
222	 }
223	 receive() external payable {
224	 }
225	 function _initialize(address _zap, address _platform) internal {
226	 OwnableUpgradeable.__Ownable_init();
227	 ReentrancyGuardUpgradeable.__ReentrancyGuard_init();
228	 require(_zap != address(0), "Concentrator: zero zap address");
229	 require(_platform != address(0), "Concentrator: zero platform address");
230	 platform = _platform;
231	 zap = _zap;
232	 }
233	 function rewardToken() public view virtual override returns (address) {
234	 }
235	 function poolLength() external view returns (uint256 pools) {
236	 pools = poolIndex;
237	 }
238	 function pendingReward(uint256 _pid, address _account) public view override returns (uint256) {
239	 PoolInfo storage _pool = poolInfo[_pid];
240	 PoolRewardInfo memory _reward = _pool.reward;
241	 PoolSupplyInfo memory _supply = _pool.supply;
242	 if (_reward.periodLength > 0) {
243	 uint256 _currentTime = _reward.finishAt;
244	 if (_currentTime > block.timestamp) _currentTime = block.timestamp;
245	 uint256 _duration = _currentTime >= _reward.lastUpdate ? _currentTime - _reward.lastUpdate : 0;
246	 if (_duration > 0 && _supply.totalShare > 0) {
247	 _reward.accRewardPerShare = _reward.accRewardPerShare.add( _duration.mul(_reward.rate).mul(REWARD_PRECISION) / _supply.totalShare );
248	 }
249	 }
250	 return _pendingReward(_pid, _account, _reward.accRewardPerShare);
251	 }
252	 function pendingRewardAll(address _account) external view override returns (uint256) {
253	 uint256 _length = poolIndex;
254	 uint256 _pending;
255	 for (uint256 i = 0; i < _length; i++) {
256	 _pending += pendingReward(i, _account);
257	 }
258	 return _pending;
259	 }
260	 function getUserShare(uint256 _pid, address _account) external view override returns (uint256) {
261	 return userInfo[_pid][_account].shares;
262	 }
263	 function underlying(uint256 _pid) external view override returns (address) {
264	 return poolInfo[_pid].strategy.token;
265	 }
266	 function getTotalUnderlying(uint256 _pid) external view override returns (uint256) {
267	 return poolInfo[_pid].supply.totalUnderlying;
268	 }
269	 function getTotalShare(uint256 _pid) external view override returns (uint256) {
270	 return poolInfo[_pid].supply.totalShare;
271	 }
272	 function allowance( uint256 _pid, address _owner, address _spender ) external view override returns (uint256) {
273	 UserInfo storage _info = userInfo[_pid][_owner];
274	 return _info.allowances[_spender];
275	 }
276	 function approve( uint256 _pid, address _spender, uint256 _amount ) external override {
277	 _approve(_pid, msg.sender, _spender, _amount);
278	 }
279	 function deposit( uint256 _pid, address _recipient, uint256 _assetsIn ) public override onlyExistPool(_pid) nonReentrant returns (uint256) {
280	 PoolStrategyInfo memory _strategy = poolInfo[_pid].strategy;
281	 require(!_strategy.pauseDeposit, "Concentrator: deposit paused");
282	 if (_assetsIn == uint256(-1)) {
283	 _assetsIn = IERC20Upgradeable(_strategy.token).balanceOf(msg.sender);
284	 }
285	 require(_assetsIn > 0, "Concentrator: deposit zero amount");
286	 _updateRewards(_pid, _recipient);
287	 uint256 _before = IERC20Upgradeable(_strategy.token).balanceOf(_strategy.strategy);
288	 IERC20Upgradeable(_strategy.token).safeTransferFrom(msg.sender, _strategy.strategy, _assetsIn);
289	 _assetsIn = IERC20Upgradeable(_strategy.token).balanceOf(_strategy.strategy) - _before;
290	 return _deposit(_pid, _recipient, _assetsIn);
291	 }
292	 function withdraw( uint256 _pid, uint256 _sharesIn, address _recipient, address _owner ) public override onlyExistPool(_pid) nonReentrant returns (uint256) {
293	 if (_sharesIn == uint256(-1)) {
294	 _sharesIn = userInfo[_pid][_owner].shares;
295	 }
296	 require(_sharesIn > 0, "Concentrator: withdraw zero share");
297	 if (msg.sender != _owner) {
298	 UserInfo storage _info = userInfo[_pid][_owner];
299	 uint256 _allowance = _info.allowances[msg.sender];
300	 require(_allowance >= _sharesIn, "Concentrator: withdraw exceeds allowance");
301	 if (_allowance != uint256(-1)) {
302	 _approve(_pid, _owner, msg.sender, _allowance - _sharesIn);
303	 }
304	 }
305	 PoolInfo storage _pool = poolInfo[_pid];
306	 require(!_pool.strategy.pauseWithdraw, "Concentrator: withdraw paused");
307	 _updateRewards(_pid, _owner);
308	 return _withdraw(_pid, _sharesIn, _owner, _recipient);
309	 }
310	 function claim( uint256 _pid, address _recipient, uint256 _minOut, address _claimAsToken ) public override onlyExistPool(_pid) nonReentrant returns (uint256) {
311	 _updateRewards(_pid, msg.sender);
312	 UserInfo storage _userInfo = userInfo[_pid][msg.sender];
313	 uint256 _rewards = _userInfo.rewards;
314	 _userInfo.rewards = 0;
315	 emit Claim(_pid, msg.sender, _recipient, _rewards);
316	 _rewards = _claim(_rewards, _minOut, _recipient, _claimAsToken);
317	 return _rewards;
318	 }
319	 function claimMulti( uint256[] memory _pids, address _recipient, uint256 _minOut, address _claimAsToken ) public override nonReentrant returns (uint256) {
320	 uint256 _poolIndex = poolIndex;
321	 uint256 _rewards;
322	 for (uint256 i = 0; i < _pids.length; i++) {
323	 uint256 _pid = _pids[i];
324	 require(_pid < _poolIndex, "Concentrator: pool not exist");
325	 UserInfo storage _userInfo = userInfo[_pid][msg.sender];
326	 if (_userInfo.shares > 0) {
327	 _updateRewards(_pid, msg.sender);
328	 }
329	 if (_userInfo.rewards > 0) {
330	 _rewards = _rewards.add(_userInfo.rewards);
331	 emit Claim(_pid, msg.sender, _recipient, _userInfo.rewards);
332	 _userInfo.rewards = 0;
333	 }
334	 }
335	 return _claim(_rewards, _minOut, _recipient, _claimAsToken);
336	 }
337	 function claimAll( uint256 _minOut, address _recipient, address _claimAsToken ) external override nonReentrant returns (uint256) {
338	 uint256 _length = poolIndex;
339	 uint256 _rewards;
340	 for (uint256 _pid = 0; _pid < _length; _pid++) {
341	 UserInfo storage _userInfo = userInfo[_pid][msg.sender];
342	 if (_userInfo.shares > 0) {
343	 _updateRewards(_pid, msg.sender);
344	 }
345	 if (_userInfo.rewards > 0) {
346	 _rewards = _rewards.add(_userInfo.rewards);
347	 emit Claim(_pid, msg.sender, _recipient, _userInfo.rewards);
348	 _userInfo.rewards = 0;
349	 }
350	 }
351	 return _claim(_rewards, _minOut, _recipient, _claimAsToken);
352	 }
353	 function harvest( uint256 _pid, address _recipient, uint256 _minOut ) external virtual override onlyExistPool(_pid) nonReentrant returns (uint256) {
354	 _updateRewards(_pid, address(0));
355	 uint256 _rewards = _harvest(_pid);
356	 require(_rewards >= _minOut, "Concentrator: insufficient rewards");
357	 address _token = rewardToken();
358	 PoolFeeInfo memory _fees = poolInfo[_pid].fee;
359	 uint256 _platformFee;
360	 uint256 _harvestBounty;
361	 if (_fees.platformFeeRatio > 0) {
362	 _platformFee = (uint256(_fees.platformFeeRatio) * _rewards) / FEE_PRECISION;
363	 IERC20Upgradeable(_token).safeTransfer(platform, _platformFee);
364	 }
365	 if (_fees.harvestBountyRatio > 0) {
366	 _harvestBounty = (uint256(_fees.harvestBountyRatio) * _rewards) / FEE_PRECISION;
367	 IERC20Upgradeable(_token).safeTransfer(_recipient, _harvestBounty);
368	 }
369	 emit Harvest(_pid, msg.sender, _recipient, _rewards, _platformFee, _harvestBounty);
370	 _notifyHarvestedReward(_pid, _rewards - _platformFee - _harvestBounty);
371	 return _rewards;
372	 }
373	 function checkpoint(uint256 _pid, address _account) external {
374	 _updateRewards(_pid, _account);
375	 }
376	 function updatePoolFeeRatio( uint256 _pid, uint32 _withdrawFeeRatio, uint32 _platformFeeRatio, uint32 _harvestBountyRatio ) external onlyExistPool(_pid) onlyOwner {
377	 require(_withdrawFeeRatio <= MAX_WITHDRAW_FEE, "Concentrator: withdraw fee too large");
378	 require(_platformFeeRatio <= MAX_PLATFORM_FEE, "Concentrator: platform fee too large");
379	 require(_harvestBountyRatio <= MAX_HARVEST_BOUNTY, "Concentrator: harvest bounty too large");
380	 poolInfo[_pid].fee = PoolFeeInfo({
381	 withdrawFeeRatio: _withdrawFeeRatio, platformFeeRatio: _platformFeeRatio, harvestBountyRatio: _harvestBountyRatio, reserved: 0 }
382	 );
383	 emit UpdatePoolFeeRatio(_pid, _withdrawFeeRatio, _platformFeeRatio, _harvestBountyRatio);
384	 }
385	 function setWithdrawFeeForUser( uint256 _pid, address _user, uint32 _ratio ) external onlyExistPool(_pid) onlyOwner {
386	 require(_ratio <= MAX_WITHDRAW_FEE, "Concentrator: withdraw fee too large");
387	 _setFeeCustomization(_getWithdrawFeeType(_pid), _user, _ratio);
388	 }
389	 function updatePlatform(address _platform) external onlyOwner {
390	 require(_platform != address(0), "Concentrator: zero platform address");
391	 platform = _platform;
392	 emit UpdatePlatform(_platform);
393	 }
394	 function updateZap(address _zap) external onlyOwner {
395	 require(_zap != address(0), "Concentrator: zero zap address");
396	 zap = _zap;
397	 emit UpdateZap(_zap);
398	 }
399	 function addPool( address _underlying, address _strategy, uint32 _withdrawFeeRatio, uint32 _platformFeeRatio, uint32 _harvestBountyRatio ) external onlyOwner {
400	 require(_withdrawFeeRatio <= MAX_WITHDRAW_FEE, "Concentrator: withdraw fee too large");
401	 require(_platformFeeRatio <= MAX_PLATFORM_FEE, "Concentrator: platform fee too large");
402	 require(_harvestBountyRatio <= MAX_HARVEST_BOUNTY, "Concentrator: harvest bounty too large");
403	 uint256 _pid = poolIndex;
404	 poolIndex = _pid + 1;
405	 poolInfo[_pid].strategy = PoolStrategyInfo({
406	 token: _underlying, strategy: _strategy, pauseDeposit: false, pauseWithdraw: false }
407	 );
408	 poolInfo[_pid].fee = PoolFeeInfo({
409	 withdrawFeeRatio: _withdrawFeeRatio, platformFeeRatio: _platformFeeRatio, harvestBountyRatio: _harvestBountyRatio, reserved: 0 }
410	 );
411	 emit AddPool(_pid, _underlying, _strategy);
412	 }
413	 function updateRewardPeriod(uint256 _pid, uint32 _period) external onlyExistPool(_pid) onlyOwner {
414	 require(_period <= WEEK, "Concentrator: reward period too long");
415	 poolInfo[_pid].reward.periodLength = _period;
416	 emit UpdateRewardPeriod(_pid, _period);
417	 }
418	 function updatePoolRewardTokens(uint256 _pid, address[] memory _rewardTokens) external onlyExistPool(_pid) onlyOwner {
419	 IConcentratorStrategy(poolInfo[_pid].strategy.strategy).updateRewards(_rewardTokens);
420	 emit UpdatePoolRewardTokens(_pid, _rewardTokens);
421	 }
422	 function pausePoolWithdraw(uint256 _pid, bool _status) external onlyExistPool(_pid) onlyOwner {
423	 poolInfo[_pid].strategy.pauseWithdraw = _status;
424	 emit PausePoolWithdraw(_pid, _status);
425	 }
426	 function pausePoolDeposit(uint256 _pid, bool _status) external onlyExistPool(_pid) onlyOwner {
427	 poolInfo[_pid].strategy.pauseDeposit = _status;
428	 emit PausePoolDeposit(_pid, _status);
429	 }
430	 function migrateStrategy(uint256 _pid, address _newStrategy) external onlyExistPool(_pid) onlyOwner {
431	 uint256 _totalUnderlying = poolInfo[_pid].supply.totalUnderlying;
432	 address _oldStrategy = poolInfo[_pid].strategy.strategy;
433	 poolInfo[_pid].strategy.strategy = _newStrategy;
434	 IConcentratorStrategy(_oldStrategy).prepareMigrate(_newStrategy);
435	 IConcentratorStrategy(_oldStrategy).withdraw(_newStrategy, _totalUnderlying);
436	 IConcentratorStrategy(_oldStrategy).finishMigrate(_newStrategy);
437	 IConcentratorStrategy(_newStrategy).deposit(address(this), _totalUnderlying);
438	 emit Migrate(_pid, _oldStrategy, _newStrategy);
439	 }
440	 function _pendingReward( uint256 _pid, address _account, uint256 _accRewardPerShare ) internal view returns (uint256) {
441	 UserInfo storage _userInfo = userInfo[_pid][_account];
442	 return uint256(_userInfo.rewards).add( _accRewardPerShare.sub(_userInfo.rewardPerSharePaid).mul(_userInfo.shares) / REWARD_PRECISION );
443	 }
444	 function _updateRewards(uint256 _pid, address _account) internal virtual {
445	 PoolInfo storage _pool = poolInfo[_pid];
446	 PoolRewardInfo memory _poolRewardInfo = _pool.reward;
447	 PoolSupplyInfo memory _supply = _pool.supply;
448	 if (_poolRewardInfo.periodLength > 0) {
449	 uint256 _currentTime = _poolRewardInfo.finishAt;
450	 if (_currentTime > block.timestamp) {
451	 _currentTime = block.timestamp;
452	 }
453	 uint256 _duration = _currentTime >= _poolRewardInfo.lastUpdate ? _currentTime - _poolRewardInfo.lastUpdate : 0;
454	 if (_duration > 0) {
455	 _poolRewardInfo.lastUpdate = uint48(block.timestamp);
456	 if (_supply.totalShare > 0) {
457	 _poolRewardInfo.accRewardPerShare = _poolRewardInfo.accRewardPerShare.add( _duration.mul(_poolRewardInfo.rate).mul(REWARD_PRECISION) / _supply.totalShare );
458	 }
459	 _pool.reward = _poolRewardInfo;
460	 }
461	 }
462	 if (_account != address(0)) {
463	 uint256 _rewards = _pendingReward(_pid, _account, _poolRewardInfo.accRewardPerShare);
464	 UserInfo storage _userInfo = userInfo[_pid][_account];
465	 _userInfo.rewards = SafeCastUpgradeable.toUint128(_rewards);
466	 _userInfo.rewardPerSharePaid = _poolRewardInfo.accRewardPerShare;
467	 }
468	 }
469	 function _deposit( uint256 _pid, address _recipient, uint256 _assetsIn ) internal returns (uint256) {
470	 PoolInfo storage _pool = poolInfo[_pid];
471	 IConcentratorStrategy(_pool.strategy.strategy).deposit(_recipient, _assetsIn);
472	 PoolSupplyInfo memory _supply = _pool.supply;
473	 uint256 _sharesOut;
474	 if (_supply.totalShare == 0) {
475	 _sharesOut = _assetsIn;
476	 }
477	 else {
478	 _sharesOut = _assetsIn.mul(_supply.totalShare) / _supply.totalUnderlying;
479	 }
480	 _supply.totalShare = _supply.totalShare + uint128(_sharesOut);
481	 _supply.totalUnderlying = _supply.totalUnderlying + uint128(_assetsIn);
482	 _pool.supply = _supply;
483	 UserInfo storage _userInfo = userInfo[_pid][_recipient];
484	 _userInfo.shares = uint128(_sharesOut + _userInfo.shares);
485	 emit Deposit(_pid, msg.sender, _recipient, _assetsIn, _sharesOut);
486	 return _sharesOut;
487	 }
488	 function _withdraw( uint256 _pid, uint256 _sharesIn, address _owner, address _recipient ) internal returns (uint256) {
489	 PoolInfo storage _pool = poolInfo[_pid];
490	 UserInfo storage _userInfo = userInfo[_pid][_owner];
491	 require(_sharesIn <= _userInfo.shares, "Concentrator: exceed user shares");
492	 PoolSupplyInfo memory _supply = _pool.supply;
493	 uint256 _assetsOut;
494	 if (_sharesIn == _supply.totalShare) {
495	 _assetsOut = _supply.totalUnderlying;
496	 }
497	 else {
498	 uint256 _withdrawFeeRatio = getFeeRate(_getWithdrawFeeType(_pid), _owner);
499	 _assetsOut = _sharesIn.mul(_supply.totalUnderlying) / _supply.totalShare;
500	 uint256 _fee = _assetsOut.mul(_withdrawFeeRatio) / FEE_PRECISION;
501	 _assetsOut = _assetsOut - _fee;
502	 }
503	 _supply.totalShare = _supply.totalShare - uint128(_sharesIn);
504	 _supply.totalUnderlying = _supply.totalUnderlying - uint128(_assetsOut);
505	 _pool.supply = _supply;
506	 _userInfo.shares = _userInfo.shares - uint128(_sharesIn);
507	 IConcentratorStrategy(_pool.strategy.strategy).withdraw(_recipient, _assetsOut);
508	 emit Withdraw(_pid, msg.sender, _owner, _recipient, _sharesIn, _assetsOut);
509	 return _assetsOut;
510	 }
511	 function _approve( uint256 _pid, address _owner, address _spender, uint256 _amount ) internal {
512	 require(_owner != address(0), "Concentrator: approve from the zero address");
513	 require(_spender != address(0), "Concentrator: approve to the zero address");
514	 UserInfo storage _info = userInfo[_pid][_owner];
515	 _info.allowances[_spender] = _amount;
516	 emit Approval(_pid, _owner, _spender, _amount);
517	 }
518	 function _notifyHarvestedReward(uint256 _pid, uint256 _amount) internal virtual {
519	 require(_amount < uint128(-1), "Concentrator: harvested amount overflow");
520	 PoolRewardInfo memory _info = poolInfo[_pid].reward;
521	 if (_info.periodLength == 0) {
522	 _info.accRewardPerShare = _info.accRewardPerShare.add( _amount.mul(REWARD_PRECISION) / poolInfo[_pid].supply.totalShare );
523	 }
524	 else {
525	 if (block.timestamp >= _info.finishAt) {
526	 _info.rate = uint128(_amount / _info.periodLength);
527	 }
528	 else {
529	 uint256 _remaining = _info.finishAt - block.timestamp;
530	 uint256 _leftover = _remaining * _info.rate;
531	 _info.rate = uint128((_amount + _leftover) / _info.periodLength);
532	 }
533	 _info.lastUpdate = uint48(block.timestamp);
534	 _info.finishAt = uint48(block.timestamp + _info.periodLength);
535	 }
536	 poolInfo[_pid].reward = _info;
537	 }
538	 function _getWithdrawFeeType(uint256 _pid) internal pure returns (bytes32) {
539	 return bytes32(uint256(WITHDRAW_FEE_TYPE) + _pid);
540	 }
541	 function _defaultFeeRate(bytes32 _feeType) internal view override returns (uint256 rate) {
542	 uint256 _pid = uint256(_feeType) - uint256(WITHDRAW_FEE_TYPE);
543	 rate = poolInfo[_pid].fee.withdrawFeeRatio;
544	 }
545	 function _claim( uint256 _amount, uint256 _minOut, address _recipient, address _claimAsToken ) internal virtual returns (uint256) {
546	 }
547	 function _harvest(uint256 _pid) internal virtual returns (uint256) {
548	 }
549	 }
550	 pragma solidity ^0.7.6;
551	 contract ConcentratorAladdinETHVault is ConcentratorGeneralVault {
552	 using SafeMathUpgradeable for uint256;
553	 using SafeERC20Upgradeable for IERC20Upgradeable;
554	 address private aladdinETH;
555	 address private aladdinETHUnderlying;
556	 function initialize( address _aladdinETH, address _zap, address _platform ) external initializer {
557	 require(_aladdinETH != address(0), "Concentrator: zero aladdinETH address");
558	 ConcentratorGeneralVault._initialize(_zap, _platform);
559	 address _aladdinETHUnderlying = IAladdinCompounder(_aladdinETH).asset();
560	 IERC20Upgradeable(_aladdinETHUnderlying).safeApprove(_aladdinETH, uint256(-1));
561	 aladdinETH = _aladdinETH;
562	 aladdinETHUnderlying = _aladdinETHUnderlying;
563	 }
564	 function rewardToken() public view virtual override returns (address) {
565	 return aladdinETH;
566	 }
567	 function _claim( uint256 _amount, uint256 _minOut, address _recipient, address _claimAsToken ) internal virtual override returns (uint256) {
568	 address _aladdinETH = aladdinETH;
569	 uint256 _amountOut;
570	 if (_claimAsToken == _aladdinETH) {
571	 _amountOut = _amount;
572	 }
573	 else {
574	 _amountOut = IAladdinCompounder(_aladdinETH).redeem(_amount, address(this), address(this));
575	 address _aladdinETHUnderlying = aladdinETHUnderlying;
576	 if (_claimAsToken != _aladdinETHUnderlying) {
577	 address _zap = zap;
578	 IERC20Upgradeable(_aladdinETHUnderlying).safeTransfer(_zap, _amountOut);
579	 _amountOut = IZap(_zap).zap(_aladdinETHUnderlying, _amountOut, _claimAsToken, 0);
580	 }
581	 }
582	 require(_amountOut >= _minOut, "Concentrator: insufficient rewards");
583	 if (_claimAsToken == address(0)) {
584	 (bool _success, ) = msg.sender.call{
585	 value: _amount }
586	 ("");
587	 require(_success, "Concentrator: transfer ETH failed");
588	 }
589	 else {
590	 IERC20Upgradeable(_claimAsToken).safeTransfer(_recipient, _amountOut);
591	 }
592	 return _amountOut;
593	 }
594	 function _harvest(uint256 _pid) internal virtual override returns (uint256) {
595	 address _strategy = poolInfo[_pid].strategy.strategy;
596	 address _zap = zap;
597	 uint256 _amountETH = IConcentratorStrategy(_strategy).harvest(_zap, address(0));
598	 uint256 _amount = IZap(_zap).zap{
599	 value: _amountETH }
600	 (address(0), _amountETH, aladdinETHUnderlying, 0);
601	 return IAladdinCompounder(aladdinETH).deposit(_amount, address(this));
602	 }
603	 }
604	 pragma solidity ^0.7.6;
605	 interface IZap {
606	 function zap( address _fromToken, uint256 _amountIn, address _toToken, uint256 _minOut ) external payable returns (uint256);
607	 function zapWithRoutes( address _fromToken, uint256 _amountIn, address _toToken, uint256[] calldata _routes, uint256 _minOut ) external payable returns (uint256);
608	 function zapFrom( address _fromToken, uint256 _amountIn, address _toToken, uint256 _minOut ) external payable returns (uint256);
609	 }
610	 pragma solidity ^0.7.6;
611	 interface IAladdinCompounder {
612	 event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);
613	 event Withdraw( address indexed sender, address indexed receiver, address indexed owner, uint256 assets, uint256 shares );
614	 event Harvest( address indexed caller, address indexed recipient, uint256 assets, uint256 platformFee, uint256 harvestBounty );
615	 function asset() external view returns (address assetTokenAddress);
616	 function totalAssets() external view returns (uint256 totalManagedAssets);
617	 function convertToShares(uint256 assets) external view returns (uint256 shares);
618	 function convertToAssets(uint256 shares) external view returns (uint256 assets);
619	 function maxDeposit(address receiver) external view returns (uint256 maxAssets);
620	 function previewDeposit(uint256 assets) external view returns (uint256 shares);
621	 function deposit(uint256 assets, address receiver) external returns (uint256 shares);
622	 function maxMint(address receiver) external view returns (uint256 maxShares);
623	 function previewMint(uint256 shares) external view returns (uint256 assets);
624	 function mint(uint256 shares, address receiver) external returns (uint256 assets);
625	 function maxWithdraw(address owner) external view returns (uint256 maxAssets);
626	 function previewWithdraw(uint256 assets) external view returns (uint256 shares);
627	 function withdraw( uint256 assets, address receiver, address owner ) external returns (uint256 shares);
628	 function maxRedeem(address owner) external view returns (uint256 maxShares);
629	 function previewRedeem(uint256 shares) external view returns (uint256 assets);
630	 function redeem( uint256 shares, address receiver, address owner ) external returns (uint256 assets);
631	 function harvest(address recipient, uint256 minAssets) external returns (uint256 assets);
632	 }
633	 pragma solidity ^0.7.6;
634	 interface ICurveETHPool {
635	 function add_liquidity(uint256[2] memory amounts, uint256 min_mint_amount) external payable returns (uint256);
636	 function calc_token_amount(uint256[2] memory amounts, bool is_deposit) external view returns (uint256);
637	 function remove_liquidity_one_coin( uint256 _token_amount, int128 i, uint256 _min_amount ) external returns (uint256);
638	 function calc_withdraw_one_coin(uint256 _token_amount, int128 i) external view returns (uint256);
639	 function exchange( int128 i, int128 j, uint256 dx, uint256 min_dy ) external payable returns (uint256);
640	 function get_dy( int128 i, int128 j, uint256 dx ) external view returns (uint256);
641	 function coins(uint256 index) external view returns (address);
642	 function lp_token() external view returns (address);
643	 }
644	 pragma solidity ^0.7.0;
645	 library SafeMathUpgradeable {
646	 function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
647	 uint256 c = a + b;
648	 if (c < a) return (false, 0);
649	 return (true, c);
650	 }
651	 function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
652	 if (b > a) return (false, 0);
653	 return (true, a - b);
654	 }
655	 function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
656	 if (a == 0) return (true, 0);
657	 uint256 c = a * b;
658	 if (c / a != b) return (false, 0);
659	 return (true, c);
660	 }
661	 function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
662	 if (b == 0) return (false, 0);
663	 return (true, a / b);
664	 }
665	 function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
666	 if (b == 0) return (false, 0);
667	 return (true, a % b);
668	 }
669	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
670	 uint256 c = a + b;
671	 require(c >= a, "SafeMath: addition overflow");
672	 return c;
673	 }
674	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
675	 require(b <= a, "SafeMath: subtraction overflow");
676	 return a - b;
677	 }
678	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
679	 if (a == 0) return 0;
680	 uint256 c = a * b;
681	 require(c / a == b, "SafeMath: multiplication overflow");
682	 return c;
683	 }
684	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
685	 require(b > 0, "SafeMath: division by zero");
686	 return a / b;
687	 }
688	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
689	 require(b > 0, "SafeMath: modulo by zero");
690	 return a % b;
691	 }
692	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
693	 require(b <= a, errorMessage);
694	 return a - b;
695	 }
696	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
697	 require(b > 0, errorMessage);
698	 return a / b;
699	 }
700	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
701	 require(b > 0, errorMessage);
702	 return a % b;
703	 }
704	 }
705	 pragma solidity ^0.7.6;
706	 interface IConcentratorStrategy {
707	 function name() external view returns (string memory);
708	 function updateRewards(address[] memory _rewards) external;
709	 function deposit(address _recipient, uint256 _amount) external;
710	 function withdraw(address _recipient, uint256 _amount) external;
711	 function harvest(address _zapper, address _intermediate) external returns (uint256 amount);
712	 function execute( address _to, uint256 _value, bytes calldata _data ) external payable returns (bool, bytes memory);
713	 function prepareMigrate(address _newStrategy) external;
714	 function finishMigrate(address _newStrategy) external;
715	 }
716	 pragma solidity ^0.7.0;
717	 library SafeCastUpgradeable {
718	 function toUint128(uint256 value) internal pure returns (uint128) {
719	 require(value < 2**128, "SafeCast: value doesn\'t fit in 128 bits");
720	 return uint128(value);
721	 }
722	 function toUint64(uint256 value) internal pure returns (uint64) {
723	 require(value < 2**64, "SafeCast: value doesn\'t fit in 64 bits");
724	 return uint64(value);
725	 }
726	 function toUint32(uint256 value) internal pure returns (uint32) {
727	 require(value < 2**32, "SafeCast: value doesn\'t fit in 32 bits");
728	 return uint32(value);
729	 }
730	 function toUint16(uint256 value) internal pure returns (uint16) {
731	 require(value < 2**16, "SafeCast: value doesn\'t fit in 16 bits");
732	 return uint16(value);
733	 }
734	 function toUint8(uint256 value) internal pure returns (uint8) {
735	 require(value < 2**8, "SafeCast: value doesn\'t fit in 8 bits");
736	 return uint8(value);
737	 }
738	 function toUint256(int256 value) internal pure returns (uint256) {
739	 require(value >= 0, "SafeCast: value must be positive");
740	 return uint256(value);
741	 }
742	 function toInt128(int256 value) internal pure returns (int128) {
743	 require(value >= -2**127 && value < 2**127, "SafeCast: value doesn\'t fit in 128 bits");
744	 return int128(value);
745	 }
746	 function toInt64(int256 value) internal pure returns (int64) {
747	 require(value >= -2**63 && value < 2**63, "SafeCast: value doesn\'t fit in 64 bits");
748	 return int64(value);
749	 }
750	 function toInt32(int256 value) internal pure returns (int32) {
751	 require(value >= -2**31 && value < 2**31, "SafeCast: value doesn\'t fit in 32 bits");
752	 return int32(value);
753	 }
754	 function toInt16(int256 value) internal pure returns (int16) {
755	 require(value >= -2**15 && value < 2**15, "SafeCast: value doesn\'t fit in 16 bits");
756	 return int16(value);
757	 }
758	 function toInt8(int256 value) internal pure returns (int8) {
759	 require(value >= -2**7 && value < 2**7, "SafeCast: value doesn\'t fit in 8 bits");
760	 return int8(value);
761	 }
762	 function toInt256(uint256 value) internal pure returns (int256) {
763	 require(value < 2**255, "SafeCast: value doesn't fit in an int256");
764	 return int256(value);
765	 }
766	 }
767	 pragma solidity ^0.7.0;
768	 interface IERC20Upgradeable {
769	 function totalSupply() external view returns (uint256);
770	 function balanceOf(address account) external view returns (uint256);
771	 function transfer(address recipient, uint256 amount) external returns (bool);
772	 function allowance(address owner, address spender) external view returns (uint256);
773	 function approve(address spender, uint256 amount) external returns (bool);
774	 function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
775	 event Transfer(address indexed from, address indexed to, uint256 value);
776	 event Approval(address indexed owner, address indexed spender, uint256 value);
777	 }
778	 pragma solidity ^0.7.0;
779	 library SafeERC20Upgradeable {
780	 using SafeMathUpgradeable for uint256;
781	 using AddressUpgradeable for address;
782	 function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {
783	 _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
784	 }
785	 function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {
786	 _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
787	 }
788	 function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {
789	 require((value == 0) || (token.allowance(address(this), spender) == 0), "SafeERC20: approve from non-zero to non-zero allowance" );
790	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
791	 }
792	 function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {
793	 uint256 newAllowance = token.allowance(address(this), spender).add(value);
794	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
795	 }
796	 function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {
797	 uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
798	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
799	 }
800	 function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {
801	 bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
802	 if (returndata.length > 0) {
803	 require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
804	 }
805	 }
806	 }
807	 pragma solidity ^0.7.0;
808	 library AddressUpgradeable {
809	 function isContract(address account) internal view returns (bool) {
810	 uint256 size;
811	 assembly {
812	 size := extcodesize(account) }
813	 return size > 0;
814	 }
815	 function sendValue(address payable recipient, uint256 amount) internal {
816	 require(address(this).balance >= amount, "Address: insufficient balance");
817	 (bool success, ) = recipient.call{
818	 value: amount }
819	 ("");
820	 require(success, "Address: unable to send value, recipient may have reverted");
821	 }
822	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
823	 return functionCall(target, data, "Address: low-level call failed");
824	 }
825	 function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
826	 return functionCallWithValue(target, data, 0, errorMessage);
827	 }
828	 function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
829	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
830	 }
831	 function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
832	 require(address(this).balance >= value, "Address: insufficient balance for call");
833	 require(isContract(target), "Address: call to non-contract");
834	 (bool success, bytes memory returndata) = target.call{
835	 value: value }
836	 (data);
837	 return _verifyCallResult(success, returndata, errorMessage);
838	 }
839	 function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
840	 return functionStaticCall(target, data, "Address: low-level static call failed");
841	 }
842	 function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
843	 require(isContract(target), "Address: static call to non-contract");
844	 (bool success, bytes memory returndata) = target.staticcall(data);
845	 return _verifyCallResult(success, returndata, errorMessage);
846	 }
847	 function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
848	 if (success) {
849	 return returndata;
850	 }
851	 else {
852	 if (returndata.length > 0) {
853	 assembly {
854	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
855	 }
856	 else {
857	 revert(errorMessage);
858	 }
859	 }
860	 }
861	 }
