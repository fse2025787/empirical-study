row number 
1	            pragma solidity ^0.8.2;
2	 library Base64 {
3	 bytes internal constant TABLE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
4	 function encode(bytes memory data) internal pure returns (string memory) {
5	 uint256 len = data.length;
6	 if (len == 0) return "";
7	 uint256 encodedLen = 4 * ((len + 2) / 3);
8	 bytes memory result = new bytes(encodedLen + 32);
9	 bytes memory table = TABLE;
10	 assembly {
11	 let tablePtr := add(table, 1) let resultPtr := add(result, 32) for {
12	 let i := 0 }
13	 lt(i, len) {
14	 }
15	 {
16	 i := add(i, 3) let input := and(mload(add(data, i)), 0xffffff) let out := mload(add(tablePtr, and(shr(18, input), 0x3F))) out := shl(8, out) out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF)) out := shl(8, out) out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF)) out := shl(8, out) out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF)) out := shl(224, out) mstore(resultPtr, out) resultPtr := add(resultPtr, 4) }
17	 switch mod(len, 3) case 1 {
18	 mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }
19	 case 2 {
20	 mstore(sub(resultPtr, 1), shl(248, 0x3d)) }
21	 mstore(result, encodedLen) }
22	 return string(result);
23	 }
24	 }
25	 pragma solidity ^0.8.0;
26	 library SVG721 {
27	 function metadata( string memory tokenName, string memory tokenDescription, string memory svgString, string memory attributes ) internal pure returns (string memory) {
28	 string memory json = string(abi.encodePacked('{
29	 "name":"', tokenName, '","description":"', tokenDescription, '","image": "data:image/svg+xml;
30	 base64,', Base64.encode(bytes(svgString)),'",',attributes,'}
31	 '));
32	 return string(abi.encodePacked("data:application/json;
33	 base64,", Base64.encode(bytes(json))));
34	 }
35	 }
36	 pragma solidity ^0.8.0;
37	 contract VRFRequestIDBase {
38	 function makeVRFInputSeed( bytes32 _keyHash, uint256 _userSeed, address _requester, uint256 _nonce ) internal pure returns ( uint256 ) {
39	 return uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));
40	 }
41	 function makeRequestId( bytes32 _keyHash, uint256 _vRFInputSeed ) internal pure returns ( bytes32 ) {
42	 return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));
43	 }
44	 }
45	 pragma solidity ^0.8.0;
46	 interface LinkTokenInterface {
47	 function allowance( address owner, address spender ) external view returns ( uint256 remaining );
48	 function approve( address spender, uint256 value ) external returns ( bool success );
49	 function balanceOf( address owner ) external view returns ( uint256 balance );
50	 function decimals() external view returns ( uint8 decimalPlaces );
51	 function decreaseApproval( address spender, uint256 addedValue ) external returns ( bool success );
52	 function increaseApproval( address spender, uint256 subtractedValue ) external;
53	 function name() external view returns ( string memory tokenName );
54	 function symbol() external view returns ( string memory tokenSymbol );
55	 function totalSupply() external view returns ( uint256 totalTokensIssued );
56	 function transfer( address to, uint256 value ) external returns ( bool success );
57	 function transferAndCall( address to, uint256 value, bytes calldata data ) external returns ( bool success );
58	 function transferFrom( address from, address to, uint256 value ) external returns ( bool success );
59	 }
60	 pragma solidity ^0.8.0;
61	 abstract contract VRFConsumerBase is VRFRequestIDBase {
62	 function fulfillRandomness( bytes32 requestId, uint256 randomness ) internal virtual;
63	 uint256 constant private USER_SEED_PLACEHOLDER = 0;
64	 function requestRandomness( bytes32 _keyHash, uint256 _fee ) internal returns ( bytes32 requestId ) {
65	 LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, USER_SEED_PLACEHOLDER));
66	 uint256 vRFSeed = makeVRFInputSeed(_keyHash, USER_SEED_PLACEHOLDER, address(this), nonces[_keyHash]);
67	 nonces[_keyHash] = nonces[_keyHash] + 1;
68	 return makeRequestId(_keyHash, vRFSeed);
69	 }
70	 LinkTokenInterface immutable internal LINK;
71	 address immutable private vrfCoordinator;
72	 mapping(bytes32 => uint256 ) private nonces;
73	 constructor( address _vrfCoordinator, address _link ) {
74	 vrfCoordinator = _vrfCoordinator;
75	 LINK = LinkTokenInterface(_link);
76	 }
77	 function rawFulfillRandomness( bytes32 requestId, uint256 randomness ) external {
78	 require(msg.sender == vrfCoordinator, "Only VRFCoordinator can fulfill");
79	 fulfillRandomness(requestId, randomness);
80	 }
81	 }
82	 pragma solidity ^0.8.0;
83	 library SafeMath {
84	 function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
85	 unchecked {
86	 uint256 c = a + b;
87	 if (c < a) return (false, 0);
88	 return (true, c);
89	 }
90	 }
91	 function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
92	 unchecked {
93	 if (b > a) return (false, 0);
94	 return (true, a - b);
95	 }
96	 }
97	 function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
98	 unchecked {
99	 if (a == 0) return (true, 0);
100	 uint256 c = a * b;
101	 if (c / a != b) return (false, 0);
102	 return (true, c);
103	 }
104	 }
105	 function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
106	 unchecked {
107	 if (b == 0) return (false, 0);
108	 return (true, a / b);
109	 }
110	 }
111	 function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
112	 unchecked {
113	 if (b == 0) return (false, 0);
114	 return (true, a % b);
115	 }
116	 }
117	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
118	 return a + b;
119	 }
120	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
121	 return a - b;
122	 }
123	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
124	 return a * b;
125	 }
126	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
127	 return a / b;
128	 }
129	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
130	 return a % b;
131	 }
132	 function sub( uint256 a, uint256 b, string memory errorMessage ) internal pure returns (uint256) {
133	 unchecked {
134	 require(b <= a, errorMessage);
135	 return a - b;
136	 }
137	 }
138	 function div( uint256 a, uint256 b, string memory errorMessage ) internal pure returns (uint256) {
139	 unchecked {
140	 require(b > 0, errorMessage);
141	 return a / b;
142	 }
143	 }
144	 function mod( uint256 a, uint256 b, string memory errorMessage ) internal pure returns (uint256) {
145	 unchecked {
146	 require(b > 0, errorMessage);
147	 return a % b;
148	 }
149	 }
150	 }
151	 pragma solidity ^0.8.0;
152	 library MerkleProof {
153	 function verify( bytes32[] memory proof, bytes32 root, bytes32 leaf ) internal pure returns (bool) {
154	 return processProof(proof, leaf) == root;
155	 }
156	 function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {
157	 bytes32 computedHash = leaf;
158	 for (uint256 i = 0; i < proof.length; i++) {
159	 bytes32 proofElement = proof[i];
160	 if (computedHash <= proofElement) {
161	 computedHash = keccak256(abi.encodePacked(computedHash, proofElement));
162	 }
163	 else {
164	 computedHash = keccak256(abi.encodePacked(proofElement, computedHash));
165	 }
166	 }
167	 return computedHash;
168	 }
169	 }
170	 pragma solidity ^0.8.0;
171	 library Counters {
172	 struct Counter {
173	 uint256 _value;
174	 }
175	 function current(Counter storage counter) internal view returns (uint256) {
176	 return counter._value;
177	 }
178	 function increment(Counter storage counter) internal {
179	 unchecked {
180	 counter._value += 1;
181	 }
182	 }
183	 function decrement(Counter storage counter) internal {
184	 uint256 value = counter._value;
185	 require(value > 0, "Counter: decrement overflow");
186	 unchecked {
187	 counter._value = value - 1;
188	 }
189	 }
190	 function reset(Counter storage counter) internal {
191	 counter._value = 0;
192	 }
193	 }
194	 pragma solidity ^0.8.0;
195	 library Strings {
196	 bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";
197	 function toString(uint256 value) internal pure returns (string memory) {
198	 if (value == 0) {
199	 return "0";
200	 }
201	 uint256 temp = value;
202	 uint256 digits;
203	 while (temp != 0) {
204	 digits++;
205	 temp /= 10;
206	 }
207	 bytes memory buffer = new bytes(digits);
208	 while (value != 0) {
209	 digits -= 1;
210	 buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
211	 value /= 10;
212	 }
213	 return string(buffer);
214	 }
215	 function toHexString(uint256 value) internal pure returns (string memory) {
216	 if (value == 0) {
217	 return "0x00";
218	 }
219	 uint256 temp = value;
220	 uint256 length = 0;
221	 while (temp != 0) {
222	 length++;
223	 temp >>= 8;
224	 }
225	 return toHexString(value, length);
226	 }
227	 function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
228	 bytes memory buffer = new bytes(2 * length + 2);
229	 buffer[0] = "0";
230	 buffer[1] = "x";
231	 for (uint256 i = 2 * length + 1; i > 1; --i) {
232	 buffer[i] = _HEX_SYMBOLS[value & 0xf];
233	 value >>= 4;
234	 }
235	 require(value == 0, "Strings: hex length insufficient");
236	 return string(buffer);
237	 }
238	 }
239	 pragma solidity ^0.8.0;
240	 abstract contract Context {
241	 function _msgSender() internal view virtual returns (address) {
242	 return msg.sender;
243	 }
244	 function _msgData() internal view virtual returns (bytes calldata) {
245	 return msg.data;
246	 }
247	 }
248	 pragma solidity ^0.8.0;
249	 abstract contract Pausable is Context {
250	 event Paused(address account);
251	 event Unpaused(address account);
252	 bool private _paused;
253	 constructor() {
254	 _paused = false;
255	 }
256	 function paused() public view virtual returns (bool) {
257	 return _paused;
258	 }
259	 modifier whenNotPaused() {
260	 require(!paused(), "Pausable: paused");
261	 _;
262	 }
263	 modifier whenPaused() {
264	 require(paused(), "Pausable: not paused");
265	 _;
266	 }
267	 function _pause() internal virtual whenNotPaused {
268	 _paused = true;
269	 emit Paused(_msgSender());
270	 }
271	 function _unpause() internal virtual whenPaused {
272	 _paused = false;
273	 emit Unpaused(_msgSender());
274	 }
275	 }
276	 pragma solidity ^0.8.0;
277	 abstract contract Ownable is Context {
278	 address private _owner;
279	 event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
280	 constructor() {
281	 _transferOwnership(_msgSender());
282	 }
283	 function owner() public view virtual returns (address) {
284	 return _owner;
285	 }
286	 modifier onlyOwner() {
287	 require(owner() == _msgSender(), "Ownable: caller is not the owner");
288	 _;
289	 }
290	 function renounceOwnership() public virtual onlyOwner {
291	 _transferOwnership(address(0));
292	 }
293	 function transferOwnership(address newOwner) public virtual onlyOwner {
294	 require(newOwner != address(0), "Ownable: new owner is the zero address");
295	 _transferOwnership(newOwner);
296	 }
297	 function _transferOwnership(address newOwner) internal virtual {
298	 address oldOwner = _owner;
299	 _owner = newOwner;
300	 emit OwnershipTransferred(oldOwner, newOwner);
301	 }
302	 }
303	 pragma solidity ^0.8.0;
304	 library Address {
305	 function isContract(address account) internal view returns (bool) {
306	 uint256 size;
307	 assembly {
308	 size := extcodesize(account) }
309	 return size > 0;
310	 }
311	 function sendValue(address payable recipient, uint256 amount) internal {
312	 require(address(this).balance >= amount, "Address: insufficient balance");
313	 (bool success, ) = recipient.call{
314	 value: amount}
315	 ("");
316	 require(success, "Address: unable to send value, recipient may have reverted");
317	 }
318	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
319	 return functionCall(target, data, "Address: low-level call failed");
320	 }
321	 function functionCall( address target, bytes memory data, string memory errorMessage ) internal returns (bytes memory) {
322	 return functionCallWithValue(target, data, 0, errorMessage);
323	 }
324	 function functionCallWithValue( address target, bytes memory data, uint256 value ) internal returns (bytes memory) {
325	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
326	 }
327	 function functionCallWithValue( address target, bytes memory data, uint256 value, string memory errorMessage ) internal returns (bytes memory) {
328	 require(address(this).balance >= value, "Address: insufficient balance for call");
329	 require(isContract(target), "Address: call to non-contract");
330	 (bool success, bytes memory returndata) = target.call{
331	 value: value}
332	 (data);
333	 return verifyCallResult(success, returndata, errorMessage);
334	 }
335	 function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
336	 return functionStaticCall(target, data, "Address: low-level static call failed");
337	 }
338	 function functionStaticCall( address target, bytes memory data, string memory errorMessage ) internal view returns (bytes memory) {
339	 require(isContract(target), "Address: static call to non-contract");
340	 (bool success, bytes memory returndata) = target.staticcall(data);
341	 return verifyCallResult(success, returndata, errorMessage);
342	 }
343	 function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
344	 return functionDelegateCall(target, data, "Address: low-level delegate call failed");
345	 }
346	 function functionDelegateCall( address target, bytes memory data, string memory errorMessage ) internal returns (bytes memory) {
347	 require(isContract(target), "Address: delegate call to non-contract");
348	 (bool success, bytes memory returndata) = target.delegatecall(data);
349	 return verifyCallResult(success, returndata, errorMessage);
350	 }
351	 function verifyCallResult( bool success, bytes memory returndata, string memory errorMessage ) internal pure returns (bytes memory) {
352	 if (success) {
353	 return returndata;
354	 }
355	 else {
356	 if (returndata.length > 0) {
357	 assembly {
358	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
359	 }
360	 else {
361	 revert(errorMessage);
362	 }
363	 }
364	 }
365	 }
366	 pragma solidity ^0.8.0;
367	 interface IERC721Receiver {
368	 function onERC721Received( address operator, address from, uint256 tokenId, bytes calldata data ) external returns (bytes4);
369	 }
370	 pragma solidity ^0.8.0;
371	 interface IERC165 {
372	 function supportsInterface(bytes4 interfaceId) external view returns (bool);
373	 }
374	 pragma solidity ^0.8.0;
375	 abstract contract ERC165 is IERC165 {
376	 function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
377	 return interfaceId == type(IERC165).interfaceId;
378	 }
379	 }
380	 pragma solidity ^0.8.0;
381	 interface IERC721 is IERC165 {
382	 event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
383	 event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
384	 event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
385	 function balanceOf(address owner) external view returns (uint256 balance);
386	 function ownerOf(uint256 tokenId) external view returns (address owner);
387	 function safeTransferFrom( address from, address to, uint256 tokenId ) external;
388	 function transferFrom( address from, address to, uint256 tokenId ) external;
389	 function approve(address to, uint256 tokenId) external;
390	 function getApproved(uint256 tokenId) external view returns (address operator);
391	 function setApprovalForAll(address operator, bool _approved) external;
392	 function isApprovedForAll(address owner, address operator) external view returns (bool);
393	 function safeTransferFrom( address from, address to, uint256 tokenId, bytes calldata data ) external;
394	 }
395	 pragma solidity ^0.8.0;
396	 interface IERC721Enumerable is IERC721 {
397	 function totalSupply() external view returns (uint256);
398	 function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);
399	 function tokenByIndex(uint256 index) external view returns (uint256);
400	 }
401	 pragma solidity ^0.8.4;
402	 interface IScrambles is IERC721Enumerable {
403	 function mint(uint8 windowIndex, uint8 amount, bytes32[] calldata merkleProof) external;
404	 function unpause() external;
405	 function pause() external;
406	 function editRedemptionWindow(uint8 _windowID, bytes32 _merkleRoot, bool _open, uint8 _maxPerWallet) external;
407	 function getCoreNumbers(uint256 tokenId) external returns(string memory);
408	 }
409	 pragma solidity ^0.8.0;
410	 interface IERC721Metadata is IERC721 {
411	 function name() external view returns (string memory);
412	 function symbol() external view returns (string memory);
413	 function tokenURI(uint256 tokenId) external view returns (string memory);
414	 }
415	 pragma solidity ^0.8.0;
416	 contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {
417	 using Address for address;
418	 using Strings for uint256;
419	 string private _name;
420	 string private _symbol;
421	 mapping(uint256 => address) private _owners;
422	 mapping(address => uint256) private _balances;
423	 mapping(uint256 => address) private _tokenApprovals;
424	 mapping(address => mapping(address => bool)) private _operatorApprovals;
425	 constructor(string memory name_, string memory symbol_) {
426	 _name = name_;
427	 _symbol = symbol_;
428	 }
429	 function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
430	 return interfaceId == type(IERC721).interfaceId || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId);
431	 }
432	 function balanceOf(address owner) public view virtual override returns (uint256) {
433	 require(owner != address(0), "ERC721: balance query for the zero address");
434	 return _balances[owner];
435	 }
436	 function ownerOf(uint256 tokenId) public view virtual override returns (address) {
437	 address owner = _owners[tokenId];
438	 require(owner != address(0), "ERC721: owner query for nonexistent token");
439	 return owner;
440	 }
441	 function name() public view virtual override returns (string memory) {
442	 return _name;
443	 }
444	 function symbol() public view virtual override returns (string memory) {
445	 return _symbol;
446	 }
447	 function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
448	 require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
449	 string memory baseURI = _baseURI();
450	 return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";
451	 }
452	 function _baseURI() internal view virtual returns (string memory) {
453	 return "";
454	 }
455	 function approve(address to, uint256 tokenId) public virtual override {
456	 address owner = ERC721.ownerOf(tokenId);
457	 require(to != owner, "ERC721: approval to current owner");
458	 require( _msgSender() == owner || isApprovedForAll(owner, _msgSender()), "ERC721: approve caller is not owner nor approved for all" );
459	 _approve(to, tokenId);
460	 }
461	 function getApproved(uint256 tokenId) public view virtual override returns (address) {
462	 require(_exists(tokenId), "ERC721: approved query for nonexistent token");
463	 return _tokenApprovals[tokenId];
464	 }
465	 function setApprovalForAll(address operator, bool approved) public virtual override {
466	 _setApprovalForAll(_msgSender(), operator, approved);
467	 }
468	 function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
469	 return _operatorApprovals[owner][operator];
470	 }
471	 function transferFrom( address from, address to, uint256 tokenId ) public virtual override {
472	 require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");
473	 _transfer(from, to, tokenId);
474	 }
475	 function safeTransferFrom( address from, address to, uint256 tokenId ) public virtual override {
476	 safeTransferFrom(from, to, tokenId, "");
477	 }
478	 function safeTransferFrom( address from, address to, uint256 tokenId, bytes memory _data ) public virtual override {
479	 require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");
480	 _safeTransfer(from, to, tokenId, _data);
481	 }
482	 function _safeTransfer( address from, address to, uint256 tokenId, bytes memory _data ) internal virtual {
483	 _transfer(from, to, tokenId);
484	 require(_checkOnERC721Received(from, to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");
485	 }
486	 function _exists(uint256 tokenId) internal view virtual returns (bool) {
487	 return _owners[tokenId] != address(0);
488	 }
489	 function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {
490	 require(_exists(tokenId), "ERC721: operator query for nonexistent token");
491	 address owner = ERC721.ownerOf(tokenId);
492	 return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
493	 }
494	 function _safeMint(address to, uint256 tokenId) internal virtual {
495	 _safeMint(to, tokenId, "");
496	 }
497	 function _safeMint( address to, uint256 tokenId, bytes memory _data ) internal virtual {
498	 _mint(to, tokenId);
499	 require( _checkOnERC721Received(address(0), to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer" );
500	 }
501	 function _mint(address to, uint256 tokenId) internal virtual {
502	 require(to != address(0), "ERC721: mint to the zero address");
503	 require(!_exists(tokenId), "ERC721: token already minted");
504	 _beforeTokenTransfer(address(0), to, tokenId);
505	 _balances[to] += 1;
506	 _owners[tokenId] = to;
507	 emit Transfer(address(0), to, tokenId);
508	 }
509	 function _burn(uint256 tokenId) internal virtual {
510	 address owner = ERC721.ownerOf(tokenId);
511	 _beforeTokenTransfer(owner, address(0), tokenId);
512	 _approve(address(0), tokenId);
513	 _balances[owner] -= 1;
514	 delete _owners[tokenId];
515	 emit Transfer(owner, address(0), tokenId);
516	 }
517	 function _transfer( address from, address to, uint256 tokenId ) internal virtual {
518	 require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer of token that is not own");
519	 require(to != address(0), "ERC721: transfer to the zero address");
520	 _beforeTokenTransfer(from, to, tokenId);
521	 _approve(address(0), tokenId);
522	 _balances[from] -= 1;
523	 _balances[to] += 1;
524	 _owners[tokenId] = to;
525	 emit Transfer(from, to, tokenId);
526	 }
527	 function _approve(address to, uint256 tokenId) internal virtual {
528	 _tokenApprovals[tokenId] = to;
529	 emit Approval(ERC721.ownerOf(tokenId), to, tokenId);
530	 }
531	 function _setApprovalForAll( address owner, address operator, bool approved ) internal virtual {
532	 require(owner != operator, "ERC721: approve to caller");
533	 _operatorApprovals[owner][operator] = approved;
534	 emit ApprovalForAll(owner, operator, approved);
535	 }
536	 function _checkOnERC721Received( address from, address to, uint256 tokenId, bytes memory _data ) private returns (bool) {
537	 if (to.isContract()) {
538	 try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {
539	 return retval == IERC721Receiver.onERC721Received.selector;
540	 }
541	 catch (bytes memory reason) {
542	 if (reason.length == 0) {
543	 revert("ERC721: transfer to non ERC721Receiver implementer");
544	 }
545	 else {
546	 assembly {
547	 revert(add(32, reason), mload(reason)) }
548	 }
549	 }
550	 }
551	 else {
552	 return true;
553	 }
554	 }
555	 function _beforeTokenTransfer( address from, address to, uint256 tokenId ) internal virtual {
556	 }
557	 }
558	 pragma solidity ^0.8.0;
559	 abstract contract ERC721Enumerable is ERC721, IERC721Enumerable {
560	 mapping(address => mapping(uint256 => uint256)) private _ownedTokens;
561	 mapping(uint256 => uint256) private _ownedTokensIndex;
562	 uint256[] private _allTokens;
563	 mapping(uint256 => uint256) private _allTokensIndex;
564	 function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {
565	 return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);
566	 }
567	 function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {
568	 require(index < ERC721.balanceOf(owner), "ERC721Enumerable: owner index out of bounds");
569	 return _ownedTokens[owner][index];
570	 }
571	 function totalSupply() public view virtual override returns (uint256) {
572	 return _allTokens.length;
573	 }
574	 function tokenByIndex(uint256 index) public view virtual override returns (uint256) {
575	 require(index < ERC721Enumerable.totalSupply(), "ERC721Enumerable: global index out of bounds");
576	 return _allTokens[index];
577	 }
578	 function _beforeTokenTransfer( address from, address to, uint256 tokenId ) internal virtual override {
579	 super._beforeTokenTransfer(from, to, tokenId);
580	 if (from == address(0)) {
581	 _addTokenToAllTokensEnumeration(tokenId);
582	 }
583	 else if (from != to) {
584	 _removeTokenFromOwnerEnumeration(from, tokenId);
585	 }
586	 if (to == address(0)) {
587	 _removeTokenFromAllTokensEnumeration(tokenId);
588	 }
589	 else if (to != from) {
590	 _addTokenToOwnerEnumeration(to, tokenId);
591	 }
592	 }
593	 function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {
594	 uint256 length = ERC721.balanceOf(to);
595	 _ownedTokens[to][length] = tokenId;
596	 _ownedTokensIndex[tokenId] = length;
597	 }
598	 function _addTokenToAllTokensEnumeration(uint256 tokenId) private {
599	 _allTokensIndex[tokenId] = _allTokens.length;
600	 _allTokens.push(tokenId);
601	 }
602	 function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {
603	 uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;
604	 uint256 tokenIndex = _ownedTokensIndex[tokenId];
605	 if (tokenIndex != lastTokenIndex) {
606	 uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];
607	 _ownedTokens[from][tokenIndex] = lastTokenId;
608	 _ownedTokensIndex[lastTokenId] = tokenIndex;
609	 }
610	 delete _ownedTokensIndex[tokenId];
611	 delete _ownedTokens[from][lastTokenIndex];
612	 }
613	 function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {
614	 uint256 lastTokenIndex = _allTokens.length - 1;
615	 uint256 tokenIndex = _allTokensIndex[tokenId];
616	 uint256 lastTokenId = _allTokens[lastTokenIndex];
617	 _allTokens[tokenIndex] = lastTokenId;
618	 _allTokensIndex[lastTokenId] = tokenIndex;
619	 delete _allTokensIndex[tokenId];
620	 _allTokens.pop();
621	 }
622	 }
623	 pragma solidity ^0.8.0;
624	 abstract contract ERC721Burnable is Context, ERC721 {
625	 function burn(uint256 tokenId) public virtual {
626	 require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721Burnable: caller is not owner nor approved");
627	 _burn(tokenId);
628	 }
629	 }
630	 pragma solidity ^0.8.0;
631	 abstract contract ERC721Pausable is ERC721, Pausable {
632	 function _beforeTokenTransfer( address from, address to, uint256 tokenId ) internal virtual override {
633	 super._beforeTokenTransfer(from, to, tokenId);
634	 require(!paused(), "ERC721Pausable: token transfer while paused");
635	 }
636	 }
637	 pragma solidity ^0.8.4;
638	 contract Scrambles is IScrambles, ERC721Enumerable, ERC721Pausable, ERC721Burnable, Ownable, VRFConsumerBase {
639	 using Strings for uint256;
640	 using Strings for uint8;
641	 using SafeMath for uint256;
642	 using Counters for Counters.Counter;
643	 Counters.Counter private generalCounter;
644	 uint public constant MAX_MINT = 963;
645	 address public VRFCoordinator;
646	 address public LinkToken;
647	 bytes32 internal keyHash;
648	 uint256 public baseSeed;
649	 struct RedemptionWindow {
650	 bool open;
651	 uint8 maxRedeemPerWallet;
652	 bytes32 merkleRoot;
653	 }
654	 mapping(uint8 => RedemptionWindow) public redemptionWindows;
655	 mapping(address => uint8) public mintedTotal;
656	 mapping(uint8 => string[]) colours;
657	 string public _contractURI;
658	 bool public revealed;
659	 event Minted(address indexed account, string tokens);
660	 constructor ( string memory _name, string memory _symbol, uint8[] memory _maxRedeemPerWallet, bytes32[] memory _merkleRoots, string memory _contractMetaDataURI, address _VRFCoordinator, address _LinkToken, bytes32 _keyHash ) VRFConsumerBase(_VRFCoordinator, _LinkToken) ERC721(_name, _symbol) {
661	 VRFCoordinator = _VRFCoordinator;
662	 LinkToken = _LinkToken;
663	 _contractURI = _contractMetaDataURI;
664	 keyHash = _keyHash;
665	 for(uint8 i = 0; i < _merkleRoots.length; i++) {
666	 redemptionWindows[i].open = false;
667	 redemptionWindows[i].maxRedeemPerWallet = _maxRedeemPerWallet[i];
668	 redemptionWindows[i].merkleRoot = _merkleRoots[i];
669	 }
670	 colours[0].push("#ff0000");
671	 colours[0].push("#00ff00");
672	 colours[0].push("#0000ff");
673	 colours[0].push("#ff8000");
674	 colours[0].push("#ffff00");
675	 colours[0].push("#ffffff");
676	 colours[1].push("#ff00ff");
677	 colours[1].push("#00ffff");
678	 colours[1].push("#ffff00");
679	 colours[1].push("#000000");
680	 colours[1].push("#808080");
681	 colours[1].push("#ffffff");
682	 colours[2].push("#000000");
683	 colours[2].push("#333333");
684	 colours[2].push("#666666");
685	 colours[2].push("#999999");
686	 colours[2].push("#cccccc");
687	 colours[2].push("#ffffff");
688	 }
689	 function pause() external override onlyOwner {
690	 _pause();
691	 }
692	 function unpause() external override onlyOwner {
693	 _unpause();
694	 }
695	 function reveal(bool state) external onlyOwner {
696	 revealed = state;
697	 }
698	 function editRedemptionWindow( uint8 _windowID, bytes32 _merkleRoot, bool _open, uint8 _maxPerWallet ) external override onlyOwner {
699	 if(redemptionWindows[_windowID].open != _open) {
700	 redemptionWindows[_windowID].open = _open;
701	 }
702	 if(redemptionWindows[_windowID].maxRedeemPerWallet != _maxPerWallet) {
703	 redemptionWindows[_windowID].maxRedeemPerWallet = _maxPerWallet;
704	 }
705	 if(redemptionWindows[_windowID].merkleRoot != _merkleRoot) {
706	 redemptionWindows[_windowID].merkleRoot = _merkleRoot;
707	 }
708	 }
709	 function withdrawEther(address payable _to, uint256 _amount) public onlyOwner {
710	 _to.transfer(_amount);
711	 }
712	 function mint(uint8 windowIndex, uint8 amount, bytes32[] calldata merkleProof) external override{
713	 require(redemptionWindows[windowIndex].open, "Redeem: window is not open");
714	 require(amount > 0, "Redeem: amount cannot be zero");
715	 require(amount < 11, "Redeem: amount cannot be more than 10");
716	 require(generalCounter.current() + amount <= MAX_MINT, "Max limit");
717	 if(windowIndex != 3) {
718	 require(mintedTotal[msg.sender] + amount <= redemptionWindows[windowIndex].maxRedeemPerWallet, "Too many for presale window");
719	 require(verifyMerkleProof(merkleProof, redemptionWindows[windowIndex].merkleRoot),"Invalid proof");
720	 }
721	 string memory tokens = "";
722	 for(uint8 j = 0; j < amount; j++) {
723	 _safeMint(msg.sender, generalCounter.current());
724	 tokens = string(abi.encodePacked(tokens, generalCounter.current().toString(), ","));
725	 generalCounter.increment();
726	 }
727	 mintedTotal[msg.sender] = mintedTotal[msg.sender] + amount;
728	 emit Minted(msg.sender, tokens);
729	 }
730	 function verifyMerkleProof(bytes32[] memory proof, bytes32 root) public view returns (bool) {
731	 bytes32 leaf = keccak256(abi.encodePacked(msg.sender));
732	 return MerkleProof.verify(proof, root, leaf);
733	 }
734	 function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {
735	 baseSeed = randomness;
736	 }
737	 function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721, ERC721Enumerable) returns (bool) {
738	 return super.supportsInterface(interfaceId);
739	 }
740	 function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override(ERC721, ERC721Enumerable, ERC721Pausable) {
741	 super._beforeTokenTransfer(from, to, tokenId);
742	 }
743	 function setContractURI(string memory uri) external onlyOwner{
744	 _contractURI = uri;
745	 }
746	 function contractURI() public view returns (string memory) {
747	 return _contractURI;
748	 }
749	 function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
750	 string memory name = string(abi.encodePacked("Scramble #", tokenId.toString()));
751	 return SVG721.metadata(name, getCoreNumbers(tokenId), getSVGString(tokenId),getTraits(tokenId));
752	 }
753	 function getCoreNumbers(uint256 tokenId) public view virtual override returns (string memory){
754	 string memory coreNumbers = "";
755	 if(!revealed) {
756	 return coreNumbers;
757	 }
758	 coreNumbers = string(abi.encodePacked(coreNumbers,getPaletteIndex(getSeed(tokenId)).toString()," "));
759	 for(uint8 i = 1; i < 10; i++) {
760	 coreNumbers = string(abi.encodePacked(coreNumbers,(expandRandom(getSeed(tokenId),i) % 6).toString()," "));
761	 }
762	 return coreNumbers;
763	 }
764	 function checkConnection(string[9] memory cols, uint8 a, uint8 b) internal pure returns(uint8) {
765	 if(keccak256(abi.encodePacked(cols[a])) == keccak256(abi.encodePacked(cols[b]))){
766	 return 1;
767	 }
768	 else{
769	 return 0;
770	 }
771	 }
772	 function getTraits(uint256 tokenId) public view returns (string memory) {
773	 if(!revealed){
774	 return '"attributes": [{
775	 "value": "Unscrambled"}
776	 ]';
777	 }
778	 string[9] memory cols;
779	 uint256[6] memory colTotals;
780	 for(uint8 j = 1; j < 10; j++) {
781	 string memory col = getColour(j,getSeed(tokenId));
782	 cols[j-1] =col;
783	 for (uint i = 0; i<6; i++) {
784	 string memory colToCheck = colours[getPaletteIndex(getSeed(tokenId))][i];
785	 if(keccak256(abi.encodePacked(col)) == keccak256(abi.encodePacked(colToCheck))) {
786	 colTotals[i]++;
787	 }
788	 }
789	 }
790	 uint8 connections = 0;
791	 connections += checkConnection(cols,0,1);
792	 connections += checkConnection(cols,1,2);
793	 connections += checkConnection(cols,0,3);
794	 connections += checkConnection(cols,1,4);
795	 connections += checkConnection(cols,2,5);
796	 connections += checkConnection(cols,3,4);
797	 connections += checkConnection(cols,4,5);
798	 connections += checkConnection(cols,3,6);
799	 connections += checkConnection(cols,4,7);
800	 connections += checkConnection(cols,5,8);
801	 connections += checkConnection(cols,6,7);
802	 connections += checkConnection(cols,7,8);
803	 uint256 totalCols = 0;
804	 for (uint256 h=0; h<6; h++){
805	 if(colTotals[h] > 0) {
806	 totalCols++;
807	 }
808	 }
809	 string memory traits = '"attributes": [';
810	 string memory newTrait = "";
811	 for (uint256 h = 0; h < 6; h++){
812	 string memory traitName = string(abi.encodePacked('Colour #', h.toString()));
813	 newTrait = getPropertyString(traitName,colTotals[h]);
814	 traits = string(abi.encodePacked(traits,newTrait,","));
815	 }
816	 newTrait = getPropertyString("Connections",connections);
817	 traits = string(abi.encodePacked(traits,newTrait,","));
818	 newTrait = getPropertyString("Palette",getPaletteIndex(getSeed(tokenId)));
819	 traits = string(abi.encodePacked(traits,newTrait,","));
820	 newTrait = getPropertyString("Total Colours",totalCols);
821	 traits = string(abi.encodePacked(traits,newTrait,","));
822	 newTrait = getLevelString("Background Colour",expandRandom(getSeed(tokenId),10) % 256);
823	 traits = string(abi.encodePacked(traits,newTrait,","));
824	 newTrait = getLevelString("Shirt Colour",expandRandom(getSeed(tokenId),11) % 256);
825	 traits = string(abi.encodePacked(traits,newTrait,"]"));
826	 return traits;
827	 }
828	 function getPropertyString(string memory traitName, uint256 value) internal pure returns (string memory) {
829	 return string(abi.encodePacked('{
830	 "trait_type": "',traitName,'" , "value": "',value.toString(),'"}
831	 '));
832	 }
833	 function getLevelString(string memory traitName, uint256 value) internal pure returns (string memory) {
834	 return string(abi.encodePacked('{
835	 "trait_type": "',traitName,'" , "value": ',value.toString(),'}
836	 '));
837	 }
838	 function getSVGString(uint256 tokenId) public view returns (string memory) {
839	 if(!revealed){
840	 return "";
841	 }
842	 string memory svgPartOne = string(abi.encodePacked('<svg xmlns="http: string(abi.encodePacked('<rect width="420" height="420" x="0" y="0" fill=',getGrey(10,getSeed(tokenId),100),' />')), string(abi.encodePacked('<rect width="280" height="280" x="90" y="90" fill=',getGrey(10,getSeed(tokenId),66),' />')), string(abi.encodePacked('<rect width="280" height="280" x="80" y="80" fill=',getGrey(10,getSeed(tokenId),33),' />')), string(abi.encodePacked('<rect width="280" height="280" x="70" y="70" fill="#000000" />')), string(abi.encodePacked('<rect width="120" height="70" x="150" y="350" fill=',getGrey(11,getSeed(tokenId),100),' />'))));
843	 string memory svgPartTwo = string(abi.encodePacked( string(abi.encodePacked('<rect width="10" height="50" x="170" y="370" fill="#000000" />')), string(abi.encodePacked('<rect width="10" height="50" x="240" y="370" fill="#000000" />')), string(abi.encodePacked('<rect width="80" height="80" x="80" y="80" fill="',getColour(1,getSeed(tokenId)),'" />')), string(abi.encodePacked('<rect width="80" height="80" x="170" y="80" fill="',getColour(2,getSeed(tokenId)),'" />')), string(abi.encodePacked('<rect width="80" height="80" x="260" y="80" fill="',getColour(3,getSeed(tokenId)),'" />'))));
844	 string memory svgPartThree = string(abi.encodePacked( string(abi.encodePacked('<rect width="80" height="80" x="80" y="170" fill="',getColour(4,getSeed(tokenId)),'" />')), string(abi.encodePacked('<rect width="80" height="80" x="170" y="170" fill="',getColour(5,getSeed(tokenId)),'" />')), string(abi.encodePacked('<rect width="80" height="80" x="260" y="170" fill="',getColour(6,getSeed(tokenId)),'" />')), string(abi.encodePacked('<rect width="80" height="80" x="80" y="260" fill="',getColour(7,getSeed(tokenId)),'" />')), string(abi.encodePacked('<rect width="80" height="80" x="170" y="260" fill="',getColour(8,getSeed(tokenId)),'" />')), string(abi.encodePacked('<rect width="80" height="80" x="260" y="260" fill="',getColour(9,getSeed(tokenId)),'" />')), '</svg>'));
845	 return string(abi.encodePacked(svgPartOne,svgPartTwo,svgPartThree));
846	 }
847	 function getColour(uint8 colourIndex, uint256 seed) internal view returns (string memory) {
848	 uint256 expandedVal = expandRandom(seed,colourIndex) % 6;
849	 return colours[getPaletteIndex(seed)][expandedVal];
850	 }
851	 function getGrey(uint8 colourIndex, uint256 seed, uint256 percentage) public pure returns (string memory) {
852	 uint256 grey = ((expandRandom(seed,colourIndex) % 256)*percentage)/100;
853	 return string(abi.encodePacked('"rgb(',grey.toString(),',',grey.toString(),',',grey.toString(),')"'));
854	 }
855	 function getPaletteIndex(uint256 seed) internal pure returns (uint8) {
856	 if (seed % 10 < 6){
857	 return 0;
858	 }
859	 else if (seed % 10 < 9){
860	 return 1;
861	 }
862	 else{
863	 return 2;
864	 }
865	 }
866	 function scramble(uint256 fee) public onlyOwner returns (bytes32 requestId) {
867	 require(LINK.balanceOf(address(this)) >= fee, "Not enough LINK");
868	 return requestRandomness(keyHash, fee);
869	 }
870	 function getSeed(uint256 tokenId) public view returns (uint256) {
871	 require(totalSupply()>tokenId, "Token Not Found");
872	 if (baseSeed == 0){
873	 return 0;
874	 }
875	 else{
876	 return expandRandom(baseSeed, tokenId);
877	 }
878	 }
879	 function expandRandom(uint256 random, uint256 expansion) internal pure returns (uint256) {
880	 return uint256(keccak256(abi.encode(random, expansion))) % 2000000000;
881	 }
882	 }
