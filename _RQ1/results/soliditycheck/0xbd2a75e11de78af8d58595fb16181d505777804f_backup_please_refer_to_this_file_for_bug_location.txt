row number 
1	           pragma solidity ^0.5.0;
2	 library SafeMath {
3	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
4	 uint256 c = a + b;
5	 require(c >= a, "SafeMath: addition overflow");
6	 return c;
7	 }
8	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
9	 return sub(a, b, "SafeMath: subtraction overflow");
10	 }
11	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
12	 require(b <= a, errorMessage);
13	 uint256 c = a - b;
14	 return c;
15	 }
16	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
17	 if (a == 0) {
18	 return 0;
19	 }
20	 uint256 c = a * b;
21	 require(c / a == b, "SafeMath: multiplication overflow");
22	 return c;
23	 }
24	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
25	 return div(a, b, "SafeMath: division by zero");
26	 }
27	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
28	 require(b > 0, errorMessage);
29	 uint256 c = a / b;
30	 return c;
31	 }
32	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
33	 return mod(a, b, "SafeMath: modulo by zero");
34	 }
35	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
36	 require(b != 0, errorMessage);
37	 return a % b;
38	 }
39	 }
40	 pragma solidity ^0.5.0;
41	 interface IERC165 {
42	 function supportsInterface(bytes4 interfaceId) external view returns (bool);
43	 }
44	 pragma solidity ^0.5.0;
45	 contract IERC721 is IERC165 {
46	 event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
47	 event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
48	 event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
49	 function balanceOf(address owner) public view returns (uint256 balance);
50	 function ownerOf(uint256 tokenId) public view returns (address owner);
51	 function safeTransferFrom(address from, address to, uint256 tokenId) public;
52	 function transferFrom(address from, address to, uint256 tokenId) public;
53	 function approve(address to, uint256 tokenId) public;
54	 function getApproved(uint256 tokenId) public view returns (address operator);
55	 function setApprovalForAll(address operator, bool _approved) public;
56	 function isApprovedForAll(address owner, address operator) public view returns (bool);
57	 function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;
58	 }
59	 pragma solidity ^0.5.0;
60	 interface IERC20 {
61	 function totalSupply() external view returns (uint256);
62	 function balanceOf(address account) external view returns (uint256);
63	 function transfer(address recipient, uint256 amount) external returns (bool);
64	 function allowance(address owner, address spender) external view returns (uint256);
65	 function approve(address spender, uint256 amount) external returns (bool);
66	 function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
67	 event Transfer(address indexed from, address indexed to, uint256 value);
68	 event Approval(address indexed owner, address indexed spender, uint256 value);
69	 }
70	 pragma solidity >=0.5.17;
71	 interface ISTokensManager {
72	 event Minted( uint256 tokenId, address owner, address property, uint256 amount, uint256 price );
73	 event Updated( uint256 tokenId, uint256 amount, uint256 price, uint256 cumulativeReward, uint256 pendingReward );
74	 function initialize(address _config) external;
75	 function mint( address _owner, address _property, uint256 _amount, uint256 _price ) external returns (uint256);
76	 function update( uint256 _tokenId, uint256 _amount, uint256 _price, uint256 _cumulativeReward, uint256 _pendingReward ) external returns (bool);
77	 function positions(uint256 _tokenId) external view returns ( address, uint256, uint256, uint256, uint256 );
78	 function rewards(uint256 _tokenId) external view returns ( uint256, uint256, uint256 );
79	 function positionsOfProperty(address _property) external view returns (uint256[] memory);
80	 function positionsOfOwner(address _owner) external view returns (uint256[] memory);
81	 }
82	 pragma solidity 0.5.17;
83	 library Decimals {
84	 using SafeMath for uint256;
85	 uint120 private constant BASIS_VAKUE = 1000000000000000000;
86	 function outOf(uint256 _a, uint256 _b) internal pure returns (uint256 result) {
87	 if (_a == 0) {
88	 return 0;
89	 }
90	 uint256 a = _a.mul(BASIS_VAKUE);
91	 if (a < _b) {
92	 return 0;
93	 }
94	 return (a.div(_b));
95	 }
96	 function mulBasis(uint256 _a) internal pure returns (uint256) {
97	 return _a.mul(BASIS_VAKUE);
98	 }
99	 function divBasis(uint256 _a) internal pure returns (uint256) {
100	 return _a.div(BASIS_VAKUE);
101	 }
102	 }
103	 pragma solidity >=0.5.17;
104	 interface IAddressConfig {
105	 function token() external view returns (address);
106	 function allocator() external view returns (address);
107	 function allocatorStorage() external view returns (address);
108	 function withdraw() external view returns (address);
109	 function withdrawStorage() external view returns (address);
110	 function marketFactory() external view returns (address);
111	 function marketGroup() external view returns (address);
112	 function propertyFactory() external view returns (address);
113	 function propertyGroup() external view returns (address);
114	 function metricsGroup() external view returns (address);
115	 function metricsFactory() external view returns (address);
116	 function policy() external view returns (address);
117	 function policyFactory() external view returns (address);
118	 function policySet() external view returns (address);
119	 function policyGroup() external view returns (address);
120	 function lockup() external view returns (address);
121	 function lockupStorage() external view returns (address);
122	 function voteTimes() external view returns (address);
123	 function voteTimesStorage() external view returns (address);
124	 function voteCounter() external view returns (address);
125	 function voteCounterStorage() external view returns (address);
126	 function setAllocator(address _addr) external;
127	 function setAllocatorStorage(address _addr) external;
128	 function setWithdraw(address _addr) external;
129	 function setWithdrawStorage(address _addr) external;
130	 function setMarketFactory(address _addr) external;
131	 function setMarketGroup(address _addr) external;
132	 function setPropertyFactory(address _addr) external;
133	 function setPropertyGroup(address _addr) external;
134	 function setMetricsFactory(address _addr) external;
135	 function setMetricsGroup(address _addr) external;
136	 function setPolicyFactory(address _addr) external;
137	 function setPolicyGroup(address _addr) external;
138	 function setPolicySet(address _addr) external;
139	 function setPolicy(address _addr) external;
140	 function setToken(address _addr) external;
141	 function setLockup(address _addr) external;
142	 function setLockupStorage(address _addr) external;
143	 function setVoteTimes(address _addr) external;
144	 function setVoteTimesStorage(address _addr) external;
145	 function setVoteCounter(address _addr) external;
146	 function setVoteCounterStorage(address _addr) external;
147	 }
148	 pragma solidity 0.5.17;
149	 contract UsingConfig {
150	 address private _config;
151	 constructor(address _addressConfig) public {
152	 _config = _addressConfig;
153	 }
154	 function config() internal view returns (IAddressConfig) {
155	 return IAddressConfig(_config);
156	 }
157	 function configAddress() external view returns (address) {
158	 return _config;
159	 }
160	 }
161	 pragma solidity >=0.5.17;
162	 interface IUsingStorage {
163	 function getStorageAddress() external view returns (address);
164	 function createStorage() external;
165	 function setStorage(address _storageAddress) external;
166	 function changeOwner(address newOwner) external;
167	 }
168	 pragma solidity ^0.5.0;
169	 contract Context {
170	 constructor () internal {
171	 }
172	 function _msgSender() internal view returns (address payable) {
173	 return msg.sender;
174	 }
175	 function _msgData() internal view returns (bytes memory) {
176	 this;
177	 return msg.data;
178	 }
179	 }
180	 pragma solidity ^0.5.0;
181	 contract Ownable is Context {
182	 address private _owner;
183	 event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
184	 constructor () internal {
185	 address msgSender = _msgSender();
186	 _owner = msgSender;
187	 emit OwnershipTransferred(address(0), msgSender);
188	 }
189	 function owner() public view returns (address) {
190	 return _owner;
191	 }
192	 modifier onlyOwner() {
193	 require(isOwner(), "Ownable: caller is not the owner");
194	 _;
195	 }
196	 function isOwner() public view returns (bool) {
197	 return _msgSender() == _owner;
198	 }
199	 function renounceOwnership() public onlyOwner {
200	 emit OwnershipTransferred(_owner, address(0));
201	 _owner = address(0);
202	 }
203	 function transferOwnership(address newOwner) public onlyOwner {
204	 _transferOwnership(newOwner);
205	 }
206	 function _transferOwnership(address newOwner) internal {
207	 require(newOwner != address(0), "Ownable: new owner is the zero address");
208	 emit OwnershipTransferred(_owner, newOwner);
209	 _owner = newOwner;
210	 }
211	 }
212	 pragma solidity 0.5.17;
213	 contract EternalStorage {
214	 address private currentOwner = msg.sender;
215	 mapping(bytes32 => uint256) private uIntStorage;
216	 mapping(bytes32 => string) private stringStorage;
217	 mapping(bytes32 => address) private addressStorage;
218	 mapping(bytes32 => bytes32) private bytesStorage;
219	 mapping(bytes32 => bool) private boolStorage;
220	 mapping(bytes32 => int256) private intStorage;
221	 modifier onlyCurrentOwner() {
222	 require(msg.sender == currentOwner, "not current owner");
223	 _;
224	 }
225	 function changeOwner(address _newOwner) external {
226	 require(msg.sender == currentOwner, "not current owner");
227	 currentOwner = _newOwner;
228	 }
229	 function getUint(bytes32 _key) external view returns (uint256) {
230	 return uIntStorage[_key];
231	 }
232	 function getString(bytes32 _key) external view returns (string memory) {
233	 return stringStorage[_key];
234	 }
235	 function getAddress(bytes32 _key) external view returns (address) {
236	 return addressStorage[_key];
237	 }
238	 function getBytes(bytes32 _key) external view returns (bytes32) {
239	 return bytesStorage[_key];
240	 }
241	 function getBool(bytes32 _key) external view returns (bool) {
242	 return boolStorage[_key];
243	 }
244	 function getInt(bytes32 _key) external view returns (int256) {
245	 return intStorage[_key];
246	 }
247	 function setUint(bytes32 _key, uint256 _value) external onlyCurrentOwner {
248	 uIntStorage[_key] = _value;
249	 }
250	 function setString(bytes32 _key, string calldata _value) external onlyCurrentOwner {
251	 stringStorage[_key] = _value;
252	 }
253	 function setAddress(bytes32 _key, address _value) external onlyCurrentOwner {
254	 addressStorage[_key] = _value;
255	 }
256	 function setBytes(bytes32 _key, bytes32 _value) external onlyCurrentOwner {
257	 bytesStorage[_key] = _value;
258	 }
259	 function setBool(bytes32 _key, bool _value) external onlyCurrentOwner {
260	 boolStorage[_key] = _value;
261	 }
262	 function setInt(bytes32 _key, int256 _value) external onlyCurrentOwner {
263	 intStorage[_key] = _value;
264	 }
265	 function deleteUint(bytes32 _key) external onlyCurrentOwner {
266	 delete uIntStorage[_key];
267	 }
268	 function deleteString(bytes32 _key) external onlyCurrentOwner {
269	 delete stringStorage[_key];
270	 }
271	 function deleteAddress(bytes32 _key) external onlyCurrentOwner {
272	 delete addressStorage[_key];
273	 }
274	 function deleteBytes(bytes32 _key) external onlyCurrentOwner {
275	 delete bytesStorage[_key];
276	 }
277	 function deleteBool(bytes32 _key) external onlyCurrentOwner {
278	 delete boolStorage[_key];
279	 }
280	 function deleteInt(bytes32 _key) external onlyCurrentOwner {
281	 delete intStorage[_key];
282	 }
283	 }
284	 pragma solidity 0.5.17;
285	 contract UsingStorage is Ownable, IUsingStorage {
286	 address private _storage;
287	 modifier hasStorage() {
288	 require(_storage != address(0), "storage is not set");
289	 _;
290	 }
291	 function eternalStorage() internal view hasStorage returns (EternalStorage) {
292	 return EternalStorage(_storage);
293	 }
294	 function getStorageAddress() external view hasStorage returns (address) {
295	 return _storage;
296	 }
297	 function createStorage() external onlyOwner {
298	 require(_storage == address(0), "storage is set");
299	 EternalStorage tmp = new EternalStorage();
300	 _storage = address(tmp);
301	 }
302	 function setStorage(address _storageAddress) external onlyOwner {
303	 _storage = _storageAddress;
304	 }
305	 function changeOwner(address newOwner) external onlyOwner {
306	 EternalStorage(_storage).changeOwner(newOwner);
307	 }
308	 }
309	 pragma solidity 0.5.17;
310	 contract LockupStorage is UsingStorage {
311	 using SafeMath for uint256;
312	 uint256 private constant BASIS = 100000000000000000000000000000000;
313	 function setStorageAllValue(uint256 _value) internal {
314	 bytes32 key = getStorageAllValueKey();
315	 eternalStorage().setUint(key, _value);
316	 }
317	 function getStorageAllValue() public view returns (uint256) {
318	 bytes32 key = getStorageAllValueKey();
319	 return eternalStorage().getUint(key);
320	 }
321	 function getStorageAllValueKey() private pure returns (bytes32) {
322	 return keccak256(abi.encodePacked("_allValue"));
323	 }
324	 function setStorageValue( address _property, address _sender, uint256 _value ) internal {
325	 bytes32 key = getStorageValueKey(_property, _sender);
326	 eternalStorage().setUint(key, _value);
327	 }
328	 function getStorageValue(address _property, address _sender) public view returns (uint256) {
329	 bytes32 key = getStorageValueKey(_property, _sender);
330	 return eternalStorage().getUint(key);
331	 }
332	 function getStorageValueKey(address _property, address _sender) private pure returns (bytes32) {
333	 return keccak256(abi.encodePacked("_value", _property, _sender));
334	 }
335	 function setStoragePropertyValue(address _property, uint256 _value) internal {
336	 bytes32 key = getStoragePropertyValueKey(_property);
337	 eternalStorage().setUint(key, _value);
338	 }
339	 function getStoragePropertyValue(address _property) public view returns (uint256) {
340	 bytes32 key = getStoragePropertyValueKey(_property);
341	 return eternalStorage().getUint(key);
342	 }
343	 function getStoragePropertyValueKey(address _property) private pure returns (bytes32) {
344	 return keccak256(abi.encodePacked("_propertyValue", _property));
345	 }
346	 function setStorageInterestPrice(address _property, uint256 _value) internal {
347	 eternalStorage().setUint(getStorageInterestPriceKey(_property), _value);
348	 }
349	 function getStorageInterestPrice(address _property) public view returns (uint256) {
350	 return eternalStorage().getUint(getStorageInterestPriceKey(_property));
351	 }
352	 function getStorageInterestPriceKey(address _property) private pure returns (bytes32) {
353	 return keccak256(abi.encodePacked("_interestTotals", _property));
354	 }
355	 function setStorageLastInterestPrice( address _property, address _user, uint256 _value ) internal {
356	 eternalStorage().setUint( getStorageLastInterestPriceKey(_property, _user), _value );
357	 }
358	 function getStorageLastInterestPrice(address _property, address _user) public view returns (uint256) {
359	 return eternalStorage().getUint( getStorageLastInterestPriceKey(_property, _user) );
360	 }
361	 function getStorageLastInterestPriceKey(address _property, address _user) private pure returns (bytes32) {
362	 return keccak256( abi.encodePacked("_lastLastInterestPrice", _property, _user) );
363	 }
364	 function setStorageLastSameRewardsAmountAndBlock( uint256 _amount, uint256 _block ) internal {
365	 uint256 record = _amount.mul(BASIS).add(_block);
366	 eternalStorage().setUint( getStorageLastSameRewardsAmountAndBlockKey(), record );
367	 }
368	 function getStorageLastSameRewardsAmountAndBlock() public view returns (uint256 _amount, uint256 _block) {
369	 uint256 record = eternalStorage().getUint( getStorageLastSameRewardsAmountAndBlockKey() );
370	 uint256 amount = record.div(BASIS);
371	 uint256 blockNumber = record.sub(amount.mul(BASIS));
372	 return (amount, blockNumber);
373	 }
374	 function getStorageLastSameRewardsAmountAndBlockKey() private pure returns (bytes32) {
375	 return keccak256(abi.encodePacked("_LastSameRewardsAmountAndBlock"));
376	 }
377	 function setStorageCumulativeGlobalRewards(uint256 _value) internal {
378	 eternalStorage().setUint( getStorageCumulativeGlobalRewardsKey(), _value );
379	 }
380	 function getStorageCumulativeGlobalRewards() public view returns (uint256) {
381	 return eternalStorage().getUint(getStorageCumulativeGlobalRewardsKey());
382	 }
383	 function getStorageCumulativeGlobalRewardsKey() private pure returns (bytes32) {
384	 return keccak256(abi.encodePacked("_cumulativeGlobalRewards"));
385	 }
386	 function setStoragePendingInterestWithdrawal( address _property, address _user, uint256 _value ) internal {
387	 eternalStorage().setUint( getStoragePendingInterestWithdrawalKey(_property, _user), _value );
388	 }
389	 function getStoragePendingInterestWithdrawal( address _property, address _user ) public view returns (uint256) {
390	 return eternalStorage().getUint( getStoragePendingInterestWithdrawalKey(_property, _user) );
391	 }
392	 function getStoragePendingInterestWithdrawalKey( address _property, address _user ) private pure returns (bytes32) {
393	 return keccak256( abi.encodePacked("_pendingInterestWithdrawal", _property, _user) );
394	 }
395	 function setStorageDIP4GenesisBlock(uint256 _block) internal {
396	 eternalStorage().setUint(getStorageDIP4GenesisBlockKey(), _block);
397	 }
398	 function getStorageDIP4GenesisBlock() public view returns (uint256) {
399	 return eternalStorage().getUint(getStorageDIP4GenesisBlockKey());
400	 }
401	 function getStorageDIP4GenesisBlockKey() private pure returns (bytes32) {
402	 return keccak256(abi.encodePacked("_dip4GenesisBlock"));
403	 }
404	 function setStorageLastStakedInterestPrice( address _property, address _user, uint256 _value ) internal {
405	 eternalStorage().setUint( getStorageLastStakedInterestPriceKey(_property, _user), _value );
406	 }
407	 function getStorageLastStakedInterestPrice(address _property, address _user) public view returns (uint256) {
408	 return eternalStorage().getUint( getStorageLastStakedInterestPriceKey(_property, _user) );
409	 }
410	 function getStorageLastStakedInterestPriceKey( address _property, address _user ) private pure returns (bytes32) {
411	 return keccak256( abi.encodePacked("_lastStakedInterestPrice", _property, _user) );
412	 }
413	 function setStorageLastStakesChangedCumulativeReward(uint256 _value) internal {
414	 eternalStorage().setUint( getStorageLastStakesChangedCumulativeRewardKey(), _value );
415	 }
416	 function getStorageLastStakesChangedCumulativeReward() public view returns (uint256) {
417	 return eternalStorage().getUint( getStorageLastStakesChangedCumulativeRewardKey() );
418	 }
419	 function getStorageLastStakesChangedCumulativeRewardKey() private pure returns (bytes32) {
420	 return keccak256(abi.encodePacked("_lastStakesChangedCumulativeReward"));
421	 }
422	 function setStorageLastCumulativeHoldersRewardPrice(uint256 _holders) internal {
423	 eternalStorage().setUint( getStorageLastCumulativeHoldersRewardPriceKey(), _holders );
424	 }
425	 function getStorageLastCumulativeHoldersRewardPrice() public view returns (uint256) {
426	 return eternalStorage().getUint( getStorageLastCumulativeHoldersRewardPriceKey() );
427	 }
428	 function getStorageLastCumulativeHoldersRewardPriceKey() private pure returns (bytes32) {
429	 return keccak256(abi.encodePacked("0lastCumulativeHoldersRewardPrice"));
430	 }
431	 function setStorageLastCumulativeInterestPrice(uint256 _interest) internal {
432	 eternalStorage().setUint( getStorageLastCumulativeInterestPriceKey(), _interest );
433	 }
434	 function getStorageLastCumulativeInterestPrice() public view returns (uint256) {
435	 return eternalStorage().getUint( getStorageLastCumulativeInterestPriceKey() );
436	 }
437	 function getStorageLastCumulativeInterestPriceKey() private pure returns (bytes32) {
438	 return keccak256(abi.encodePacked("0lastCumulativeInterestPrice"));
439	 }
440	 function setStorageLastCumulativeHoldersRewardAmountPerProperty( address _property, uint256 _value ) internal {
441	 eternalStorage().setUint( getStorageLastCumulativeHoldersRewardAmountPerPropertyKey( _property ), _value );
442	 }
443	 function getStorageLastCumulativeHoldersRewardAmountPerProperty( address _property ) public view returns (uint256) {
444	 return eternalStorage().getUint( getStorageLastCumulativeHoldersRewardAmountPerPropertyKey( _property ) );
445	 }
446	 function getStorageLastCumulativeHoldersRewardAmountPerPropertyKey( address _property ) private pure returns (bytes32) {
447	 return keccak256( abi.encodePacked( "0lastCumulativeHoldersRewardAmountPerProperty", _property ) );
448	 }
449	 function setStorageLastCumulativeHoldersRewardPricePerProperty( address _property, uint256 _price ) internal {
450	 eternalStorage().setUint( getStorageLastCumulativeHoldersRewardPricePerPropertyKey(_property), _price );
451	 }
452	 function getStorageLastCumulativeHoldersRewardPricePerProperty( address _property ) public view returns (uint256) {
453	 return eternalStorage().getUint( getStorageLastCumulativeHoldersRewardPricePerPropertyKey( _property ) );
454	 }
455	 function getStorageLastCumulativeHoldersRewardPricePerPropertyKey( address _property ) private pure returns (bytes32) {
456	 return keccak256( abi.encodePacked( "0lastCumulativeHoldersRewardPricePerProperty", _property ) );
457	 }
458	 function setStorageCap(uint256 _cap) internal {
459	 eternalStorage().setUint(getStorageCapKey(), _cap);
460	 }
461	 function getStorageCap() public view returns (uint256) {
462	 return eternalStorage().getUint(getStorageCapKey());
463	 }
464	 function getStorageCapKey() private pure returns (bytes32) {
465	 return keccak256(abi.encodePacked("_cap"));
466	 }
467	 function setStorageCumulativeHoldersRewardCap(uint256 _value) internal {
468	 eternalStorage().setUint( getStorageCumulativeHoldersRewardCapKey(), _value );
469	 }
470	 function getStorageCumulativeHoldersRewardCap() public view returns (uint256) {
471	 return eternalStorage().getUint(getStorageCumulativeHoldersRewardCapKey());
472	 }
473	 function getStorageCumulativeHoldersRewardCapKey() private pure returns (bytes32) {
474	 return keccak256(abi.encodePacked("_cumulativeHoldersRewardCap"));
475	 }
476	 function setStorageLastCumulativeHoldersPriceCap(uint256 _value) internal {
477	 eternalStorage().setUint( getStorageLastCumulativeHoldersPriceCapKey(), _value );
478	 }
479	 function getStorageLastCumulativeHoldersPriceCap() public view returns (uint256) {
480	 return eternalStorage().getUint( getStorageLastCumulativeHoldersPriceCapKey() );
481	 }
482	 function getStorageLastCumulativeHoldersPriceCapKey() private pure returns (bytes32) {
483	 return keccak256(abi.encodePacked("_lastCumulativeHoldersPriceCap"));
484	 }
485	 function setStorageInitialCumulativeHoldersRewardCap( address _property, uint256 _value ) internal {
486	 eternalStorage().setUint( getStorageInitialCumulativeHoldersRewardCapKey(_property), _value );
487	 }
488	 function getStorageInitialCumulativeHoldersRewardCap(address _property) public view returns (uint256) {
489	 return eternalStorage().getUint( getStorageInitialCumulativeHoldersRewardCapKey(_property) );
490	 }
491	 function getStorageInitialCumulativeHoldersRewardCapKey(address _property) private pure returns (bytes32) {
492	 return keccak256( abi.encodePacked( "_initialCumulativeHoldersRewardCap", _property ) );
493	 }
494	 function setStorageFallbackInitialCumulativeHoldersRewardCap(uint256 _value) internal {
495	 eternalStorage().setUint( getStorageFallbackInitialCumulativeHoldersRewardCapKey(), _value );
496	 }
497	 function getStorageFallbackInitialCumulativeHoldersRewardCap() public view returns (uint256) {
498	 return eternalStorage().getUint( getStorageFallbackInitialCumulativeHoldersRewardCapKey() );
499	 }
500	 function getStorageFallbackInitialCumulativeHoldersRewardCapKey() private pure returns (bytes32) {
501	 return keccak256( abi.encodePacked("_fallbackInitialCumulativeHoldersRewardCap") );
502	 }
503	 }
504	 pragma solidity >=0.5.17;
505	 interface IDev {
506	 function deposit(address _to, uint256 _amount) external returns (bool);
507	 function depositFrom( address _from, address _to, uint256 _amount ) external returns (bool);
508	 function fee(address _from, uint256 _amount) external returns (bool);
509	 }
510	 pragma solidity >=0.5.17;
511	 interface IDevMinter {
512	 function mint(address account, uint256 amount) external returns (bool);
513	 function renounceMinter() external;
514	 }
515	 pragma solidity >=0.5.17;
516	 interface IProperty {
517	 function author() external view returns (address);
518	 function changeAuthor(address _nextAuthor) external;
519	 function changeName(string calldata _name) external;
520	 function changeSymbol(string calldata _symbol) external;
521	 function withdraw(address _sender, uint256 _value) external;
522	 }
523	 pragma solidity >=0.5.17;
524	 interface IPolicy {
525	 function rewards(uint256 _lockups, uint256 _assets) external view returns (uint256);
526	 function holdersShare(uint256 _amount, uint256 _lockups) external view returns (uint256);
527	 function authenticationFee(uint256 _assets, uint256 _propertyAssets) external view returns (uint256);
528	 function marketVotingBlocks() external view returns (uint256);
529	 function policyVotingBlocks() external view returns (uint256);
530	 function shareOfTreasury(uint256 _supply) external view returns (uint256);
531	 function treasury() external view returns (address);
532	 function capSetter() external view returns (address);
533	 }
534	 pragma solidity >=0.5.17;
535	 interface IAllocator {
536	 function beforeBalanceChange( address _property, address _from, address _to ) external;
537	 function calculateMaxRewardsPerBlock() external view returns (uint256);
538	 }
539	 pragma solidity >=0.5.17;
540	 interface ILockup {
541	 function depositToProperty(address _property, uint256 _amount) external returns (uint256);
542	 function depositToPosition(uint256 _tokenId, uint256 _amount) external returns (bool);
543	 function lockup( address _from, address _property, uint256 _value ) external;
544	 function update() external;
545	 function withdraw(address _property, uint256 _amount) external;
546	 function withdrawByPosition(uint256 _tokenId, uint256 _amount) external returns (bool);
547	 function calculateCumulativeRewardPrices() external view returns ( uint256 _reward, uint256 _holders, uint256 _interest, uint256 _holdersCap );
548	 function calculateRewardAmount(address _property) external view returns (uint256, uint256);
549	 function calculateCumulativeHoldersRewardAmount(address _property) external view returns (uint256);
550	 function getPropertyValue(address _property) external view returns (uint256);
551	 function getAllValue() external view returns (uint256);
552	 function getValue(address _property, address _sender) external view returns (uint256);
553	 function calculateWithdrawableInterestAmount( address _property, address _user ) external view returns (uint256);
554	 function calculateWithdrawableInterestAmountByPosition(uint256 _tokenId) external view returns (uint256);
555	 function cap() external view returns (uint256);
556	 function updateCap(uint256 _cap) external;
557	 function devMinter() external view returns (address);
558	 function sTokensManager() external view returns (address);
559	 function migrateToSTokens(address _property) external returns (uint256);
560	 }
561	 pragma solidity >=0.5.17;
562	 interface IMetricsGroup {
563	 function addGroup(address _addr) external;
564	 function removeGroup(address _addr) external;
565	 function isGroup(address _addr) external view returns (bool);
566	 function totalIssuedMetrics() external view returns (uint256);
567	 function hasAssets(address _property) external view returns (bool);
568	 function getMetricsCountPerProperty(address _property) external view returns (uint256);
569	 function totalAuthenticatedProperties() external view returns (uint256);
570	 }
571	 pragma solidity 0.5.17;
572	 contract Lockup is ILockup, UsingConfig, LockupStorage {
573	 using SafeMath for uint256;
574	 using Decimals for uint256;
575	 address public devMinter;
576	 address public sTokensManager;
577	 struct RewardPrices {
578	 uint256 reward;
579	 uint256 holders;
580	 uint256 interest;
581	 uint256 holdersCap;
582	 }
583	 event Lockedup(address _from, address _property, uint256 _value);
584	 event UpdateCap(uint256 _cap);
585	 constructor( address _config, address _devMinter, address _sTokensManager ) public UsingConfig(_config) {
586	 devMinter = _devMinter;
587	 sTokensManager = _sTokensManager;
588	 }
589	 modifier onlyAuthenticatedProperty(address _property) {
590	 require( IMetricsGroup(config().metricsGroup()).hasAssets(_property), "unable to stake to unauthenticated property" );
591	 _;
592	 }
593	 modifier onlyPositionOwner(uint256 _tokenId) {
594	 require( IERC721(sTokensManager).ownerOf(_tokenId) == msg.sender, "illegal sender" );
595	 _;
596	 }
597	 function depositToProperty(address _property, uint256 _amount) external onlyAuthenticatedProperty(_property) returns (uint256) {
598	 require(_amount != 0, "illegal deposit amount");
599	 ( uint256 reward, uint256 holders, uint256 interest, uint256 holdersCap ) = calculateCumulativeRewardPrices();
600	 updateValues( true, _property, _amount, RewardPrices(reward, holders, interest, holdersCap) );
601	 require( IERC20(config().token()).transferFrom( msg.sender, _property, _amount ), "dev transfer failed" );
602	 uint256 tokenId = ISTokensManager(sTokensManager).mint( msg.sender, _property, _amount, interest );
603	 emit Lockedup(msg.sender, _property, _amount);
604	 return tokenId;
605	 }
606	 function depositToPosition(uint256 _tokenId, uint256 _amount) external onlyPositionOwner(_tokenId) returns (bool) {
607	 require(_amount != 0, "illegal deposit amount");
608	 ISTokensManager sTokenManagerInstance = ISTokensManager(sTokensManager);
609	 ( address property, uint256 amount, uint256 price, uint256 cumulativeReward, uint256 pendingReward ) = sTokenManagerInstance.positions(_tokenId);
610	 ( uint256 withdrawable, RewardPrices memory prices ) = _calculateWithdrawableInterestAmount( property, amount, price, pendingReward );
611	 updateValues(true, property, _amount, prices);
612	 require( IERC20(config().token()).transferFrom( msg.sender, property, _amount ), "dev transfer failed" );
613	 bool result = sTokenManagerInstance.update( _tokenId, amount.add(_amount), prices.interest, cumulativeReward.add(withdrawable), pendingReward.add(withdrawable) );
614	 require(result, "failed to update");
615	 emit Lockedup(msg.sender, property, _amount);
616	 return true;
617	 }
618	 function lockup( address _from, address _property, uint256 _value ) external onlyAuthenticatedProperty(_property) {
619	 require(msg.sender == config().token(), "this is illegal address");
620	 require(_value != 0, "illegal lockup value");
621	 RewardPrices memory prices = updatePendingInterestWithdrawal( _property, _from );
622	 updateValues4Legacy(true, _from, _property, _value, prices);
623	 emit Lockedup(_from, _property, _value);
624	 }
625	 function withdrawByPosition(uint256 _tokenId, uint256 _amount) external onlyPositionOwner(_tokenId) returns (bool) {
626	 ISTokensManager sTokenManagerInstance = ISTokensManager(sTokensManager);
627	 ( address property, uint256 amount, uint256 price, uint256 cumulativeReward, uint256 pendingReward ) = sTokenManagerInstance.positions(_tokenId);
628	 require(amount >= _amount, "insufficient tokens staked");
629	 (uint256 value, RewardPrices memory prices) = _withdrawInterest( property, amount, price, pendingReward );
630	 if (_amount != 0) {
631	 IProperty(property).withdraw(msg.sender, _amount);
632	 }
633	 updateValues(false, property, _amount, prices);
634	 uint256 cumulative = cumulativeReward.add(value);
635	 return sTokenManagerInstance.update( _tokenId, amount.sub(_amount), prices.interest, cumulative, 0 );
636	 }
637	 function withdraw(address _property, uint256 _amount) external {
638	 require( hasValue(_property, msg.sender, _amount), "insufficient tokens staked" );
639	 RewardPrices memory prices = _withdrawInterest4Legacy(_property);
640	 if (_amount != 0) {
641	 IProperty(_property).withdraw(msg.sender, _amount);
642	 }
643	 updateValues4Legacy(false, msg.sender, _property, _amount, prices);
644	 }
645	 function cap() external view returns (uint256) {
646	 return getStorageCap();
647	 }
648	 function updateCap(uint256 _cap) external {
649	 address setter = IPolicy(config().policy()).capSetter();
650	 require(setter == msg.sender, "illegal access");
651	 ( , uint256 holdersPrice, , uint256 cCap ) = calculateCumulativeRewardPrices();
652	 setStorageCumulativeHoldersRewardCap(cCap);
653	 setStorageLastCumulativeHoldersPriceCap(holdersPrice);
654	 setStorageCap(_cap);
655	 emit UpdateCap(_cap);
656	 }
657	 function _calculateLatestCap(uint256 _holdersPrice) private view returns (uint256) {
658	 uint256 cCap = getStorageCumulativeHoldersRewardCap();
659	 uint256 lastHoldersPrice = getStorageLastCumulativeHoldersPriceCap();
660	 uint256 additionalCap = _holdersPrice.sub(lastHoldersPrice).mul( getStorageCap() );
661	 return cCap.add(additionalCap);
662	 }
663	 function beforeStakesChanged(address _property, RewardPrices memory _prices) private {
664	 uint256 cHoldersReward = _calculateCumulativeHoldersRewardAmount( _prices.holders, _property );
665	 if ( getStorageLastCumulativeHoldersRewardPricePerProperty(_property) == 0 && getStorageInitialCumulativeHoldersRewardCap(_property) == 0 && getStoragePropertyValue(_property) == 0 ) {
666	 setStorageInitialCumulativeHoldersRewardCap( _property, _prices.holdersCap );
667	 }
668	 setStorageLastStakesChangedCumulativeReward(_prices.reward);
669	 setStorageLastCumulativeHoldersRewardPrice(_prices.holders);
670	 setStorageLastCumulativeInterestPrice(_prices.interest);
671	 setStorageLastCumulativeHoldersRewardAmountPerProperty( _property, cHoldersReward );
672	 setStorageLastCumulativeHoldersRewardPricePerProperty( _property, _prices.holders );
673	 setStorageCumulativeHoldersRewardCap(_prices.holdersCap);
674	 setStorageLastCumulativeHoldersPriceCap(_prices.holders);
675	 }
676	 function calculateCumulativeRewardPrices() public view returns ( uint256 _reward, uint256 _holders, uint256 _interest, uint256 _holdersCap ) {
677	 uint256 lastReward = getStorageLastStakesChangedCumulativeReward();
678	 uint256 lastHoldersPrice = getStorageLastCumulativeHoldersRewardPrice();
679	 uint256 lastInterestPrice = getStorageLastCumulativeInterestPrice();
680	 uint256 allStakes = getStorageAllValue();
681	 (uint256 reward, ) = dry();
682	 uint256 mReward = reward.mulBasis();
683	 uint256 price = allStakes > 0 ? mReward.sub(lastReward).div(allStakes) : 0;
684	 uint256 holdersShare = IPolicy(config().policy()).holdersShare( price, allStakes );
685	 uint256 holdersPrice = holdersShare.add(lastHoldersPrice);
686	 uint256 interestPrice = price.sub(holdersShare).add(lastInterestPrice);
687	 uint256 cCap = _calculateLatestCap(holdersPrice);
688	 return (mReward, holdersPrice, interestPrice, cCap);
689	 }
690	 function _calculateCumulativeHoldersRewardAmount( uint256 _holdersPrice, address _property ) private view returns (uint256) {
691	 (uint256 cHoldersReward, uint256 lastReward) = ( getStorageLastCumulativeHoldersRewardAmountPerProperty(_property), getStorageLastCumulativeHoldersRewardPricePerProperty(_property) );
692	 uint256 additionalHoldersReward = _holdersPrice.sub(lastReward).mul( getStoragePropertyValue(_property) );
693	 return cHoldersReward.add(additionalHoldersReward);
694	 }
695	 function calculateCumulativeHoldersRewardAmount(address _property) external view returns (uint256) {
696	 (, uint256 holders, , ) = calculateCumulativeRewardPrices();
697	 return _calculateCumulativeHoldersRewardAmount(holders, _property);
698	 }
699	 function calculateRewardAmount(address _property) external view returns (uint256, uint256) {
700	 ( , uint256 holders, , uint256 holdersCap ) = calculateCumulativeRewardPrices();
701	 uint256 initialCap = _getInitialCap(_property);
702	 uint256 capValue = holdersCap.sub(initialCap);
703	 return ( _calculateCumulativeHoldersRewardAmount(holders, _property), capValue );
704	 }
705	 function _getInitialCap(address _property) private view returns (uint256) {
706	 uint256 initialCap = getStorageInitialCumulativeHoldersRewardCap( _property );
707	 if (initialCap > 0) {
708	 return initialCap;
709	 }
710	 if ( getStorageLastCumulativeHoldersRewardPricePerProperty(_property) > 0 || getStoragePropertyValue(_property) > 0 ) {
711	 return getStorageFallbackInitialCumulativeHoldersRewardCap();
712	 }
713	 return 0;
714	 }
715	 function update() public {
716	 (uint256 _nextRewards, uint256 _amount) = dry();
717	 setStorageCumulativeGlobalRewards(_nextRewards);
718	 setStorageLastSameRewardsAmountAndBlock(_amount, block.number);
719	 }
720	 function dry() private view returns (uint256 _nextRewards, uint256 _amount) {
721	 uint256 rewardsAmount = IAllocator(config().allocator()) .calculateMaxRewardsPerBlock();
722	 ( uint256 lastAmount, uint256 lastBlock ) = getStorageLastSameRewardsAmountAndBlock();
723	 uint256 lastMaxRewards = lastAmount == rewardsAmount ? rewardsAmount : lastAmount;
724	 uint256 blocks = lastBlock > 0 ? block.number.sub(lastBlock) : 0;
725	 uint256 additionalRewards = lastMaxRewards.mul(blocks);
726	 uint256 nextRewards = getStorageCumulativeGlobalRewards().add( additionalRewards );
727	 return (nextRewards, rewardsAmount);
728	 }
729	 function _calculateInterestAmount(uint256 _amount, uint256 _price) private view returns ( uint256 amount_, uint256 interestPrice_, RewardPrices memory prices_ ) {
730	 ( uint256 reward, uint256 holders, uint256 interest, uint256 holdersCap ) = calculateCumulativeRewardPrices();
731	 uint256 result = interest >= _price ? interest.sub(_price).mul(_amount).divBasis() : 0;
732	 return ( result, interest, RewardPrices(reward, holders, interest, holdersCap) );
733	 }
734	 function _calculateInterestAmount4Legacy(address _property, address _user) private view returns ( uint256 _amount, uint256 _interestPrice, RewardPrices memory _prices ) {
735	 uint256 lockedUpPerAccount = getStorageValue(_property, _user);
736	 uint256 lastInterest = getStorageLastStakedInterestPrice( _property, _user );
737	 ( uint256 reward, uint256 holders, uint256 interest, uint256 holdersCap ) = calculateCumulativeRewardPrices();
738	 uint256 result = interest >= lastInterest ? interest.sub(lastInterest).mul(lockedUpPerAccount).divBasis() : 0;
739	 return ( result, interest, RewardPrices(reward, holders, interest, holdersCap) );
740	 }
741	 function _calculateWithdrawableInterestAmount( address _property, uint256 _amount, uint256 _price, uint256 _pendingReward ) private view returns (uint256 amount_, RewardPrices memory prices_) {
742	 if ( IMetricsGroup(config().metricsGroup()).hasAssets(_property) == false ) {
743	 return (0, RewardPrices(0, 0, 0, 0));
744	 }
745	 ( uint256 amount, , RewardPrices memory prices ) = _calculateInterestAmount(_amount, _price);
746	 uint256 withdrawableAmount = amount.add(_pendingReward);
747	 return (withdrawableAmount, prices);
748	 }
749	 function _calculateWithdrawableInterestAmount4Legacy( address _property, address _user ) private view returns (uint256 _amount, RewardPrices memory _prices) {
750	 if ( IMetricsGroup(config().metricsGroup()).hasAssets(_property) == false ) {
751	 return (0, RewardPrices(0, 0, 0, 0));
752	 }
753	 uint256 pending = getStoragePendingInterestWithdrawal(_property, _user);
754	 uint256 legacy = __legacyWithdrawableInterestAmount(_property, _user);
755	 ( uint256 amount, , RewardPrices memory prices ) = _calculateInterestAmount4Legacy(_property, _user);
756	 uint256 withdrawableAmount = amount.add(pending).add(legacy);
757	 return (withdrawableAmount, prices);
758	 }
759	 function calculateWithdrawableInterestAmount( address _property, address _user ) external view returns (uint256) {
760	 (uint256 amount, ) = _calculateWithdrawableInterestAmount4Legacy( _property, _user );
761	 return amount;
762	 }
763	 function calculateWithdrawableInterestAmountByPosition(uint256 _tokenId) external view returns (uint256) {
764	 ISTokensManager sTokenManagerInstance = ISTokensManager(sTokensManager);
765	 ( address property, uint256 amount, uint256 price, , uint256 pendingReward ) = sTokenManagerInstance.positions(_tokenId);
766	 (uint256 result, ) = _calculateWithdrawableInterestAmount( property, amount, price, pendingReward );
767	 return result;
768	 }
769	 function _withdrawInterest( address _property, uint256 _amount, uint256 _price, uint256 _pendingReward ) private returns (uint256 value_, RewardPrices memory prices_) {
770	 ( uint256 value, RewardPrices memory prices ) = _calculateWithdrawableInterestAmount( _property, _amount, _price, _pendingReward );
771	 require( IDevMinter(devMinter).mint(msg.sender, value), "dev mint failed" );
772	 update();
773	 return (value, prices);
774	 }
775	 function _withdrawInterest4Legacy(address _property) private returns (RewardPrices memory _prices) {
776	 ( uint256 value, RewardPrices memory prices ) = _calculateWithdrawableInterestAmount4Legacy(_property, msg.sender);
777	 setStoragePendingInterestWithdrawal(_property, msg.sender, 0);
778	 setStorageLastStakedInterestPrice( _property, msg.sender, prices.interest );
779	 __updateLegacyWithdrawableInterestAmount(_property, msg.sender);
780	 require( IDevMinter(devMinter).mint(msg.sender, value), "dev mint failed" );
781	 update();
782	 return prices;
783	 }
784	 function updateValues4Legacy( bool _addition, address _account, address _property, uint256 _value, RewardPrices memory _prices ) private {
785	 setStorageLastStakedInterestPrice( _property, _account, _prices.interest );
786	 updateValues(_addition, _property, _value, _prices);
787	 if (_addition) {
788	 addValue(_property, _account, _value);
789	 }
790	 else {
791	 subValue(_property, _account, _value);
792	 }
793	 }
794	 function updateValues( bool _addition, address _property, uint256 _value, RewardPrices memory _prices ) private {
795	 beforeStakesChanged(_property, _prices);
796	 if (_addition) {
797	 addAllValue(_value);
798	 addPropertyValue(_property, _value);
799	 }
800	 else {
801	 subAllValue(_value);
802	 subPropertyValue(_property, _value);
803	 }
804	 update();
805	 }
806	 function getAllValue() external view returns (uint256) {
807	 return getStorageAllValue();
808	 }
809	 function addAllValue(uint256 _value) private {
810	 uint256 value = getStorageAllValue();
811	 value = value.add(_value);
812	 setStorageAllValue(value);
813	 }
814	 function subAllValue(uint256 _value) private {
815	 uint256 value = getStorageAllValue();
816	 value = value.sub(_value);
817	 setStorageAllValue(value);
818	 }
819	 function getValue(address _property, address _sender) external view returns (uint256) {
820	 return getStorageValue(_property, _sender);
821	 }
822	 function addValue( address _property, address _sender, uint256 _value ) private {
823	 uint256 value = getStorageValue(_property, _sender);
824	 value = value.add(_value);
825	 setStorageValue(_property, _sender, value);
826	 }
827	 function subValue( address _property, address _sender, uint256 _value ) private {
828	 uint256 value = getStorageValue(_property, _sender);
829	 value = value.sub(_value);
830	 setStorageValue(_property, _sender, value);
831	 }
832	 function hasValue( address _property, address _sender, uint256 _amount ) private view returns (bool) {
833	 uint256 value = getStorageValue(_property, _sender);
834	 return value >= _amount;
835	 }
836	 function getPropertyValue(address _property) external view returns (uint256) {
837	 return getStoragePropertyValue(_property);
838	 }
839	 function addPropertyValue(address _property, uint256 _value) private {
840	 uint256 value = getStoragePropertyValue(_property);
841	 value = value.add(_value);
842	 setStoragePropertyValue(_property, value);
843	 }
844	 function subPropertyValue(address _property, uint256 _value) private {
845	 uint256 value = getStoragePropertyValue(_property);
846	 uint256 nextValue = value.sub(_value);
847	 setStoragePropertyValue(_property, nextValue);
848	 }
849	 function updatePendingInterestWithdrawal(address _property, address _user) private returns (RewardPrices memory _prices) {
850	 ( uint256 withdrawableAmount, RewardPrices memory prices ) = _calculateWithdrawableInterestAmount4Legacy(_property, _user);
851	 setStoragePendingInterestWithdrawal( _property, _user, withdrawableAmount );
852	 __updateLegacyWithdrawableInterestAmount(_property, _user);
853	 return prices;
854	 }
855	 function __legacyWithdrawableInterestAmount( address _property, address _user ) private view returns (uint256) {
856	 uint256 _last = getStorageLastInterestPrice(_property, _user);
857	 uint256 price = getStorageInterestPrice(_property);
858	 uint256 priceGap = price.sub(_last);
859	 uint256 lockedUpValue = getStorageValue(_property, _user);
860	 uint256 value = priceGap.mul(lockedUpValue);
861	 return value.divBasis();
862	 }
863	 function __updateLegacyWithdrawableInterestAmount( address _property, address _user ) private {
864	 uint256 interestPrice = getStorageInterestPrice(_property);
865	 if (getStorageLastInterestPrice(_property, _user) != interestPrice) {
866	 setStorageLastInterestPrice(_property, _user, interestPrice);
867	 }
868	 }
869	 function ___setFallbackInitialCumulativeHoldersRewardCap(uint256 _value) external onlyOwner {
870	 setStorageFallbackInitialCumulativeHoldersRewardCap(_value);
871	 }
872	 function migrateToSTokens(address _property) external returns (uint256 tokenId_) {
873	 uint256 amount = getStorageValue(_property, msg.sender);
874	 require(amount > 0, "not staked");
875	 uint256 price = getStorageLastStakedInterestPrice( _property, msg.sender );
876	 uint256 pending = getStoragePendingInterestWithdrawal( _property, msg.sender );
877	 setStoragePendingInterestWithdrawal(_property, msg.sender, 0);
878	 setStorageValue(_property, msg.sender, 0);
879	 ISTokensManager sTokenManagerInstance = ISTokensManager(sTokensManager);
880	 uint256 tokenId = sTokenManagerInstance.mint( msg.sender, _property, amount, price );
881	 bool result = sTokenManagerInstance.update( tokenId, amount, price, 0, pending );
882	 require(result, "failed to update");
883	 return tokenId;
884	 }
885	 }
