row number 
1	  pragma abicoder v2;
2	 pragma solidity ^0.7.0;
3	 interface IERC20 {
4	 function totalSupply() external view returns (uint256);
5	 function balanceOf(address account) external view returns (uint256);
6	 function transfer(address recipient, uint256 amount) external returns (bool);
7	 function allowance(address owner, address spender) external view returns (uint256);
8	 function approve(address spender, uint256 amount) external returns (bool);
9	 function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
10	 event Transfer(address indexed from, address indexed to, uint256 value);
11	 event Approval(address indexed owner, address indexed spender, uint256 value);
12	 }
13	 pragma solidity 0.7.6;
14	 interface IPopsicleV3Optimizer {
15	 function token0() external view returns (address);
16	 function token1() external view returns (address);
17	 function tickSpacing() external view returns (int24);
18	 function pool() external view returns (IUniswapV3Pool);
19	 function tickLower() external view returns (int24);
20	 function tickUpper() external view returns (int24);
21	 function deposit(uint256 amount0Desired, uint256 amount1Desired, address to) external payable returns (uint256 shares, uint256 amount0,uint256 amount1);
22	 function withdraw(uint256 shares, address to) external returns (uint256 amount0, uint256 amount1);
23	 function rerange() external payable;
24	 function rebalance() external payable;
25	 }
26	 pragma solidity 0.7.6;
27	 interface IOptimizerStrategy {
28	 function maxTotalSupply() external view returns (uint256);
29	 function twapDuration() external view returns (uint32);
30	 function maxTwapDeviation() external view returns (int24);
31	 function tickRangeMultiplier() external view returns (int24);
32	 function priceImpactPercentage() external view returns (uint24);
33	 }
34	 pragma solidity >=0.5.0;
35	 library PositionKey {
36	 function compute( address owner, int24 tickLower, int24 tickUpper ) internal pure returns (bytes32) {
37	 return keccak256(abi.encodePacked(owner, tickLower, tickUpper));
38	 }
39	 }
40	 pragma solidity >=0.5.0;
41	 library TickMath {
42	 int24 internal constant MIN_TICK = -887272;
43	 int24 internal constant MAX_TICK = -MIN_TICK;
44	 uint160 internal constant MIN_SQRT_RATIO = 4295128739;
45	 uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;
46	 function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {
47	 uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));
48	 require(absTick <= uint256(MAX_TICK), 'T');
49	 uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;
50	 if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;
51	 if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;
52	 if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;
53	 if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;
54	 if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;
55	 if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;
56	 if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;
57	 if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;
58	 if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;
59	 if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;
60	 if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;
61	 if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;
62	 if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;
63	 if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;
64	 if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;
65	 if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;
66	 if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;
67	 if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;
68	 if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;
69	 if (tick > 0) ratio = type(uint256).max / ratio;
70	 sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));
71	 }
72	 function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {
73	 require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');
74	 uint256 ratio = uint256(sqrtPriceX96) << 32;
75	 uint256 r = ratio;
76	 uint256 msb = 0;
77	 assembly {
78	 let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) msb := or(msb, f) r := shr(f, r) }
79	 assembly {
80	 let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF)) msb := or(msb, f) r := shr(f, r) }
81	 assembly {
82	 let f := shl(5, gt(r, 0xFFFFFFFF)) msb := or(msb, f) r := shr(f, r) }
83	 assembly {
84	 let f := shl(4, gt(r, 0xFFFF)) msb := or(msb, f) r := shr(f, r) }
85	 assembly {
86	 let f := shl(3, gt(r, 0xFF)) msb := or(msb, f) r := shr(f, r) }
87	 assembly {
88	 let f := shl(2, gt(r, 0xF)) msb := or(msb, f) r := shr(f, r) }
89	 assembly {
90	 let f := shl(1, gt(r, 0x3)) msb := or(msb, f) r := shr(f, r) }
91	 assembly {
92	 let f := gt(r, 0x1) msb := or(msb, f) }
93	 if (msb >= 128) r = ratio >> (msb - 127);
94	 else r = ratio << (127 - msb);
95	 int256 log_2 = (int256(msb) - 128) << 64;
96	 assembly {
97	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(63, f)) r := shr(f, r) }
98	 assembly {
99	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(62, f)) r := shr(f, r) }
100	 assembly {
101	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(61, f)) r := shr(f, r) }
102	 assembly {
103	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(60, f)) r := shr(f, r) }
104	 assembly {
105	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(59, f)) r := shr(f, r) }
106	 assembly {
107	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(58, f)) r := shr(f, r) }
108	 assembly {
109	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(57, f)) r := shr(f, r) }
110	 assembly {
111	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(56, f)) r := shr(f, r) }
112	 assembly {
113	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(55, f)) r := shr(f, r) }
114	 assembly {
115	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(54, f)) r := shr(f, r) }
116	 assembly {
117	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(53, f)) r := shr(f, r) }
118	 assembly {
119	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(52, f)) r := shr(f, r) }
120	 assembly {
121	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(51, f)) r := shr(f, r) }
122	 assembly {
123	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(50, f)) }
124	 int256 log_sqrt10001 = log_2 * 255738958999603826347141;
125	 int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);
126	 int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);
127	 tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;
128	 }
129	 }
130	 pragma solidity >=0.5.0;
131	 library LiquidityAmounts {
132	 function toUint128(uint256 x) private pure returns (uint128 y) {
133	 require((y = uint128(x)) == x);
134	 }
135	 function getLiquidityForAmount0( uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint256 amount0 ) internal pure returns (uint128 liquidity) {
136	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
137	 uint256 intermediate = FullMath.mulDiv(sqrtRatioAX96, sqrtRatioBX96, FixedPoint96.Q96);
138	 return toUint128(FullMath.mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));
139	 }
140	 function getLiquidityForAmount1( uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint256 amount1 ) internal pure returns (uint128 liquidity) {
141	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
142	 return toUint128(FullMath.mulDiv(amount1, FixedPoint96.Q96, sqrtRatioBX96 - sqrtRatioAX96));
143	 }
144	 function getLiquidityForAmounts( uint160 sqrtRatioX96, uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint256 amount0, uint256 amount1 ) internal pure returns (uint128 liquidity) {
145	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
146	 if (sqrtRatioX96 <= sqrtRatioAX96) {
147	 liquidity = getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);
148	 }
149	 else if (sqrtRatioX96 < sqrtRatioBX96) {
150	 uint128 liquidity0 = getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);
151	 uint128 liquidity1 = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);
152	 liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;
153	 }
154	 else {
155	 liquidity = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);
156	 }
157	 }
158	 function getAmount0ForLiquidity( uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity ) internal pure returns (uint256 amount0) {
159	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
160	 return FullMath.mulDiv( uint256(liquidity) << FixedPoint96.RESOLUTION, sqrtRatioBX96 - sqrtRatioAX96, sqrtRatioBX96 ) / sqrtRatioAX96;
161	 }
162	 function getAmount1ForLiquidity( uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity ) internal pure returns (uint256 amount1) {
163	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
164	 return FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);
165	 }
166	 function getAmountsForLiquidity( uint160 sqrtRatioX96, uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity ) internal pure returns (uint256 amount0, uint256 amount1) {
167	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
168	 if (sqrtRatioX96 <= sqrtRatioAX96) {
169	 amount0 = getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);
170	 }
171	 else if (sqrtRatioX96 < sqrtRatioBX96) {
172	 amount0 = getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);
173	 amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);
174	 }
175	 else {
176	 amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);
177	 }
178	 }
179	 }
180	 pragma solidity >=0.5.0;
181	 library PoolVariables {
182	 using LowGasSafeMath for uint256;
183	 struct Info {
184	 uint256 amount0Desired;
185	 uint256 amount1Desired;
186	 uint256 amount0;
187	 uint256 amount1;
188	 uint128 liquidity;
189	 int24 tickLower;
190	 int24 tickUpper;
191	 }
192	 function amountsForLiquidity( IUniswapV3Pool pool, uint128 liquidity, int24 _tickLower, int24 _tickUpper ) internal view returns (uint256, uint256) {
193	 (uint160 sqrtRatioX96, , , , , , ) = pool.slot0();
194	 return LiquidityAmounts.getAmountsForLiquidity( sqrtRatioX96, TickMath.getSqrtRatioAtTick(_tickLower), TickMath.getSqrtRatioAtTick(_tickUpper), liquidity );
195	 }
196	 function liquidityForAmounts( IUniswapV3Pool pool, uint256 amount0, uint256 amount1, int24 _tickLower, int24 _tickUpper ) internal view returns (uint128) {
197	 (uint160 sqrtRatioX96, , , , , , ) = pool.slot0();
198	 return LiquidityAmounts.getLiquidityForAmounts( sqrtRatioX96, TickMath.getSqrtRatioAtTick(_tickLower), TickMath.getSqrtRatioAtTick(_tickUpper), amount0, amount1 );
199	 }
200	 function positionAmounts(IUniswapV3Pool pool, int24 _tickLower, int24 _tickUpper) internal view returns (uint256 amount0, uint256 amount1) {
201	 bytes32 positionKey = PositionKey.compute(address(this), _tickLower, _tickUpper);
202	 (uint128 liquidity, , , uint128 tokensOwed0, uint128 tokensOwed1) = pool.positions(positionKey);
203	 (amount0, amount1) = amountsForLiquidity(pool, liquidity, _tickLower, _tickUpper);
204	 amount0 = amount0.add(uint256(tokensOwed0));
205	 amount1 = amount1.add(uint256(tokensOwed1));
206	 }
207	 function positionLiquidity(IUniswapV3Pool pool, int24 _tickLower, int24 _tickUpper) internal view returns (uint128 liquidity) {
208	 bytes32 positionKey = PositionKey.compute(address(this), _tickLower, _tickUpper);
209	 (liquidity, , , , ) = pool.positions(positionKey);
210	 }
211	 function checkRange(int24 tickLower, int24 tickUpper) internal pure {
212	 require(tickLower < tickUpper, "TLU");
213	 require(tickLower >= TickMath.MIN_TICK, "TLM");
214	 require(tickUpper <= TickMath.MAX_TICK, "TUM");
215	 }
216	 function floor(int24 tick, int24 tickSpacing) internal pure returns (int24) {
217	 int24 compressed = tick / tickSpacing;
218	 if (tick < 0 && tick % tickSpacing != 0) compressed--;
219	 return compressed * tickSpacing;
220	 }
221	 function getPositionTicks(IUniswapV3Pool pool, uint256 amount0Desired, uint256 amount1Desired, int24 baseThreshold, int24 tickSpacing) internal view returns(int24 tickLower, int24 tickUpper) {
222	 Info memory cache = Info(amount0Desired, amount1Desired, 0, 0, 0, 0, 0);
223	 ( uint160 sqrtPriceX96, int24 currentTick, , , , , ) = pool.slot0();
224	 (cache.tickLower, cache.tickUpper) = baseTicks(currentTick, baseThreshold, tickSpacing);
225	 (cache.amount0, cache.amount1) = amountsForTicks(pool, cache.amount0Desired, cache.amount1Desired, cache.tickLower, cache.tickUpper);
226	 cache.liquidity = liquidityForAmounts(pool, cache.amount0, cache.amount1, cache.tickLower, cache.tickUpper);
227	 bool zeroGreaterOne = amountsDirection(cache.amount0Desired, cache.amount1Desired, cache.amount0, cache.amount1);
228	 if ( zeroGreaterOne) {
229	 uint160 nextSqrtPrice0 = SqrtPriceMath.getNextSqrtPriceFromAmount0RoundingUp(sqrtPriceX96, cache.liquidity, cache.amount0Desired, false);
230	 cache.tickUpper = PoolVariables.floor(TickMath.getTickAtSqrtRatio(nextSqrtPrice0), tickSpacing);
231	 }
232	 else{
233	 uint160 nextSqrtPrice1 = SqrtPriceMath.getNextSqrtPriceFromAmount1RoundingDown(sqrtPriceX96, cache.liquidity, cache.amount1Desired, false);
234	 cache.tickLower = PoolVariables.floor(TickMath.getTickAtSqrtRatio(nextSqrtPrice1), tickSpacing);
235	 }
236	 checkRange(cache.tickLower, cache.tickUpper);
237	 tickLower = cache.tickLower;
238	 tickUpper = cache.tickUpper;
239	 }
240	 function amountsForTicks(IUniswapV3Pool pool, uint256 amount0Desired, uint256 amount1Desired, int24 _tickLower, int24 _tickUpper) internal view returns(uint256 amount0, uint256 amount1) {
241	 uint128 liquidity = liquidityForAmounts(pool, amount0Desired, amount1Desired, _tickLower, _tickUpper);
242	 (amount0, amount1) = amountsForLiquidity(pool, liquidity, _tickLower, _tickUpper);
243	 }
244	 function baseTicks(int24 currentTick, int24 baseThreshold, int24 tickSpacing) internal pure returns(int24 tickLower, int24 tickUpper) {
245	 int24 tickFloor = floor(currentTick, tickSpacing);
246	 tickLower = tickFloor - baseThreshold;
247	 tickUpper = tickFloor + baseThreshold;
248	 }
249	 function amountsDirection(uint256 amount0Desired, uint256 amount1Desired, uint256 amount0, uint256 amount1) internal pure returns (bool zeroGreaterOne) {
250	 zeroGreaterOne = amount0Desired.sub(amount0).mul(amount1Desired) > amount1Desired.sub(amount1).mul(amount0Desired) ? true : false;
251	 }
252	 function checkDeviation(IUniswapV3Pool pool, int24 maxTwapDeviation, uint32 twapDuration) internal view {
253	 (, int24 currentTick, , , , , ) = pool.slot0();
254	 int24 twap = getTwap(pool, twapDuration);
255	 int24 deviation = currentTick > twap ? currentTick - twap : twap - currentTick;
256	 require(deviation <= maxTwapDeviation, "PSC");
257	 }
258	 function getTwap(IUniswapV3Pool pool, uint32 twapDuration) internal view returns (int24) {
259	 uint32 _twapDuration = twapDuration;
260	 uint32[] memory secondsAgo = new uint32[](2);
261	 secondsAgo[0] = _twapDuration;
262	 secondsAgo[1] = 0;
263	 (int56[] memory tickCumulatives, ) = pool.observe(secondsAgo);
264	 return int24((tickCumulatives[1] - tickCumulatives[0]) / _twapDuration);
265	 }
266	 }
267	 pragma solidity >=0.5.0;
268	 interface IUniswapV3PoolActions {
269	 function mint( address recipient, int24 tickLower, int24 tickUpper, uint128 amount, bytes calldata data ) external returns (uint256 amount0, uint256 amount1);
270	 function collect( address recipient, int24 tickLower, int24 tickUpper, uint128 amount0Requested, uint128 amount1Requested ) external returns (uint128 amount0, uint128 amount1);
271	 function burn( int24 tickLower, int24 tickUpper, uint128 amount ) external returns (uint256 amount0, uint256 amount1);
272	 function swap( address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes calldata data ) external returns (int256 amount0, int256 amount1);
273	 }
274	 pragma solidity >=0.5.0;
275	 interface IUniswapV3PoolDerivedState {
276	 function observe(uint32[] calldata secondsAgos) external view returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);
277	 }
278	 pragma solidity >=0.5.0;
279	 interface IUniswapV3PoolState {
280	 function slot0() external view returns ( uint160 sqrtPriceX96, int24 tick, uint16 observationIndex, uint16 observationCardinality, uint16 observationCardinalityNext, uint8 feeProtocol, bool unlocked );
281	 function positions(bytes32 key) external view returns ( uint128 _liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, uint128 tokensOwed0, uint128 tokensOwed1 );
282	 }
283	 pragma solidity >=0.5.0;
284	 interface IUniswapV3PoolImmutables {
285	 function token0() external view returns (address);
286	 function token1() external view returns (address);
287	 function tickSpacing() external view returns (int24);
288	 }
289	 pragma solidity >=0.5.0;
290	 interface IUniswapV3Pool is IUniswapV3PoolImmutables, IUniswapV3PoolState, IUniswapV3PoolDerivedState, IUniswapV3PoolActions {
291	 }
292	 pragma solidity 0.7.6;
293	 library PoolActions {
294	 using PoolVariables for IUniswapV3Pool;
295	 using LowGasSafeMath for uint256;
296	 using SafeCast for uint256;
297	 function burnLiquidityShare( IUniswapV3Pool pool, int24 tickLower, int24 tickUpper, uint256 totalSupply, uint256 share, address to, uint128 protocolLiquidity ) internal returns (uint256 amount0, uint256 amount1) {
298	 require(totalSupply > 0, "TS");
299	 uint128 liquidityInPool = pool.positionLiquidity(tickLower, tickUpper);
300	 uint256 liquidity = uint256(liquidityInPool).sub(protocolLiquidity).mul(share) / totalSupply;
301	 if (liquidity > 0) {
302	 (amount0, amount1) = pool.burn(tickLower, tickUpper, liquidity.toUint128());
303	 if (amount0 > 0 || amount1 > 0) {
304	 (amount0, amount1) = pool.collect( to, tickLower, tickUpper, amount0.toUint128(), amount1.toUint128() );
305	 }
306	 }
307	 }
308	 function burnExactLiquidity( IUniswapV3Pool pool, int24 tickLower, int24 tickUpper, uint128 liquidity, address to ) internal returns (uint256 amount0, uint256 amount1) {
309	 uint128 liquidityInPool = pool.positionLiquidity(tickLower, tickUpper);
310	 require(liquidityInPool >= liquidity, "TML");
311	 (amount0, amount1) = pool.burn(tickLower, tickUpper, liquidity);
312	 if (amount0 > 0 || amount1 > 0) {
313	 (amount0, amount0) = pool.collect( to, tickLower, tickUpper, amount0.toUint128(), amount1.toUint128() );
314	 }
315	 }
316	 function burnAllLiquidity( IUniswapV3Pool pool, int24 tickLower, int24 tickUpper ) internal {
317	 uint128 liquidity = pool.positionLiquidity(tickLower, tickUpper);
318	 if (liquidity > 0) {
319	 pool.burn(tickLower, tickUpper, liquidity);
320	 }
321	 pool.collect( address(this), tickLower, tickUpper, type(uint128).max, type(uint128).max );
322	 }
323	 }
324	 pragma solidity >=0.4.0;
325	 library Babylonian {
326	 function sqrt(uint256 x) internal pure returns (uint256) {
327	 if (x == 0) return 0;
328	 uint256 xx = x;
329	 uint256 r = 1;
330	 if (xx >= 0x100000000000000000000000000000000) {
331	 xx >>= 128;
332	 r <<= 64;
333	 }
334	 if (xx >= 0x10000000000000000) {
335	 xx >>= 64;
336	 r <<= 32;
337	 }
338	 if (xx >= 0x100000000) {
339	 xx >>= 32;
340	 r <<= 16;
341	 }
342	 if (xx >= 0x10000) {
343	 xx >>= 16;
344	 r <<= 8;
345	 }
346	 if (xx >= 0x100) {
347	 xx >>= 8;
348	 r <<= 4;
349	 }
350	 if (xx >= 0x10) {
351	 xx >>= 4;
352	 r <<= 2;
353	 }
354	 if (xx >= 0x8) {
355	 r <<= 1;
356	 }
357	 r = (r + x / r) >> 1;
358	 r = (r + x / r) >> 1;
359	 r = (r + x / r) >> 1;
360	 r = (r + x / r) >> 1;
361	 r = (r + x / r) >> 1;
362	 r = (r + x / r) >> 1;
363	 r = (r + x / r) >> 1;
364	 uint256 r1 = x / r;
365	 return (r < r1 ? r : r1);
366	 }
367	 }
368	 pragma solidity ^0.7.0;
369	 library Counters {
370	 using LowGasSafeMath for uint256;
371	 struct Counter {
372	 uint256 _value;
373	 }
374	 function current(Counter storage counter) internal view returns (uint256) {
375	 return counter._value;
376	 }
377	 function increment(Counter storage counter) internal {
378	 counter._value += 1;
379	 }
380	 }
381	 pragma solidity >=0.7.0;
382	 library ChainId {
383	 function get() internal pure returns (uint256 chainId) {
384	 assembly {
385	 chainId := chainid() }
386	 }
387	 }
388	 pragma solidity =0.7.6;
389	 library ECDSA {
390	 function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {
391	 require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, "ISS");
392	 require(v == 27 || v == 28, "ISV");
393	 address signer = ecrecover(hash, v, r, s);
394	 require(signer != address(0), "IS");
395	 return signer;
396	 }
397	 function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {
398	 return keccak256(abi.encodePacked("\x19\x01", domainSeparator, structHash));
399	 }
400	 }
401	 pragma solidity =0.7.6;
402	 abstract contract EIP712 {
403	 bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;
404	 uint256 private immutable _CACHED_CHAIN_ID;
405	 bytes32 private immutable _HASHED_NAME;
406	 bytes32 private immutable _HASHED_VERSION;
407	 bytes32 private immutable _TYPE_HASH;
408	 constructor(string memory name, string memory version) {
409	 bytes32 hashedName = keccak256(bytes(name));
410	 bytes32 hashedVersion = keccak256(bytes(version));
411	 bytes32 typeHash = keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");
412	 _HASHED_NAME = hashedName;
413	 _HASHED_VERSION = hashedVersion;
414	 _CACHED_CHAIN_ID = ChainId.get();
415	 _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);
416	 _TYPE_HASH = typeHash;
417	 }
418	 function _domainSeparatorV4() internal view returns (bytes32) {
419	 if (ChainId.get() == _CACHED_CHAIN_ID) {
420	 return _CACHED_DOMAIN_SEPARATOR;
421	 }
422	 else {
423	 return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);
424	 }
425	 }
426	 function _buildDomainSeparator(bytes32 typeHash, bytes32 name, bytes32 version) private view returns (bytes32) {
427	 return keccak256( abi.encode( typeHash, name, version, ChainId.get(), address(this) ) );
428	 }
429	 function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {
430	 return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);
431	 }
432	 }
433	 pragma solidity >=0.6.0 <0.8.0;
434	 interface IERC20Permit {
435	 function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;
436	 function nonces(address owner) external view returns (uint256);
437	 function DOMAIN_SEPARATOR() external view returns (bytes32);
438	 }
439	 pragma solidity >=0.6.0 <0.8.0;
440	 abstract contract Context {
441	 function _msgSender() internal view virtual returns (address payable) {
442	 return msg.sender;
443	 }
444	 function _msgData() internal view virtual returns (bytes memory) {
445	 this;
446	 return msg.data;
447	 }
448	 }
449	 pragma solidity ^0.7.0;
450	 contract ERC20 is Context, IERC20 {
451	 using LowGasSafeMath for uint256;
452	 mapping (address => uint256) private _balances;
453	 mapping (address => mapping (address => uint256)) private _allowances;
454	 uint256 private _totalSupply;
455	 string private _name;
456	 string private _symbol;
457	 uint8 private _decimals;
458	 constructor (string memory name_, string memory symbol_) {
459	 _name = name_;
460	 _symbol = symbol_;
461	 _decimals = 18;
462	 }
463	 function name() public view virtual returns (string memory) {
464	 return _name;
465	 }
466	 function symbol() public view virtual returns (string memory) {
467	 return _symbol;
468	 }
469	 function decimals() public view virtual returns (uint8) {
470	 return _decimals;
471	 }
472	 function totalSupply() public view virtual override returns (uint256) {
473	 return _totalSupply;
474	 }
475	 function balanceOf(address account) public view virtual override returns (uint256) {
476	 return _balances[account];
477	 }
478	 function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
479	 _transfer(_msgSender(), recipient, amount);
480	 return true;
481	 }
482	 function allowance(address owner, address spender) public view virtual override returns (uint256) {
483	 return _allowances[owner][spender];
484	 }
485	 function approve(address spender, uint256 amount) public virtual override returns (bool) {
486	 _approve(_msgSender(), spender, amount);
487	 return true;
488	 }
489	 function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
490	 _transfer(sender, recipient, amount);
491	 _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "TEA"));
492	 return true;
493	 }
494	 function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
495	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
496	 return true;
497	 }
498	 function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
499	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "DEB"));
500	 return true;
501	 }
502	 function _transfer(address sender, address recipient, uint256 amount) internal virtual {
503	 require(sender != address(0), "FZA");
504	 require(recipient != address(0), "TZA");
505	 _beforeTokenTransfer(sender, recipient, amount);
506	 _balances[sender] = _balances[sender].sub(amount, "TEB");
507	 _balances[recipient] = _balances[recipient].add(amount);
508	 emit Transfer(sender, recipient, amount);
509	 }
510	 function _mint(address account, uint256 amount) internal virtual {
511	 require(account != address(0), "MZA");
512	 _beforeTokenTransfer(address(0), account, amount);
513	 _totalSupply = _totalSupply.add(amount);
514	 _balances[account] = _balances[account].add(amount);
515	 emit Transfer(address(0), account, amount);
516	 }
517	 function _burn(address account, uint256 amount) internal virtual {
518	 require(account != address(0), "BZA");
519	 _beforeTokenTransfer(account, address(0), amount);
520	 _balances[account] = _balances[account].sub(amount, "BEB");
521	 _totalSupply = _totalSupply.sub(amount);
522	 emit Transfer(account, address(0), amount);
523	 }
524	 function _approve(address owner, address spender, uint256 amount) internal virtual {
525	 require(owner != address(0), "AFZA");
526	 require(spender != address(0), "ATZA");
527	 _allowances[owner][spender] = amount;
528	 emit Approval(owner, spender, amount);
529	 }
530	 function _setupDecimals(uint8 decimals_) internal virtual {
531	 _decimals = decimals_;
532	 }
533	 function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {
534	 }
535	 }
536	 pragma solidity =0.7.6;
537	 abstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {
538	 using Counters for Counters.Counter;
539	 mapping (address => Counters.Counter) private _nonces;
540	 bytes32 private immutable _PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;
541	 constructor(string memory name) EIP712(name, "1") {
542	 }
543	 function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public virtual override {
544	 require(block.timestamp <= deadline, "ED");
545	 bytes32 structHash = keccak256( abi.encode( _PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline ) );
546	 bytes32 hash = _hashTypedDataV4(structHash);
547	 address signer = ECDSA.recover(hash, v, r, s);
548	 require(signer == owner, "IS");
549	 _approve(owner, spender, value);
550	 }
551	 function nonces(address owner) public view virtual override returns (uint256) {
552	 return _nonces[owner].current();
553	 }
554	 function DOMAIN_SEPARATOR() external view override returns (bytes32) {
555	 return _domainSeparatorV4();
556	 }
557	 function _useNonce(address owner) internal virtual returns (uint256 current) {
558	 Counters.Counter storage nonce = _nonces[owner];
559	 current = nonce.current();
560	 nonce.increment();
561	 }
562	 }
563	 pragma solidity >=0.4.0;
564	 library FixedPoint96 {
565	 uint8 internal constant RESOLUTION = 96;
566	 uint256 internal constant Q96 = 0x1000000000000000000000000;
567	 }
568	 pragma solidity >=0.5.0;
569	 library UnsafeMath {
570	 function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {
571	 assembly {
572	 z := add(div(x, y), gt(mod(x, y), 0)) }
573	 }
574	 function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {
575	 assembly {
576	 z := div(x, y) }
577	 }
578	 }
579	 pragma solidity >=0.4.0;
580	 library FullMath {
581	 function mulDiv( uint256 a, uint256 b, uint256 denominator ) internal pure returns (uint256 result) {
582	 uint256 prod0;
583	 uint256 prod1;
584	 assembly {
585	 let mm := mulmod(a, b, not(0)) prod0 := mul(a, b) prod1 := sub(sub(mm, prod0), lt(mm, prod0)) }
586	 if (prod1 == 0) {
587	 require(denominator > 0);
588	 assembly {
589	 result := div(prod0, denominator) }
590	 return result;
591	 }
592	 require(denominator > prod1);
593	 uint256 remainder;
594	 assembly {
595	 remainder := mulmod(a, b, denominator) }
596	 assembly {
597	 prod1 := sub(prod1, gt(remainder, prod0)) prod0 := sub(prod0, remainder) }
598	 uint256 twos = -denominator & denominator;
599	 assembly {
600	 denominator := div(denominator, twos) }
601	 assembly {
602	 prod0 := div(prod0, twos) }
603	 assembly {
604	 twos := add(div(sub(0, twos), twos), 1) }
605	 prod0 |= prod1 * twos;
606	 uint256 inv = (3 * denominator) ^ 2;
607	 inv *= 2 - denominator * inv;
608	 inv *= 2 - denominator * inv;
609	 inv *= 2 - denominator * inv;
610	 inv *= 2 - denominator * inv;
611	 inv *= 2 - denominator * inv;
612	 inv *= 2 - denominator * inv;
613	 result = prod0 * inv;
614	 return result;
615	 }
616	 function mulDivRoundingUp( uint256 a, uint256 b, uint256 denominator ) internal pure returns (uint256 result) {
617	 result = mulDiv(a, b, denominator);
618	 if (mulmod(a, b, denominator) > 0) {
619	 require(result < type(uint256).max);
620	 result++;
621	 }
622	 }
623	 }
624	 pragma solidity >=0.5.0;
625	 library SafeCast {
626	 function toUint160(uint256 y) internal pure returns (uint160 z) {
627	 require((z = uint160(y)) == y);
628	 }
629	 function toUint128(uint256 y) internal pure returns (uint128 z) {
630	 require((z = uint128(y)) == y);
631	 }
632	 function toInt128(int256 y) internal pure returns (int128 z) {
633	 require((z = int128(y)) == y);
634	 }
635	 function toInt256(uint256 y) internal pure returns (int256 z) {
636	 require(y < 2**255);
637	 z = int256(y);
638	 }
639	 }
640	 pragma solidity >=0.7.0;
641	 library LowGasSafeMath {
642	 function add(uint256 x, uint256 y) internal pure returns (uint256 z) {
643	 require((z = x + y) >= x);
644	 }
645	 function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {
646	 require((z = x - y) <= x);
647	 }
648	 function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {
649	 require(x == 0 || (z = x * y) / x == y);
650	 }
651	 function sub(uint256 x, uint256 y, string memory errorMessage) internal pure returns (uint256 z) {
652	 require((z = x - y) <= x, errorMessage);
653	 }
654	 function add(int256 x, int256 y) internal pure returns (int256 z) {
655	 require((z = x + y) >= x == (y >= 0));
656	 }
657	 function sub(int256 x, int256 y) internal pure returns (int256 z) {
658	 require((z = x - y) <= x == (y >= 0));
659	 }
660	 function add128(uint128 x, uint128 y) internal pure returns (uint128 z) {
661	 require((z = x + y) >= x);
662	 }
663	 function sub128(uint128 x, uint128 y) internal pure returns (uint128 z) {
664	 require((z = x - y) <= x);
665	 }
666	 function mul128(uint128 x, uint128 y) internal pure returns (uint128 z) {
667	 require(x == 0 || (z = x * y) / x == y);
668	 }
669	 function add160(uint160 x, uint160 y) internal pure returns (uint160 z) {
670	 require((z = x + y) >= x);
671	 }
672	 function sub160(uint160 x, uint160 y) internal pure returns (uint160 z) {
673	 require((z = x - y) <= x);
674	 }
675	 function mul160(uint160 x, uint160 y) internal pure returns (uint160 z) {
676	 require(x == 0 || (z = x * y) / x == y);
677	 }
678	 }
679	 pragma solidity >=0.5.0;
680	 library SqrtPriceMath {
681	 using LowGasSafeMath for uint256;
682	 using SafeCast for uint256;
683	 function getNextSqrtPriceFromAmount0RoundingUp( uint160 sqrtPX96, uint128 liquidity, uint256 amount, bool add ) internal pure returns (uint160) {
684	 if (amount == 0) return sqrtPX96;
685	 uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;
686	 if (add) {
687	 uint256 product;
688	 if ((product = amount * sqrtPX96) / amount == sqrtPX96) {
689	 uint256 denominator = numerator1 + product;
690	 if (denominator >= numerator1) return uint160(FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator));
691	 }
692	 return uint160(UnsafeMath.divRoundingUp(numerator1, (numerator1 / sqrtPX96).add(amount)));
693	 }
694	 else {
695	 uint256 product;
696	 require((product = amount * sqrtPX96) / amount == sqrtPX96 && numerator1 > product);
697	 uint256 denominator = numerator1 - product;
698	 return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator).toUint160();
699	 }
700	 }
701	 function getNextSqrtPriceFromAmount1RoundingDown( uint160 sqrtPX96, uint128 liquidity, uint256 amount, bool add ) internal pure returns (uint160) {
702	 if (add) {
703	 uint256 quotient = ( amount <= type(uint160).max ? (amount << FixedPoint96.RESOLUTION) / liquidity : FullMath.mulDiv(amount, FixedPoint96.Q96, liquidity) );
704	 return uint256(sqrtPX96).add(quotient).toUint160();
705	 }
706	 else {
707	 uint256 quotient = ( amount <= type(uint160).max ? UnsafeMath.divRoundingUp(amount << FixedPoint96.RESOLUTION, liquidity) : FullMath.mulDivRoundingUp(amount, FixedPoint96.Q96, liquidity) );
708	 require(sqrtPX96 > quotient);
709	 return uint160(sqrtPX96 - quotient);
710	 }
711	 }
712	 }
713	 pragma solidity >=0.6.0;
714	 library TransferHelper {
715	 function safeTransferFrom( address token, address from, address to, uint256 value ) internal {
716	 (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));
717	 require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');
718	 }
719	 function safeTransfer( address token, address to, uint256 value ) internal {
720	 (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));
721	 require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');
722	 }
723	 function safeTransferETH(address to, uint256 value) internal {
724	 (bool success, ) = to.call{
725	 value: value}
726	 (new bytes(0));
727	 require(success, 'STE');
728	 }
729	 }
730	 pragma solidity ^0.7.0;
731	 abstract contract ReentrancyGuard {
732	 uint256 private constant _NOT_ENTERED = 1;
733	 uint256 private constant _ENTERED = 2;
734	 uint256 private _status;
735	 constructor () {
736	 _status = _NOT_ENTERED;
737	 }
738	 modifier nonReentrant() {
739	 require(_status != _ENTERED, "RC");
740	 _status = _ENTERED;
741	 _;
742	 _status = _NOT_ENTERED;
743	 }
744	 }
745	 pragma solidity =0.7.6;
746	 interface IWETH9 is IERC20 {
747	 function deposit() external payable;
748	 }
749	 pragma solidity 0.7.6;
750	 contract PopsicleV3Optimizer is ERC20Permit, ReentrancyGuard, IPopsicleV3Optimizer {
751	 using LowGasSafeMath for uint256;
752	 using LowGasSafeMath for uint160;
753	 using LowGasSafeMath for uint128;
754	 using UnsafeMath for uint256;
755	 using SafeCast for uint256;
756	 using PoolVariables for IUniswapV3Pool;
757	 using PoolActions for IUniswapV3Pool;
758	 struct MintCallbackData {
759	 address payer;
760	 }
761	 struct SwapCallbackData {
762	 bool zeroForOne;
763	 }
764	 event Deposit( address indexed sender, uint256 liquidity, uint256 amount0, uint256 amount1 );
765	 event Withdraw( address indexed sender, uint256 shares, uint256 amount0, uint256 amount1, uint256 fee0, uint256 fee1 );
766	 event CollectFees( uint256 feesFromPool0, uint256 feesFromPool1, uint256 usersFees0, uint256 usersFees1 );
767	 event CompoundFees( uint256 amount0, uint256 amount1 );
768	 event Rerange( int24 tickLower, int24 tickUpper, uint256 amount0, uint256 amount1 );
769	 event RewardPaid( address indexed sender, uint256 fees0, uint256 fees1 );
770	 event Snapshot(uint256 totalAmount0, uint256 totalAmount1);
771	 event TransferGovernance(address indexed previousGovernance, address indexed newGovernance);
772	 modifier onlyGovernance {
773	 require(msg.sender == governance, "OG");
774	 _;
775	 }
776	 address public immutable override token0;
777	 address public immutable override token1;
778	 address public constant weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
779	 int24 public immutable override tickSpacing;
780	 uint24 constant GLOBAL_DIVISIONER = 1e6;
781	 uint24 constant protocolFee = 1e5;
782	 mapping (address => bool) private _operatorApproved;
783	 IUniswapV3Pool public override pool;
784	 uint256 public protocolFees0;
785	 uint256 public protocolFees1;
786	 uint256 public totalFees0;
787	 uint256 public totalFees1;
788	 address public governance;
789	 address public pendingGovernance;
790	 address public strategy;
791	 int24 public override tickLower;
792	 int24 public override tickUpper;
793	 bool public initialized;
794	 bool private _paused = false;
795	 constructor( address _pool, address _strategy ) ERC20("Popsicle LP V3 USDT/WETH", "PLP") ERC20Permit("Popsicle LP V3 USDT/WETH") {
796	 pool = IUniswapV3Pool(_pool);
797	 strategy = _strategy;
798	 token0 = pool.token0();
799	 token1 = pool.token1();
800	 tickSpacing = pool.tickSpacing();
801	 governance = msg.sender;
802	 _operatorApproved[msg.sender] = true;
803	 }
804	 function init() external onlyGovernance {
805	 require(!initialized, "F");
806	 initialized = true;
807	 int24 baseThreshold = tickSpacing * IOptimizerStrategy(strategy).tickRangeMultiplier();
808	 ( , int24 currentTick, , , , , ) = pool.slot0();
809	 int24 tickFloor = PoolVariables.floor(currentTick, tickSpacing);
810	 tickLower = tickFloor - baseThreshold;
811	 tickUpper = tickFloor + baseThreshold;
812	 PoolVariables.checkRange(tickLower, tickUpper);
813	 }
814	 function deposit( uint256 amount0Desired, uint256 amount1Desired, address to ) external payable override nonReentrant checkDeviation whenNotPaused returns ( uint256 shares, uint256 amount0, uint256 amount1 ) {
815	 require(amount0Desired > 0 && amount1Desired > 0, "ANV");
816	 _earnFees();
817	 uint128 liquidityLast = pool.positionLiquidity(tickLower, tickUpper);
818	 uint128 liquidity = pool.liquidityForAmounts(amount0Desired, amount1Desired, tickLower, tickUpper);
819	 (amount0, amount1) = pool.mint( address(this), tickLower, tickUpper, liquidity, abi.encode(MintCallbackData({
820	 payer: msg.sender}
821	 )));
822	 shares = _calcShare(liquidity, liquidityLast);
823	 _mint(to, shares);
824	 require(IOptimizerStrategy(strategy).maxTotalSupply() >= totalSupply(), "MTS");
825	 refundETH();
826	 _compoundFees();
827	 emit Deposit(msg.sender, shares, amount0, amount1);
828	 }
829	 function withdraw( uint256 shares, address to ) external override nonReentrant checkDeviation whenNotPaused returns ( uint256 amount0, uint256 amount1 ) {
830	 require(shares > 0, "S");
831	 require(to != address(0), "WZA");
832	 (uint256 collect0, uint256 collect1) = _earnFees();
833	 uint128 protocolLiquidity = pool.liquidityForAmounts(protocolFees0, protocolFees1, tickLower, tickUpper);
834	 (amount0, amount1) = pool.burnLiquidityShare(tickLower, tickUpper, totalSupply(), shares, to, protocolLiquidity);
835	 uint256 userFees0 = collect0.mul(shares) / totalSupply();
836	 uint256 userFees1 = collect1.mul(shares) / totalSupply();
837	 _burn(msg.sender, shares);
838	 if (userFees0 > 0) pay(token0, address(this), to, userFees0);
839	 if (userFees1 > 0) pay(token1, address(this), to, userFees1);
840	 _compoundFees();
841	 emit Withdraw(msg.sender, shares, amount0, amount1, userFees0, userFees1);
842	 }
843	 function rerange() external payable override nonReentrant checkDeviation {
844	 require(_operatorApproved[msg.sender], "ONA");
845	 _earnFees();
846	 pool.burnAllLiquidity(tickLower, tickUpper);
847	 uint256 balance0 = _balance0();
848	 uint256 balance1 = _balance1();
849	 emit Snapshot(balance0, balance1);
850	 int24 baseThreshold = tickSpacing * IOptimizerStrategy(strategy).tickRangeMultiplier();
851	 (tickLower, tickUpper) = pool.getPositionTicks(balance0, balance1, baseThreshold, tickSpacing);
852	 uint128 liquidity = pool.liquidityForAmounts(balance0, balance1, tickLower, tickUpper);
853	 (uint256 amount0, uint256 amount1) = pool.mint( address(this), tickLower, tickUpper, liquidity, abi.encode(MintCallbackData({
854	 payer: address(this)}
855	 )));
856	 block.coinbase.transfer(msg.value);
857	 emit Rerange(tickLower, tickUpper, amount0, amount1);
858	 }
859	 function rebalance() external payable override nonReentrant checkDeviation {
860	 require(_operatorApproved[msg.sender], "ONA");
861	 _earnFees();
862	 pool.burnAllLiquidity(tickLower, tickUpper);
863	 (uint160 sqrtPriceX96, int24 currentTick, , , , , ) = pool.slot0();
864	 PoolVariables.Info memory cache;
865	 int24 baseThreshold = tickSpacing * IOptimizerStrategy(strategy).tickRangeMultiplier();
866	 (cache.tickLower, cache.tickUpper) = PoolVariables.baseTicks(currentTick, baseThreshold, tickSpacing);
867	 cache.amount0Desired = _balance0();
868	 cache.amount1Desired = _balance1();
869	 emit Snapshot(cache.amount0Desired, cache.amount1Desired);
870	 cache.liquidity = pool.liquidityForAmounts(cache.amount0Desired, cache.amount1Desired, cache.tickLower, cache.tickUpper);
871	 (cache.amount0, cache.amount1) = pool.amountsForLiquidity(cache.liquidity, cache.tickLower, cache.tickUpper);
872	 bool zeroForOne = PoolVariables.amountsDirection(cache.amount0Desired, cache.amount1Desired, cache.amount0, cache.amount1);
873	 int256 amountSpecified = zeroForOne ? int256(cache.amount0Desired.sub(cache.amount0).unsafeDiv(2)) : int256(cache.amount1Desired.sub(cache.amount1).unsafeDiv(2));
874	 uint160 exactSqrtPriceImpact = sqrtPriceX96.mul160(IOptimizerStrategy(strategy).priceImpactPercentage() / 2) / GLOBAL_DIVISIONER;
875	 uint160 sqrtPriceLimitX96 = zeroForOne ? sqrtPriceX96.sub160(exactSqrtPriceImpact) : sqrtPriceX96.add160(exactSqrtPriceImpact);
876	 pool.swap( address(this), zeroForOne, amountSpecified, sqrtPriceLimitX96, abi.encode(SwapCallbackData({
877	 zeroForOne: zeroForOne}
878	 )) );
879	 (sqrtPriceX96, currentTick, , , , , ) = pool.slot0();
880	 cache.amount0Desired = _balance0();
881	 cache.amount1Desired = _balance1();
882	 emit Snapshot(cache.amount0Desired, cache.amount1Desired);
883	 (tickLower, tickUpper) = pool.getPositionTicks(cache.amount0Desired, cache.amount1Desired, baseThreshold, tickSpacing);
884	 cache.liquidity = pool.liquidityForAmounts(cache.amount0Desired, cache.amount1Desired, tickLower, tickUpper);
885	 (cache.amount0, cache.amount1) = pool.mint( address(this), tickLower, tickUpper, cache.liquidity, abi.encode(MintCallbackData({
886	 payer: address(this)}
887	 )));
888	 block.coinbase.transfer(msg.value);
889	 emit Rerange(tickLower, tickUpper, cache.amount0, cache.amount1);
890	 }
891	 function _calcShare(uint128 liquidity, uint128 liquidityLast) internal view returns ( uint256 shares ) {
892	 shares = totalSupply() == 0 ? uint256(liquidity) : uint256(liquidity).mul(totalSupply()).unsafeDiv(uint256(liquidityLast));
893	 }
894	 function _balance0() internal view returns (uint256) {
895	 return IERC20(token0).balanceOf(address(this));
896	 }
897	 function _balance1() internal view returns (uint256) {
898	 return IERC20(token1).balanceOf(address(this));
899	 }
900	 function _earnFees() internal returns (uint256 collect0, uint256 collect1) {
901	 uint liquidity = pool.positionLiquidity(tickLower, tickUpper);
902	 if (liquidity == 0) return (0,0);
903	 pool.burn(tickLower, tickUpper, 0);
904	 (collect0, collect1) = pool.collect( address(this), tickLower, tickUpper, type(uint128).max, type(uint128).max );
905	 protocolFees0 = protocolFees0.add(collect0.mul(protocolFee).unsafeDiv(GLOBAL_DIVISIONER));
906	 protocolFees1 = protocolFees1.add(collect1.mul(protocolFee).unsafeDiv(GLOBAL_DIVISIONER));
907	 totalFees0 = totalFees0.add(collect0);
908	 totalFees1 = totalFees1.add(collect1);
909	 emit CollectFees(collect0, collect1, totalFees0, totalFees1);
910	 }
911	 function _compoundFees() internal returns (uint256 amount0, uint256 amount1){
912	 uint256 balance0 = _balance0();
913	 uint256 balance1 = _balance1();
914	 emit Snapshot(balance0, balance1);
915	 uint128 liquidity = pool.liquidityForAmounts(balance0, balance1, tickLower, tickUpper);
916	 if (liquidity > 0) {
917	 (amount0, amount1) = pool.mint( address(this), tickLower, tickUpper, liquidity, abi.encode(MintCallbackData({
918	 payer: address(this)}
919	 )));
920	 emit CompoundFees(amount0, amount1);
921	 }
922	 }
923	 function position() external view returns (uint128 liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, uint128 tokensOwed0, uint128 tokensOwed1) {
924	 bytes32 positionKey = PositionKey.compute(address(this), tickLower, tickUpper);
925	 (liquidity, feeGrowthInside0LastX128, feeGrowthInside1LastX128, tokensOwed0, tokensOwed1) = pool.positions(positionKey);
926	 }
927	 function uniswapV3MintCallback( uint256 amount0, uint256 amount1, bytes calldata data ) external {
928	 require(msg.sender == address(pool), "FP");
929	 MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));
930	 if (amount0 > 0) pay(token0, decoded.payer, msg.sender, amount0);
931	 if (amount1 > 0) pay(token1, decoded.payer, msg.sender, amount1);
932	 }
933	 function uniswapV3SwapCallback( int256 amount0, int256 amount1, bytes calldata _data ) external {
934	 require(msg.sender == address(pool), "FP");
935	 require(amount0 > 0 || amount1 > 0, "LEZ");
936	 SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));
937	 bool zeroForOne = data.zeroForOne;
938	 if (zeroForOne) pay(token0, address(this), msg.sender, uint256(amount0));
939	 else pay(token1, address(this), msg.sender, uint256(amount1));
940	 }
941	 function pay( address token, address payer, address recipient, uint256 value ) internal {
942	 if (token == weth && address(this).balance >= value) {
943	 IWETH9(weth).deposit{
944	 value: value}
945	 ();
946	 IWETH9(weth).transfer(recipient, value);
947	 }
948	 else if (payer == address(this)) {
949	 TransferHelper.safeTransfer(token, recipient, value);
950	 }
951	 else {
952	 TransferHelper.safeTransferFrom(token, payer, recipient, value);
953	 }
954	 }
955	 function collectProtocolFees( uint256 amount0, uint256 amount1 ) external nonReentrant onlyGovernance {
956	 require(protocolFees0 >= amount0, "A0F");
957	 require(protocolFees1 >= amount1, "A1F");
958	 _earnFees();
959	 uint256 balance0 = _balance0();
960	 uint256 balance1 = _balance1();
961	 if (balance0 >= amount0 && balance1 >= amount1) {
962	 if (amount0 > 0) pay(token0, address(this), msg.sender, amount0);
963	 if (amount1 > 0) pay(token1, address(this), msg.sender, amount1);
964	 }
965	 else {
966	 uint128 liquidity = pool.liquidityForAmounts(amount0, amount1, tickLower, tickUpper);
967	 (amount0, amount1) = pool.burnExactLiquidity(tickLower, tickUpper, liquidity, msg.sender);
968	 }
969	 protocolFees0 = protocolFees0.sub(amount0);
970	 protocolFees1 = protocolFees1.sub(amount1);
971	 _compoundFees();
972	 emit RewardPaid(msg.sender, amount0, amount1);
973	 }
974	 modifier checkDeviation() {
975	 pool.checkDeviation(IOptimizerStrategy(strategy).maxTwapDeviation(), IOptimizerStrategy(strategy).twapDuration());
976	 _;
977	 }
978	 function refundETH() internal {
979	 if (address(this).balance > 0) TransferHelper.safeTransferETH(msg.sender, address(this).balance);
980	 }
981	 function setGovernance(address _governance) external onlyGovernance {
982	 pendingGovernance = _governance;
983	 }
984	 function acceptGovernance() external {
985	 require(msg.sender == pendingGovernance, "PG");
986	 emit TransferGovernance(governance, pendingGovernance);
987	 pendingGovernance = address(0);
988	 governance = msg.sender;
989	 }
990	 function setStrategy(address _strategy) external onlyGovernance {
991	 require(_strategy != address(0), "NA");
992	 strategy = _strategy;
993	 }
994	 function approveOperator(address _operator) external onlyGovernance {
995	 _operatorApproved[_operator] = true;
996	 }
997	 function disableOperator(address _operator) external onlyGovernance {
998	 _operatorApproved[_operator] = false;
999	 }
1000	 function isOperator(address _operator) external view returns (bool) {
1001	 return _operatorApproved[_operator];
1002	 }
1003	 modifier whenNotPaused() {
1004	 require(!_paused, "P");
1005	 _;
1006	 }
1007	 modifier whenPaused() {
1008	 require(_paused, "NP");
1009	 _;
1010	 }
1011	 function pause() external onlyGovernance whenNotPaused {
1012	 _paused = true;
1013	 }
1014	 function unpause() external onlyGovernance whenPaused {
1015	 _paused = false;
1016	 }
1017	 }
