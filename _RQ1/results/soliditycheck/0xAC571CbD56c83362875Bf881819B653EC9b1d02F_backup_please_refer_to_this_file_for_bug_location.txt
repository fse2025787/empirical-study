row number 
1	  pragma abicoder v2;
2	 pragma solidity >=0.6.0 <0.8.0;
3	 interface IERC20 {
4	 function totalSupply() external view returns (uint256);
5	 function balanceOf(address account) external view returns (uint256);
6	 function transfer(address recipient, uint256 amount) external returns (bool);
7	 function allowance(address owner, address spender) external view returns (uint256);
8	 function approve(address spender, uint256 amount) external returns (bool);
9	 function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
10	 event Transfer(address indexed from, address indexed to, uint256 value);
11	 event Approval(address indexed owner, address indexed spender, uint256 value);
12	 }
13	 pragma solidity >=0.6.0 <0.8.0;
14	 abstract contract Context {
15	 function _msgSender() internal view virtual returns (address payable) {
16	 return msg.sender;
17	 }
18	 function _msgData() internal view virtual returns (bytes memory) {
19	 this;
20	 return msg.data;
21	 }
22	 }
23	 pragma solidity >=0.6.0 <0.8.0;
24	 contract ERC20 is Context, IERC20 {
25	 using SafeMath for uint256;
26	 mapping (address => uint256) private _balances;
27	 mapping (address => mapping (address => uint256)) private _allowances;
28	 uint256 private _totalSupply;
29	 string private _name;
30	 string private _symbol;
31	 uint8 private _decimals;
32	 constructor (string memory name_, string memory symbol_) public {
33	 _name = name_;
34	 _symbol = symbol_;
35	 _decimals = 18;
36	 }
37	 function name() public view virtual returns (string memory) {
38	 return _name;
39	 }
40	 function symbol() public view virtual returns (string memory) {
41	 return _symbol;
42	 }
43	 function decimals() public view virtual returns (uint8) {
44	 return _decimals;
45	 }
46	 function totalSupply() public view virtual override returns (uint256) {
47	 return _totalSupply;
48	 }
49	 function balanceOf(address account) public view virtual override returns (uint256) {
50	 return _balances[account];
51	 }
52	 function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
53	 _transfer(_msgSender(), recipient, amount);
54	 return true;
55	 }
56	 function allowance(address owner, address spender) public view virtual override returns (uint256) {
57	 return _allowances[owner][spender];
58	 }
59	 function approve(address spender, uint256 amount) public virtual override returns (bool) {
60	 _approve(_msgSender(), spender, amount);
61	 return true;
62	 }
63	 function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
64	 _transfer(sender, recipient, amount);
65	 _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
66	 return true;
67	 }
68	 function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
69	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
70	 return true;
71	 }
72	 function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
73	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
74	 return true;
75	 }
76	 function _transfer(address sender, address recipient, uint256 amount) internal virtual {
77	 require(sender != address(0), "ERC20: transfer from the zero address");
78	 require(recipient != address(0), "ERC20: transfer to the zero address");
79	 _beforeTokenTransfer(sender, recipient, amount);
80	 _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
81	 _balances[recipient] = _balances[recipient].add(amount);
82	 emit Transfer(sender, recipient, amount);
83	 }
84	 function _mint(address account, uint256 amount) internal virtual {
85	 require(account != address(0), "ERC20: mint to the zero address");
86	 _beforeTokenTransfer(address(0), account, amount);
87	 _totalSupply = _totalSupply.add(amount);
88	 _balances[account] = _balances[account].add(amount);
89	 emit Transfer(address(0), account, amount);
90	 }
91	 function _burn(address account, uint256 amount) internal virtual {
92	 require(account != address(0), "ERC20: burn from the zero address");
93	 _beforeTokenTransfer(account, address(0), amount);
94	 _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
95	 _totalSupply = _totalSupply.sub(amount);
96	 emit Transfer(account, address(0), amount);
97	 }
98	 function _approve(address owner, address spender, uint256 amount) internal virtual {
99	 require(owner != address(0), "ERC20: approve from the zero address");
100	 require(spender != address(0), "ERC20: approve to the zero address");
101	 _allowances[owner][spender] = amount;
102	 emit Approval(owner, spender, amount);
103	 }
104	 function _setupDecimals(uint8 decimals_) internal virtual {
105	 _decimals = decimals_;
106	 }
107	 function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {
108	 }
109	 }
110	 pragma solidity >=0.6.0 <0.8.0;
111	 interface IERC20Permit {
112	 function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;
113	 function nonces(address owner) external view returns (uint256);
114	 function DOMAIN_SEPARATOR() external view returns (bytes32);
115	 }
116	 pragma solidity >=0.6.0 <0.8.0;
117	 abstract contract EIP712 {
118	 bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;
119	 uint256 private immutable _CACHED_CHAIN_ID;
120	 bytes32 private immutable _HASHED_NAME;
121	 bytes32 private immutable _HASHED_VERSION;
122	 bytes32 private immutable _TYPE_HASH;
123	 constructor(string memory name, string memory version) internal {
124	 bytes32 hashedName = keccak256(bytes(name));
125	 bytes32 hashedVersion = keccak256(bytes(version));
126	 bytes32 typeHash = keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");
127	 _HASHED_NAME = hashedName;
128	 _HASHED_VERSION = hashedVersion;
129	 _CACHED_CHAIN_ID = _getChainId();
130	 _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);
131	 _TYPE_HASH = typeHash;
132	 }
133	 function _domainSeparatorV4() internal view virtual returns (bytes32) {
134	 if (_getChainId() == _CACHED_CHAIN_ID) {
135	 return _CACHED_DOMAIN_SEPARATOR;
136	 }
137	 else {
138	 return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);
139	 }
140	 }
141	 function _buildDomainSeparator(bytes32 typeHash, bytes32 name, bytes32 version) private view returns (bytes32) {
142	 return keccak256( abi.encode( typeHash, name, version, _getChainId(), address(this) ) );
143	 }
144	 function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {
145	 return keccak256(abi.encodePacked("\x19\x01", _domainSeparatorV4(), structHash));
146	 }
147	 function _getChainId() private view returns (uint256 chainId) {
148	 this;
149	 assembly {
150	 chainId := chainid() }
151	 }
152	 }
153	 pragma solidity >=0.6.5 <0.8.0;
154	 abstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {
155	 using Counters for Counters.Counter;
156	 mapping (address => Counters.Counter) private _nonces;
157	 bytes32 private immutable _PERMIT_TYPEHASH = keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");
158	 constructor(string memory name) internal EIP712(name, "1") {
159	 }
160	 function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public virtual override {
161	 require(block.timestamp <= deadline, "ERC20Permit: expired deadline");
162	 bytes32 structHash = keccak256( abi.encode( _PERMIT_TYPEHASH, owner, spender, value, _nonces[owner].current(), deadline ) );
163	 bytes32 hash = _hashTypedDataV4(structHash);
164	 address signer = ECDSA.recover(hash, v, r, s);
165	 require(signer == owner, "ERC20Permit: invalid signature");
166	 _nonces[owner].increment();
167	 _approve(owner, spender, value);
168	 }
169	 function nonces(address owner) public view override returns (uint256) {
170	 return _nonces[owner].current();
171	 }
172	 function DOMAIN_SEPARATOR() external view override returns (bytes32) {
173	 return _domainSeparatorV4();
174	 }
175	 }
176	 pragma solidity >=0.5.0;
177	 interface IUniswapV3MintCallback {
178	 function uniswapV3MintCallback( uint256 amount0Owed, uint256 amount1Owed, bytes calldata data ) external;
179	 }
180	 pragma solidity >=0.5.0;
181	 interface IUniswapV3SwapCallback {
182	 function uniswapV3SwapCallback( int256 amount0Delta, int256 amount1Delta, bytes calldata data ) external;
183	 }
184	 pragma solidity 0.7.6;
185	 interface IVault {
186	 function deposit( uint256, uint256, address, address ) external returns (uint256);
187	 function withdraw( uint256, address, address ) external returns (uint256, uint256);
188	 function rebalance( int24 _baseLower, int24 _baseUpper, int24 _limitLower, int24 _limitUpper, address feeRecipient, int256 swapQuantity ) external;
189	 function getTotalAmounts() external view returns (uint256, uint256);
190	 event Deposit( address indexed sender, address indexed to, uint256 shares, uint256 amount0, uint256 amount1 );
191	 event Withdraw( address indexed sender, address indexed to, uint256 shares, uint256 amount0, uint256 amount1 );
192	 event Rebalance( int24 tick, uint256 totalAmount0, uint256 totalAmount1, uint256 feeAmount0, uint256 feeAmount1, uint256 totalSupply );
193	 }
194	 pragma solidity >=0.5.0;
195	 interface IUniswapV3PoolImmutables {
196	 function factory() external view returns (address);
197	 function token0() external view returns (address);
198	 function token1() external view returns (address);
199	 function fee() external view returns (uint24);
200	 function tickSpacing() external view returns (int24);
201	 function maxLiquidityPerTick() external view returns (uint128);
202	 }
203	 pragma solidity >=0.5.0;
204	 interface IUniswapV3PoolState {
205	 function slot0() external view returns ( uint160 sqrtPriceX96, int24 tick, uint16 observationIndex, uint16 observationCardinality, uint16 observationCardinalityNext, uint8 feeProtocol, bool unlocked );
206	 function feeGrowthGlobal0X128() external view returns (uint256);
207	 function feeGrowthGlobal1X128() external view returns (uint256);
208	 function protocolFees() external view returns (uint128 token0, uint128 token1);
209	 function liquidity() external view returns (uint128);
210	 function ticks(int24 tick) external view returns ( uint128 liquidityGross, int128 liquidityNet, uint256 feeGrowthOutside0X128, uint256 feeGrowthOutside1X128, int56 tickCumulativeOutside, uint160 secondsPerLiquidityOutsideX128, uint32 secondsOutside, bool initialized );
211	 function tickBitmap(int16 wordPosition) external view returns (uint256);
212	 function positions(bytes32 key) external view returns ( uint128 _liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, uint128 tokensOwed0, uint128 tokensOwed1 );
213	 function observations(uint256 index) external view returns ( uint32 blockTimestamp, int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128, bool initialized );
214	 }
215	 pragma solidity >=0.5.0;
216	 interface IUniswapV3PoolDerivedState {
217	 function observe(uint32[] calldata secondsAgos) external view returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);
218	 function snapshotCumulativesInside(int24 tickLower, int24 tickUpper) external view returns ( int56 tickCumulativeInside, uint160 secondsPerLiquidityInsideX128, uint32 secondsInside );
219	 }
220	 pragma solidity >=0.5.0;
221	 interface IUniswapV3PoolActions {
222	 function initialize(uint160 sqrtPriceX96) external;
223	 function mint( address recipient, int24 tickLower, int24 tickUpper, uint128 amount, bytes calldata data ) external returns (uint256 amount0, uint256 amount1);
224	 function collect( address recipient, int24 tickLower, int24 tickUpper, uint128 amount0Requested, uint128 amount1Requested ) external returns (uint128 amount0, uint128 amount1);
225	 function burn( int24 tickLower, int24 tickUpper, uint128 amount ) external returns (uint256 amount0, uint256 amount1);
226	 function swap( address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes calldata data ) external returns (int256 amount0, int256 amount1);
227	 function flash( address recipient, uint256 amount0, uint256 amount1, bytes calldata data ) external;
228	 function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;
229	 }
230	 pragma solidity >=0.5.0;
231	 interface IUniswapV3PoolOwnerActions {
232	 function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;
233	 function collectProtocol( address recipient, uint128 amount0Requested, uint128 amount1Requested ) external returns (uint128 amount0, uint128 amount1);
234	 }
235	 pragma solidity >=0.5.0;
236	 interface IUniswapV3PoolEvents {
237	 event Initialize(uint160 sqrtPriceX96, int24 tick);
238	 event Mint( address sender, address indexed owner, int24 indexed tickLower, int24 indexed tickUpper, uint128 amount, uint256 amount0, uint256 amount1 );
239	 event Collect( address indexed owner, address recipient, int24 indexed tickLower, int24 indexed tickUpper, uint128 amount0, uint128 amount1 );
240	 event Burn( address indexed owner, int24 indexed tickLower, int24 indexed tickUpper, uint128 amount, uint256 amount0, uint256 amount1 );
241	 event Swap( address indexed sender, address indexed recipient, int256 amount0, int256 amount1, uint160 sqrtPriceX96, uint128 liquidity, int24 tick );
242	 event Flash( address indexed sender, address indexed recipient, uint256 amount0, uint256 amount1, uint256 paid0, uint256 paid1 );
243	 event IncreaseObservationCardinalityNext( uint16 observationCardinalityNextOld, uint16 observationCardinalityNextNew );
244	 event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);
245	 event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);
246	 }
247	 pragma solidity 0.7.6;
248	 contract Hypervisor is IVault, IUniswapV3MintCallback, IUniswapV3SwapCallback, ERC20Permit {
249	 using SafeERC20 for IERC20;
250	 using SafeMath for uint256;
251	 using SignedSafeMath for int256;
252	 IUniswapV3Pool public pool;
253	 IERC20 public token0;
254	 IERC20 public token1;
255	 uint24 public fee;
256	 int24 public tickSpacing;
257	 int24 public baseLower;
258	 int24 public baseUpper;
259	 int24 public limitLower;
260	 int24 public limitUpper;
261	 address public owner;
262	 uint256 public deposit0Max;
263	 uint256 public deposit1Max;
264	 uint256 public maxTotalSupply;
265	 mapping(address => bool) public list;
266	 bool public whitelisted;
267	 bool public directDeposit;
268	 uint256 public constant PRECISION = 1e36;
269	 constructor( address _pool, address _owner, string memory name, string memory symbol ) ERC20Permit(name) ERC20(name, symbol) {
270	 pool = IUniswapV3Pool(_pool);
271	 token0 = IERC20(pool.token0());
272	 token1 = IERC20(pool.token1());
273	 fee = pool.fee();
274	 tickSpacing = pool.tickSpacing();
275	 owner = _owner;
276	 maxTotalSupply = 0;
277	 deposit0Max = uint256(-1);
278	 deposit1Max = uint256(-1);
279	 whitelisted = false;
280	 }
281	 function deposit( uint256 deposit0, uint256 deposit1, address to, address from ) external override returns (uint256 shares) {
282	 require(deposit0 > 0 || deposit1 > 0, "deposits must be nonzero");
283	 require(deposit0 <= deposit0Max && deposit1 <= deposit1Max, "deposits must be less than maximum amounts");
284	 require(to != address(0) && to != address(this), "to");
285	 require(!whitelisted || list[from], "must be on the list");
286	 (uint128 baseLiquidity, uint128 limitLiquidity) = zeroBurn();
287	 uint160 sqrtPrice = TickMath.getSqrtRatioAtTick(currentTick());
288	 uint256 price = FullMath.mulDiv(uint256(sqrtPrice).mul(uint256(sqrtPrice)), PRECISION, 2**(96 * 2));
289	 (uint256 pool0, uint256 pool1) = getTotalAmounts();
290	 uint256 deposit0PricedInToken1 = deposit0.mul(price).div(PRECISION);
291	 shares = deposit1.add(deposit0PricedInToken1);
292	 if (deposit0 > 0) {
293	 token0.safeTransferFrom(from, address(this), deposit0);
294	 }
295	 if (deposit1 > 0) {
296	 token1.safeTransferFrom(from, address(this), deposit1);
297	 }
298	 if (totalSupply() != 0) {
299	 uint256 pool0PricedInToken1 = pool0.mul(price).div(PRECISION);
300	 shares = shares.mul(totalSupply()).div(pool0PricedInToken1.add(pool1));
301	 if (directDeposit) {
302	 baseLiquidity = _liquidityForAmounts( baseLower, baseUpper, token0.balanceOf(address(this)), token1.balanceOf(address(this)) );
303	 _mintLiquidity(baseLower, baseUpper, baseLiquidity, address(this));
304	 limitLiquidity = _liquidityForAmounts( limitLower, limitUpper, token0.balanceOf(address(this)), token1.balanceOf(address(this)) );
305	 _mintLiquidity(limitLower, limitUpper, limitLiquidity, address(this));
306	 }
307	 }
308	 _mint(to, shares);
309	 emit Deposit(from, to, shares, deposit0, deposit1);
310	 require(maxTotalSupply == 0 || totalSupply() <= maxTotalSupply, "maxTotalSupply");
311	 }
312	 function zeroBurn() internal returns(uint128 baseLiquidity, uint128 limitLiquidity) {
313	 (baseLiquidity, , ) = _position(baseLower, baseUpper);
314	 if (baseLiquidity > 0) {
315	 pool.burn(baseLower, baseUpper, 0);
316	 }
317	 (limitLiquidity, , ) = _position(limitLower, limitUpper);
318	 if (limitLiquidity > 0) {
319	 pool.burn(limitLower, limitUpper, 0);
320	 }
321	 }
322	 function pullLiquidity( uint256 shares ) external onlyOwner returns( uint256 base0, uint256 base1, uint256 limit0, uint256 limit1 ) {
323	 zeroBurn();
324	 (base0, base1) = _burnLiquidity( baseLower, baseUpper, _liquidityForShares(baseLower, baseUpper, shares), address(this), false );
325	 (limit0, limit1) = _burnLiquidity( limitLower, limitUpper, _liquidityForShares(limitLower, limitUpper, shares), address(this), false );
326	 }
327	 function withdraw( uint256 shares, address to, address from ) external override returns (uint256 amount0, uint256 amount1) {
328	 require(shares > 0, "shares");
329	 require(to != address(0), "to");
330	 zeroBurn();
331	 (uint256 base0, uint256 base1) = _burnLiquidity( baseLower, baseUpper, _liquidityForShares(baseLower, baseUpper, shares), to, false );
332	 (uint256 limit0, uint256 limit1) = _burnLiquidity( limitLower, limitUpper, _liquidityForShares(limitLower, limitUpper, shares), to, false );
333	 uint256 supply = totalSupply();
334	 uint256 unusedAmount0 = token0.balanceOf(address(this)).mul(shares).div(supply);
335	 uint256 unusedAmount1 = token1.balanceOf(address(this)).mul(shares).div(supply);
336	 if (unusedAmount0 > 0) token0.safeTransfer(to, unusedAmount0);
337	 if (unusedAmount1 > 0) token1.safeTransfer(to, unusedAmount1);
338	 amount0 = base0.add(limit0).add(unusedAmount0);
339	 amount1 = base1.add(limit1).add(unusedAmount1);
340	 require( from == msg.sender || IUniversalVault(from).owner() == msg.sender, "Sender must own the tokens" );
341	 _burn(from, shares);
342	 emit Withdraw(from, to, shares, amount0, amount1);
343	 }
344	 function rebalance( int24 _baseLower, int24 _baseUpper, int24 _limitLower, int24 _limitUpper, address feeRecipient, int256 swapQuantity ) external override onlyOwner {
345	 require( _baseLower < _baseUpper && _baseLower % tickSpacing == 0 && _baseUpper % tickSpacing == 0, "base position invalid" );
346	 require( _limitLower < _limitUpper && _limitLower % tickSpacing == 0 && _limitUpper % tickSpacing == 0, "limit position invalid" );
347	 require( _limitUpper != _baseUpper || _limitLower != _baseLower, "limit equals base" );
348	 (uint128 baseLiquidity, uint128 limitLiquidity) = zeroBurn();
349	 (, uint256 feesLimit0, uint256 feesLimit1) = _position(baseLower, baseUpper);
350	 (, uint256 feesBase0, uint256 feesBase1) = _position(limitLower, limitUpper);
351	 uint256 fees0 = feesBase0.add(feesLimit0);
352	 uint256 fees1 = feesBase1.add(feesLimit1);
353	 (baseLiquidity, , ) = _position(baseLower, baseUpper);
354	 (limitLiquidity, , ) = _position(limitLower, limitUpper);
355	 _burnLiquidity(baseLower, baseUpper, baseLiquidity, address(this), true);
356	 _burnLiquidity(limitLower, limitUpper, limitLiquidity, address(this), true);
357	 if (fees0 > 0) token0.safeTransfer(feeRecipient, fees0.div(10));
358	 if (fees1 > 0) token1.safeTransfer(feeRecipient, fees1.div(10));
359	 emit Rebalance( currentTick(), token0.balanceOf(address(this)), token1.balanceOf(address(this)), fees0, fees1, totalSupply() );
360	 if (swapQuantity != 0) {
361	 pool.swap( address(this), swapQuantity > 0, swapQuantity > 0 ? swapQuantity : -swapQuantity, swapQuantity > 0 ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1, abi.encode(address(this)) );
362	 }
363	 baseLower = _baseLower;
364	 baseUpper = _baseUpper;
365	 baseLiquidity = _liquidityForAmounts( baseLower, baseUpper, token0.balanceOf(address(this)), token1.balanceOf(address(this)) );
366	 _mintLiquidity(baseLower, baseUpper, baseLiquidity, address(this));
367	 limitLower = _limitLower;
368	 limitUpper = _limitUpper;
369	 limitLiquidity = _liquidityForAmounts( limitLower, limitUpper, token0.balanceOf(address(this)), token1.balanceOf(address(this)) );
370	 _mintLiquidity(limitLower, limitUpper, limitLiquidity, address(this));
371	 }
372	 function pendingFees() external onlyOwner returns (uint256 fees0, uint256 fees1) {
373	 (uint128 baseLiquidity, , ) = _position(baseLower, baseUpper);
374	 if (baseLiquidity > 0) {
375	 pool.burn(baseLower, baseUpper, 0);
376	 }
377	 (uint128 limitLiquidity, , ) = _position(limitLower, limitUpper);
378	 if (limitLiquidity > 0) {
379	 pool.burn(limitLower, limitUpper, 0);
380	 }
381	 (, uint256 feesLimit0, uint256 feesLimit1) = _position(baseLower, baseUpper);
382	 (, uint256 feesBase0, uint256 feesBase1) = _position(limitLower, limitUpper);
383	 fees0 = feesBase0.add(feesLimit0);
384	 fees1 = feesBase1.add(feesLimit1);
385	 }
386	 function addBaseLiquidity(uint256 amount0, uint256 amount1) external onlyOwner {
387	 uint128 baseLiquidity = _liquidityForAmounts( baseLower, baseUpper, amount0 == 0 && amount1 == 0 ? token0.balanceOf(address(this)) : amount0, amount0 == 0 && amount1 == 0 ? token1.balanceOf(address(this)) : amount1 );
388	 _mintLiquidity(baseLower, baseUpper, baseLiquidity, address(this));
389	 }
390	 function addLimitLiquidity(uint256 amount0, uint256 amount1) external onlyOwner {
391	 uint128 limitLiquidity = _liquidityForAmounts( limitLower, limitUpper, amount0 == 0 && amount1 == 0 ? token0.balanceOf(address(this)) : amount0, amount0 == 0 && amount1 == 0 ? token1.balanceOf(address(this)) : amount1 );
392	 _mintLiquidity(limitLower, limitUpper, limitLiquidity, address(this));
393	 }
394	 function _mintLiquidity( int24 tickLower, int24 tickUpper, uint128 liquidity, address payer ) internal returns (uint256 amount0, uint256 amount1) {
395	 if (liquidity > 0) {
396	 (amount0, amount1) = pool.mint( address(this), tickLower, tickUpper, liquidity, abi.encode(payer) );
397	 }
398	 }
399	 function _burnLiquidity( int24 tickLower, int24 tickUpper, uint128 liquidity, address to, bool collectAll ) internal returns (uint256 amount0, uint256 amount1) {
400	 if (liquidity > 0) {
401	 (uint256 owed0, uint256 owed1) = pool.burn(tickLower, tickUpper, liquidity);
402	 uint128 collect0 = collectAll ? type(uint128).max : _uint128Safe(owed0);
403	 uint128 collect1 = collectAll ? type(uint128).max : _uint128Safe(owed1);
404	 if (collect0 > 0 || collect1 > 0) {
405	 (amount0, amount1) = pool.collect(to, tickLower, tickUpper, collect0, collect1);
406	 }
407	 }
408	 }
409	 function _liquidityForShares( int24 tickLower, int24 tickUpper, uint256 shares ) internal view returns (uint128) {
410	 (uint128 position, , ) = _position(tickLower, tickUpper);
411	 return _uint128Safe(uint256(position).mul(shares).div(totalSupply()));
412	 }
413	 function _position(int24 tickLower, int24 tickUpper) internal view returns ( uint128 liquidity, uint128 tokensOwed0, uint128 tokensOwed1 ) {
414	 bytes32 positionKey = keccak256(abi.encodePacked(address(this), tickLower, tickUpper));
415	 (liquidity, , , tokensOwed0, tokensOwed1) = pool.positions(positionKey);
416	 }
417	 function uniswapV3MintCallback( uint256 amount0, uint256 amount1, bytes calldata data ) external override {
418	 require(msg.sender == address(pool));
419	 address payer = abi.decode(data, (address));
420	 if (payer == address(this)) {
421	 if (amount0 > 0) token0.safeTransfer(msg.sender, amount0);
422	 if (amount1 > 0) token1.safeTransfer(msg.sender, amount1);
423	 }
424	 else {
425	 if (amount0 > 0) token0.safeTransferFrom(payer, msg.sender, amount0);
426	 if (amount1 > 0) token1.safeTransferFrom(payer, msg.sender, amount1);
427	 }
428	 }
429	 function uniswapV3SwapCallback( int256 amount0Delta, int256 amount1Delta, bytes calldata data ) external override {
430	 require(msg.sender == address(pool));
431	 address payer = abi.decode(data, (address));
432	 if (amount0Delta > 0) {
433	 if (payer == address(this)) {
434	 token0.safeTransfer(msg.sender, uint256(amount0Delta));
435	 }
436	 else {
437	 token0.safeTransferFrom(payer, msg.sender, uint256(amount0Delta));
438	 }
439	 }
440	 else if (amount1Delta > 0) {
441	 if (payer == address(this)) {
442	 token1.safeTransfer(msg.sender, uint256(amount1Delta));
443	 }
444	 else {
445	 token1.safeTransferFrom(payer, msg.sender, uint256(amount1Delta));
446	 }
447	 }
448	 }
449	 function getTotalAmounts() public view override returns (uint256 total0, uint256 total1) {
450	 (, uint256 base0, uint256 base1) = getBasePosition();
451	 (, uint256 limit0, uint256 limit1) = getLimitPosition();
452	 total0 = token0.balanceOf(address(this)).add(base0).add(limit0);
453	 total1 = token1.balanceOf(address(this)).add(base1).add(limit1);
454	 }
455	 function getBasePosition() public view returns ( uint128 liquidity, uint256 amount0, uint256 amount1 ) {
456	 (uint128 positionLiquidity, uint128 tokensOwed0, uint128 tokensOwed1) = _position( baseLower, baseUpper );
457	 (amount0, amount1) = _amountsForLiquidity(baseLower, baseUpper, positionLiquidity);
458	 amount0 = amount0.add(uint256(tokensOwed0));
459	 amount1 = amount1.add(uint256(tokensOwed1));
460	 liquidity = positionLiquidity;
461	 }
462	 function getLimitPosition() public view returns ( uint128 liquidity, uint256 amount0, uint256 amount1 ) {
463	 (uint128 positionLiquidity, uint128 tokensOwed0, uint128 tokensOwed1) = _position( limitLower, limitUpper );
464	 (amount0, amount1) = _amountsForLiquidity(limitLower, limitUpper, positionLiquidity);
465	 amount0 = amount0.add(uint256(tokensOwed0));
466	 amount1 = amount1.add(uint256(tokensOwed1));
467	 liquidity = positionLiquidity;
468	 }
469	 function _amountsForLiquidity( int24 tickLower, int24 tickUpper, uint128 liquidity ) internal view returns (uint256, uint256) {
470	 (uint160 sqrtRatioX96, , , , , , ) = pool.slot0();
471	 return LiquidityAmounts.getAmountsForLiquidity( sqrtRatioX96, TickMath.getSqrtRatioAtTick(tickLower), TickMath.getSqrtRatioAtTick(tickUpper), liquidity );
472	 }
473	 function _liquidityForAmounts( int24 tickLower, int24 tickUpper, uint256 amount0, uint256 amount1 ) internal view returns (uint128) {
474	 (uint160 sqrtRatioX96, , , , , , ) = pool.slot0();
475	 return LiquidityAmounts.getLiquidityForAmounts( sqrtRatioX96, TickMath.getSqrtRatioAtTick(tickLower), TickMath.getSqrtRatioAtTick(tickUpper), amount0, amount1 );
476	 }
477	 function currentTick() public view returns (int24 tick) {
478	 (, tick, , , , , ) = pool.slot0();
479	 }
480	 function _uint128Safe(uint256 x) internal pure returns (uint128) {
481	 assert(x <= type(uint128).max);
482	 return uint128(x);
483	 }
484	 function setMaxTotalSupply(uint256 _maxTotalSupply) external onlyOwner {
485	 maxTotalSupply = _maxTotalSupply;
486	 }
487	 function setDepositMax(uint256 _deposit0Max, uint256 _deposit1Max) external onlyOwner {
488	 deposit0Max = _deposit0Max;
489	 deposit1Max = _deposit1Max;
490	 }
491	 function appendList(address[] memory listed) external onlyOwner {
492	 for (uint8 i; i < listed.length; i++) {
493	 list[listed[i]] = true;
494	 }
495	 }
496	 function removeListed(address listed) external onlyOwner {
497	 list[listed] = false;
498	 }
499	 function toggleDirectDeposit() external onlyOwner {
500	 directDeposit = !directDeposit;
501	 }
502	 function toggleWhitelist() external onlyOwner {
503	 whitelisted = !whitelisted;
504	 }
505	 function transferOwnership(address newOwner) external onlyOwner {
506	 owner = newOwner;
507	 }
508	 modifier onlyOwner {
509	 require(msg.sender == owner, "only owner");
510	 _;
511	 }
512	 }
513	 pragma solidity >=0.6.0 <0.8.0;
514	 library Math {
515	 function max(uint256 a, uint256 b) internal pure returns (uint256) {
516	 return a >= b ? a : b;
517	 }
518	 function min(uint256 a, uint256 b) internal pure returns (uint256) {
519	 return a < b ? a : b;
520	 }
521	 function average(uint256 a, uint256 b) internal pure returns (uint256) {
522	 return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);
523	 }
524	 }
525	 pragma solidity >=0.6.0 <0.8.0;
526	 library SafeMath {
527	 function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
528	 uint256 c = a + b;
529	 if (c < a) return (false, 0);
530	 return (true, c);
531	 }
532	 function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
533	 if (b > a) return (false, 0);
534	 return (true, a - b);
535	 }
536	 function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
537	 if (a == 0) return (true, 0);
538	 uint256 c = a * b;
539	 if (c / a != b) return (false, 0);
540	 return (true, c);
541	 }
542	 function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
543	 if (b == 0) return (false, 0);
544	 return (true, a / b);
545	 }
546	 function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
547	 if (b == 0) return (false, 0);
548	 return (true, a % b);
549	 }
550	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
551	 uint256 c = a + b;
552	 require(c >= a, "SafeMath: addition overflow");
553	 return c;
554	 }
555	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
556	 require(b <= a, "SafeMath: subtraction overflow");
557	 return a - b;
558	 }
559	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
560	 if (a == 0) return 0;
561	 uint256 c = a * b;
562	 require(c / a == b, "SafeMath: multiplication overflow");
563	 return c;
564	 }
565	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
566	 require(b > 0, "SafeMath: division by zero");
567	 return a / b;
568	 }
569	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
570	 require(b > 0, "SafeMath: modulo by zero");
571	 return a % b;
572	 }
573	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
574	 require(b <= a, errorMessage);
575	 return a - b;
576	 }
577	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
578	 require(b > 0, errorMessage);
579	 return a / b;
580	 }
581	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
582	 require(b > 0, errorMessage);
583	 return a % b;
584	 }
585	 }
586	 pragma solidity >=0.6.0 <0.8.0;
587	 library SignedSafeMath {
588	 int256 constant private _INT256_MIN = -2**255;
589	 function mul(int256 a, int256 b) internal pure returns (int256) {
590	 if (a == 0) {
591	 return 0;
592	 }
593	 require(!(a == -1 && b == _INT256_MIN), "SignedSafeMath: multiplication overflow");
594	 int256 c = a * b;
595	 require(c / a == b, "SignedSafeMath: multiplication overflow");
596	 return c;
597	 }
598	 function div(int256 a, int256 b) internal pure returns (int256) {
599	 require(b != 0, "SignedSafeMath: division by zero");
600	 require(!(b == -1 && a == _INT256_MIN), "SignedSafeMath: division overflow");
601	 int256 c = a / b;
602	 return c;
603	 }
604	 function sub(int256 a, int256 b) internal pure returns (int256) {
605	 int256 c = a - b;
606	 require((b >= 0 && c <= a) || (b < 0 && c > a), "SignedSafeMath: subtraction overflow");
607	 return c;
608	 }
609	 function add(int256 a, int256 b) internal pure returns (int256) {
610	 int256 c = a + b;
611	 require((b >= 0 && c >= a) || (b < 0 && c < a), "SignedSafeMath: addition overflow");
612	 return c;
613	 }
614	 }
615	 pragma solidity >=0.6.0 <0.8.0;
616	 library SafeERC20 {
617	 using SafeMath for uint256;
618	 using Address for address;
619	 function safeTransfer(IERC20 token, address to, uint256 value) internal {
620	 _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
621	 }
622	 function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
623	 _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
624	 }
625	 function safeApprove(IERC20 token, address spender, uint256 value) internal {
626	 require((value == 0) || (token.allowance(address(this), spender) == 0), "SafeERC20: approve from non-zero to non-zero allowance" );
627	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
628	 }
629	 function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
630	 uint256 newAllowance = token.allowance(address(this), spender).add(value);
631	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
632	 }
633	 function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
634	 uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
635	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
636	 }
637	 function _callOptionalReturn(IERC20 token, bytes memory data) private {
638	 bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
639	 if (returndata.length > 0) {
640	 require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
641	 }
642	 }
643	 }
644	 pragma solidity >=0.5.0;
645	 interface IUniswapV3Pool is IUniswapV3PoolImmutables, IUniswapV3PoolState, IUniswapV3PoolDerivedState, IUniswapV3PoolActions, IUniswapV3PoolOwnerActions, IUniswapV3PoolEvents {
646	 }
647	 pragma solidity >=0.5.0;
648	 library TickMath {
649	 int24 internal constant MIN_TICK = -887272;
650	 int24 internal constant MAX_TICK = -MIN_TICK;
651	 uint160 internal constant MIN_SQRT_RATIO = 4295128739;
652	 uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;
653	 function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {
654	 uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));
655	 require(absTick <= uint256(MAX_TICK), 'T');
656	 uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;
657	 if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;
658	 if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;
659	 if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;
660	 if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;
661	 if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;
662	 if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;
663	 if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;
664	 if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;
665	 if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;
666	 if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;
667	 if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;
668	 if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;
669	 if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;
670	 if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;
671	 if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;
672	 if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;
673	 if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;
674	 if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;
675	 if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;
676	 if (tick > 0) ratio = type(uint256).max / ratio;
677	 sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));
678	 }
679	 function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {
680	 require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');
681	 uint256 ratio = uint256(sqrtPriceX96) << 32;
682	 uint256 r = ratio;
683	 uint256 msb = 0;
684	 assembly {
685	 let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) msb := or(msb, f) r := shr(f, r) }
686	 assembly {
687	 let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF)) msb := or(msb, f) r := shr(f, r) }
688	 assembly {
689	 let f := shl(5, gt(r, 0xFFFFFFFF)) msb := or(msb, f) r := shr(f, r) }
690	 assembly {
691	 let f := shl(4, gt(r, 0xFFFF)) msb := or(msb, f) r := shr(f, r) }
692	 assembly {
693	 let f := shl(3, gt(r, 0xFF)) msb := or(msb, f) r := shr(f, r) }
694	 assembly {
695	 let f := shl(2, gt(r, 0xF)) msb := or(msb, f) r := shr(f, r) }
696	 assembly {
697	 let f := shl(1, gt(r, 0x3)) msb := or(msb, f) r := shr(f, r) }
698	 assembly {
699	 let f := gt(r, 0x1) msb := or(msb, f) }
700	 if (msb >= 128) r = ratio >> (msb - 127);
701	 else r = ratio << (127 - msb);
702	 int256 log_2 = (int256(msb) - 128) << 64;
703	 assembly {
704	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(63, f)) r := shr(f, r) }
705	 assembly {
706	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(62, f)) r := shr(f, r) }
707	 assembly {
708	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(61, f)) r := shr(f, r) }
709	 assembly {
710	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(60, f)) r := shr(f, r) }
711	 assembly {
712	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(59, f)) r := shr(f, r) }
713	 assembly {
714	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(58, f)) r := shr(f, r) }
715	 assembly {
716	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(57, f)) r := shr(f, r) }
717	 assembly {
718	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(56, f)) r := shr(f, r) }
719	 assembly {
720	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(55, f)) r := shr(f, r) }
721	 assembly {
722	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(54, f)) r := shr(f, r) }
723	 assembly {
724	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(53, f)) r := shr(f, r) }
725	 assembly {
726	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(52, f)) r := shr(f, r) }
727	 assembly {
728	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(51, f)) r := shr(f, r) }
729	 assembly {
730	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(50, f)) }
731	 int256 log_sqrt10001 = log_2 * 255738958999603826347141;
732	 int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);
733	 int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);
734	 tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;
735	 }
736	 }
737	 pragma solidity >=0.4.0;
738	 library FullMath {
739	 function mulDiv( uint256 a, uint256 b, uint256 denominator ) internal pure returns (uint256 result) {
740	 uint256 prod0;
741	 uint256 prod1;
742	 assembly {
743	 let mm := mulmod(a, b, not(0)) prod0 := mul(a, b) prod1 := sub(sub(mm, prod0), lt(mm, prod0)) }
744	 if (prod1 == 0) {
745	 require(denominator > 0);
746	 assembly {
747	 result := div(prod0, denominator) }
748	 return result;
749	 }
750	 require(denominator > prod1);
751	 uint256 remainder;
752	 assembly {
753	 remainder := mulmod(a, b, denominator) }
754	 assembly {
755	 prod1 := sub(prod1, gt(remainder, prod0)) prod0 := sub(prod0, remainder) }
756	 uint256 twos = -denominator & denominator;
757	 assembly {
758	 denominator := div(denominator, twos) }
759	 assembly {
760	 prod0 := div(prod0, twos) }
761	 assembly {
762	 twos := add(div(sub(0, twos), twos), 1) }
763	 prod0 |= prod1 * twos;
764	 uint256 inv = (3 * denominator) ^ 2;
765	 inv *= 2 - denominator * inv;
766	 inv *= 2 - denominator * inv;
767	 inv *= 2 - denominator * inv;
768	 inv *= 2 - denominator * inv;
769	 inv *= 2 - denominator * inv;
770	 inv *= 2 - denominator * inv;
771	 result = prod0 * inv;
772	 return result;
773	 }
774	 function mulDivRoundingUp( uint256 a, uint256 b, uint256 denominator ) internal pure returns (uint256 result) {
775	 result = mulDiv(a, b, denominator);
776	 if (mulmod(a, b, denominator) > 0) {
777	 require(result < type(uint256).max);
778	 result++;
779	 }
780	 }
781	 }
782	 pragma solidity >=0.5.0;
783	 library LiquidityAmounts {
784	 function toUint128(uint256 x) private pure returns (uint128 y) {
785	 require((y = uint128(x)) == x);
786	 }
787	 function getLiquidityForAmount0( uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint256 amount0 ) internal pure returns (uint128 liquidity) {
788	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
789	 uint256 intermediate = FullMath.mulDiv(sqrtRatioAX96, sqrtRatioBX96, FixedPoint96.Q96);
790	 return toUint128(FullMath.mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));
791	 }
792	 function getLiquidityForAmount1( uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint256 amount1 ) internal pure returns (uint128 liquidity) {
793	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
794	 return toUint128(FullMath.mulDiv(amount1, FixedPoint96.Q96, sqrtRatioBX96 - sqrtRatioAX96));
795	 }
796	 function getLiquidityForAmounts( uint160 sqrtRatioX96, uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint256 amount0, uint256 amount1 ) internal pure returns (uint128 liquidity) {
797	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
798	 if (sqrtRatioX96 <= sqrtRatioAX96) {
799	 liquidity = getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);
800	 }
801	 else if (sqrtRatioX96 < sqrtRatioBX96) {
802	 uint128 liquidity0 = getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);
803	 uint128 liquidity1 = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);
804	 liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;
805	 }
806	 else {
807	 liquidity = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);
808	 }
809	 }
810	 function getAmount0ForLiquidity( uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity ) internal pure returns (uint256 amount0) {
811	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
812	 return FullMath.mulDiv( uint256(liquidity) << FixedPoint96.RESOLUTION, sqrtRatioBX96 - sqrtRatioAX96, sqrtRatioBX96 ) / sqrtRatioAX96;
813	 }
814	 function getAmount1ForLiquidity( uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity ) internal pure returns (uint256 amount1) {
815	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
816	 return FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);
817	 }
818	 function getAmountsForLiquidity( uint160 sqrtRatioX96, uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity ) internal pure returns (uint256 amount0, uint256 amount1) {
819	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
820	 if (sqrtRatioX96 <= sqrtRatioAX96) {
821	 amount0 = getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);
822	 }
823	 else if (sqrtRatioX96 < sqrtRatioBX96) {
824	 amount0 = getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);
825	 amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);
826	 }
827	 else {
828	 amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);
829	 }
830	 }
831	 }
832	 pragma solidity 0.7.6;
833	 interface IUniversalVault {
834	 event Locked(address delegate, address token, uint256 amount);
835	 event Unlocked(address delegate, address token, uint256 amount);
836	 event RageQuit(address delegate, address token, bool notified, string reason);
837	 struct LockData {
838	 address delegate;
839	 address token;
840	 uint256 balance;
841	 }
842	 function initialize() external;
843	 function lock( address token, uint256 amount, bytes calldata permission ) external;
844	 function unlock( address token, uint256 amount, bytes calldata permission ) external;
845	 function rageQuit(address delegate, address token) external returns (bool notified, string memory error);
846	 function transferERC20( address token, address to, uint256 amount ) external;
847	 function transferETH(address to, uint256 amount) external payable;
848	 function calculateLockID(address delegate, address token) external pure returns (bytes32 lockID);
849	 function getPermissionHash( bytes32 eip712TypeHash, address delegate, address token, uint256 amount, uint256 nonce ) external view returns (bytes32 permissionHash);
850	 function getNonce() external view returns (uint256 nonce);
851	 function owner() external view returns (address ownerAddress);
852	 function getLockSetCount() external view returns (uint256 count);
853	 function getLockAt(uint256 index) external view returns (LockData memory lockData);
854	 function getBalanceDelegated(address token, address delegate) external view returns (uint256 balance);
855	 function getBalanceLocked(address token) external view returns (uint256 balance);
856	 function checkBalances() external view returns (bool validity);
857	 }
858	 pragma solidity >=0.6.2 <0.8.0;
859	 library Address {
860	 function isContract(address account) internal view returns (bool) {
861	 uint256 size;
862	 assembly {
863	 size := extcodesize(account) }
864	 return size > 0;
865	 }
866	 function sendValue(address payable recipient, uint256 amount) internal {
867	 require(address(this).balance >= amount, "Address: insufficient balance");
868	 (bool success, ) = recipient.call{
869	 value: amount }
870	 ("");
871	 require(success, "Address: unable to send value, recipient may have reverted");
872	 }
873	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
874	 return functionCall(target, data, "Address: low-level call failed");
875	 }
876	 function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
877	 return functionCallWithValue(target, data, 0, errorMessage);
878	 }
879	 function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
880	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
881	 }
882	 function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
883	 require(address(this).balance >= value, "Address: insufficient balance for call");
884	 require(isContract(target), "Address: call to non-contract");
885	 (bool success, bytes memory returndata) = target.call{
886	 value: value }
887	 (data);
888	 return _verifyCallResult(success, returndata, errorMessage);
889	 }
890	 function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
891	 return functionStaticCall(target, data, "Address: low-level static call failed");
892	 }
893	 function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
894	 require(isContract(target), "Address: static call to non-contract");
895	 (bool success, bytes memory returndata) = target.staticcall(data);
896	 return _verifyCallResult(success, returndata, errorMessage);
897	 }
898	 function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
899	 return functionDelegateCall(target, data, "Address: low-level delegate call failed");
900	 }
901	 function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
902	 require(isContract(target), "Address: delegate call to non-contract");
903	 (bool success, bytes memory returndata) = target.delegatecall(data);
904	 return _verifyCallResult(success, returndata, errorMessage);
905	 }
906	 function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
907	 if (success) {
908	 return returndata;
909	 }
910	 else {
911	 if (returndata.length > 0) {
912	 assembly {
913	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
914	 }
915	 else {
916	 revert(errorMessage);
917	 }
918	 }
919	 }
920	 }
921	 pragma solidity >=0.6.0 <0.8.0;
922	 library ECDSA {
923	 function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {
924	 if (signature.length != 65) {
925	 revert("ECDSA: invalid signature length");
926	 }
927	 bytes32 r;
928	 bytes32 s;
929	 uint8 v;
930	 assembly {
931	 r := mload(add(signature, 0x20)) s := mload(add(signature, 0x40)) v := byte(0, mload(add(signature, 0x60))) }
932	 return recover(hash, v, r, s);
933	 }
934	 function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {
935	 require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, "ECDSA: invalid signature 's' value");
936	 require(v == 27 || v == 28, "ECDSA: invalid signature 'v' value");
937	 address signer = ecrecover(hash, v, r, s);
938	 require(signer != address(0), "ECDSA: invalid signature");
939	 return signer;
940	 }
941	 function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {
942	 return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
943	 }
944	 }
945	 pragma solidity >=0.6.0 <0.8.0;
946	 library Counters {
947	 using SafeMath for uint256;
948	 struct Counter {
949	 uint256 _value;
950	 }
951	 function current(Counter storage counter) internal view returns (uint256) {
952	 return counter._value;
953	 }
954	 function increment(Counter storage counter) internal {
955	 counter._value += 1;
956	 }
957	 function decrement(Counter storage counter) internal {
958	 counter._value = counter._value.sub(1);
959	 }
960	 }
961	 pragma solidity >=0.4.0;
962	 library FixedPoint96 {
963	 uint8 internal constant RESOLUTION = 96;
964	 uint256 internal constant Q96 = 0x1000000000000000000000000;
965	 }
