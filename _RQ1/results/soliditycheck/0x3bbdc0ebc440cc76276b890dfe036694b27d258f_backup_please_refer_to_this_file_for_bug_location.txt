row number 
1	   pragma solidity ^0.4.4;
2	 contract Token {
3	 function totalSupply() constant returns (uint256 supply) {
4	 }
5	 function balanceOf(address _owner) constant returns (uint256 balance) {
6	 }
7	 function transfer(address _to, uint256 _value) returns (bool success) {
8	 }
9	 function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
10	 }
11	 function approve(address _spender, uint256 _value) returns (bool success) {
12	 }
13	 function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
14	 }
15	 event Transfer(address indexed _from, address indexed _to, uint256 _value);
16	 event Approval(address indexed _owner, address indexed _spender, uint256 _value);
17	 }
18	 contract StandardToken is Token {
19	 function transfer(address _to, uint256 _value) returns (bool success) {
20	 if (balances[msg.sender] >= _value && _value > 0) {
21	 balances[msg.sender] -= _value;
22	 balances[_to] += _value;
23	 Transfer(msg.sender, _to, _value);
24	 return true;
25	 }
26	 else {
27	 return false;
28	 }
29	 }
30	 function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
31	 if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
32	 balances[_to] += _value;
33	 balances[_from] -= _value;
34	 allowed[_from][msg.sender] -= _value;
35	 Transfer(_from, _to, _value);
36	 return true;
37	 }
38	 else {
39	 return false;
40	 }
41	 }
42	 function balanceOf(address _owner) constant returns (uint256 balance) {
43	 return balances[_owner];
44	 }
45	 function approve(address _spender, uint256 _value) returns (bool success) {
46	 allowed[msg.sender][_spender] = _value;
47	 Approval(msg.sender, _spender, _value);
48	 return true;
49	 }
50	 function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
51	 return allowed[_owner][_spender];
52	 }
53	 mapping (address => uint256) balances;
54	 mapping (address => mapping (address => uint256)) allowed;
55	 uint256 public totalSupply;
56	 }
57	 contract Raffle is StandardToken {
58	 string public name;
59	 uint8 public decimals;
60	 string public symbol;
61	 string public version = 'H1.0';
62	 uint256 public unitsOneEthCanBuy;
63	 uint256 public totalEthInWei;
64	 address public fundsWallet;
65	 function Raffle() {
66	 balances[msg.sender] = 1000000000000000000000000000000;
67	 totalSupply = 1000000000000000000000000000000;
68	 name = "Rafflecoin";
69	 decimals = 18;
70	 symbol = "Rafflecoin";
71	 unitsOneEthCanBuy = 600;
72	 fundsWallet = msg.sender;
73	 }
74	 function() payable{
75	 totalEthInWei = totalEthInWei + msg.value;
76	 uint256 amount = msg.value * unitsOneEthCanBuy;
77	 require(balances[fundsWallet] >= amount);
78	 balances[fundsWallet] = balances[fundsWallet] - amount;
79	 balances[msg.sender] = balances[msg.sender] + amount;
80	 Transfer(fundsWallet, msg.sender, amount);
81	 fundsWallet.transfer(msg.value);
82	 }
83	 function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
84	 allowed[msg.sender][_spender] = _value;
85	 Approval(msg.sender, _spender, _value);
86	 if(!_spender.call(bytes4(bytes32(sha3("receiveApproval(address,uint256,address,bytes)"))), msg.sender, _value, this, _extraData)) {
87	 throw;
88	 }
89	 return true;
90	 }
91	 }
