row number 
1	           pragma solidity ^0.6.2;
2	 abstract contract Context {
3	 function _msgSender() internal view virtual returns (address) {
4	 return msg.sender;
5	 }
6	 function _msgData() internal view virtual returns (bytes calldata) {
7	 this;
8	 return msg.data;
9	 }
10	 }
11	 interface IERC20 {
12	 function totalSupply() external view returns (uint256);
13	 function balanceOf(address account) external view returns (uint256);
14	 function transfer(address recipient, uint256 amount) external returns (bool);
15	 function allowance(address owner, address spender) external view returns (uint256);
16	 function approve(address spender, uint256 amount) external returns (bool);
17	 function transferFrom( address sender, address recipient, uint256 amount ) external returns (bool);
18	 event Transfer(address indexed from, address indexed to, uint256 value);
19	 event Approval(address indexed owner, address indexed spender, uint256 value);
20	 }
21	 interface IERC20Metadata is IERC20 {
22	 function name() external view returns (string memory);
23	 function symbol() external view returns (string memory);
24	 function decimals() external view returns (uint8);
25	 }
26	 interface DividendPayingTokenOptionalInterface {
27	 function withdrawableDividendOf(address _owner) external view returns(uint256);
28	 function withdrawnDividendOf(address _owner) external view returns(uint256);
29	 function accumulativeDividendOf(address _owner) external view returns(uint256);
30	 }
31	 interface DividendPayingTokenInterface {
32	 function dividendOf(address _owner) external view returns(uint256);
33	 function distributeDividends() external payable;
34	 function withdrawDividend() external;
35	 event DividendsDistributed( address indexed from, uint256 weiAmount );
36	 event DividendWithdrawn( address indexed to, uint256 weiAmount );
37	 }
38	 library SafeMathInt {
39	 int256 private constant MIN_INT256 = int256(1) << 255;
40	 int256 private constant MAX_INT256 = ~(int256(1) << 255);
41	 function mul(int256 a, int256 b) internal pure returns (int256) {
42	 int256 c = a * b;
43	 require(c != MIN_INT256 || (a & MIN_INT256) != (b & MIN_INT256));
44	 require((b == 0) || (c / b == a));
45	 return c;
46	 }
47	 function div(int256 a, int256 b) internal pure returns (int256) {
48	 require(b != -1 || a != MIN_INT256);
49	 return a / b;
50	 }
51	 function sub(int256 a, int256 b) internal pure returns (int256) {
52	 int256 c = a - b;
53	 require((b >= 0 && c <= a) || (b < 0 && c > a));
54	 return c;
55	 }
56	 function add(int256 a, int256 b) internal pure returns (int256) {
57	 int256 c = a + b;
58	 require((b >= 0 && c >= a) || (b < 0 && c < a));
59	 return c;
60	 }
61	 function abs(int256 a) internal pure returns (int256) {
62	 require(a != MIN_INT256);
63	 return a < 0 ? -a : a;
64	 }
65	 function toUint256Safe(int256 a) internal pure returns (uint256) {
66	 require(a >= 0);
67	 return uint256(a);
68	 }
69	 }
70	 library SafeMathUint {
71	 function toInt256Safe(uint256 a) internal pure returns (int256) {
72	 int256 b = int256(a);
73	 require(b >= 0);
74	 return b;
75	 }
76	 }
77	 library SafeMath {
78	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
79	 uint256 c = a + b;
80	 require(c >= a, "SafeMath: addition overflow");
81	 return c;
82	 }
83	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
84	 return sub(a, b, "SafeMath: subtraction overflow");
85	 }
86	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
87	 require(b <= a, errorMessage);
88	 uint256 c = a - b;
89	 return c;
90	 }
91	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
92	 if (a == 0) {
93	 return 0;
94	 }
95	 uint256 c = a * b;
96	 require(c / a == b, "SafeMath: multiplication overflow");
97	 return c;
98	 }
99	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
100	 return div(a, b, "SafeMath: division by zero");
101	 }
102	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
103	 require(b > 0, errorMessage);
104	 uint256 c = a / b;
105	 return c;
106	 }
107	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
108	 return mod(a, b, "SafeMath: modulo by zero");
109	 }
110	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
111	 require(b != 0, errorMessage);
112	 return a % b;
113	 }
114	 }
115	 contract Ownable is Context {
116	 address private _owner;
117	 event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
118	 constructor () public {
119	 address msgSender = _msgSender();
120	 _owner = msgSender;
121	 emit OwnershipTransferred(address(0), _owner);
122	 }
123	 function owner() public view returns (address) {
124	 return _owner;
125	 }
126	 modifier onlyOwner() {
127	 require(_owner == _msgSender(), "Ownable: caller is not the owner");
128	 _;
129	 }
130	 function renounceOwnership() public virtual onlyOwner {
131	 emit OwnershipTransferred(_owner, address(0));
132	 _owner = address(0);
133	 }
134	 function transferOwnership(address newOwner) public virtual onlyOwner {
135	 require(newOwner != address(0), "Ownable: new owner is the zero address");
136	 emit OwnershipTransferred(_owner, newOwner);
137	 _owner = newOwner;
138	 }
139	 }
140	 contract ERC20 is Context, IERC20, IERC20Metadata, Ownable {
141	 using SafeMath for uint256;
142	 mapping(address => uint256) private _balances;
143	 mapping(address => mapping(address => uint256)) private _allowances;
144	 uint256 private _totalSupply;
145	 string private _name;
146	 string private _symbol;
147	 constructor(string memory name_, string memory symbol_) public {
148	 _name = name_;
149	 _symbol = symbol_;
150	 }
151	 function name() public view virtual override returns (string memory) {
152	 return _name;
153	 }
154	 function symbol() public view virtual override returns (string memory) {
155	 return _symbol;
156	 }
157	 function decimals() public view virtual override returns (uint8) {
158	 return 18;
159	 }
160	 function totalSupply() public view virtual override returns (uint256) {
161	 return _totalSupply;
162	 }
163	 function balanceOf(address account) public view virtual override returns (uint256) {
164	 return _balances[account];
165	 }
166	 function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
167	 _transfer(_msgSender(), recipient, amount);
168	 return true;
169	 }
170	 function allowance(address owner, address spender) public view virtual override returns (uint256) {
171	 return _allowances[owner][spender];
172	 }
173	 function approve(address spender, uint256 amount) public virtual override returns (bool) {
174	 _approve(_msgSender(), spender, amount);
175	 return true;
176	 }
177	 function transferFrom( address sender, address recipient, uint256 amount ) public virtual override returns (bool) {
178	 _transfer(sender, recipient, amount);
179	 _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
180	 return true;
181	 }
182	 function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
183	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
184	 return true;
185	 }
186	 function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
187	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
188	 return true;
189	 }
190	 function _transfer( address sender, address recipient, uint256 amount ) internal virtual {
191	 require(sender != address(0), "ERC20: transfer from the zero address");
192	 require(recipient != address(0), "ERC20: transfer to the zero address");
193	 _beforeTokenTransfer(sender, recipient, amount);
194	 _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
195	 _balances[recipient] = _balances[recipient].add(amount);
196	 emit Transfer(sender, recipient, amount);
197	 }
198	 function _mint(address account, uint256 amount) internal virtual {
199	 require(account != address(0), "ERC20: mint to the zero address");
200	 _beforeTokenTransfer(address(0), account, amount);
201	 _totalSupply = _totalSupply.add(amount);
202	 _balances[account] = _balances[account].add(amount);
203	 emit Transfer(address(0), account, amount);
204	 }
205	 function _burn(address account, uint256 amount) internal virtual {
206	 require(account != address(0), "ERC20: burn from the zero address");
207	 _beforeTokenTransfer(account, address(0), amount);
208	 _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
209	 _totalSupply = _totalSupply.sub(amount);
210	 emit Transfer(account, address(0), amount);
211	 }
212	 function _approve( address owner, address spender, uint256 amount ) internal virtual {
213	 require(owner != address(0), "ERC20: approve from the zero address");
214	 require(spender != address(0), "ERC20: approve to the zero address");
215	 _allowances[owner][spender] = amount;
216	 emit Approval(owner, spender, amount);
217	 }
218	 function _beforeTokenTransfer( address from, address to, uint256 amount ) internal virtual {
219	 }
220	 }
221	 interface IUniswapV2Router01 {
222	 function factory() external pure returns (address);
223	 function WETH() external pure returns (address);
224	 function addLiquidity( address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline ) external returns (uint amountA, uint amountB, uint liquidity);
225	 function addLiquidityETH( address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
226	 function removeLiquidity( address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline ) external returns (uint amountA, uint amountB);
227	 function removeLiquidityETH( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) external returns (uint amountToken, uint amountETH);
228	 function removeLiquidityWithPermit( address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s ) external returns (uint amountA, uint amountB);
229	 function removeLiquidityETHWithPermit( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s ) external returns (uint amountToken, uint amountETH);
230	 function swapExactTokensForTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external returns (uint[] memory amounts);
231	 function swapTokensForExactTokens( uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline ) external returns (uint[] memory amounts);
232	 function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);
233	 function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);
234	 function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);
235	 function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);
236	 function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);
237	 function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);
238	 function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);
239	 function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);
240	 function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);
241	 }
242	 interface IUniswapV2Router02 is IUniswapV2Router01 {
243	 function removeLiquidityETHSupportingFeeOnTransferTokens( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) external returns (uint amountETH);
244	 function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s ) external returns (uint amountETH);
245	 function swapExactTokensForTokensSupportingFeeOnTransferTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external;
246	 function swapExactETHForTokensSupportingFeeOnTransferTokens( uint amountOutMin, address[] calldata path, address to, uint deadline ) external payable;
247	 function swapExactTokensForETHSupportingFeeOnTransferTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external;
248	 }
249	 interface IUniswapV2Factory {
250	 event PairCreated(address indexed token0, address indexed token1, address pair, uint);
251	 function feeTo() external view returns (address);
252	 function feeToSetter() external view returns (address);
253	 function getPair(address tokenA, address tokenB) external view returns (address pair);
254	 function allPairs(uint) external view returns (address pair);
255	 function allPairsLength() external view returns (uint);
256	 function createPair(address tokenA, address tokenB) external returns (address pair);
257	 function setFeeTo(address) external;
258	 function setFeeToSetter(address) external;
259	 }
260	 interface IUniswapV2Pair {
261	 event Approval(address indexed owner, address indexed spender, uint value);
262	 event Transfer(address indexed from, address indexed to, uint value);
263	 function name() external pure returns (string memory);
264	 function symbol() external pure returns (string memory);
265	 function decimals() external pure returns (uint8);
266	 function totalSupply() external view returns (uint);
267	 function balanceOf(address owner) external view returns (uint);
268	 function allowance(address owner, address spender) external view returns (uint);
269	 function approve(address spender, uint value) external returns (bool);
270	 function transfer(address to, uint value) external returns (bool);
271	 function transferFrom(address from, address to, uint value) external returns (bool);
272	 function DOMAIN_SEPARATOR() external view returns (bytes32);
273	 function PERMIT_TYPEHASH() external pure returns (bytes32);
274	 function nonces(address owner) external view returns (uint);
275	 function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;
276	 event Mint(address indexed sender, uint amount0, uint amount1);
277	 event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
278	 event Swap( address indexed sender, uint amount0In, uint amount1In, uint amount0Out, uint amount1Out, address indexed to );
279	 event Sync(uint112 reserve0, uint112 reserve1);
280	 function MINIMUM_LIQUIDITY() external pure returns (uint);
281	 function factory() external view returns (address);
282	 function token0() external view returns (address);
283	 function token1() external view returns (address);
284	 function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
285	 function price0CumulativeLast() external view returns (uint);
286	 function price1CumulativeLast() external view returns (uint);
287	 function kLast() external view returns (uint);
288	 function mint(address to) external returns (uint liquidity);
289	 function burn(address to) external returns (uint amount0, uint amount1);
290	 function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
291	 function skim(address to) external;
292	 function sync() external;
293	 function initialize(address, address) external;
294	 }
295	 library IterableMapping {
296	 struct Map {
297	 address[] keys;
298	 mapping(address => uint) values;
299	 mapping(address => uint) indexOf;
300	 mapping(address => bool) inserted;
301	 }
302	 function get(Map storage map, address key) public view returns (uint) {
303	 return map.values[key];
304	 }
305	 function getIndexOfKey(Map storage map, address key) public view returns (int) {
306	 if(!map.inserted[key]) {
307	 return -1;
308	 }
309	 return int(map.indexOf[key]);
310	 }
311	 function getKeyAtIndex(Map storage map, uint index) public view returns (address) {
312	 return map.keys[index];
313	 }
314	 function size(Map storage map) public view returns (uint) {
315	 return map.keys.length;
316	 }
317	 function set(Map storage map, address key, uint val) public {
318	 if (map.inserted[key]) {
319	 map.values[key] = val;
320	 }
321	 else {
322	 map.inserted[key] = true;
323	 map.values[key] = val;
324	 map.indexOf[key] = map.keys.length;
325	 map.keys.push(key);
326	 }
327	 }
328	 function remove(Map storage map, address key) public {
329	 if (!map.inserted[key]) {
330	 return;
331	 }
332	 delete map.inserted[key];
333	 delete map.values[key];
334	 uint index = map.indexOf[key];
335	 uint lastIndex = map.keys.length - 1;
336	 address lastKey = map.keys[lastIndex];
337	 map.indexOf[lastKey] = index;
338	 delete map.indexOf[key];
339	 map.keys[index] = lastKey;
340	 map.keys.pop();
341	 }
342	 }
343	 contract DividendPayingToken is ERC20, DividendPayingTokenInterface, DividendPayingTokenOptionalInterface {
344	 using SafeMath for uint256;
345	 using SafeMathUint for uint256;
346	 using SafeMathInt for int256;
347	 uint256 constant internal magnitude = 2**128;
348	 uint256 internal magnifiedDividendPerShare;
349	 mapping(address => int256) internal magnifiedDividendCorrections;
350	 mapping(address => uint256) internal withdrawnDividends;
351	 uint256 public totalDividendsDistributed;
352	 constructor(string memory _name, string memory _symbol) public ERC20(_name, _symbol) {
353	 }
354	 receive() external payable {
355	 distributeDividends();
356	 }
357	 function distributeDividends() public override payable {
358	 require(totalSupply() > 0);
359	 if (msg.value > 0) {
360	 magnifiedDividendPerShare = magnifiedDividendPerShare.add( (msg.value).mul(magnitude) / totalSupply() );
361	 emit DividendsDistributed(msg.sender, msg.value);
362	 totalDividendsDistributed = totalDividendsDistributed.add(msg.value);
363	 }
364	 }
365	 function withdrawDividend() public virtual override {
366	 _withdrawDividendOfUser(msg.sender);
367	 }
368	 function _withdrawDividendOfUser(address payable user) internal returns (uint256) {
369	 uint256 _withdrawableDividend = withdrawableDividendOf(user);
370	 if (_withdrawableDividend > 0) {
371	 withdrawnDividends[user] = withdrawnDividends[user].add(_withdrawableDividend);
372	 emit DividendWithdrawn(user, _withdrawableDividend);
373	 (bool success,) = user.call{
374	 value: _withdrawableDividend, gas: 3000}
375	 ("");
376	 if(!success) {
377	 withdrawnDividends[user] = withdrawnDividends[user].sub(_withdrawableDividend);
378	 return 0;
379	 }
380	 return _withdrawableDividend;
381	 }
382	 return 0;
383	 }
384	 function dividendOf(address _owner) public view override returns(uint256) {
385	 return withdrawableDividendOf(_owner);
386	 }
387	 function withdrawableDividendOf(address _owner) public view override returns(uint256) {
388	 return accumulativeDividendOf(_owner).sub(withdrawnDividends[_owner]);
389	 }
390	 function withdrawnDividendOf(address _owner) public view override returns(uint256) {
391	 return withdrawnDividends[_owner];
392	 }
393	 function accumulativeDividendOf(address _owner) public view override returns(uint256) {
394	 return magnifiedDividendPerShare.mul(balanceOf(_owner)).toInt256Safe() .add(magnifiedDividendCorrections[_owner]).toUint256Safe() / magnitude;
395	 }
396	 function _transfer(address from, address to, uint256 value) internal virtual override {
397	 require(false);
398	 int256 _magCorrection = magnifiedDividendPerShare.mul(value).toInt256Safe();
399	 magnifiedDividendCorrections[from] = magnifiedDividendCorrections[from].add(_magCorrection);
400	 magnifiedDividendCorrections[to] = magnifiedDividendCorrections[to].sub(_magCorrection);
401	 }
402	 function _mint(address account, uint256 value) internal override {
403	 super._mint(account, value);
404	 magnifiedDividendCorrections[account] = magnifiedDividendCorrections[account] .sub( (magnifiedDividendPerShare.mul(value)).toInt256Safe() );
405	 }
406	 function _burn(address account, uint256 value) internal override {
407	 super._burn(account, value);
408	 magnifiedDividendCorrections[account] = magnifiedDividendCorrections[account] .add( (magnifiedDividendPerShare.mul(value)).toInt256Safe() );
409	 }
410	 function _setBalance(address account, uint256 newBalance) internal {
411	 uint256 currentBalance = balanceOf(account);
412	 if(newBalance > currentBalance) {
413	 uint256 mintAmount = newBalance.sub(currentBalance);
414	 _mint(account, mintAmount);
415	 }
416	 else if(newBalance < currentBalance) {
417	 uint256 burnAmount = currentBalance.sub(newBalance);
418	 _burn(account, burnAmount);
419	 }
420	 }
421	 }
422	 contract VNS6 is ERC20 {
423	 using SafeMath for uint256;
424	 IUniswapV2Router02 public uniswapV2Router;
425	 address public immutable uniswapV2Pair;
426	 bool private swapping;
427	 bool public pauseSell = false;
428	 bool public pauseBuy = false;
429	 VNS6DividendTracker public dividendTracker;
430	 address public liquidityWallet;
431	 address payable public marketingWallet = 0x31b7EFac2D8BD38697eFE8e7AacEDFc3575de906;
432	 uint256 public swapTokensAtAmount = 1000000 * (10**18);
433	 uint256 public maxWalletToken = 10000000000000 * (10**18);
434	 uint256 public immutable ETHRewardsFee;
435	 uint256 public immutable liquidityFee;
436	 uint256 public immutable MarketingWalletFee;
437	 uint256 public immutable totalFees;
438	 uint256 public sellFeeIncreaseFactor = 120;
439	 uint256 public gasForProcessing = 50000;
440	 mapping (address => bool) private _isExcludedFromFees;
441	 mapping (address => bool) public blackList;
442	 mapping (address => bool) public automatedMarketMakerPairs;
443	 event UpdateDividendTracker(address indexed newAddress, address indexed oldAddress);
444	 event UpdateUniswapV2Router(address indexed newAddress, address indexed oldAddress);
445	 event ExcludeFromFees(address indexed account, bool isExcluded);
446	 event ExcludeMultipleAccountsFromFees(address[] accounts, bool isExcluded);
447	 event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);
448	 event LiquidityWalletUpdated(address indexed newLiquidityWallet, address indexed oldLiquidityWallet);
449	 event GasForProcessingUpdated(uint256 indexed newValue, uint256 indexed oldValue);
450	 event SwapAndLiquify( uint256 tokensSwapped, uint256 ethReceived, uint256 tokensIntoLiqudity );
451	 event SendDividends( uint256 tokensSwapped, uint256 amount );
452	 event ProcessedDividendTracker( uint256 iterations, uint256 claims, uint256 lastProcessedIndex, bool indexed automatic, uint256 gas, address indexed processor );
453	 constructor() public ERC20("VENUSIAN 6th", "VNS6") {
454	 uint256 _ETHRewardsFee = 2;
455	 uint256 _liquidityFee = 2;
456	 uint256 _MarketingWalletFee = 6;
457	 ETHRewardsFee = _ETHRewardsFee;
458	 liquidityFee = _liquidityFee;
459	 MarketingWalletFee = _MarketingWalletFee;
460	 totalFees = _ETHRewardsFee.add(_liquidityFee).add(_MarketingWalletFee);
461	 dividendTracker = new VNS6DividendTracker();
462	 liquidityWallet = owner();
463	 IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
464	 address _uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()) .createPair(address(this), _uniswapV2Router.WETH());
465	 uniswapV2Router = _uniswapV2Router;
466	 uniswapV2Pair = _uniswapV2Pair;
467	 _setAutomatedMarketMakerPair(_uniswapV2Pair, true);
468	 dividendTracker.excludeFromDividends(address(dividendTracker));
469	 dividendTracker.excludeFromDividends(address(this));
470	 dividendTracker.excludeFromDividends(owner());
471	 dividendTracker.excludeFromDividends(address(_uniswapV2Router));
472	 excludeFromFees(liquidityWallet, true);
473	 excludeFromFees(address(this), true);
474	 _mint(owner(), 1000000000000000 * (10**18));
475	 }
476	 receive() external payable {
477	 }
478	 function updateDividendTracker(address newAddress) public onlyOwner {
479	 require(newAddress != address(dividendTracker), "The dividend tracker already has that address");
480	 VNS6DividendTracker newDividendTracker = VNS6DividendTracker(payable(newAddress));
481	 require(newDividendTracker.owner() == address(this), "The new dividend tracker must be owned by the VNS6 token contract");
482	 newDividendTracker.excludeFromDividends(address(newDividendTracker));
483	 newDividendTracker.excludeFromDividends(address(this));
484	 newDividendTracker.excludeFromDividends(owner());
485	 newDividendTracker.excludeFromDividends(address(uniswapV2Router));
486	 emit UpdateDividendTracker(newAddress, address(dividendTracker));
487	 dividendTracker = newDividendTracker;
488	 }
489	 function updateUniswapV2Router(address newAddress) public onlyOwner {
490	 require(newAddress != address(uniswapV2Router), "The router already has that address");
491	 emit UpdateUniswapV2Router(newAddress, address(uniswapV2Router));
492	 uniswapV2Router = IUniswapV2Router02(newAddress);
493	 }
494	 function setSellStatus(bool enabled) external onlyOwner {
495	 pauseSell = enabled;
496	 }
497	 function setBuyStatus(bool enabled) external onlyOwner {
498	 pauseBuy = enabled;
499	 }
500	 function excludeFromFees(address account, bool excluded) public onlyOwner {
501	 require(_isExcludedFromFees[account] != excluded, "VNS6: Account is already the value of 'excluded'");
502	 _isExcludedFromFees[account] = excluded;
503	 emit ExcludeFromFees(account, excluded);
504	 }
505	 function setMaxWalletToken(uint256 maxToken) external onlyOwner {
506	 maxWalletToken = maxToken * (10**18);
507	 }
508	 function excludeFromDividends(address account) external onlyOwner {
509	 dividendTracker.excludeFromDividends(account);
510	 }
511	 function setSellFactor(uint256 newFactor) external onlyOwner {
512	 sellFeeIncreaseFactor = newFactor;
513	 }
514	 function setSwapAtAmount(uint256 newAmount) external onlyOwner {
515	 swapTokensAtAmount = newAmount * (10**18);
516	 }
517	 function changeMinimumHoldingLimit(uint256 newLimit) public onlyOwner {
518	 dividendTracker.setMinimumTokenBalanceForDividends(newLimit);
519	 }
520	 function excludeMultipleAccountsFromFees(address[] calldata accounts, bool excluded) public onlyOwner {
521	 for(uint256 i = 0; i < accounts.length; i++) {
522	 _isExcludedFromFees[accounts[i]] = excluded;
523	 }
524	 emit ExcludeMultipleAccountsFromFees(accounts, excluded);
525	 }
526	 function changeMarketingWallet(address payable newAddress) external onlyOwner {
527	 marketingWallet = newAddress;
528	 }
529	 function setAutomatedMarketMakerPair(address pair, bool value) public onlyOwner {
530	 require(pair != uniswapV2Pair, "The Uniswap pair cannot be removed from automatedMarketMakerPairs");
531	 _setAutomatedMarketMakerPair(pair, value);
532	 }
533	 function _setAutomatedMarketMakerPair(address pair, bool value) private {
534	 require(automatedMarketMakerPairs[pair] != value, "Automated market maker pair is already set to that value");
535	 automatedMarketMakerPairs[pair] = value;
536	 if(value) {
537	 dividendTracker.excludeFromDividends(pair);
538	 }
539	 emit SetAutomatedMarketMakerPair(pair, value);
540	 }
541	 function sendETHToWallets(uint256 amount) private {
542	 swapTokensForEth(amount);
543	 marketingWallet.transfer(address(this).balance);
544	 }
545	 function updateLiquidityWallet(address newLiquidityWallet) public onlyOwner {
546	 require(newLiquidityWallet != liquidityWallet, "VNS6: The liquidity wallet is already this address");
547	 excludeFromFees(newLiquidityWallet, true);
548	 emit LiquidityWalletUpdated(newLiquidityWallet, liquidityWallet);
549	 liquidityWallet = newLiquidityWallet;
550	 }
551	 function updateGasForProcessing(uint256 newValue) public onlyOwner {
552	 require(newValue != gasForProcessing, "VNS6: Cannot update gasForProcessing to same value");
553	 emit GasForProcessingUpdated(newValue, gasForProcessing);
554	 gasForProcessing = newValue;
555	 }
556	 function blackListAddress(address account) external onlyOwner {
557	 blackList[account] = true;
558	 }
559	 function unBlockAddress(address account) external onlyOwner {
560	 blackList[account] = false;
561	 }
562	 function updateClaimWait(uint256 claimWait) external onlyOwner {
563	 dividendTracker.updateClaimWait(claimWait);
564	 }
565	 function getClaimWait() external view returns(uint256) {
566	 return dividendTracker.claimWait();
567	 }
568	 function minimumLimitForDividend() public view returns(uint256) {
569	 return dividendTracker.minimumTokenLimit();
570	 }
571	 function getTotalDividendsDistributed() external view returns (uint256) {
572	 return dividendTracker.totalDividendsDistributed();
573	 }
574	 function isExcludedFromFees(address account) public view returns(bool) {
575	 return _isExcludedFromFees[account];
576	 }
577	 function isExcludedFromDividends(address account) public view returns(bool) {
578	 return dividendTracker.excludedFromDividends(account);
579	 }
580	 function withdrawableDividendOf(address account) public view returns(uint256) {
581	 return dividendTracker.withdrawableDividendOf(account);
582	 }
583	 function dividendTokenBalanceOf(address account) public view returns (uint256) {
584	 return dividendTracker.balanceOf(account);
585	 }
586	 function getAccountDividendsInfo(address account) external view returns ( address, int256, int256, uint256, uint256, uint256, uint256, uint256) {
587	 return dividendTracker.getAccount(account);
588	 }
589	 function getAccountDividendsInfoAtIndex(uint256 index) external view returns ( address, int256, int256, uint256, uint256, uint256, uint256, uint256) {
590	 return dividendTracker.getAccountAtIndex(index);
591	 }
592	 function processDividendTracker(uint256 gas) external {
593	 (uint256 iterations, uint256 claims, uint256 lastProcessedIndex) = dividendTracker.process(gas);
594	 emit ProcessedDividendTracker(iterations, claims, lastProcessedIndex, false, gas, tx.origin);
595	 }
596	 function claim() external {
597	 dividendTracker.processAccount(msg.sender, false);
598	 }
599	 function getLastProcessedIndex() external view returns(uint256) {
600	 return dividendTracker.getLastProcessedIndex();
601	 }
602	 function getNumberOfDividendTokenHolders() external view returns(uint256) {
603	 return dividendTracker.getNumberOfTokenHolders();
604	 }
605	 function _transfer( address from, address to, uint256 amount ) internal override {
606	 require(from != address(0), "ERC20: transfer from the zero address");
607	 require(to != address(0), "ERC20: transfer to the zero address");
608	 if(amount == 0) {
609	 super._transfer(from, to, 0);
610	 return;
611	 }
612	 if ( automatedMarketMakerPairs[from] ) {
613	 uint256 contractBalanceRecepient = balanceOf(to);
614	 require( contractBalanceRecepient + amount <= maxWalletToken, "Exceeds maximum wallet token amount." );
615	 }
616	 if(blackList[from] == true || blackList[to] == true) {
617	 revert();
618	 }
619	 if(to == uniswapV2Pair && pauseSell == true && from != owner()) {
620	 revert();
621	 }
622	 if(from == uniswapV2Pair && pauseBuy == true && to != owner()) {
623	 revert();
624	 }
625	 uint256 contractTokenBalance = balanceOf(address(this));
626	 bool canSwap = contractTokenBalance >= swapTokensAtAmount;
627	 if( canSwap && !swapping && !automatedMarketMakerPairs[from] && from != liquidityWallet && to != liquidityWallet ) {
628	 swapping = true;
629	 uint256 devWalletTokens = contractTokenBalance.mul(MarketingWalletFee).div(totalFees);
630	 sendETHToWallets(devWalletTokens);
631	 uint256 swapTokens = contractTokenBalance.mul(liquidityFee).div(totalFees);
632	 swapAndLiquify(swapTokens);
633	 uint256 sellTokens = balanceOf(address(this));
634	 swapAndSendDividends(sellTokens);
635	 swapping = false;
636	 }
637	 bool takeFee = !swapping;
638	 if(_isExcludedFromFees[from] || _isExcludedFromFees[to]) {
639	 takeFee = false;
640	 }
641	 if(takeFee) {
642	 uint256 fees = amount.mul(totalFees).div(100);
643	 if(automatedMarketMakerPairs[to]) {
644	 fees = fees.mul(sellFeeIncreaseFactor).div(100);
645	 }
646	 amount = amount.sub(fees);
647	 super._transfer(from, address(this), fees);
648	 }
649	 super._transfer(from, to, amount);
650	 try dividendTracker.setBalance(payable(from), balanceOf(from)) {
651	 }
652	 catch {
653	 }
654	 try dividendTracker.setBalance(payable(to), balanceOf(to)) {
655	 }
656	 catch {
657	 }
658	 if(!swapping) {
659	 uint256 gas = gasForProcessing;
660	 try dividendTracker.process(gas) returns (uint256 iterations, uint256 claims, uint256 lastProcessedIndex) {
661	 emit ProcessedDividendTracker(iterations, claims, lastProcessedIndex, true, gas, tx.origin);
662	 }
663	 catch {
664	 }
665	 }
666	 }
667	 function swapAndLiquify(uint256 tokens) private {
668	 uint256 half = tokens.div(2);
669	 uint256 otherHalf = tokens.sub(half);
670	 uint256 initialBalance = address(this).balance;
671	 swapTokensForEth(half);
672	 uint256 newBalance = address(this).balance.sub(initialBalance);
673	 addLiquidity(otherHalf, newBalance);
674	 emit SwapAndLiquify(half, newBalance, otherHalf);
675	 }
676	 function swapTokensForEth(uint256 tokenAmount) private {
677	 address[] memory path = new address[](2);
678	 path[0] = address(this);
679	 path[1] = uniswapV2Router.WETH();
680	 _approve(address(this), address(uniswapV2Router), tokenAmount);
681	 uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens( tokenAmount, 0, path, address(this), block.timestamp );
682	 }
683	 function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {
684	 _approve(address(this), address(uniswapV2Router), tokenAmount);
685	 uniswapV2Router.addLiquidityETH{
686	 value: ethAmount}
687	 ( address(this), tokenAmount, 0, 0, liquidityWallet, block.timestamp );
688	 }
689	 function swapAndSendDividends(uint256 tokens) private {
690	 swapTokensForEth(tokens);
691	 uint256 dividends = address(this).balance;
692	 (bool success,) = address(dividendTracker).call{
693	 value: dividends}
694	 ("");
695	 if(success) {
696	 emit SendDividends(tokens, dividends);
697	 }
698	 }
699	 }
700	 contract VNS6DividendTracker is DividendPayingToken {
701	 using SafeMath for uint256;
702	 using SafeMathInt for int256;
703	 using IterableMapping for IterableMapping.Map;
704	 IterableMapping.Map private tokenHoldersMap;
705	 uint256 public lastProcessedIndex;
706	 mapping (address => bool) public excludedFromDividends;
707	 mapping (address => uint256) public lastClaimTimes;
708	 uint256 public claimWait;
709	 uint256 private minimumTokenBalanceForDividends;
710	 event ExcludeFromDividends(address indexed account);
711	 event ClaimWaitUpdated(uint256 indexed newValue, uint256 indexed oldValue);
712	 event Claim(address indexed account, uint256 amount, bool indexed automatic);
713	 constructor() public DividendPayingToken("VNS6_Dividend_Tracker", "VNS6_Dividend_Tracker") {
714	 claimWait = 3600;
715	 minimumTokenBalanceForDividends = 500000000000 * (10**18);
716	 }
717	 function setMinimumTokenBalanceForDividends(uint256 newMinTokenBalForDividends) external onlyOwner {
718	 minimumTokenBalanceForDividends = newMinTokenBalForDividends * (10**18);
719	 }
720	 function _transfer(address, address, uint256) internal override {
721	 require(false, "VNS6_Dividend_Tracker: No transfers allowed");
722	 }
723	 function withdrawDividend() public override {
724	 require(false, "VNS6_Dividend_Tracker: withdrawDividend disabled. Use the 'claim' function on the main VNS6 contract.");
725	 }
726	 function excludeFromDividends(address account) external onlyOwner {
727	 require(!excludedFromDividends[account]);
728	 excludedFromDividends[account] = true;
729	 _setBalance(account, 0);
730	 tokenHoldersMap.remove(account);
731	 emit ExcludeFromDividends(account);
732	 }
733	 function updateClaimWait(uint256 newClaimWait) external onlyOwner {
734	 require(newClaimWait >= 3600 && newClaimWait <= 86400, "VNS6_Dividend_Tracker: claimWait must be updated to between 1 and 24 hours");
735	 require(newClaimWait != claimWait, "VNS6_Dividend_Tracker: Cannot update claimWait to same value");
736	 emit ClaimWaitUpdated(newClaimWait, claimWait);
737	 claimWait = newClaimWait;
738	 }
739	 function getLastProcessedIndex() external view returns(uint256) {
740	 return lastProcessedIndex;
741	 }
742	 function minimumTokenLimit() public view returns(uint256) {
743	 return minimumTokenBalanceForDividends;
744	 }
745	 function getNumberOfTokenHolders() external view returns(uint256) {
746	 return tokenHoldersMap.keys.length;
747	 }
748	 function getAccount(address _account) public view returns ( address account, int256 index, int256 iterationsUntilProcessed, uint256 withdrawableDividends, uint256 totalDividends, uint256 lastClaimTime, uint256 nextClaimTime, uint256 secondsUntilAutoClaimAvailable) {
749	 account = _account;
750	 index = tokenHoldersMap.getIndexOfKey(account);
751	 iterationsUntilProcessed = -1;
752	 if(index >= 0) {
753	 if(uint256(index) > lastProcessedIndex) {
754	 iterationsUntilProcessed = index.sub(int256(lastProcessedIndex));
755	 }
756	 else {
757	 uint256 processesUntilEndOfArray = tokenHoldersMap.keys.length > lastProcessedIndex ? tokenHoldersMap.keys.length.sub(lastProcessedIndex) : 0;
758	 iterationsUntilProcessed = index.add(int256(processesUntilEndOfArray));
759	 }
760	 }
761	 withdrawableDividends = withdrawableDividendOf(account);
762	 totalDividends = accumulativeDividendOf(account);
763	 lastClaimTime = lastClaimTimes[account];
764	 nextClaimTime = lastClaimTime > 0 ? lastClaimTime.add(claimWait) : 0;
765	 secondsUntilAutoClaimAvailable = nextClaimTime > block.timestamp ? nextClaimTime.sub(block.timestamp) : 0;
766	 }
767	 function getAccountAtIndex(uint256 index) public view returns ( address, int256, int256, uint256, uint256, uint256, uint256, uint256) {
768	 if(index >= tokenHoldersMap.size()) {
769	 return (0x0000000000000000000000000000000000000000, -1, -1, 0, 0, 0, 0, 0);
770	 }
771	 address account = tokenHoldersMap.getKeyAtIndex(index);
772	 return getAccount(account);
773	 }
774	 function canAutoClaim(uint256 lastClaimTime) private view returns (bool) {
775	 if(lastClaimTime > block.timestamp) {
776	 return false;
777	 }
778	 return block.timestamp.sub(lastClaimTime) >= claimWait;
779	 }
780	 function setBalance(address payable account, uint256 newBalance) external onlyOwner {
781	 if(excludedFromDividends[account]) {
782	 return;
783	 }
784	 if(newBalance >= minimumTokenBalanceForDividends) {
785	 _setBalance(account, newBalance);
786	 tokenHoldersMap.set(account, newBalance);
787	 }
788	 else {
789	 _setBalance(account, 0);
790	 tokenHoldersMap.remove(account);
791	 }
792	 processAccount(account, true);
793	 }
794	 function process(uint256 gas) public returns (uint256, uint256, uint256) {
795	 uint256 numberOfTokenHolders = tokenHoldersMap.keys.length;
796	 if(numberOfTokenHolders == 0) {
797	 return (0, 0, lastProcessedIndex);
798	 }
799	 uint256 _lastProcessedIndex = lastProcessedIndex;
800	 uint256 gasUsed = 0;
801	 uint256 gasLeft = gasleft();
802	 uint256 iterations = 0;
803	 uint256 claims = 0;
804	 while(gasUsed < gas && iterations < numberOfTokenHolders) {
805	 _lastProcessedIndex++;
806	 if(_lastProcessedIndex >= tokenHoldersMap.keys.length) {
807	 _lastProcessedIndex = 0;
808	 }
809	 address account = tokenHoldersMap.keys[_lastProcessedIndex];
810	 if(canAutoClaim(lastClaimTimes[account])) {
811	 if(processAccount(payable(account), true)) {
812	 claims++;
813	 }
814	 }
815	 iterations++;
816	 uint256 newGasLeft = gasleft();
817	 if(gasLeft > newGasLeft) {
818	 gasUsed = gasUsed.add(gasLeft.sub(newGasLeft));
819	 }
820	 gasLeft = newGasLeft;
821	 }
822	 lastProcessedIndex = _lastProcessedIndex;
823	 return (iterations, claims, lastProcessedIndex);
824	 }
825	 function processAccount(address payable account, bool automatic) public onlyOwner returns (bool) {
826	 uint256 amount = _withdrawDividendOfUser(account);
827	 if(amount > 0) {
828	 lastClaimTimes[account] = block.timestamp;
829	 emit Claim(account, amount, automatic);
830	 return true;
831	 }
832	 return false;
833	 }
834	 }
