row number 
1	  pragma abicoder v2;
2	 pragma solidity >=0.4.24 <0.8.0;
3	 abstract contract Initializable {
4	 bool private _initialized;
5	 bool private _initializing;
6	 modifier initializer() {
7	 require(_initializing || _isConstructor() || !_initialized, "Initializable: contract is already initialized");
8	 bool isTopLevelCall = !_initializing;
9	 if (isTopLevelCall) {
10	 _initializing = true;
11	 _initialized = true;
12	 }
13	 _;
14	 if (isTopLevelCall) {
15	 _initializing = false;
16	 }
17	 }
18	 function _isConstructor() private view returns (bool) {
19	 return !AddressUpgradeable.isContract(address(this));
20	 }
21	 }
22	 pragma solidity >=0.6.0 <0.8.0;
23	 interface IERC165 {
24	 function supportsInterface(bytes4 interfaceId) external view returns (bool);
25	 }
26	 pragma solidity >=0.6.0 <0.8.0;
27	 abstract contract Proxy {
28	 function _delegate(address implementation) internal virtual {
29	 assembly {
30	 calldatacopy(0, 0, calldatasize()) let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0) returndatacopy(0, 0, returndatasize()) switch result case 0 {
31	 revert(0, returndatasize()) }
32	 default {
33	 return(0, returndatasize()) }
34	 }
35	 }
36	 function _implementation() internal view virtual returns (address);
37	 function _fallback() internal virtual {
38	 _beforeFallback();
39	 _delegate(_implementation());
40	 }
41	 fallback () external payable virtual {
42	 _fallback();
43	 }
44	 receive () external payable virtual {
45	 _fallback();
46	 }
47	 function _beforeFallback() internal virtual {
48	 }
49	 }
50	 pragma solidity >=0.6.0 <0.8.0;
51	 abstract contract ContextUpgradeable is Initializable {
52	 function __Context_init() internal initializer {
53	 __Context_init_unchained();
54	 }
55	 function __Context_init_unchained() internal initializer {
56	 }
57	 function _msgSender() internal view virtual returns (address payable) {
58	 return msg.sender;
59	 }
60	 function _msgData() internal view virtual returns (bytes memory) {
61	 this;
62	 return msg.data;
63	 }
64	 uint256[50] private __gap;
65	 }
66	 pragma solidity >=0.6.2 <0.8.0;
67	 interface IERC721 is IERC165 {
68	 event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
69	 event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
70	 event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
71	 function balanceOf(address owner) external view returns (uint256 balance);
72	 function ownerOf(uint256 tokenId) external view returns (address owner);
73	 function safeTransferFrom(address from, address to, uint256 tokenId) external;
74	 function transferFrom(address from, address to, uint256 tokenId) external;
75	 function approve(address to, uint256 tokenId) external;
76	 function getApproved(uint256 tokenId) external view returns (address operator);
77	 function setApprovalForAll(address operator, bool _approved) external;
78	 function isApprovedForAll(address owner, address operator) external view returns (bool);
79	 function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;
80	 }
81	 pragma solidity >=0.6.0 <0.8.0;
82	 contract UpgradeableProxy is Proxy {
83	 constructor(address _logic, bytes memory _data) public payable {
84	 assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1));
85	 _setImplementation(_logic);
86	 if(_data.length > 0) {
87	 Address.functionDelegateCall(_logic, _data);
88	 }
89	 }
90	 event Upgraded(address indexed implementation);
91	 bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
92	 function _implementation() internal view virtual override returns (address impl) {
93	 bytes32 slot = _IMPLEMENTATION_SLOT;
94	 assembly {
95	 impl := sload(slot) }
96	 }
97	 function _upgradeTo(address newImplementation) internal virtual {
98	 _setImplementation(newImplementation);
99	 emit Upgraded(newImplementation);
100	 }
101	 function _setImplementation(address newImplementation) private {
102	 require(Address.isContract(newImplementation), "UpgradeableProxy: new implementation is not a contract");
103	 bytes32 slot = _IMPLEMENTATION_SLOT;
104	 assembly {
105	 sstore(slot, newImplementation) }
106	 }
107	 }
108	 pragma solidity >=0.6.0 <0.8.0;
109	 abstract contract Context {
110	 function _msgSender() internal view virtual returns (address payable) {
111	 return msg.sender;
112	 }
113	 function _msgData() internal view virtual returns (bytes memory) {
114	 this;
115	 return msg.data;
116	 }
117	 }
118	 pragma solidity ^0.7.0;
119	 abstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {
120	 address private _owner;
121	 event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
122	 function __Ownable_init() internal initializer {
123	 __Context_init_unchained();
124	 __Ownable_init_unchained();
125	 }
126	 function __Ownable_init_unchained() internal initializer {
127	 address msgSender = _msgSender();
128	 _owner = msgSender;
129	 emit OwnershipTransferred(address(0), msgSender);
130	 }
131	 function owner() public view virtual returns (address) {
132	 return _owner;
133	 }
134	 modifier onlyOwner() {
135	 require(owner() == _msgSender(), "Ownable: caller is not the owner");
136	 _;
137	 }
138	 function renounceOwnership() public virtual onlyOwner {
139	 emit OwnershipTransferred(_owner, address(0));
140	 _owner = address(0);
141	 }
142	 function transferOwnership(address newOwner) public virtual onlyOwner {
143	 require(newOwner != address(0), "Ownable: new owner is the zero address");
144	 emit OwnershipTransferred(_owner, newOwner);
145	 _owner = newOwner;
146	 }
147	 uint256[49] private __gap;
148	 }
149	 pragma solidity >=0.6.0 <0.8.0;
150	 interface IERC20 {
151	 function totalSupply() external view returns (uint256);
152	 function balanceOf(address account) external view returns (uint256);
153	 function transfer(address recipient, uint256 amount) external returns (bool);
154	 function allowance(address owner, address spender) external view returns (uint256);
155	 function approve(address spender, uint256 amount) external returns (bool);
156	 function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
157	 event Transfer(address indexed from, address indexed to, uint256 value);
158	 event Approval(address indexed owner, address indexed spender, uint256 value);
159	 }
160	 pragma solidity >=0.6.2 <0.8.0;
161	 interface IERC721Metadata is IERC721 {
162	 function name() external view returns (string memory);
163	 function symbol() external view returns (string memory);
164	 function tokenURI(uint256 tokenId) external view returns (string memory);
165	 }
166	 pragma solidity >=0.6.2 <0.8.0;
167	 interface IERC721Enumerable is IERC721 {
168	 function totalSupply() external view returns (uint256);
169	 function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);
170	 function tokenByIndex(uint256 index) external view returns (uint256);
171	 }
172	 pragma solidity >=0.7.5;
173	 interface IPoolInitializer {
174	 function createAndInitializePoolIfNecessary( address token0, address token1, uint24 fee, uint160 sqrtPriceX96 ) external payable returns (address pool);
175	 }
176	 pragma solidity >=0.7.5;
177	 interface IERC721Permit is IERC721 {
178	 function PERMIT_TYPEHASH() external pure returns (bytes32);
179	 function DOMAIN_SEPARATOR() external view returns (bytes32);
180	 function permit( address spender, uint256 tokenId, uint256 deadline, uint8 v, bytes32 r, bytes32 s ) external payable;
181	 }
182	 pragma solidity >=0.5.0;
183	 interface IPeripheryImmutableState {
184	 function factory() external view returns (address);
185	 function WETH9() external view returns (address);
186	 }
187	 pragma solidity 0.7.6;
188	 interface IStakingRewards {
189	 function earned(address account, address token) external view returns (uint256);
190	 function getRewardForDuration(address token) external view returns (uint256);
191	 function getRewardTokens() external view returns (address[] memory tokens);
192	 function getRewardTokensCount() external view returns (uint256);
193	 function lastTimeRewardApplicable() external view returns (uint256);
194	 function lastUpdateTime(address) external view returns (uint256);
195	 function periodFinish() external view returns (uint256);
196	 function rewardEscrow() external view returns (IRewardEscrow);
197	 function rewardInfo(address) external view returns ( uint256 rewardRate, uint256 rewardPerTokenStored, uint256 totalRewardAmount, uint256 remainingRewardAmount );
198	 function rewardPerToken(address token) external view returns (uint256);
199	 function rewardTokens(uint256) external view returns (address);
200	 function rewardsAreEscrowed() external view returns (bool);
201	 function rewardsDuration() external view returns (uint256);
202	 function stakedBalanceOf(address account) external view returns (uint256);
203	 function stakedTotalSupply() external view returns (uint256);
204	 function claimReward() external;
205	 function initializeReward(uint256 rewardAmount, address token) external;
206	 function setRewardsDuration(uint256 _rewardsDuration) external;
207	 }
208	 pragma solidity >=0.6.0 <0.8.0;
209	 abstract contract Ownable is Context {
210	 address private _owner;
211	 event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
212	 constructor () internal {
213	 address msgSender = _msgSender();
214	 _owner = msgSender;
215	 emit OwnershipTransferred(address(0), msgSender);
216	 }
217	 function owner() public view virtual returns (address) {
218	 return _owner;
219	 }
220	 modifier onlyOwner() {
221	 require(owner() == _msgSender(), "Ownable: caller is not the owner");
222	 _;
223	 }
224	 function renounceOwnership() public virtual onlyOwner {
225	 emit OwnershipTransferred(_owner, address(0));
226	 _owner = address(0);
227	 }
228	 function transferOwnership(address newOwner) public virtual onlyOwner {
229	 require(newOwner != address(0), "Ownable: new owner is the zero address");
230	 emit OwnershipTransferred(_owner, newOwner);
231	 _owner = newOwner;
232	 }
233	 }
234	 pragma solidity >=0.6.0 <0.8.0;
235	 contract TransparentUpgradeableProxy is UpgradeableProxy {
236	 constructor(address _logic, address admin_, bytes memory _data) public payable UpgradeableProxy(_logic, _data) {
237	 assert(_ADMIN_SLOT == bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1));
238	 _setAdmin(admin_);
239	 }
240	 event AdminChanged(address previousAdmin, address newAdmin);
241	 bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;
242	 modifier ifAdmin() {
243	 if (msg.sender == _admin()) {
244	 _;
245	 }
246	 else {
247	 _fallback();
248	 }
249	 }
250	 function admin() external ifAdmin returns (address admin_) {
251	 admin_ = _admin();
252	 }
253	 function implementation() external ifAdmin returns (address implementation_) {
254	 implementation_ = _implementation();
255	 }
256	 function changeAdmin(address newAdmin) external virtual ifAdmin {
257	 require(newAdmin != address(0), "TransparentUpgradeableProxy: new admin is the zero address");
258	 emit AdminChanged(_admin(), newAdmin);
259	 _setAdmin(newAdmin);
260	 }
261	 function upgradeTo(address newImplementation) external virtual ifAdmin {
262	 _upgradeTo(newImplementation);
263	 }
264	 function upgradeToAndCall(address newImplementation, bytes calldata data) external payable virtual ifAdmin {
265	 _upgradeTo(newImplementation);
266	 Address.functionDelegateCall(newImplementation, data);
267	 }
268	 function _admin() internal view virtual returns (address adm) {
269	 bytes32 slot = _ADMIN_SLOT;
270	 assembly {
271	 adm := sload(slot) }
272	 }
273	 function _setAdmin(address newAdmin) private {
274	 bytes32 slot = _ADMIN_SLOT;
275	 assembly {
276	 sstore(slot, newAdmin) }
277	 }
278	 function _beforeFallback() internal virtual override {
279	 require(msg.sender != _admin(), "TransparentUpgradeableProxy: admin cannot fallback to proxy target");
280	 super._beforeFallback();
281	 }
282	 }
283	 pragma solidity 0.7.6;
284	 contract LMTerminal is Initializable, OwnableUpgradeable {
285	 using SafeMath for uint256;
286	 using SafeERC20 for IERC20;
287	 IRewardEscrow public rewardEscrow;
288	 ICLR[] public deployedCLRPools;
289	 uint256 public deploymentFee;
290	 uint256 public rewardFee;
291	 uint256 public tradeFee;
292	 mapping(address => uint256) public customDeploymentFee;
293	 mapping(address => bool) public customDeploymentFeeEnabled;
294	 CLRDeployer public clrDeployer;
295	 IxTokenManager public xTokenManager;
296	 address public proxyAdmin;
297	 IUniswapV3Factory public uniswapFactory;
298	 INonfungiblePositionManager public positionManager;
299	 ICLR.UniswapContracts public uniContracts;
300	 mapping(address => bool) private isCLRPool;
301	 NonRewardPoolDeployer public nonRewardPoolDeployer;
302	 struct PositionTicks {
303	 int24 lowerTick;
304	 int24 upperTick;
305	 }
306	 struct RewardsProgram {
307	 address[] rewardTokens;
308	 uint256 vestingPeriod;
309	 }
310	 struct PoolDetails {
311	 uint24 fee;
312	 address token0;
313	 address token1;
314	 uint256 amount0;
315	 uint256 amount1;
316	 }
317	 event DeployedUniV3Pool( address indexed pool, address indexed token0, address indexed token1, uint24 fee );
318	 event DeployedIncentivizedPool( address indexed clrInstance, address indexed token0, address indexed token1, uint24 fee, int24 lowerTick, int24 upperTick );
319	 event DeployedNonIncentivizedPool( address indexed poolInstance, address indexed token0, address indexed token1, uint24 fee, int24 lowerTick, int24 upperTick );
320	 event InitiatedRewardsProgram( address indexed clrInstance, address[] rewardTokens, uint256[] totalRewardAmounts, uint256 rewardsDuration );
321	 event TokenFeeWithdraw(address indexed token, uint256 amount);
322	 event EthFeeWithdraw(uint256 amount);
323	 constructor() initializer {
324	 }
325	 function initialize( address _xTokenManager, address _rewardEscrow, address _proxyAdmin, address _clrDeployer, address _nonRewardPoolDeployer, address _uniswapFactory, ICLR.UniswapContracts memory _uniContracts, uint256 _deploymentFee, uint256 _rewardFee, uint256 _tradeFee ) external initializer {
326	 __Ownable_init();
327	 xTokenManager = IxTokenManager(_xTokenManager);
328	 rewardEscrow = IRewardEscrow(_rewardEscrow);
329	 proxyAdmin = _proxyAdmin;
330	 clrDeployer = CLRDeployer(_clrDeployer);
331	 nonRewardPoolDeployer = NonRewardPoolDeployer(_nonRewardPoolDeployer);
332	 positionManager = INonfungiblePositionManager( _uniContracts.positionManager );
333	 uniswapFactory = IUniswapV3Factory(_uniswapFactory);
334	 uniContracts = _uniContracts;
335	 deploymentFee = _deploymentFee;
336	 rewardFee = _rewardFee;
337	 tradeFee = _tradeFee;
338	 }
339	 function deployUniswapPool( address token0, address token1, uint24 fee, uint160 initPrice ) external returns (address pool) {
340	 if (token0 > token1) {
341	 (token0, token1) = (token1, token0);
342	 }
343	 pool = positionManager.createAndInitializePoolIfNecessary( token0, token1, fee, initPrice );
344	 emit DeployedUniV3Pool(pool, token0, token1, fee);
345	 }
346	 function deployNonIncentivizedPool( string memory symbol, PositionTicks memory ticks, PoolDetails memory pool ) external payable {
347	 uint256 feeOwed = customDeploymentFeeEnabled[msg.sender] ? customDeploymentFee[msg.sender] : deploymentFee;
348	 require( msg.value == feeOwed, "Need to send ETH for non reward pool deployment" );
349	 INonRewardPool nonRewardPool = INonRewardPool( nonRewardPoolDeployer.deployNonRewardPool(proxyAdmin) );
350	 if (pool.token0 > pool.token1) {
351	 (pool.token0, pool.token1) = (pool.token1, pool.token0);
352	 (pool.amount0, pool.amount1) = (pool.amount1, pool.amount0);
353	 }
354	 address poolAddress = getPool(pool.token0, pool.token1, pool.fee);
355	 nonRewardPool.initialize( symbol, ticks.lowerTick, ticks.upperTick, pool.fee, tradeFee, pool.token0, pool.token1, address(this), poolAddress, INonRewardPool.UniswapContracts({
356	 router: uniContracts.router, quoter: uniContracts.quoter, positionManager: uniContracts.positionManager }
357	 ) );
358	 (uint256 actualAmount0, uint256 actualAmount1) = nonRewardPool .calculatePoolMintedAmounts(pool.amount0, pool.amount1);
359	 IERC20(pool.token0).safeApprove(address(nonRewardPool), actualAmount0);
360	 IERC20(pool.token1).safeApprove(address(nonRewardPool), actualAmount1);
361	 IERC20(pool.token0).safeTransferFrom( msg.sender, address(this), actualAmount0 );
362	 IERC20(pool.token1).safeTransferFrom( msg.sender, address(this), actualAmount1 );
363	 nonRewardPool.mintInitial(actualAmount0, actualAmount1, msg.sender);
364	 nonRewardPool.transferOwnership(msg.sender);
365	 IProxyAdmin(proxyAdmin).addProxyAdmin( address(nonRewardPool), msg.sender );
366	 emit DeployedNonIncentivizedPool( address(nonRewardPool), pool.token0, pool.token1, pool.fee, ticks.lowerTick, ticks.upperTick );
367	 }
368	 function deployIncentivizedPool( string memory symbol, PositionTicks memory ticks, RewardsProgram memory rewardsProgram, PoolDetails memory pool ) external payable {
369	 uint256 feeOwed = customDeploymentFeeEnabled[msg.sender] ? customDeploymentFee[msg.sender] : deploymentFee;
370	 require( msg.value == feeOwed, "Need to send ETH for CLR pool deployment" );
371	 ICLR clrPool = ICLR(clrDeployer.deployCLRPool(proxyAdmin));
372	 IStakedCLRToken stakedToken = IStakedCLRToken( clrDeployer.deploySCLRToken(proxyAdmin) );
373	 stakedToken.initialize( "StakedCLRToken", symbol, address(clrPool), false );
374	 if (pool.token0 > pool.token1) {
375	 (pool.token0, pool.token1) = (pool.token1, pool.token0);
376	 (pool.amount0, pool.amount1) = (pool.amount1, pool.amount0);
377	 }
378	 bool rewardsAreEscrowed = rewardsProgram.vestingPeriod > 0 ? true : false;
379	 address poolAddress = getPool(pool.token0, pool.token1, pool.fee);
380	 ICLR.StakingDetails memory stakingParams = ICLR.StakingDetails({
381	 rewardTokens: rewardsProgram.rewardTokens, rewardEscrow: address(rewardEscrow), rewardsAreEscrowed: rewardsAreEscrowed }
382	 );
383	 clrPool.initialize( symbol, ticks.lowerTick, ticks.upperTick, pool.fee, tradeFee, pool.token0, pool.token1, address(stakedToken), address(this), poolAddress, uniContracts, stakingParams );
384	 {
385	 (uint256 actualAmount0, uint256 actualAmount1) = clrPool .calculatePoolMintedAmounts(pool.amount0, pool.amount1);
386	 IERC20(pool.token0).safeApprove(address(clrPool), actualAmount0);
387	 IERC20(pool.token1).safeApprove(address(clrPool), actualAmount1);
388	 IERC20(pool.token0).safeTransferFrom( msg.sender, address(this), actualAmount0 );
389	 IERC20(pool.token1).safeTransferFrom( msg.sender, address(this), actualAmount1 );
390	 clrPool.mintInitial(actualAmount0, actualAmount1, msg.sender);
391	 }
392	 if (rewardsAreEscrowed) {
393	 rewardEscrow.setCLRPoolVestingPeriod( address(clrPool), rewardsProgram.vestingPeriod );
394	 }
395	 clrPool.transferOwnership(msg.sender);
396	 IProxyAdmin(proxyAdmin).addProxyAdmin(address(clrPool), msg.sender);
397	 IProxyAdmin(proxyAdmin).addProxyAdmin(address(stakedToken), msg.sender);
398	 deployedCLRPools.push(clrPool);
399	 isCLRPool[address(clrPool)] = true;
400	 emit DeployedIncentivizedPool( address(clrPool), pool.token0, pool.token1, pool.fee, ticks.lowerTick, ticks.upperTick );
401	 }
402	 function initiateRewardsProgram( ICLR clrPool, uint256[] memory totalRewardAmounts, uint256 rewardsDuration ) external {
403	 require(isCLRPool[address(clrPool)], "Not CLR pool");
404	 require( clrPool.periodFinish() == 0, "Reward program has been initiated" );
405	 if (clrPool.rewardsAreEscrowed()) {
406	 rewardEscrow.addRewardsContract(address(clrPool));
407	 }
408	 clrPool.setRewardsDuration(rewardsDuration);
409	 _initiateRewardsProgram(clrPool, totalRewardAmounts);
410	 }
411	 function initiateNewRewardsProgram( ICLR clrPool, uint256[] memory totalRewardAmounts, uint256 rewardsDuration ) external {
412	 require( clrPool.periodFinish() != 0, "First program must be initialized using initiateRewardsProgram" );
413	 require( block.timestamp > clrPool.periodFinish(), "Previous program must finish before initializing a new one" );
414	 clrPool.setRewardsDuration(rewardsDuration);
415	 _initiateRewardsProgram(clrPool, totalRewardAmounts);
416	 }
417	 function _initiateRewardsProgram( ICLR clrPool, uint256[] memory totalRewardAmounts ) private {
418	 address[] memory rewardTokens = clrPool.getRewardTokens();
419	 require( totalRewardAmounts.length == rewardTokens.length, "Total reward amounts count should be the same as reward tokens count" );
420	 address owner = clrPool.owner();
421	 address manager = clrPool.manager();
422	 require( msg.sender == owner || msg.sender == manager, "Only owner or manager can initiate the rewards program" );
423	 for (uint256 i = 0; i < rewardTokens.length; ++i) {
424	 address rewardToken = rewardTokens[i];
425	 uint256 rewardAmountFee = totalRewardAmounts[i].div(rewardFee);
426	 uint256 rewardAmount = totalRewardAmounts[i];
427	 IERC20(rewardToken).safeTransferFrom( msg.sender, address(this), rewardAmountFee );
428	 IERC20(rewardToken).safeTransferFrom( msg.sender, address(clrPool), rewardAmount );
429	 clrPool.initializeReward(rewardAmount, rewardToken);
430	 }
431	 emit InitiatedRewardsProgram( address(clrPool), rewardTokens, totalRewardAmounts, clrPool.rewardsDuration() );
432	 }
433	 function getPool( address token0, address token1, uint24 fee ) public view returns (address pool) {
434	 return uniswapFactory.getPool(token0, token1, fee);
435	 }
436	 function enableCustomDeploymentFee(address deployer, uint256 feeAmount) public onlyOwner {
437	 require( feeAmount < deploymentFee, "Custom fee should be less than flat deployment fee" );
438	 customDeploymentFeeEnabled[deployer] = true;
439	 customDeploymentFee[deployer] = feeAmount;
440	 }
441	 function disableCustomDeploymentFee(address deployer) public onlyOwner {
442	 customDeploymentFeeEnabled[deployer] = false;
443	 }
444	 function setCLRDeployer(address newDeployer) public onlyOwner {
445	 clrDeployer = CLRDeployer(newDeployer);
446	 }
447	 function setNonRewardPoolDeployer(address newDeployer) public onlyOwner {
448	 nonRewardPoolDeployer = NonRewardPoolDeployer(newDeployer);
449	 }
450	 function withdrawFees(IERC20 token) external onlyRevenueController {
451	 uint256 fees = token.balanceOf(address(this));
452	 if (fees > 0) {
453	 token.safeTransfer(msg.sender, fees);
454	 emit TokenFeeWithdraw(address(token), fees);
455	 }
456	 if (address(this).balance > 0) {
457	 bool sent = transferETH(address(this).balance, msg.sender);
458	 if (sent) {
459	 emit EthFeeWithdraw(address(this).balance);
460	 }
461	 }
462	 }
463	 function transferETH(uint256 amount, address payable to) private returns (bool sent) {
464	 (sent, ) = to.call{
465	 value: amount}
466	 ("");
467	 }
468	 receive() external payable {
469	 }
470	 modifier onlyRevenueController() {
471	 require( xTokenManager.isRevenueController(msg.sender), "Callable only by Revenue Controller" );
472	 _;
473	 }
474	 }
475	 pragma solidity >=0.6.0 <0.8.0;
476	 library SafeMath {
477	 function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
478	 uint256 c = a + b;
479	 if (c < a) return (false, 0);
480	 return (true, c);
481	 }
482	 function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
483	 if (b > a) return (false, 0);
484	 return (true, a - b);
485	 }
486	 function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
487	 if (a == 0) return (true, 0);
488	 uint256 c = a * b;
489	 if (c / a != b) return (false, 0);
490	 return (true, c);
491	 }
492	 function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
493	 if (b == 0) return (false, 0);
494	 return (true, a / b);
495	 }
496	 function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
497	 if (b == 0) return (false, 0);
498	 return (true, a % b);
499	 }
500	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
501	 uint256 c = a + b;
502	 require(c >= a, "SafeMath: addition overflow");
503	 return c;
504	 }
505	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
506	 require(b <= a, "SafeMath: subtraction overflow");
507	 return a - b;
508	 }
509	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
510	 if (a == 0) return 0;
511	 uint256 c = a * b;
512	 require(c / a == b, "SafeMath: multiplication overflow");
513	 return c;
514	 }
515	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
516	 require(b > 0, "SafeMath: division by zero");
517	 return a / b;
518	 }
519	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
520	 require(b > 0, "SafeMath: modulo by zero");
521	 return a % b;
522	 }
523	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
524	 require(b <= a, errorMessage);
525	 return a - b;
526	 }
527	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
528	 require(b > 0, errorMessage);
529	 return a / b;
530	 }
531	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
532	 require(b > 0, errorMessage);
533	 return a % b;
534	 }
535	 }
536	 pragma solidity >=0.6.0 <0.8.0;
537	 library SafeERC20 {
538	 using SafeMath for uint256;
539	 using Address for address;
540	 function safeTransfer(IERC20 token, address to, uint256 value) internal {
541	 _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
542	 }
543	 function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
544	 _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
545	 }
546	 function safeApprove(IERC20 token, address spender, uint256 value) internal {
547	 require((value == 0) || (token.allowance(address(this), spender) == 0), "SafeERC20: approve from non-zero to non-zero allowance" );
548	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
549	 }
550	 function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
551	 uint256 newAllowance = token.allowance(address(this), spender).add(value);
552	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
553	 }
554	 function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
555	 uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
556	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
557	 }
558	 function _callOptionalReturn(IERC20 token, bytes memory data) private {
559	 bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
560	 if (returndata.length > 0) {
561	 require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
562	 }
563	 }
564	 }
565	 pragma solidity >=0.7.5;
566	 interface INonfungiblePositionManager is IPoolInitializer, IPeripheryImmutableState, IERC721Metadata, IERC721Enumerable, IERC721Permit {
567	 event IncreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);
568	 event DecreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);
569	 event Collect(uint256 indexed tokenId, address recipient, uint256 amount0, uint256 amount1);
570	 function positions(uint256 tokenId) external view returns ( uint96 nonce, address operator, address token0, address token1, uint24 fee, int24 tickLower, int24 tickUpper, uint128 liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, uint128 tokensOwed0, uint128 tokensOwed1 );
571	 struct MintParams {
572	 address token0;
573	 address token1;
574	 uint24 fee;
575	 int24 tickLower;
576	 int24 tickUpper;
577	 uint256 amount0Desired;
578	 uint256 amount1Desired;
579	 uint256 amount0Min;
580	 uint256 amount1Min;
581	 address recipient;
582	 uint256 deadline;
583	 }
584	 function mint(MintParams calldata params) external payable returns ( uint256 tokenId, uint128 liquidity, uint256 amount0, uint256 amount1 );
585	 struct IncreaseLiquidityParams {
586	 uint256 tokenId;
587	 uint256 amount0Desired;
588	 uint256 amount1Desired;
589	 uint256 amount0Min;
590	 uint256 amount1Min;
591	 uint256 deadline;
592	 }
593	 function increaseLiquidity(IncreaseLiquidityParams calldata params) external payable returns ( uint128 liquidity, uint256 amount0, uint256 amount1 );
594	 struct DecreaseLiquidityParams {
595	 uint256 tokenId;
596	 uint128 liquidity;
597	 uint256 amount0Min;
598	 uint256 amount1Min;
599	 uint256 deadline;
600	 }
601	 function decreaseLiquidity(DecreaseLiquidityParams calldata params) external payable returns (uint256 amount0, uint256 amount1);
602	 struct CollectParams {
603	 uint256 tokenId;
604	 address recipient;
605	 uint128 amount0Max;
606	 uint128 amount1Max;
607	 }
608	 function collect(CollectParams calldata params) external payable returns (uint256 amount0, uint256 amount1);
609	 function burn(uint256 tokenId) external payable;
610	 }
611	 pragma solidity >=0.5.0;
612	 interface IUniswapV3Factory {
613	 event OwnerChanged(address indexed oldOwner, address indexed newOwner);
614	 event PoolCreated( address indexed token0, address indexed token1, uint24 indexed fee, int24 tickSpacing, address pool );
615	 event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);
616	 function owner() external view returns (address);
617	 function feeAmountTickSpacing(uint24 fee) external view returns (int24);
618	 function getPool( address tokenA, address tokenB, uint24 fee ) external view returns (address pool);
619	 function createPool( address tokenA, address tokenB, uint24 fee ) external returns (address pool);
620	 function setOwner(address _owner) external;
621	 function enableFeeAmount(uint24 fee, int24 tickSpacing) external;
622	 }
623	 pragma solidity 0.7.6;
624	 interface IERC20Extended is IERC20 {
625	 function name() external view returns (string memory);
626	 function symbol() external view returns (string memory);
627	 function decimals() external view returns (uint8);
628	 }
629	 pragma solidity 0.7.6;
630	 interface ICLR is IERC20, IStakingRewards {
631	 function addManager(address _manager) external;
632	 function adminStake(uint256 amount0, uint256 amount1) external;
633	 function adminSwap(uint256 amount, bool _0for1) external;
634	 function calculateAmountsMintedSingleToken(uint8 inputAsset, uint256 amount) external view returns (uint256 amount0Minted, uint256 amount1Minted);
635	 function calculateMintAmount(uint256 amount0, uint256 amount1) external view returns (uint256 mintAmount);
636	 function calculatePoolMintedAmounts(uint256 amount0, uint256 amount1) external view returns (uint256 amount0Minted, uint256 amount1Minted);
637	 function collect() external returns (uint256 collected0, uint256 collected1);
638	 function decimals() external view returns (uint8);
639	 function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);
640	 function deposit(uint8 inputAsset, uint256 amount) external;
641	 function getAmountsForLiquidity(uint128 liquidity) external view returns (uint256 amount0, uint256 amount1);
642	 function getBufferToken0Balance() external view returns (uint256 amount0);
643	 function getBufferToken1Balance() external view returns (uint256 amount1);
644	 function getBufferTokenBalance() external view returns (uint256 amount0, uint256 amount1);
645	 function getLiquidityForAmounts(uint256 amount0, uint256 amount1) external view returns (uint128 liquidity);
646	 function getPositionLiquidity() external view returns (uint128 liquidity);
647	 function getStakedTokenBalance() external view returns (uint256 amount0, uint256 amount1);
648	 function getTicks() external view returns (int24 tick0, int24 tick1);
649	 function increaseAllowance(address spender, uint256 addedValue) external returns (bool);
650	 function initialize( string memory _symbol, int24 _tickLower, int24 _tickUpper, uint24 _poolFee, uint256 _tradeFee, address _token0, address _token1, address _stakedToken, address _terminal, address _uniswapPool, UniswapContracts memory contracts, StakingDetails memory stakingParams ) external;
651	 function manager() external view returns (address);
652	 function mintInitial( uint256 amount0, uint256 amount1, address sender ) external;
653	 function name() external view returns (string memory);
654	 function owner() external view returns (address);
655	 function pauseContract() external returns (bool);
656	 function paused() external view returns (bool);
657	 function poolFee() external view returns (uint24);
658	 function reinvest() external;
659	 function renounceOwnership() external;
660	 function stakedToken() external view returns (address);
661	 function symbol() external view returns (string memory);
662	 function token0() external view returns (address);
663	 function token0DecimalMultiplier() external view returns (uint256);
664	 function token0Decimals() external view returns (uint8);
665	 function token1() external view returns (address);
666	 function token1DecimalMultiplier() external view returns (uint256);
667	 function token1Decimals() external view returns (uint8);
668	 function tokenId() external view returns (uint256);
669	 function tradeFee() external view returns (uint256);
670	 function transferOwnership(address newOwner) external;
671	 function uniContracts() external view returns ( address router, address quoter, address positionManager );
672	 function uniswapPool() external view returns (address);
673	 function unpauseContract() external returns (bool);
674	 function withdraw(uint256 amount) external;
675	 function withdrawAndClaimReward(uint256 amount) external;
676	 struct UniswapContracts {
677	 address router;
678	 address quoter;
679	 address positionManager;
680	 }
681	 struct StakingDetails {
682	 address[] rewardTokens;
683	 address rewardEscrow;
684	 bool rewardsAreEscrowed;
685	 }
686	 }
687	 pragma solidity 0.7.6;
688	 interface IStakedCLRToken is IERC20 {
689	 function mint(address _recipient, uint256 _amount) external returns (bool);
690	 function burnFrom(address _sender, uint256 _amount) external returns (bool);
691	 function initialize( string memory _name, string memory _symbol, address _clrPool, bool _transferable ) external;
692	 }
693	 pragma solidity 0.7.6;
694	 interface INonRewardPool is IERC20 {
695	 function addManager(address _manager) external;
696	 function adminStake(uint256 amount0, uint256 amount1) external;
697	 function adminSwap(uint256 amount, bool _0for1) external;
698	 function calculateAmountsMintedSingleToken(uint8 inputAsset, uint256 amount) external view returns (uint256 amount0Minted, uint256 amount1Minted);
699	 function calculateMintAmount(uint256 amount0, uint256 amount1) external view returns (uint256 mintAmount);
700	 function calculatePoolMintedAmounts(uint256 amount0, uint256 amount1) external view returns (uint256 amount0Minted, uint256 amount1Minted);
701	 function collect() external returns (uint256 collected0, uint256 collected1);
702	 function decimals() external view returns (uint8);
703	 function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);
704	 function deposit(uint8 inputAsset, uint256 amount) external;
705	 function getAmountsForLiquidity(uint128 liquidity) external view returns (uint256 amount0, uint256 amount1);
706	 function getBufferToken0Balance() external view returns (uint256 amount0);
707	 function getBufferToken1Balance() external view returns (uint256 amount1);
708	 function getBufferTokenBalance() external view returns (uint256 amount0, uint256 amount1);
709	 function getLiquidityForAmounts(uint256 amount0, uint256 amount1) external view returns (uint128 liquidity);
710	 function getPositionLiquidity() external view returns (uint128 liquidity);
711	 function getStakedTokenBalance() external view returns (uint256 amount0, uint256 amount1);
712	 function getTicks() external view returns (int24 tick0, int24 tick1);
713	 function increaseAllowance(address spender, uint256 addedValue) external returns (bool);
714	 function initialize( string memory _symbol, int24 _tickLower, int24 _tickUpper, uint24 _poolFee, uint256 _tradeFee, address _token0, address _token1, address _terminal, address _uniswapPool, UniswapContracts memory contracts ) external;
715	 function manager() external view returns (address);
716	 function mintInitial( uint256 amount0, uint256 amount1, address sender ) external;
717	 function name() external view returns (string memory);
718	 function owner() external view returns (address);
719	 function pauseContract() external returns (bool);
720	 function paused() external view returns (bool);
721	 function poolFee() external view returns (uint24);
722	 function reinvest() external;
723	 function renounceOwnership() external;
724	 function symbol() external view returns (string memory);
725	 function token0() external view returns (address);
726	 function token0DecimalMultiplier() external view returns (uint256);
727	 function token0Decimals() external view returns (uint8);
728	 function token1() external view returns (address);
729	 function token1DecimalMultiplier() external view returns (uint256);
730	 function token1Decimals() external view returns (uint8);
731	 function tokenId() external view returns (uint256);
732	 function tradeFee() external view returns (uint256);
733	 function transferOwnership(address newOwner) external;
734	 function uniContracts() external view returns ( address router, address quoter, address positionManager );
735	 function uniswapPool() external view returns (address);
736	 function unpauseContract() external returns (bool);
737	 function withdraw(uint256 amount) external;
738	 struct UniswapContracts {
739	 address router;
740	 address quoter;
741	 address positionManager;
742	 }
743	 }
744	 pragma solidity 0.7.6;
745	 interface IRewardEscrow {
746	 function MAX_VESTING_ENTRIES() external view returns (uint256);
747	 function addRewardsContract(address _rewardContract) external;
748	 function appendVestingEntry( address token, address account, address pool, uint256 quantity ) external;
749	 function balanceOf(address token, address account) external view returns (uint256);
750	 function checkAccountSchedule( address pool, address token, address account ) external view returns (uint256[] memory);
751	 function clrPoolVestingPeriod(address) external view returns (uint256);
752	 function getNextVestingEntry( address pool, address token, address account ) external view returns (uint256[2] memory);
753	 function getNextVestingIndex( address pool, address token, address account ) external view returns (uint256);
754	 function getNextVestingQuantity( address pool, address token, address account ) external view returns (uint256);
755	 function getNextVestingTime( address pool, address token, address account ) external view returns (uint256);
756	 function getVestingQuantity( address pool, address token, address account, uint256 index ) external view returns (uint256);
757	 function getVestingScheduleEntry( address pool, address token, address account, uint256 index ) external view returns (uint256[2] memory);
758	 function getVestingTime( address pool, address token, address account, uint256 index ) external view returns (uint256);
759	 function initialize() external;
760	 function isRewardContract(address) external view returns (bool);
761	 function numVestingEntries( address pool, address token, address account ) external view returns (uint256);
762	 function owner() external view returns (address);
763	 function removeRewardsContract(address _rewardContract) external;
764	 function renounceOwnership() external;
765	 function setCLRPoolVestingPeriod(address pool, uint256 vestingPeriod) external;
766	 function totalEscrowedAccountBalance(address, address) external view returns (uint256);
767	 function totalEscrowedBalance(address) external view returns (uint256);
768	 function totalSupply(address token) external view returns (uint256);
769	 function totalVestedAccountBalance(address, address) external view returns (uint256);
770	 function transferOwnership(address newOwner) external;
771	 function vest(address pool, address token) external;
772	 function vestAll(address pool, address[] memory tokens) external;
773	 function vestingSchedules( address, address, address, uint256, uint256 ) external view returns (uint256);
774	 }
775	 pragma solidity 0.7.6;
776	 interface IxTokenManager {
777	 function addManager(address manager, address fund) external;
778	 function removeManager(address manager, address fund) external;
779	 function isManager(address manager, address fund) external view returns (bool);
780	 function setRevenueController(address controller) external;
781	 function isRevenueController(address caller) external view returns (bool);
782	 }
783	 pragma solidity 0.7.6;
784	 interface IProxyAdmin {
785	 function addProxyAdmin(address proxy, address admin) external;
786	 function changeProxyAdmin(address proxy, address newAdmin) external;
787	 function getProxyAdmin(address proxy) external view returns (address);
788	 function getProxyImplementation(address proxy) external view returns (address);
789	 function owner() external view returns (address);
790	 function renounceOwnership() external;
791	 function transferOwnership(address newOwner) external;
792	 function upgrade(address proxy, address implementation) external;
793	 }
794	 pragma solidity 0.7.6;
795	 contract CLRDeployer is Ownable {
796	 address public clrImplementation;
797	 address public sCLRTokenImplementation;
798	 constructor(address _clrImplementation, address _sclrTokenImplementation) {
799	 clrImplementation = _clrImplementation;
800	 sCLRTokenImplementation = _sclrTokenImplementation;
801	 emit CLRImplementationSet(_clrImplementation);
802	 emit CLRTokenImplementationSet(_sclrTokenImplementation);
803	 }
804	 function deployCLRPool(address _proxyAdmin) external returns (address pool) {
805	 CLRProxy clrInstance = new CLRProxy( clrImplementation, _proxyAdmin, address(this) );
806	 return address(clrInstance);
807	 }
808	 function deploySCLRToken(address _proxyAdmin) external returns (address token) {
809	 StakedCLRTokenProxy clrTokenInstance = new StakedCLRTokenProxy( sCLRTokenImplementation, _proxyAdmin, address(this) );
810	 return address(clrTokenInstance);
811	 }
812	 function setCLRImplementation(address _clrImplementation) external onlyOwner {
813	 clrImplementation = _clrImplementation;
814	 emit CLRImplementationSet(_clrImplementation);
815	 }
816	 function setsCLRTokenImplementation(address _sCLRTokenImplementation) external onlyOwner {
817	 sCLRTokenImplementation = _sCLRTokenImplementation;
818	 emit CLRTokenImplementationSet(_sCLRTokenImplementation);
819	 }
820	 event CLRImplementationSet(address indexed clrImplementation);
821	 event CLRTokenImplementationSet(address indexed sCLRTokenImplementation);
822	 }
823	 pragma solidity 0.7.6;
824	 contract NonRewardPoolDeployer is Ownable {
825	 address public nonRewardPoolImplementation;
826	 constructor(address _nonRewardPoolImplementation) {
827	 nonRewardPoolImplementation = _nonRewardPoolImplementation;
828	 emit NonRewardPoolImplementationSet(_nonRewardPoolImplementation);
829	 }
830	 function deployNonRewardPool(address _proxyAdmin) external returns (address pool) {
831	 NonRewardPoolProxy poolInstance = new NonRewardPoolProxy( nonRewardPoolImplementation, _proxyAdmin, address(this) );
832	 return address(poolInstance);
833	 }
834	 function setNonRewardPoolImplementation(address _poolImplementation) external onlyOwner {
835	 nonRewardPoolImplementation = _poolImplementation;
836	 emit NonRewardPoolImplementationSet(_poolImplementation);
837	 }
838	 event NonRewardPoolImplementationSet(address indexed poolImplementation);
839	 }
840	 pragma solidity ^0.7.0;
841	 library AddressUpgradeable {
842	 function isContract(address account) internal view returns (bool) {
843	 uint256 size;
844	 assembly {
845	 size := extcodesize(account) }
846	 return size > 0;
847	 }
848	 function sendValue(address payable recipient, uint256 amount) internal {
849	 require(address(this).balance >= amount, "Address: insufficient balance");
850	 (bool success, ) = recipient.call{
851	 value: amount }
852	 ("");
853	 require(success, "Address: unable to send value, recipient may have reverted");
854	 }
855	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
856	 return functionCall(target, data, "Address: low-level call failed");
857	 }
858	 function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
859	 return functionCallWithValue(target, data, 0, errorMessage);
860	 }
861	 function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
862	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
863	 }
864	 function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
865	 require(address(this).balance >= value, "Address: insufficient balance for call");
866	 require(isContract(target), "Address: call to non-contract");
867	 (bool success, bytes memory returndata) = target.call{
868	 value: value }
869	 (data);
870	 return _verifyCallResult(success, returndata, errorMessage);
871	 }
872	 function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
873	 return functionStaticCall(target, data, "Address: low-level static call failed");
874	 }
875	 function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
876	 require(isContract(target), "Address: static call to non-contract");
877	 (bool success, bytes memory returndata) = target.staticcall(data);
878	 return _verifyCallResult(success, returndata, errorMessage);
879	 }
880	 function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
881	 if (success) {
882	 return returndata;
883	 }
884	 else {
885	 if (returndata.length > 0) {
886	 assembly {
887	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
888	 }
889	 else {
890	 revert(errorMessage);
891	 }
892	 }
893	 }
894	 }
895	 pragma solidity >=0.6.2 <0.8.0;
896	 library Address {
897	 function isContract(address account) internal view returns (bool) {
898	 uint256 size;
899	 assembly {
900	 size := extcodesize(account) }
901	 return size > 0;
902	 }
903	 function sendValue(address payable recipient, uint256 amount) internal {
904	 require(address(this).balance >= amount, "Address: insufficient balance");
905	 (bool success, ) = recipient.call{
906	 value: amount }
907	 ("");
908	 require(success, "Address: unable to send value, recipient may have reverted");
909	 }
910	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
911	 return functionCall(target, data, "Address: low-level call failed");
912	 }
913	 function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
914	 return functionCallWithValue(target, data, 0, errorMessage);
915	 }
916	 function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
917	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
918	 }
919	 function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
920	 require(address(this).balance >= value, "Address: insufficient balance for call");
921	 require(isContract(target), "Address: call to non-contract");
922	 (bool success, bytes memory returndata) = target.call{
923	 value: value }
924	 (data);
925	 return _verifyCallResult(success, returndata, errorMessage);
926	 }
927	 function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
928	 return functionStaticCall(target, data, "Address: low-level static call failed");
929	 }
930	 function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
931	 require(isContract(target), "Address: static call to non-contract");
932	 (bool success, bytes memory returndata) = target.staticcall(data);
933	 return _verifyCallResult(success, returndata, errorMessage);
934	 }
935	 function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
936	 return functionDelegateCall(target, data, "Address: low-level delegate call failed");
937	 }
938	 function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
939	 require(isContract(target), "Address: delegate call to non-contract");
940	 (bool success, bytes memory returndata) = target.delegatecall(data);
941	 return _verifyCallResult(success, returndata, errorMessage);
942	 }
943	 function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
944	 if (success) {
945	 return returndata;
946	 }
947	 else {
948	 if (returndata.length > 0) {
949	 assembly {
950	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
951	 }
952	 else {
953	 revert(errorMessage);
954	 }
955	 }
956	 }
957	 }
958	 pragma solidity >=0.5.0;
959	 library PoolAddress {
960	 bytes32 internal constant POOL_INIT_CODE_HASH = 0xc02f72e8ae5e68802e6d893d58ddfb0df89a2f4c9c2f04927db1186a29373660;
961	 struct PoolKey {
962	 address token0;
963	 address token1;
964	 uint24 fee;
965	 }
966	 function getPoolKey( address tokenA, address tokenB, uint24 fee ) internal pure returns (PoolKey memory) {
967	 if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);
968	 return PoolKey({
969	 token0: tokenA, token1: tokenB, fee: fee}
970	 );
971	 }
972	 function computeAddress(address factory, PoolKey memory key) internal pure returns (address pool) {
973	 require(key.token0 < key.token1);
974	 pool = address( uint256( keccak256( abi.encodePacked( hex'ff', factory, keccak256(abi.encode(key.token0, key.token1, key.fee)), POOL_INIT_CODE_HASH ) ) ) );
975	 }
976	 }
977	 pragma solidity 0.7.6;
978	 contract CLRProxy is TransparentUpgradeableProxy {
979	 bytes32 private constant _DEPLOYER_SLOT = 0x3d08d612cd86aed0e9677508733085e4cbe15d53bdc770ec5b581bb4e0a721ca;
980	 constructor( address _logic, address _proxyAdmin, address __clrDeployer ) TransparentUpgradeableProxy(_logic, _proxyAdmin, "") {
981	 assert( _DEPLOYER_SLOT == bytes32(uint256(keccak256("eip1967.proxy.clrDeployer")) - 1) );
982	 _setCLRDeployer(__clrDeployer);
983	 }
984	 function _clrDeployer() internal view virtual returns (address clrDeployer) {
985	 bytes32 slot = _DEPLOYER_SLOT;
986	 assembly {
987	 clrDeployer := sload(slot) }
988	 }
989	 function _setCLRDeployer(address clrDeployer) private {
990	 bytes32 slot = _DEPLOYER_SLOT;
991	 assembly {
992	 sstore(slot, clrDeployer) }
993	 }
994	 function upgradeTo(address _implementation) external override ifAdmin {
995	 require( ICLRDeployer(_clrDeployer()).clrImplementation() == _implementation, "Can only upgrade to latest CLR implementation" );
996	 _upgradeTo(_implementation);
997	 }
998	 function upgradeToAndCall(address _implementation, bytes calldata data) external payable override ifAdmin {
999	 require( ICLRDeployer(_clrDeployer()).clrImplementation() == _implementation, "Can only upgrade to latest CLR implementation" );
1000	 _upgradeTo(_implementation);
1001	 Address.functionDelegateCall(_implementation, data);
1002	 }
1003	 }
1004	 pragma solidity 0.7.6;
1005	 contract StakedCLRTokenProxy is TransparentUpgradeableProxy {
1006	 bytes32 private constant _DEPLOYER_SLOT = 0x3d08d612cd86aed0e9677508733085e4cbe15d53bdc770ec5b581bb4e0a721ca;
1007	 constructor( address _logic, address _proxyAdmin, address __clrDeployer ) TransparentUpgradeableProxy(_logic, _proxyAdmin, "") {
1008	 assert( _DEPLOYER_SLOT == bytes32(uint256(keccak256("eip1967.proxy.clrDeployer")) - 1) );
1009	 _setCLRDeployer(__clrDeployer);
1010	 }
1011	 function _clrDeployer() internal view virtual returns (address clrDeployer) {
1012	 bytes32 slot = _DEPLOYER_SLOT;
1013	 assembly {
1014	 clrDeployer := sload(slot) }
1015	 }
1016	 function _setCLRDeployer(address clrDeployer) private {
1017	 bytes32 slot = _DEPLOYER_SLOT;
1018	 assembly {
1019	 sstore(slot, clrDeployer) }
1020	 }
1021	 function upgradeTo(address _implementation) external override ifAdmin {
1022	 require( ICLRDeployer(_clrDeployer()).sCLRTokenImplementation() == _implementation, "Can only upgrade to latest Staked CLR token implementation" );
1023	 _upgradeTo(_implementation);
1024	 }
1025	 function upgradeToAndCall(address _implementation, bytes calldata data) external payable override ifAdmin {
1026	 require( ICLRDeployer(_clrDeployer()).sCLRTokenImplementation() == _implementation, "Can only upgrade to latest Staked CLR token implementation" );
1027	 _upgradeTo(_implementation);
1028	 Address.functionDelegateCall(_implementation, data);
1029	 }
1030	 }
1031	 pragma solidity 0.7.6;
1032	 interface ICLRDeployer {
1033	 function clrImplementation() external view returns (address);
1034	 function deployCLRPool(address _proxyAdmin) external returns (address pool);
1035	 function deploySCLRToken(address _proxyAdmin) external returns (address token);
1036	 function owner() external view returns (address);
1037	 function renounceOwnership() external;
1038	 function sCLRTokenImplementation() external view returns (address);
1039	 function setCLRImplementation(address _clrImplementation) external;
1040	 function setsCLRTokenImplementation(address _sCLRTokenImplementation) external;
1041	 function transferOwnership(address newOwner) external;
1042	 }
1043	 pragma solidity 0.7.6;
1044	 contract NonRewardPoolProxy is TransparentUpgradeableProxy {
1045	 bytes32 private constant _DEPLOYER_SLOT = 0xa31c8a9c15ab83630b8333276b3d2f13132daf1ee481355dbdc6ab0253791319;
1046	 constructor( address _logic, address _proxyAdmin, address __poolDeployer ) TransparentUpgradeableProxy(_logic, _proxyAdmin, "") {
1047	 assert( _DEPLOYER_SLOT == bytes32( uint256(keccak256("eip1967.proxy.nonRewardPoolDeployer")) - 1 ) );
1048	 _setNonRewardPoolDeployer(__poolDeployer);
1049	 }
1050	 function _poolDeployer() internal view virtual returns (address poolDeployer) {
1051	 bytes32 slot = _DEPLOYER_SLOT;
1052	 assembly {
1053	 poolDeployer := sload(slot) }
1054	 }
1055	 function _setNonRewardPoolDeployer(address poolDeployer) private {
1056	 bytes32 slot = _DEPLOYER_SLOT;
1057	 assembly {
1058	 sstore(slot, poolDeployer) }
1059	 }
1060	 function upgradeTo(address _implementation) external override ifAdmin {
1061	 require( INonRewardPoolDeployer(_poolDeployer()) .nonRewardPoolImplementation() == _implementation, "Can only upgrade to latest NonRewardPool implementation" );
1062	 _upgradeTo(_implementation);
1063	 }
1064	 function upgradeToAndCall(address _implementation, bytes calldata data) external payable override ifAdmin {
1065	 require( INonRewardPoolDeployer(_poolDeployer()) .nonRewardPoolImplementation() == _implementation, "Can only upgrade to latest NonRewardPool implementation" );
1066	 _upgradeTo(_implementation);
1067	 Address.functionDelegateCall(_implementation, data);
1068	 }
1069	 }
1070	 pragma solidity 0.7.6;
1071	 interface INonRewardPoolDeployer {
1072	 function nonRewardPoolImplementation() external view returns (address);
1073	 function deployNonRewardPool(address _proxyAdmin) external returns (address pool);
1074	 function owner() external view returns (address);
1075	 function renounceOwnership() external;
1076	 function setNonRewardPoolImplementation(address _poolImplementation) external;
1077	 function transferOwnership(address newOwner) external;
1078	 }
