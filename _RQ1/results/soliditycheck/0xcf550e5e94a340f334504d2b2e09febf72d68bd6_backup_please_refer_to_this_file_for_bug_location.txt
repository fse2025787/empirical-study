row number 
1	 pragma experimental ABIEncoderV2;
2	 library Address {
3	 function isContract(address account) internal view returns (bool) {
4	 bytes32 codehash;
5	 bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
6	 assembly {
7	 codehash := extcodehash(account) }
8	 return (codehash != accountHash && codehash != 0x0);
9	 }
10	 function sendValue(address payable recipient, uint256 amount) internal {
11	 require(address(this).balance >= amount, "Address: insufficient balance");
12	 (bool success, ) = recipient.call{
13	 value: amount }
14	 ("");
15	 require(success, "Address: unable to send value, recipient may have reverted");
16	 }
17	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
18	 return functionCall(target, data, "Address: low-level call failed");
19	 }
20	 function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
21	 return _functionCallWithValue(target, data, 0, errorMessage);
22	 }
23	 function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
24	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
25	 }
26	 function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
27	 require(address(this).balance >= value, "Address: insufficient balance for call");
28	 return _functionCallWithValue(target, data, value, errorMessage);
29	 }
30	 function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {
31	 require(isContract(target), "Address: call to non-contract");
32	 (bool success, bytes memory returndata) = target.call{
33	 value: weiValue }
34	 (data);
35	 if (success) {
36	 return returndata;
37	 }
38	 else {
39	 if (returndata.length > 0) {
40	 assembly {
41	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
42	 }
43	 else {
44	 revert(errorMessage);
45	 }
46	 }
47	 }
48	 }
49	 abstract contract Context {
50	 function _msgSender() internal view virtual returns (address payable) {
51	 return msg.sender;
52	 }
53	 function _msgData() internal view virtual returns (bytes memory) {
54	 this;
55	 return msg.data;
56	 }
57	 }
58	 interface IERC20 {
59	 function totalSupply() external view returns (uint256);
60	 function balanceOf(address account) external view returns (uint256);
61	 function transfer(address recipient, uint256 amount) external returns (bool);
62	 function allowance(address owner, address spender) external view returns (uint256);
63	 function approve(address spender, uint256 amount) external returns (bool);
64	 function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
65	 event Transfer(address indexed from, address indexed to, uint256 value);
66	 event Approval(address indexed owner, address indexed spender, uint256 value);
67	 }
68	 interface ILiquidityGauge {
69	 function integrate_fraction(address user) external view returns (uint256);
70	 function user_checkpoint(address user) external returns (bool);
71	 function is_killed() external view returns (bool);
72	 function killGauge() external;
73	 function unkillGauge() external;
74	 }
75	 library Math {
76	 function max(uint256 a, uint256 b) internal pure returns (uint256) {
77	 return a >= b ? a : b;
78	 }
79	 function min(uint256 a, uint256 b) internal pure returns (uint256) {
80	 return a < b ? a : b;
81	 }
82	 function average(uint256 a, uint256 b) internal pure returns (uint256) {
83	 return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);
84	 }
85	 }
86	 library SafeMath {
87	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
88	 uint256 c = a + b;
89	 require(c >= a, "SafeMath: addition overflow");
90	 return c;
91	 }
92	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
93	 return sub(a, b, "SafeMath: subtraction overflow");
94	 }
95	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
96	 require(b <= a, errorMessage);
97	 uint256 c = a - b;
98	 return c;
99	 }
100	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
101	 if (a == 0) {
102	 return 0;
103	 }
104	 uint256 c = a * b;
105	 require(c / a == b, "SafeMath: multiplication overflow");
106	 return c;
107	 }
108	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
109	 return div(a, b, "SafeMath: division by zero");
110	 }
111	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
112	 require(b > 0, errorMessage);
113	 uint256 c = a / b;
114	 return c;
115	 }
116	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
117	 return mod(a, b, "SafeMath: modulo by zero");
118	 }
119	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
120	 require(b != 0, errorMessage);
121	 return a % b;
122	 }
123	 }
124	 contract ERC20 is Context, IERC20 {
125	 using SafeMath for uint256;
126	 using Address for address;
127	 mapping (address => uint256) private _balances;
128	 mapping (address => mapping (address => uint256)) private _allowances;
129	 uint256 private _totalSupply;
130	 string private _name;
131	 string private _symbol;
132	 uint8 private _decimals;
133	 constructor (string memory name, string memory symbol) public {
134	 _name = name;
135	 _symbol = symbol;
136	 _decimals = 18;
137	 }
138	 function name() public view returns (string memory) {
139	 return _name;
140	 }
141	 function symbol() public view returns (string memory) {
142	 return _symbol;
143	 }
144	 function decimals() public view returns (uint8) {
145	 return _decimals;
146	 }
147	 function totalSupply() public view override returns (uint256) {
148	 return _totalSupply;
149	 }
150	 function balanceOf(address account) public view override returns (uint256) {
151	 return _balances[account];
152	 }
153	 function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
154	 _transfer(_msgSender(), recipient, amount);
155	 return true;
156	 }
157	 function allowance(address owner, address spender) public view virtual override returns (uint256) {
158	 return _allowances[owner][spender];
159	 }
160	 function approve(address spender, uint256 amount) public virtual override returns (bool) {
161	 _approve(_msgSender(), spender, amount);
162	 return true;
163	 }
164	 function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
165	 _transfer(sender, recipient, amount);
166	 _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
167	 return true;
168	 }
169	 function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
170	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
171	 return true;
172	 }
173	 function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
174	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
175	 return true;
176	 }
177	 function _transfer(address sender, address recipient, uint256 amount) internal virtual {
178	 require(sender != address(0), "ERC20: transfer from the zero address");
179	 require(recipient != address(0), "ERC20: transfer to the zero address");
180	 _beforeTokenTransfer(sender, recipient, amount);
181	 _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
182	 _balances[recipient] = _balances[recipient].add(amount);
183	 emit Transfer(sender, recipient, amount);
184	 }
185	 function _mint(address account, uint256 amount) internal virtual {
186	 require(account != address(0), "ERC20: mint to the zero address");
187	 _beforeTokenTransfer(address(0), account, amount);
188	 _totalSupply = _totalSupply.add(amount);
189	 _balances[account] = _balances[account].add(amount);
190	 emit Transfer(address(0), account, amount);
191	 }
192	 function _burn(address account, uint256 amount) internal virtual {
193	 require(account != address(0), "ERC20: burn from the zero address");
194	 _beforeTokenTransfer(account, address(0), amount);
195	 _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
196	 _totalSupply = _totalSupply.sub(amount);
197	 emit Transfer(account, address(0), amount);
198	 }
199	 function _approve(address owner, address spender, uint256 amount) internal virtual {
200	 require(owner != address(0), "ERC20: approve from the zero address");
201	 require(spender != address(0), "ERC20: approve to the zero address");
202	 _allowances[owner][spender] = amount;
203	 emit Approval(owner, spender, amount);
204	 }
205	 function _setupDecimals(uint8 decimals_) internal {
206	 _decimals = decimals_;
207	 }
208	 function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {
209	 }
210	 }
211	 interface IStakingLiquidityGauge is ILiquidityGauge, IERC20 {
212	 function initialize(address lpToken) external;
213	 function lp_token() external view returns (IERC20);
214	 function deposit(uint256 value, address recipient) external;
215	 function withdraw(uint256 value) external;
216	 function claim_rewards(address user) external;
217	 function add_reward(address rewardToken, address distributor) external;
218	 function set_reward_distributor(address rewardToken, address distributor) external;
219	 }
220	 library SafeERC20 {
221	 using SafeMath for uint256;
222	 using Address for address;
223	 function safeTransfer(IERC20 token, address to, uint256 value) internal {
224	 _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
225	 }
226	 function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
227	 _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
228	 }
229	 function safeApprove(IERC20 token, address spender, uint256 value) internal {
230	 require((value == 0) || (token.allowance(address(this), spender) == 0), "SafeERC20: approve from non-zero to non-zero allowance" );
231	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
232	 }
233	 function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
234	 uint256 newAllowance = token.allowance(address(this), spender).add(value);
235	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
236	 }
237	 function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
238	 uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
239	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
240	 }
241	 function _callOptionalReturn(IERC20 token, bytes memory data) private {
242	 bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
243	 if (returndata.length > 0) {
244	 require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
245	 }
246	 }
247	 }
248	 interface IBalancerPool is IERC20 {
249	 enum SwapKind {
250	 GIVEN_IN, GIVEN_OUT}
251	 struct SwapRequest {
252	 SwapKind kind;
253	 IERC20 tokenIn;
254	 IERC20 tokenOut;
255	 uint256 amount;
256	 bytes32 poolId;
257	 uint256 lastChangeBlock;
258	 address from;
259	 address to;
260	 bytes userData;
261	 }
262	 function getRate() external view returns (uint);
263	 function getPoolId() external view returns (bytes32 poolId);
264	 function symbol() external view returns (string memory s);
265	 function onSwap( SwapRequest memory swapRequest, uint256[] memory balances, uint256 indexIn, uint256 indexOut ) external view returns (uint256 amount);
266	 }
267	 interface IBalancerVault {
268	 enum PoolSpecialization {
269	 GENERAL, MINIMAL_SWAP_INFO, TWO_TOKEN}
270	 enum JoinKind {
271	 INIT, EXACT_TOKENS_IN_FOR_BPT_OUT, TOKEN_IN_FOR_EXACT_BPT_OUT, ALL_TOKENS_IN_FOR_EXACT_BPT_OUT}
272	 enum ExitKind {
273	 EXACT_BPT_IN_FOR_ONE_TOKEN_OUT, EXACT_BPT_IN_FOR_TOKENS_OUT, BPT_IN_FOR_EXACT_TOKENS_OUT}
274	 enum SwapKind {
275	 GIVEN_IN, GIVEN_OUT}
276	 struct BatchSwapStep {
277	 bytes32 poolId;
278	 uint256 assetInIndex;
279	 uint256 assetOutIndex;
280	 uint256 amount;
281	 bytes userData;
282	 }
283	 struct FundManagement {
284	 address sender;
285	 bool fromInternalBalance;
286	 address payable recipient;
287	 bool toInternalBalance;
288	 }
289	 struct SingleSwap {
290	 bytes32 poolId;
291	 SwapKind kind;
292	 IAsset assetIn;
293	 IAsset assetOut;
294	 uint256 amount;
295	 bytes userData;
296	 }
297	 struct JoinPoolRequest {
298	 IAsset[] assets;
299	 uint256[] maxAmountsIn;
300	 bytes userData;
301	 bool fromInternalBalance;
302	 }
303	 struct ExitPoolRequest {
304	 IAsset[] assets;
305	 uint256[] minAmountsOut;
306	 bytes userData;
307	 bool toInternalBalance;
308	 }
309	 function joinPool( bytes32 poolId, address sender, address recipient, JoinPoolRequest memory request ) external payable;
310	 function exitPool( bytes32 poolId, address sender, address payable recipient, ExitPoolRequest calldata request ) external;
311	 function getPool(bytes32 poolId) external view returns (address poolAddress, PoolSpecialization);
312	 function getPoolTokenInfo(bytes32 poolId, IERC20 token) external view returns ( uint256 cash, uint256 managed, uint256 lastChangeBlock, address assetManager );
313	 function getPoolTokens(bytes32 poolId) external view returns ( IERC20[] calldata tokens, uint256[] calldata balances, uint256 lastChangeBlock );
314	 function swap( SingleSwap memory singleSwap, FundManagement memory funds, uint256 limit, uint256 deadline ) external returns (uint256 amountCalculated);
315	 function batchSwap( SwapKind kind, BatchSwapStep[] memory swaps, IAsset[] memory assets, FundManagement memory funds, int256[] memory limits, uint256 deadline ) external payable returns (int256[] memory);
316	 }
317	 interface IAsset {
318	 }
319	 interface IBalancerVaultHelper {
320	 struct JoinPoolRequest {
321	 IAsset[] assets;
322	 uint256[] maxAmountsIn;
323	 bytes userData;
324	 bool fromInternalBalance;
325	 }
326	 struct ExitPoolRequest {
327	 IAsset[] assets;
328	 uint256[] minAmountsOut;
329	 bytes userData;
330	 bool toInternalBalance;
331	 }
332	 function queryJoin( bytes32 poolId, address sender, address recipient, IBalancerVault.JoinPoolRequest memory request ) external view returns (uint256 bptOut, uint256[] memory amountsIn);
333	 function queryExit( bytes32 poolId, address sender, address recipient, IBalancerVault.ExitPoolRequest memory request ) external view returns (uint256 bptIn, uint256[] memory amountsOut);
334	 }
335	 struct StrategyParams {
336	 uint256 performanceFee;
337	 uint256 activation;
338	 uint256 debtRatio;
339	 uint256 minDebtPerHarvest;
340	 uint256 maxDebtPerHarvest;
341	 uint256 lastReport;
342	 uint256 totalDebt;
343	 uint256 totalGain;
344	 uint256 totalLoss;
345	 }
346	 interface VaultAPI is IERC20 {
347	 function name() external view returns (string calldata);
348	 function symbol() external view returns (string calldata);
349	 function decimals() external view returns (uint256);
350	 function apiVersion() external pure returns (string memory);
351	 function permit( address owner, address spender, uint256 amount, uint256 expiry, bytes calldata signature ) external returns (bool);
352	 function deposit() external returns (uint256);
353	 function deposit(uint256 amount) external returns (uint256);
354	 function deposit(uint256 amount, address recipient) external returns (uint256);
355	 function withdraw() external returns (uint256);
356	 function withdraw(uint256 maxShares) external returns (uint256);
357	 function withdraw(uint256 maxShares, address recipient) external returns (uint256);
358	 function token() external view returns (address);
359	 function strategies(address _strategy) external view returns (StrategyParams memory);
360	 function pricePerShare() external view returns (uint256);
361	 function totalAssets() external view returns (uint256);
362	 function depositLimit() external view returns (uint256);
363	 function maxAvailableShares() external view returns (uint256);
364	 function creditAvailable() external view returns (uint256);
365	 function debtOutstanding() external view returns (uint256);
366	 function expectedReturn() external view returns (uint256);
367	 function report( uint256 _gain, uint256 _loss, uint256 _debtPayment ) external returns (uint256);
368	 function revokeStrategy() external;
369	 function governance() external view returns (address);
370	 function management() external view returns (address);
371	 function guardian() external view returns (address);
372	 }
373	 interface StrategyAPI {
374	 function name() external view returns (string memory);
375	 function vault() external view returns (address);
376	 function want() external view returns (address);
377	 function apiVersion() external pure returns (string memory);
378	 function keeper() external view returns (address);
379	 function isActive() external view returns (bool);
380	 function delegatedAssets() external view returns (uint256);
381	 function estimatedTotalAssets() external view returns (uint256);
382	 function tendTrigger(uint256 callCost) external view returns (bool);
383	 function tend() external;
384	 function harvestTrigger(uint256 callCost) external view returns (bool);
385	 function harvest() external;
386	 event Harvested(uint256 profit, uint256 loss, uint256 debtPayment, uint256 debtOutstanding);
387	 }
388	 interface HealthCheck {
389	 function check( uint256 profit, uint256 loss, uint256 debtPayment, uint256 debtOutstanding, uint256 totalDebt ) external view returns (bool);
390	 }
391	 abstract contract BaseStrategy {
392	 using SafeMath for uint256;
393	 using SafeERC20 for IERC20;
394	 string public metadataURI;
395	 bool public doHealthCheck;
396	 address public healthCheck;
397	 function apiVersion() public pure returns (string memory) {
398	 return "0.4.3";
399	 }
400	 function name() external view virtual returns (string memory);
401	 function delegatedAssets() external view virtual returns (uint256) {
402	 return 0;
403	 }
404	 VaultAPI public vault;
405	 address public strategist;
406	 address public rewards;
407	 address public keeper;
408	 IERC20 public want;
409	 event Harvested(uint256 profit, uint256 loss, uint256 debtPayment, uint256 debtOutstanding);
410	 event UpdatedStrategist(address newStrategist);
411	 event UpdatedKeeper(address newKeeper);
412	 event UpdatedRewards(address rewards);
413	 event UpdatedMinReportDelay(uint256 delay);
414	 event UpdatedMaxReportDelay(uint256 delay);
415	 event UpdatedProfitFactor(uint256 profitFactor);
416	 event UpdatedDebtThreshold(uint256 debtThreshold);
417	 event EmergencyExitEnabled();
418	 event UpdatedMetadataURI(string metadataURI);
419	 uint256 public minReportDelay;
420	 uint256 public maxReportDelay;
421	 uint256 public profitFactor;
422	 uint256 public debtThreshold;
423	 bool public emergencyExit;
424	 modifier onlyAuthorized() {
425	 require(msg.sender == strategist || msg.sender == governance(), "!authorized");
426	 _;
427	 }
428	 modifier onlyEmergencyAuthorized() {
429	 require( msg.sender == strategist || msg.sender == governance() || msg.sender == vault.guardian() || msg.sender == vault.management(), "!authorized" );
430	 _;
431	 }
432	 modifier onlyStrategist() {
433	 require(msg.sender == strategist, "!strategist");
434	 _;
435	 }
436	 modifier onlyGovernance() {
437	 require(msg.sender == governance(), "!authorized");
438	 _;
439	 }
440	 modifier onlyKeepers() {
441	 require( msg.sender == keeper || msg.sender == strategist || msg.sender == governance() || msg.sender == vault.guardian() || msg.sender == vault.management(), "!authorized" );
442	 _;
443	 }
444	 modifier onlyVaultManagers() {
445	 require(msg.sender == vault.management() || msg.sender == governance(), "!authorized");
446	 _;
447	 }
448	 constructor(address _vault) public {
449	 _initialize(_vault, msg.sender, msg.sender, msg.sender);
450	 }
451	 function _initialize( address _vault, address _strategist, address _rewards, address _keeper ) internal {
452	 require(address(want) == address(0), "Strategy already initialized");
453	 vault = VaultAPI(_vault);
454	 want = IERC20(vault.token());
455	 want.safeApprove(_vault, uint256(-1));
456	 strategist = _strategist;
457	 rewards = _rewards;
458	 keeper = _keeper;
459	 minReportDelay = 0;
460	 maxReportDelay = 86400;
461	 profitFactor = 100;
462	 debtThreshold = 0;
463	 vault.approve(rewards, uint256(-1));
464	 }
465	 function setHealthCheck(address _healthCheck) external onlyVaultManagers {
466	 healthCheck = _healthCheck;
467	 }
468	 function setDoHealthCheck(bool _doHealthCheck) external onlyVaultManagers {
469	 doHealthCheck = _doHealthCheck;
470	 }
471	 function setStrategist(address _strategist) external onlyAuthorized {
472	 require(_strategist != address(0));
473	 strategist = _strategist;
474	 emit UpdatedStrategist(_strategist);
475	 }
476	 function setKeeper(address _keeper) external onlyAuthorized {
477	 require(_keeper != address(0));
478	 keeper = _keeper;
479	 emit UpdatedKeeper(_keeper);
480	 }
481	 function setRewards(address _rewards) external onlyStrategist {
482	 require(_rewards != address(0));
483	 vault.approve(rewards, 0);
484	 rewards = _rewards;
485	 vault.approve(rewards, uint256(-1));
486	 emit UpdatedRewards(_rewards);
487	 }
488	 function setMinReportDelay(uint256 _delay) external onlyAuthorized {
489	 minReportDelay = _delay;
490	 emit UpdatedMinReportDelay(_delay);
491	 }
492	 function setMaxReportDelay(uint256 _delay) external onlyAuthorized {
493	 maxReportDelay = _delay;
494	 emit UpdatedMaxReportDelay(_delay);
495	 }
496	 function setProfitFactor(uint256 _profitFactor) external onlyAuthorized {
497	 profitFactor = _profitFactor;
498	 emit UpdatedProfitFactor(_profitFactor);
499	 }
500	 function setDebtThreshold(uint256 _debtThreshold) external onlyAuthorized {
501	 debtThreshold = _debtThreshold;
502	 emit UpdatedDebtThreshold(_debtThreshold);
503	 }
504	 function setMetadataURI(string calldata _metadataURI) external onlyAuthorized {
505	 metadataURI = _metadataURI;
506	 emit UpdatedMetadataURI(_metadataURI);
507	 }
508	 function governance() internal view returns (address) {
509	 return vault.governance();
510	 }
511	 function ethToWant(uint256 _amtInWei) public view virtual returns (uint256);
512	 function estimatedTotalAssets() public view virtual returns (uint256);
513	 function isActive() public view returns (bool) {
514	 return vault.strategies(address(this)).debtRatio > 0 || estimatedTotalAssets() > 0;
515	 }
516	 function prepareReturn(uint256 _debtOutstanding) internal virtual returns ( uint256 _profit, uint256 _loss, uint256 _debtPayment );
517	 function adjustPosition(uint256 _debtOutstanding) internal virtual;
518	 function liquidatePosition(uint256 _amountNeeded) internal virtual returns (uint256 _liquidatedAmount, uint256 _loss);
519	 function liquidateAllPositions() internal virtual returns (uint256 _amountFreed);
520	 function tendTrigger(uint256 callCostInWei) public view virtual returns (bool) {
521	 return false;
522	 }
523	 function tend() external onlyKeepers {
524	 adjustPosition(vault.debtOutstanding());
525	 }
526	 function harvestTrigger(uint256 callCostInWei) public view virtual returns (bool) {
527	 uint256 callCost = ethToWant(callCostInWei);
528	 StrategyParams memory params = vault.strategies(address(this));
529	 if (params.activation == 0) return false;
530	 if (block.timestamp.sub(params.lastReport) < minReportDelay) return false;
531	 if (block.timestamp.sub(params.lastReport) >= maxReportDelay) return true;
532	 uint256 outstanding = vault.debtOutstanding();
533	 if (outstanding > debtThreshold) return true;
534	 uint256 total = estimatedTotalAssets();
535	 if (total.add(debtThreshold) < params.totalDebt) return true;
536	 uint256 profit = 0;
537	 if (total > params.totalDebt) profit = total.sub(params.totalDebt);
538	 uint256 credit = vault.creditAvailable();
539	 return (profitFactor.mul(callCost) < credit.add(profit));
540	 }
541	 function harvest() external onlyKeepers {
542	 uint256 profit = 0;
543	 uint256 loss = 0;
544	 uint256 debtOutstanding = vault.debtOutstanding();
545	 uint256 debtPayment = 0;
546	 if (emergencyExit) {
547	 uint256 amountFreed = liquidateAllPositions();
548	 if (amountFreed < debtOutstanding) {
549	 loss = debtOutstanding.sub(amountFreed);
550	 }
551	 else if (amountFreed > debtOutstanding) {
552	 profit = amountFreed.sub(debtOutstanding);
553	 }
554	 debtPayment = debtOutstanding.sub(loss);
555	 }
556	 else {
557	 (profit, loss, debtPayment) = prepareReturn(debtOutstanding);
558	 }
559	 uint256 totalDebt = vault.strategies(address(this)).totalDebt;
560	 debtOutstanding = vault.report(profit, loss, debtPayment);
561	 adjustPosition(debtOutstanding);
562	 if (doHealthCheck && healthCheck != address(0)) {
563	 require(HealthCheck(healthCheck).check(profit, loss, debtPayment, debtOutstanding, totalDebt), "!healthcheck");
564	 }
565	 else {
566	 doHealthCheck = true;
567	 }
568	 emit Harvested(profit, loss, debtPayment, debtOutstanding);
569	 }
570	 function withdraw(uint256 _amountNeeded) external returns (uint256 _loss) {
571	 require(msg.sender == address(vault), "!vault");
572	 uint256 amountFreed;
573	 (amountFreed, _loss) = liquidatePosition(_amountNeeded);
574	 want.safeTransfer(msg.sender, amountFreed);
575	 }
576	 function prepareMigration(address _newStrategy) internal virtual;
577	 function migrate(address _newStrategy) external {
578	 require(msg.sender == address(vault));
579	 require(BaseStrategy(_newStrategy).vault() == vault);
580	 prepareMigration(_newStrategy);
581	 want.safeTransfer(_newStrategy, want.balanceOf(address(this)));
582	 }
583	 function setEmergencyExit() external onlyEmergencyAuthorized {
584	 emergencyExit = true;
585	 vault.revokeStrategy();
586	 emit EmergencyExitEnabled();
587	 }
588	 function protectedTokens() internal view virtual returns (address[] memory);
589	 function sweep(address _token) external onlyGovernance {
590	 require(_token != address(want), "!want");
591	 require(_token != address(vault), "!shares");
592	 address[] memory _protectedTokens = protectedTokens();
593	 for (uint256 i; i < _protectedTokens.length; i++) require(_token != _protectedTokens[i], "!protected");
594	 IERC20(_token).safeTransfer(governance(), IERC20(_token).balanceOf(address(this)));
595	 }
596	 }
597	 abstract contract BaseStrategyInitializable is BaseStrategy {
598	 bool public isOriginal = true;
599	 event Cloned(address indexed clone);
600	 constructor(address _vault) public BaseStrategy(_vault) {
601	 }
602	 function initialize( address _vault, address _strategist, address _rewards, address _keeper ) external virtual {
603	 _initialize(_vault, _strategist, _rewards, _keeper);
604	 }
605	 function clone(address _vault) external returns (address) {
606	 require(isOriginal, "!clone");
607	 return this.clone(_vault, msg.sender, msg.sender, msg.sender);
608	 }
609	 function clone( address _vault, address _strategist, address _rewards, address _keeper ) external returns (address newStrategy) {
610	 bytes20 addressBytes = bytes20(address(this));
611	 assembly {
612	 let clone_code := mload(0x40) mstore(clone_code, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000) mstore(add(clone_code, 0x14), addressBytes) mstore(add(clone_code, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000) newStrategy := create(0, clone_code, 0x37) }
613	 BaseStrategyInitializable(newStrategy).initialize(_vault, _strategist, _rewards, _keeper);
614	 emit Cloned(newStrategy);
615	 }
616	 }
617	 interface ILiquidityGaugeFactory {
618	 function isGaugeFromFactory(address gauge) external view returns (bool);
619	 function getPoolGauge(address pool) external view returns (IStakingLiquidityGauge);
620	 }
621	 interface IName {
622	 function name() external view returns (string memory);
623	 }
624	 contract Strategy is BaseStrategy {
625	 using SafeERC20 for IERC20;
626	 using SafeMath for uint256;
627	 modifier isVaultManager {
628	 checkVaultManagers();
629	 _;
630	 }
631	 function checkVaultManagers() internal {
632	 require(msg.sender == vault.governance() || msg.sender == vault.management());
633	 }
634	 IBalancerVault public balancerVault;
635	 IBalancerPool public bpt;
636	 ILiquidityGaugeFactory public gaugeFactory;
637	 IStakingLiquidityGauge public gauge;
638	 IERC20[] public rewardTokens;
639	 IAsset[] internal assets;
640	 SwapSteps[] internal swapSteps;
641	 bytes32 public balancerPoolId;
642	 uint8 public numTokens;
643	 uint8 public tokenIndex;
644	 Toggles public toggles;
645	 address public keep;
646	 uint256 public keepBips;
647	 struct Toggles {
648	 bool doSellRewards;
649	 bool doClaimRewards;
650	 bool doCollectTradingFees;
651	 }
652	 struct SwapSteps {
653	 bytes32[] poolIds;
654	 IAsset[] assets;
655	 }
656	 uint256 internal constant max = type(uint256).max;
657	 uint256 public maxSlippageIn;
658	 uint256 public maxSlippageOut;
659	 uint256 public maxSingleDeposit;
660	 uint256 public minDepositPeriod;
661	 uint256 public lastDepositTime;
662	 uint256 internal constant basisOne = 10000;
663	 constructor( address _vault, address _balancerVault, address _balancerPool, address _gaugeFactory, uint256 _maxSlippageIn, uint256 _maxSlippageOut, uint256 _maxSingleDeposit, uint256 _minDepositPeriod) public BaseStrategy(_vault){
664	 _initializeStrat(_vault, _balancerVault, _balancerPool, _gaugeFactory, _maxSlippageIn, _maxSlippageOut, _maxSingleDeposit, _minDepositPeriod);
665	 }
666	 function initialize( address _vault, address _strategist, address _rewards, address _keeper, address _balancerVault, address _balancerPool, address _gaugeFactory, uint256 _maxSlippageIn, uint256 _maxSlippageOut, uint256 _maxSingleDeposit, uint256 _minDepositPeriod ) external {
667	 _initialize(_vault, _strategist, _rewards, _keeper);
668	 _initializeStrat(_vault, _balancerVault, _balancerPool, _gaugeFactory, _maxSlippageIn, _maxSlippageOut, _maxSingleDeposit, _minDepositPeriod);
669	 }
670	 function _initializeStrat( address _vault, address _balancerVault, address _balancerPool, address _gaugeFactory, uint256 _maxSlippageIn, uint256 _maxSlippageOut, uint256 _maxSingleDeposit, uint256 _minDepositPeriod) internal {
671	 healthCheck = address(0xDDCea799fF1699e98EDF118e0629A974Df7DF012);
672	 bpt = IBalancerPool(_balancerPool);
673	 balancerPoolId = bpt.getPoolId();
674	 balancerVault = IBalancerVault(_balancerVault);
675	 (IERC20[] memory tokens,,) = balancerVault.getPoolTokens(balancerPoolId);
676	 require(tokens.length > 0, "Empty Pool");
677	 numTokens = uint8(tokens.length);
678	 assets = new IAsset[](numTokens);
679	 tokenIndex = type(uint8).max;
680	 for (uint8 i = 0; i < numTokens; i++) {
681	 if (tokens[i] == want) {
682	 tokenIndex = i;
683	 }
684	 assets[i] = IAsset(address(tokens[i]));
685	 }
686	 require(tokenIndex != type(uint8).max, "token not supported in pool!");
687	 maxSlippageIn = _maxSlippageIn;
688	 maxSlippageOut = _maxSlippageOut;
689	 maxSingleDeposit = _maxSingleDeposit.mul(10 ** uint256(ERC20(address(want)).decimals()));
690	 minDepositPeriod = _minDepositPeriod;
691	 require(_gaugeFactory != address(0));
692	 gaugeFactory = ILiquidityGaugeFactory(_gaugeFactory);
693	 gauge = IStakingLiquidityGauge(gaugeFactory.getPoolGauge(address(bpt)));
694	 require(address(gauge) != address(0));
695	 require(address(gauge.lp_token()) == address(bpt));
696	 want.safeApprove(address(balancerVault), max);
697	 IERC20(bpt).safeApprove(address(gauge), max);
698	 toggles = Toggles({
699	 doSellRewards : true, doClaimRewards : true, doCollectTradingFees : true}
700	 );
701	 keepBips = 1000;
702	 keep = governance();
703	 }
704	 function name() external view override returns (string memory) {
705	 return string(abi.encodePacked("SSBv3 ", ERC20(address(want)).symbol(), " ", bpt.symbol()));
706	 }
707	 function estimatedTotalAssets() public view override returns (uint256) {
708	 return balanceOfWant().add(balanceOfPooled());
709	 }
710	 function prepareReturn(uint256 _debtOutstanding) internal override returns (uint256 _profit, uint256 _loss, uint256 _debtPayment){
711	 if (_debtOutstanding > 0) {
712	 (_debtPayment, _loss) = liquidatePosition(_debtOutstanding);
713	 }
714	 uint256 beforeWant = balanceOfWant();
715	 if (toggles.doCollectTradingFees) {
716	 _collectTradingFees();
717	 }
718	 if (toggles.doClaimRewards) {
719	 _claimRewards();
720	 }
721	 if (toggles.doSellRewards) {
722	 _sellRewards();
723	 }
724	 uint256 afterWant = balanceOfWant();
725	 _profit = afterWant.sub(beforeWant);
726	 if (_profit > _loss) {
727	 _profit = _profit.sub(_loss);
728	 _debtPayment = _debtPayment.add(_loss);
729	 _loss = 0;
730	 }
731	 else {
732	 _loss = _loss.sub(_profit);
733	 _debtPayment = _debtPayment.add(_profit);
734	 _profit = 0;
735	 }
736	 }
737	 function adjustPosition(uint256 _debtOutstanding) internal override {
738	 if (now.sub(lastDepositTime) < minDepositPeriod) {
739	 return;
740	 }
741	 uint256 amountIn = Math.min(maxSingleDeposit, balanceOfWant());
742	 uint256 expectedBptOut = tokensToBpts(amountIn).mul(basisOne.sub(maxSlippageIn)).div(basisOne);
743	 uint256[] memory maxAmountsIn = new uint256[](numTokens);
744	 maxAmountsIn[tokenIndex] = amountIn;
745	 if (amountIn > 0) {
746	 bytes memory userData = abi.encode(IBalancerVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT, maxAmountsIn, expectedBptOut);
747	 IBalancerVault.JoinPoolRequest memory request = IBalancerVault.JoinPoolRequest(assets, maxAmountsIn, userData, false);
748	 balancerVault.joinPool(balancerPoolId, address(this), address(this), request);
749	 lastDepositTime = now;
750	 }
751	 uint256 _unstakedBpt = balanceOfUnstakedBpt();
752	 if (_unstakedBpt > 0) {
753	 _stakeBpt(_unstakedBpt);
754	 }
755	 }
756	 function liquidatePosition(uint256 _amountNeeded) internal override returns (uint256 _liquidatedAmount, uint256 _loss){
757	 uint256 looseAmount = balanceOfWant();
758	 if (_amountNeeded > looseAmount) {
759	 uint256 toExitAmount = tokensToBpts(_amountNeeded.sub(looseAmount));
760	 uint256 _unstakedBpt = balanceOfUnstakedBpt();
761	 if (toExitAmount > _unstakedBpt) {
762	 _unstakeBpt(toExitAmount.sub(_unstakedBpt));
763	 }
764	 _sellBpt(toExitAmount);
765	 _liquidatedAmount = Math.min(balanceOfWant(), _amountNeeded);
766	 _loss = _amountNeeded.sub(_liquidatedAmount);
767	 }
768	 else {
769	 _liquidatedAmount = _amountNeeded;
770	 }
771	 require(_amountNeeded == _liquidatedAmount.add(_loss), "!sanitycheck");
772	 }
773	 function liquidateAllPositions() internal override returns (uint256 liquidated) {
774	 _unstakeBpt(balanceOfStakedBpt());
775	 _sellBpt(balanceOfUnstakedBpt());
776	 liquidated = balanceOfWant();
777	 return liquidated;
778	 }
779	 function prepareMigration(address _newStrategy) internal override {
780	 _unstakeBpt(balanceOfStakedBpt());
781	 bpt.transfer(_newStrategy, balanceOfUnstakedBpt());
782	 for (uint i = 0; i < rewardTokens.length; i++) {
783	 IERC20 token = rewardTokens[i];
784	 uint256 balance = token.balanceOf(address(this));
785	 if (balance > 0) {
786	 token.safeTransfer(_newStrategy, balance);
787	 }
788	 }
789	 }
790	 function protectedTokens() internal view override returns (address[] memory){
791	 }
792	 function ethToWant(uint256 _amtInWei) public view override returns (uint256){
793	 }
794	 function tendTrigger(uint256 callCostInWei) public view override returns (bool) {
795	 return now.sub(lastDepositTime) > minDepositPeriod && (balanceOfWant() > 0 || balanceOfUnstakedBpt() > 0);
796	 }
797	 function claimAndSellRewards(bool _doSellRewards) external isVaultManager {
798	 _claimRewards();
799	 if (_doSellRewards) {
800	 _sellRewards();
801	 }
802	 }
803	 function _sellRewards() internal {
804	 for (uint8 i = 0; i < rewardTokens.length; i++) {
805	 ERC20 rewardToken = ERC20(address(rewardTokens[i]));
806	 uint256 amount = rewardToken.balanceOf(address(this));
807	 uint decReward = rewardToken.decimals();
808	 uint decWant = ERC20(address(want)).decimals();
809	 if (amount > 10 ** (decReward > decWant ? decReward.sub(decWant) : 0)) {
810	 uint length = swapSteps[i].poolIds.length;
811	 IBalancerVault.BatchSwapStep[] memory steps = new IBalancerVault.BatchSwapStep[](length);
812	 int[] memory limits = new int[](length + 1);
813	 limits[0] = int(amount);
814	 for (uint j = 0; j < length; j++) {
815	 steps[j] = IBalancerVault.BatchSwapStep(swapSteps[i].poolIds[j], j, j + 1, j == 0 ? amount : 0, abi.encode(0) );
816	 }
817	 balancerVault.batchSwap(IBalancerVault.SwapKind.GIVEN_IN, steps, swapSteps[i].assets, IBalancerVault.FundManagement(address(this), false, address(this), false), limits, now + 10);
818	 }
819	 }
820	 }
821	 function _claimRewards() internal {
822	 uint256 balBefore = balanceOfReward(0);
823	 gauge.claim_rewards(address(this));
824	 uint256 keepAmount = balanceOfReward(0).sub(balBefore).mul(keepBips).div(basisOne);
825	 if (keepAmount > 0) {
826	 rewardTokens[0].safeTransfer(keep, keepAmount);
827	 }
828	 }
829	 function collectTradingFees() external isVaultManager {
830	 _collectTradingFees();
831	 }
832	 function _collectTradingFees() internal {
833	 uint256 total = estimatedTotalAssets();
834	 uint256 debt = vault.strategies(address(this)).totalDebt;
835	 if (total > debt) {
836	 uint256 profit = tokensToBpts(total.sub(debt));
837	 uint256 _unstakedBpt = balanceOfUnstakedBpt();
838	 if (profit > _unstakedBpt) {
839	 _unstakeBpt(profit.sub(_unstakedBpt));
840	 _sellBpt(balanceOfUnstakedBpt());
841	 }
842	 _sellBpt(Math.min(profit, balanceOfUnstakedBpt()));
843	 }
844	 }
845	 function balanceOfWant() public view returns (uint256 _amount){
846	 return want.balanceOf(address(this));
847	 }
848	 function balanceOfUnstakedBpt() public view returns (uint256 _amount){
849	 return bpt.balanceOf(address(this));
850	 }
851	 function balanceOfStakedBpt() public view returns (uint256 _amount){
852	 return gauge.balanceOf(address(this));
853	 }
854	 function balanceOfReward(uint256 index) public view returns (uint256 _amount){
855	 return rewardTokens[index].balanceOf(address(this));
856	 }
857	 function balanceOfPooled() public view returns (uint256 _amount){
858	 return bptsToTokens(balanceOfStakedBpt().add(balanceOfUnstakedBpt()));
859	 }
860	 function bptsToTokens(uint _amountBpt) public view returns (uint _amount){
861	 uint unscaled = _amountBpt.mul(bpt.getRate()).div(1e18);
862	 return _scaleDecimals(unscaled, ERC20(address(bpt)), ERC20(address(want)));
863	 }
864	 function tokensToBpts(uint _amountTokens) public view returns (uint _amount){
865	 uint unscaled = _amountTokens.mul(1e18).div(bpt.getRate());
866	 return _scaleDecimals(unscaled, ERC20(address(want)), ERC20(address(bpt)));
867	 }
868	 function _scaleDecimals(uint _amount, ERC20 _fromToken, ERC20 _toToken) internal view returns (uint _scaled){
869	 uint decFrom = _fromToken.decimals();
870	 uint decTo = _toToken.decimals();
871	 return decTo > decFrom ? _amount.mul(10 ** (decTo.sub(decFrom))) : _amount.div(10 ** (decFrom.sub(decTo)));
872	 }
873	 function _getSwapRequest(IERC20 token, uint256 amount, uint256 lastChangeBlock) internal view returns (IBalancerPool.SwapRequest memory request){
874	 return IBalancerPool.SwapRequest(IBalancerPool.SwapKind.GIVEN_IN, token, want, amount, balancerPoolId, lastChangeBlock, address(this), address(this), abi.encode(0) );
875	 }
876	 function sellBpt(uint256 _amountBpts) external isVaultManager {
877	 _sellBpt(_amountBpts);
878	 }
879	 function _sellBpt(uint256 _amountBpts) internal {
880	 _amountBpts = Math.min(_amountBpts, balanceOfUnstakedBpt());
881	 if (_amountBpts > 0) {
882	 uint256[] memory minAmountsOut = new uint256[](numTokens);
883	 minAmountsOut[tokenIndex] = bptsToTokens(_amountBpts).mul(basisOne.sub(maxSlippageOut)).div(basisOne);
884	 bytes memory userData = abi.encode(IBalancerVault.ExitKind.EXACT_BPT_IN_FOR_ONE_TOKEN_OUT, _amountBpts, tokenIndex);
885	 IBalancerVault.ExitPoolRequest memory request = IBalancerVault.ExitPoolRequest(assets, minAmountsOut, userData, false);
886	 balancerVault.exitPool(balancerPoolId, address(this), address(this), request);
887	 }
888	 }
889	 function whitelistRewards(address _rewardToken, SwapSteps memory _steps) public isVaultManager {
890	 IERC20 token = IERC20(_rewardToken);
891	 token.approve(address(balancerVault), max);
892	 rewardTokens.push(token);
893	 swapSteps.push(_steps);
894	 }
895	 function delistAllRewards() public isVaultManager {
896	 for (uint i = 0; i < rewardTokens.length; i++) {
897	 rewardTokens[i].approve(address(balancerVault), 0);
898	 }
899	 IERC20[] memory noRewardTokens;
900	 rewardTokens = noRewardTokens;
901	 delete swapSteps;
902	 }
903	 function numRewards() public view returns (uint256 _num){
904	 return rewardTokens.length;
905	 }
906	 function setParams(uint256 _maxSlippageIn, uint256 _maxSlippageOut, uint256 _maxSingleDeposit, uint256 _minDepositPeriod) public isVaultManager {
907	 require(_maxSlippageIn <= basisOne, "maxSlippageIn too high");
908	 maxSlippageIn = _maxSlippageIn;
909	 require(_maxSlippageOut <= basisOne, "maxSlippageOut too high");
910	 maxSlippageOut = _maxSlippageOut;
911	 maxSingleDeposit = _maxSingleDeposit;
912	 minDepositPeriod = _minDepositPeriod;
913	 }
914	 function setToggles(bool _doSellRewards, bool _doClaimRewards, bool _doCollectTradingFees) external isVaultManager {
915	 toggles.doSellRewards = _doSellRewards;
916	 toggles.doClaimRewards = _doClaimRewards;
917	 toggles.doCollectTradingFees = _doCollectTradingFees;
918	 }
919	 function getSwapSteps() public view returns (SwapSteps[] memory){
920	 return swapSteps;
921	 }
922	 function stakeBpt(uint256 _amount) external isVaultManager {
923	 _stakeBpt(_amount);
924	 }
925	 function _stakeBpt(uint256 _amount) internal {
926	 gauge.deposit(Math.min(balanceOfUnstakedBpt(), _amount), address(this));
927	 }
928	 function unstakeBpt(uint256 _amount) external isVaultManager {
929	 _unstakeBpt(_amount);
930	 }
931	 function _unstakeBpt(uint256 _amount) internal {
932	 gauge.withdraw(Math.min(balanceOfStakedBpt(), _amount));
933	 }
934	 function setKeepParams(address _keep, uint256 _keepBips) external onlyGovernance {
935	 require(keepBips <= basisOne);
936	 keep = _keep;
937	 keepBips = _keepBips;
938	 }
939	 function sweepETH() public onlyGovernance {
940	 (bool success,) = governance().call{
941	 value : address(this).balance}
942	 ("");
943	 require(success, "!FailedETHSweep");
944	 }
945	 receive() external payable {
946	 }
947	 }
