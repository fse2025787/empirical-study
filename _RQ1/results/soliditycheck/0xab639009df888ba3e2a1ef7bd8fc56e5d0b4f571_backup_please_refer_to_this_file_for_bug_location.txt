row number 
1	               pragma solidity 0.7.6;
2	 interface IVault {
3	 function deposit( uint256, uint256, uint256, uint256, address ) external returns ( uint256, uint256, uint256 );
4	 function withdraw( uint256, uint256, uint256, address ) external returns (uint256, uint256);
5	 function getTotalAmounts() external view returns (uint256, uint256);
6	 }
7	 library Address {
8	 function isContract(address account) internal view returns (bool) {
9	 uint256 size;
10	 assembly {
11	 size := extcodesize(account) }
12	 return size > 0;
13	 }
14	 function sendValue(address payable recipient, uint256 amount) internal {
15	 require(address(this).balance >= amount, "Address: insufficient balance");
16	 (bool success, ) = recipient.call{
17	 value: amount }
18	 ("");
19	 require(success, "Address: unable to send value, recipient may have reverted");
20	 }
21	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
22	 return functionCall(target, data, "Address: low-level call failed");
23	 }
24	 function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
25	 return functionCallWithValue(target, data, 0, errorMessage);
26	 }
27	 function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
28	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
29	 }
30	 function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
31	 require(address(this).balance >= value, "Address: insufficient balance for call");
32	 require(isContract(target), "Address: call to non-contract");
33	 (bool success, bytes memory returndata) = target.call{
34	 value: value }
35	 (data);
36	 return _verifyCallResult(success, returndata, errorMessage);
37	 }
38	 function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
39	 return functionStaticCall(target, data, "Address: low-level static call failed");
40	 }
41	 function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
42	 require(isContract(target), "Address: static call to non-contract");
43	 (bool success, bytes memory returndata) = target.staticcall(data);
44	 return _verifyCallResult(success, returndata, errorMessage);
45	 }
46	 function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
47	 return functionDelegateCall(target, data, "Address: low-level delegate call failed");
48	 }
49	 function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
50	 require(isContract(target), "Address: delegate call to non-contract");
51	 (bool success, bytes memory returndata) = target.delegatecall(data);
52	 return _verifyCallResult(success, returndata, errorMessage);
53	 }
54	 function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
55	 if (success) {
56	 return returndata;
57	 }
58	 else {
59	 if (returndata.length > 0) {
60	 assembly {
61	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
62	 }
63	 else {
64	 revert(errorMessage);
65	 }
66	 }
67	 }
68	 }
69	 abstract contract Context {
70	 function _msgSender() internal view virtual returns (address payable) {
71	 return msg.sender;
72	 }
73	 function _msgData() internal view virtual returns (bytes memory) {
74	 this;
75	 return msg.data;
76	 }
77	 }
78	 interface IERC20 {
79	 function totalSupply() external view returns (uint256);
80	 function balanceOf(address account) external view returns (uint256);
81	 function transfer(address recipient, uint256 amount) external returns (bool);
82	 function allowance(address owner, address spender) external view returns (uint256);
83	 function approve(address spender, uint256 amount) external returns (bool);
84	 function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
85	 event Transfer(address indexed from, address indexed to, uint256 value);
86	 event Approval(address indexed owner, address indexed spender, uint256 value);
87	 }
88	 library Math {
89	 function max(uint256 a, uint256 b) internal pure returns (uint256) {
90	 return a >= b ? a : b;
91	 }
92	 function min(uint256 a, uint256 b) internal pure returns (uint256) {
93	 return a < b ? a : b;
94	 }
95	 function average(uint256 a, uint256 b) internal pure returns (uint256) {
96	 return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);
97	 }
98	 }
99	 abstract contract ReentrancyGuard {
100	 uint256 private constant _NOT_ENTERED = 1;
101	 uint256 private constant _ENTERED = 2;
102	 uint256 private _status;
103	 constructor () internal {
104	 _status = _NOT_ENTERED;
105	 }
106	 modifier nonReentrant() {
107	 require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
108	 _status = _ENTERED;
109	 _;
110	 _status = _NOT_ENTERED;
111	 }
112	 }
113	 library SafeMath {
114	 function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
115	 uint256 c = a + b;
116	 if (c < a) return (false, 0);
117	 return (true, c);
118	 }
119	 function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
120	 if (b > a) return (false, 0);
121	 return (true, a - b);
122	 }
123	 function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
124	 if (a == 0) return (true, 0);
125	 uint256 c = a * b;
126	 if (c / a != b) return (false, 0);
127	 return (true, c);
128	 }
129	 function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
130	 if (b == 0) return (false, 0);
131	 return (true, a / b);
132	 }
133	 function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
134	 if (b == 0) return (false, 0);
135	 return (true, a % b);
136	 }
137	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
138	 uint256 c = a + b;
139	 require(c >= a, "SafeMath: addition overflow");
140	 return c;
141	 }
142	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
143	 require(b <= a, "SafeMath: subtraction overflow");
144	 return a - b;
145	 }
146	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
147	 if (a == 0) return 0;
148	 uint256 c = a * b;
149	 require(c / a == b, "SafeMath: multiplication overflow");
150	 return c;
151	 }
152	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
153	 require(b > 0, "SafeMath: division by zero");
154	 return a / b;
155	 }
156	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
157	 require(b > 0, "SafeMath: modulo by zero");
158	 return a % b;
159	 }
160	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
161	 require(b <= a, errorMessage);
162	 return a - b;
163	 }
164	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
165	 require(b > 0, errorMessage);
166	 return a / b;
167	 }
168	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
169	 require(b > 0, errorMessage);
170	 return a % b;
171	 }
172	 }
173	 library PositionKey {
174	 function compute( address owner, int24 tickLower, int24 tickUpper ) internal pure returns (bytes32) {
175	 return keccak256(abi.encodePacked(owner, tickLower, tickUpper));
176	 }
177	 }
178	 library FixedPoint96 {
179	 uint8 internal constant RESOLUTION = 96;
180	 uint256 internal constant Q96 = 0x1000000000000000000000000;
181	 }
182	 library FullMath {
183	 function mulDiv( uint256 a, uint256 b, uint256 denominator ) internal pure returns (uint256 result) {
184	 uint256 prod0;
185	 uint256 prod1;
186	 assembly {
187	 let mm := mulmod(a, b, not(0)) prod0 := mul(a, b) prod1 := sub(sub(mm, prod0), lt(mm, prod0)) }
188	 if (prod1 == 0) {
189	 require(denominator > 0);
190	 assembly {
191	 result := div(prod0, denominator) }
192	 return result;
193	 }
194	 require(denominator > prod1);
195	 uint256 remainder;
196	 assembly {
197	 remainder := mulmod(a, b, denominator) }
198	 assembly {
199	 prod1 := sub(prod1, gt(remainder, prod0)) prod0 := sub(prod0, remainder) }
200	 uint256 twos = -denominator & denominator;
201	 assembly {
202	 denominator := div(denominator, twos) }
203	 assembly {
204	 prod0 := div(prod0, twos) }
205	 assembly {
206	 twos := add(div(sub(0, twos), twos), 1) }
207	 prod0 |= prod1 * twos;
208	 uint256 inv = (3 * denominator) ^ 2;
209	 inv *= 2 - denominator * inv;
210	 inv *= 2 - denominator * inv;
211	 inv *= 2 - denominator * inv;
212	 inv *= 2 - denominator * inv;
213	 inv *= 2 - denominator * inv;
214	 inv *= 2 - denominator * inv;
215	 result = prod0 * inv;
216	 return result;
217	 }
218	 function mulDivRoundingUp( uint256 a, uint256 b, uint256 denominator ) internal pure returns (uint256 result) {
219	 result = mulDiv(a, b, denominator);
220	 if (mulmod(a, b, denominator) > 0) {
221	 require(result < type(uint256).max);
222	 result++;
223	 }
224	 }
225	 }
226	 interface IUniswapV3MintCallback {
227	 function uniswapV3MintCallback( uint256 amount0Owed, uint256 amount1Owed, bytes calldata data ) external;
228	 }
229	 interface IUniswapV3PoolActions {
230	 function initialize(uint160 sqrtPriceX96) external;
231	 function mint( address recipient, int24 tickLower, int24 tickUpper, uint128 amount, bytes calldata data ) external returns (uint256 amount0, uint256 amount1);
232	 function collect( address recipient, int24 tickLower, int24 tickUpper, uint128 amount0Requested, uint128 amount1Requested ) external returns (uint128 amount0, uint128 amount1);
233	 function burn( int24 tickLower, int24 tickUpper, uint128 amount ) external returns (uint256 amount0, uint256 amount1);
234	 function swap( address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes calldata data ) external returns (int256 amount0, int256 amount1);
235	 function flash( address recipient, uint256 amount0, uint256 amount1, bytes calldata data ) external;
236	 function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;
237	 }
238	 interface IUniswapV3PoolDerivedState {
239	 function observe(uint32[] calldata secondsAgos) external view returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);
240	 function snapshotCumulativesInside(int24 tickLower, int24 tickUpper) external view returns ( int56 tickCumulativeInside, uint160 secondsPerLiquidityInsideX128, uint32 secondsInside );
241	 }
242	 interface IUniswapV3PoolEvents {
243	 event Initialize(uint160 sqrtPriceX96, int24 tick);
244	 event Mint( address sender, address indexed owner, int24 indexed tickLower, int24 indexed tickUpper, uint128 amount, uint256 amount0, uint256 amount1 );
245	 event Collect( address indexed owner, address recipient, int24 indexed tickLower, int24 indexed tickUpper, uint128 amount0, uint128 amount1 );
246	 event Burn( address indexed owner, int24 indexed tickLower, int24 indexed tickUpper, uint128 amount, uint256 amount0, uint256 amount1 );
247	 event Swap( address indexed sender, address indexed recipient, int256 amount0, int256 amount1, uint160 sqrtPriceX96, uint128 liquidity, int24 tick );
248	 event Flash( address indexed sender, address indexed recipient, uint256 amount0, uint256 amount1, uint256 paid0, uint256 paid1 );
249	 event IncreaseObservationCardinalityNext( uint16 observationCardinalityNextOld, uint16 observationCardinalityNextNew );
250	 event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);
251	 event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);
252	 }
253	 interface IUniswapV3PoolImmutables {
254	 function factory() external view returns (address);
255	 function token0() external view returns (address);
256	 function token1() external view returns (address);
257	 function fee() external view returns (uint24);
258	 function tickSpacing() external view returns (int24);
259	 function maxLiquidityPerTick() external view returns (uint128);
260	 }
261	 interface IUniswapV3PoolOwnerActions {
262	 function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;
263	 function collectProtocol( address recipient, uint128 amount0Requested, uint128 amount1Requested ) external returns (uint128 amount0, uint128 amount1);
264	 }
265	 interface IUniswapV3PoolState {
266	 function slot0() external view returns ( uint160 sqrtPriceX96, int24 tick, uint16 observationIndex, uint16 observationCardinality, uint16 observationCardinalityNext, uint8 feeProtocol, bool unlocked );
267	 function feeGrowthGlobal0X128() external view returns (uint256);
268	 function feeGrowthGlobal1X128() external view returns (uint256);
269	 function protocolFees() external view returns (uint128 token0, uint128 token1);
270	 function liquidity() external view returns (uint128);
271	 function ticks(int24 tick) external view returns ( uint128 liquidityGross, int128 liquidityNet, uint256 feeGrowthOutside0X128, uint256 feeGrowthOutside1X128, int56 tickCumulativeOutside, uint160 secondsPerLiquidityOutsideX128, uint32 secondsOutside, bool initialized );
272	 function tickBitmap(int16 wordPosition) external view returns (uint256);
273	 function positions(bytes32 key) external view returns ( uint128 _liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, uint128 tokensOwed0, uint128 tokensOwed1 );
274	 function observations(uint256 index) external view returns ( uint32 blockTimestamp, int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128, bool initialized );
275	 }
276	 library TickMath {
277	 int24 internal constant MIN_TICK = -887272;
278	 int24 internal constant MAX_TICK = -MIN_TICK;
279	 uint160 internal constant MIN_SQRT_RATIO = 4295128739;
280	 uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;
281	 function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {
282	 uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));
283	 require(absTick <= uint256(MAX_TICK), 'T');
284	 uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;
285	 if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;
286	 if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;
287	 if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;
288	 if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;
289	 if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;
290	 if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;
291	 if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;
292	 if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;
293	 if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;
294	 if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;
295	 if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;
296	 if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;
297	 if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;
298	 if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;
299	 if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;
300	 if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;
301	 if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;
302	 if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;
303	 if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;
304	 if (tick > 0) ratio = type(uint256).max / ratio;
305	 sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));
306	 }
307	 function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {
308	 require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');
309	 uint256 ratio = uint256(sqrtPriceX96) << 32;
310	 uint256 r = ratio;
311	 uint256 msb = 0;
312	 assembly {
313	 let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) msb := or(msb, f) r := shr(f, r) }
314	 assembly {
315	 let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF)) msb := or(msb, f) r := shr(f, r) }
316	 assembly {
317	 let f := shl(5, gt(r, 0xFFFFFFFF)) msb := or(msb, f) r := shr(f, r) }
318	 assembly {
319	 let f := shl(4, gt(r, 0xFFFF)) msb := or(msb, f) r := shr(f, r) }
320	 assembly {
321	 let f := shl(3, gt(r, 0xFF)) msb := or(msb, f) r := shr(f, r) }
322	 assembly {
323	 let f := shl(2, gt(r, 0xF)) msb := or(msb, f) r := shr(f, r) }
324	 assembly {
325	 let f := shl(1, gt(r, 0x3)) msb := or(msb, f) r := shr(f, r) }
326	 assembly {
327	 let f := gt(r, 0x1) msb := or(msb, f) }
328	 if (msb >= 128) r = ratio >> (msb - 127);
329	 else r = ratio << (127 - msb);
330	 int256 log_2 = (int256(msb) - 128) << 64;
331	 assembly {
332	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(63, f)) r := shr(f, r) }
333	 assembly {
334	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(62, f)) r := shr(f, r) }
335	 assembly {
336	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(61, f)) r := shr(f, r) }
337	 assembly {
338	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(60, f)) r := shr(f, r) }
339	 assembly {
340	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(59, f)) r := shr(f, r) }
341	 assembly {
342	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(58, f)) r := shr(f, r) }
343	 assembly {
344	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(57, f)) r := shr(f, r) }
345	 assembly {
346	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(56, f)) r := shr(f, r) }
347	 assembly {
348	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(55, f)) r := shr(f, r) }
349	 assembly {
350	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(54, f)) r := shr(f, r) }
351	 assembly {
352	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(53, f)) r := shr(f, r) }
353	 assembly {
354	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(52, f)) r := shr(f, r) }
355	 assembly {
356	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(51, f)) r := shr(f, r) }
357	 assembly {
358	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(50, f)) }
359	 int256 log_sqrt10001 = log_2 * 255738958999603826347141;
360	 int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);
361	 int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);
362	 tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;
363	 }
364	 }
365	 library LiquidityAmounts {
366	 function toUint128(uint256 x) private pure returns (uint128 y) {
367	 require((y = uint128(x)) == x);
368	 }
369	 function getLiquidityForAmount0( uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint256 amount0 ) internal pure returns (uint128 liquidity) {
370	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
371	 uint256 intermediate = FullMath.mulDiv(sqrtRatioAX96, sqrtRatioBX96, FixedPoint96.Q96);
372	 return toUint128(FullMath.mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));
373	 }
374	 function getLiquidityForAmount1( uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint256 amount1 ) internal pure returns (uint128 liquidity) {
375	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
376	 return toUint128(FullMath.mulDiv(amount1, FixedPoint96.Q96, sqrtRatioBX96 - sqrtRatioAX96));
377	 }
378	 function getLiquidityForAmounts( uint160 sqrtRatioX96, uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint256 amount0, uint256 amount1 ) internal pure returns (uint128 liquidity) {
379	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
380	 if (sqrtRatioX96 <= sqrtRatioAX96) {
381	 liquidity = getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);
382	 }
383	 else if (sqrtRatioX96 < sqrtRatioBX96) {
384	 uint128 liquidity0 = getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);
385	 uint128 liquidity1 = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);
386	 liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;
387	 }
388	 else {
389	 liquidity = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);
390	 }
391	 }
392	 function getAmount0ForLiquidity( uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity ) internal pure returns (uint256 amount0) {
393	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
394	 return FullMath.mulDiv( uint256(liquidity) << FixedPoint96.RESOLUTION, sqrtRatioBX96 - sqrtRatioAX96, sqrtRatioBX96 ) / sqrtRatioAX96;
395	 }
396	 function getAmount1ForLiquidity( uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity ) internal pure returns (uint256 amount1) {
397	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
398	 return FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);
399	 }
400	 function getAmountsForLiquidity( uint160 sqrtRatioX96, uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity ) internal pure returns (uint256 amount0, uint256 amount1) {
401	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
402	 if (sqrtRatioX96 <= sqrtRatioAX96) {
403	 amount0 = getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);
404	 }
405	 else if (sqrtRatioX96 < sqrtRatioBX96) {
406	 amount0 = getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);
407	 amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);
408	 }
409	 else {
410	 amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);
411	 }
412	 }
413	 }
414	 contract ERC20 is Context, IERC20 {
415	 using SafeMath for uint256;
416	 mapping (address => uint256) private _balances;
417	 mapping (address => mapping (address => uint256)) private _allowances;
418	 uint256 private _totalSupply;
419	 string private _name;
420	 string private _symbol;
421	 uint8 private _decimals;
422	 constructor (string memory name_, string memory symbol_) public {
423	 _name = name_;
424	 _symbol = symbol_;
425	 _decimals = 18;
426	 }
427	 function name() public view virtual returns (string memory) {
428	 return _name;
429	 }
430	 function symbol() public view virtual returns (string memory) {
431	 return _symbol;
432	 }
433	 function decimals() public view virtual returns (uint8) {
434	 return _decimals;
435	 }
436	 function totalSupply() public view virtual override returns (uint256) {
437	 return _totalSupply;
438	 }
439	 function balanceOf(address account) public view virtual override returns (uint256) {
440	 return _balances[account];
441	 }
442	 function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
443	 _transfer(_msgSender(), recipient, amount);
444	 return true;
445	 }
446	 function allowance(address owner, address spender) public view virtual override returns (uint256) {
447	 return _allowances[owner][spender];
448	 }
449	 function approve(address spender, uint256 amount) public virtual override returns (bool) {
450	 _approve(_msgSender(), spender, amount);
451	 return true;
452	 }
453	 function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
454	 _transfer(sender, recipient, amount);
455	 _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
456	 return true;
457	 }
458	 function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
459	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
460	 return true;
461	 }
462	 function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
463	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
464	 return true;
465	 }
466	 function _transfer(address sender, address recipient, uint256 amount) internal virtual {
467	 require(sender != address(0), "ERC20: transfer from the zero address");
468	 require(recipient != address(0), "ERC20: transfer to the zero address");
469	 _beforeTokenTransfer(sender, recipient, amount);
470	 _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
471	 _balances[recipient] = _balances[recipient].add(amount);
472	 emit Transfer(sender, recipient, amount);
473	 }
474	 function _mint(address account, uint256 amount) internal virtual {
475	 require(account != address(0), "ERC20: mint to the zero address");
476	 _beforeTokenTransfer(address(0), account, amount);
477	 _totalSupply = _totalSupply.add(amount);
478	 _balances[account] = _balances[account].add(amount);
479	 emit Transfer(address(0), account, amount);
480	 }
481	 function _burn(address account, uint256 amount) internal virtual {
482	 require(account != address(0), "ERC20: burn from the zero address");
483	 _beforeTokenTransfer(account, address(0), amount);
484	 _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
485	 _totalSupply = _totalSupply.sub(amount);
486	 emit Transfer(account, address(0), amount);
487	 }
488	 function _approve(address owner, address spender, uint256 amount) internal virtual {
489	 require(owner != address(0), "ERC20: approve from the zero address");
490	 require(spender != address(0), "ERC20: approve to the zero address");
491	 _allowances[owner][spender] = amount;
492	 emit Approval(owner, spender, amount);
493	 }
494	 function _setupDecimals(uint8 decimals_) internal virtual {
495	 _decimals = decimals_;
496	 }
497	 function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {
498	 }
499	 }
500	 library SafeERC20 {
501	 using SafeMath for uint256;
502	 using Address for address;
503	 function safeTransfer(IERC20 token, address to, uint256 value) internal {
504	 _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
505	 }
506	 function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
507	 _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
508	 }
509	 function safeApprove(IERC20 token, address spender, uint256 value) internal {
510	 require((value == 0) || (token.allowance(address(this), spender) == 0), "SafeERC20: approve from non-zero to non-zero allowance" );
511	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
512	 }
513	 function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
514	 uint256 newAllowance = token.allowance(address(this), spender).add(value);
515	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
516	 }
517	 function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
518	 uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
519	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
520	 }
521	 function _callOptionalReturn(IERC20 token, bytes memory data) private {
522	 bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
523	 if (returndata.length > 0) {
524	 require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
525	 }
526	 }
527	 }
528	 interface IUniswapV3Pool is IUniswapV3PoolImmutables, IUniswapV3PoolState, IUniswapV3PoolDerivedState, IUniswapV3PoolActions, IUniswapV3PoolOwnerActions, IUniswapV3PoolEvents {
529	 }
530	 contract AlphaVault is IVault, IUniswapV3MintCallback, ERC20, ReentrancyGuard {
531	 using SafeERC20 for IERC20;
532	 using SafeMath for uint256;
533	 event Deposit( address indexed sender, address indexed to, uint256 shares, uint256 amount0, uint256 amount1 );
534	 event Withdraw( address indexed sender, address indexed to, uint256 shares, uint256 amount0, uint256 amount1 );
535	 event CollectFees( uint256 feesFromPool0, uint256 feesFromPool1, uint256 feesToProtocol0, uint256 feesToProtocol1 );
536	 event Snapshot(int24 tick, uint256 totalAmount0, uint256 totalAmount1, uint256 totalSupply);
537	 IUniswapV3Pool public pool;
538	 IERC20 public immutable token0;
539	 IERC20 public immutable token1;
540	 int24 public immutable tickSpacing;
541	 uint256 public protocolFee;
542	 uint256 public maxTotalSupply;
543	 address public strategy;
544	 address public governance;
545	 address public pendingGovernance;
546	 bool public finalized;
547	 int24 public baseLower;
548	 int24 public baseUpper;
549	 int24 public limitLower;
550	 int24 public limitUpper;
551	 uint256 public accruedProtocolFees0;
552	 uint256 public accruedProtocolFees1;
553	 constructor( address _pool, uint256 _protocolFee, uint256 _maxTotalSupply ) ERC20("Alpha Vault", "AV") {
554	 pool = IUniswapV3Pool(_pool);
555	 token0 = IERC20(pool.token0());
556	 token1 = IERC20(pool.token1());
557	 tickSpacing = pool.tickSpacing();
558	 protocolFee = _protocolFee;
559	 maxTotalSupply = _maxTotalSupply;
560	 governance = msg.sender;
561	 require(_protocolFee < 1e6, "protocolFee");
562	 }
563	 function deposit( uint256 amount0Desired, uint256 amount1Desired, uint256 amount0Min, uint256 amount1Min, address to ) external override nonReentrant returns ( uint256 shares, uint256 amount0, uint256 amount1 ) {
564	 require(amount0Desired > 0 || amount1Desired > 0, "amount0Desired or amount1Desired");
565	 require(to != address(0) && to != address(this), "to");
566	 if (_positionLiquidity(baseLower, baseUpper) > 0) {
567	 pool.burn(baseLower, baseUpper, 0);
568	 }
569	 if (_positionLiquidity(limitLower, limitUpper) > 0) {
570	 pool.burn(limitLower, limitUpper, 0);
571	 }
572	 (shares, amount0, amount1) = _calcSharesAndAmounts(amount0Desired, amount1Desired);
573	 require(shares > 0, "shares");
574	 require(amount0 >= amount0Min, "amount0Min");
575	 require(amount1 >= amount1Min, "amount1Min");
576	 if (amount0 > 0) token0.safeTransferFrom(msg.sender, address(this), amount0);
577	 if (amount1 > 0) token1.safeTransferFrom(msg.sender, address(this), amount1);
578	 _mint(to, shares);
579	 emit Deposit(msg.sender, to, shares, amount0, amount1);
580	 require(totalSupply() <= maxTotalSupply, "maxTotalSupply");
581	 }
582	 function _calcSharesAndAmounts(uint256 amount0Desired, uint256 amount1Desired) internal view returns ( uint256 shares, uint256 amount0, uint256 amount1 ) {
583	 uint256 totalSupply = totalSupply();
584	 (uint256 total0, uint256 total1) = getTotalAmounts();
585	 assert(totalSupply == 0 || total0 > 0 || total1 > 0);
586	 if (totalSupply == 0) {
587	 amount0 = amount0Desired;
588	 amount1 = amount1Desired;
589	 shares = Math.max(amount0, amount1);
590	 }
591	 else if (total0 == 0) {
592	 amount1 = amount1Desired;
593	 shares = amount1.mul(totalSupply).div(total1);
594	 }
595	 else if (total1 == 0) {
596	 amount0 = amount0Desired;
597	 shares = amount0.mul(totalSupply).div(total0);
598	 }
599	 else {
600	 uint256 cross = Math.min(amount0Desired.mul(total1), amount1Desired.mul(total0));
601	 require(cross > 0, "cross");
602	 amount0 = cross.sub(1).div(total1).add(1);
603	 amount1 = cross.sub(1).div(total0).add(1);
604	 shares = cross.mul(totalSupply).div(total0).div(total1);
605	 }
606	 }
607	 function withdraw( uint256 shares, uint256 amount0Min, uint256 amount1Min, address to ) external override nonReentrant returns (uint256 amount0, uint256 amount1) {
608	 require(shares > 0, "shares");
609	 require(to != address(0) && to != address(this), "to");
610	 (uint256 baseAmount0, uint256 baseAmount1) = _burnLiquidityShare(baseLower, baseUpper, shares, to);
611	 (uint256 limitAmount0, uint256 limitAmount1) = _burnLiquidityShare(limitLower, limitUpper, shares, to);
612	 uint256 totalSupply = totalSupply();
613	 uint256 unusedAmount0 = _balance0().mul(shares).div(totalSupply);
614	 uint256 unusedAmount1 = _balance1().mul(shares).div(totalSupply);
615	 if (unusedAmount0 > 0) token0.safeTransfer(to, unusedAmount0);
616	 if (unusedAmount1 > 0) token1.safeTransfer(to, unusedAmount1);
617	 amount0 = baseAmount0.add(limitAmount0).add(unusedAmount0);
618	 amount1 = baseAmount1.add(limitAmount1).add(unusedAmount1);
619	 require(amount0 >= amount0Min, "amount0Min");
620	 require(amount1 >= amount1Min, "amount1Min");
621	 _burn(msg.sender, shares);
622	 emit Withdraw(msg.sender, to, shares, amount0, amount1);
623	 }
624	 function _burnLiquidityShare( int24 tickLower, int24 tickUpper, uint256 shares, address to ) internal returns (uint256 amount0, uint256 amount1) {
625	 uint128 position = _positionLiquidity(tickLower, tickUpper);
626	 uint256 liquidity = uint256(position).mul(shares).div(totalSupply());
627	 if (liquidity > 0) {
628	 (amount0, amount1) = pool.burn(tickLower, tickUpper, _toUint128(liquidity));
629	 if (amount0 > 0 || amount1 > 0) {
630	 (amount0, amount1) = pool.collect( to, tickLower, tickUpper, _toUint128(amount0), _toUint128(amount1) );
631	 }
632	 }
633	 }
634	 function rebalance( int24 _baseLower, int24 _baseUpper, int24 _bidLower, int24 _bidUpper, int24 _askLower, int24 _askUpper ) external nonReentrant {
635	 require(msg.sender == strategy, "strategy");
636	 _checkRange(_baseLower, _baseUpper);
637	 _checkRange(_bidLower, _bidUpper);
638	 _checkRange(_askLower, _askUpper);
639	 (, int24 tick, , , , , ) = pool.slot0();
640	 require(_bidUpper <= tick, "bidUpper");
641	 require(_askLower > tick, "askLower");
642	 _burnAllLiquidity(baseLower, baseUpper);
643	 _burnAllLiquidity(limitLower, limitUpper);
644	 uint256 balance0 = _balance0();
645	 uint256 balance1 = _balance1();
646	 emit Snapshot(tick, balance0, balance1, totalSupply());
647	 uint128 liquidity = _liquidityForAmounts(_baseLower, _baseUpper, balance0, balance1);
648	 _mintLiquidity(_baseLower, _baseUpper, liquidity);
649	 (baseLower, baseUpper) = (_baseLower, _baseUpper);
650	 balance0 = _balance0();
651	 balance1 = _balance1();
652	 uint128 bidLiquidity = _liquidityForAmounts(_bidLower, _bidUpper, balance0, balance1);
653	 uint128 askLiquidity = _liquidityForAmounts(_askLower, _askUpper, balance0, balance1);
654	 if (bidLiquidity > askLiquidity) {
655	 _mintLiquidity(_bidLower, _bidUpper, bidLiquidity);
656	 (limitLower, limitUpper) = (_bidLower, _bidUpper);
657	 }
658	 else {
659	 _mintLiquidity(_askLower, _askUpper, askLiquidity);
660	 (limitLower, limitUpper) = (_askLower, _askUpper);
661	 }
662	 }
663	 function _checkRange(int24 tickLower, int24 tickUpper) internal view {
664	 int24 _tickSpacing = tickSpacing;
665	 require(tickLower < tickUpper, "tickLower < tickUpper");
666	 require(tickLower >= TickMath.MIN_TICK, "tickLower too low");
667	 require(tickUpper <= TickMath.MAX_TICK, "tickUpper too high");
668	 require(tickLower % _tickSpacing == 0, "tickLower % tickSpacing");
669	 require(tickUpper % _tickSpacing == 0, "tickUpper % tickSpacing");
670	 }
671	 function _burnAllLiquidity(int24 tickLower, int24 tickUpper) internal {
672	 uint256 owed0 = 0;
673	 uint256 owed1 = 0;
674	 uint128 liquidity = _positionLiquidity(tickLower, tickUpper);
675	 if (liquidity > 0) {
676	 (owed0, owed1) = pool.burn(tickLower, tickUpper, liquidity);
677	 }
678	 (uint256 collect0, uint256 collect1) = pool.collect( address(this), tickLower, tickUpper, type(uint128).max, type(uint128).max );
679	 uint256 feesFromPool0 = collect0.sub(owed0);
680	 uint256 feesFromPool1 = collect1.sub(owed1);
681	 uint256 feesToProtocol0 = 0;
682	 uint256 feesToProtocol1 = 0;
683	 uint256 _protocolFee = protocolFee;
684	 if (_protocolFee > 0) {
685	 feesToProtocol0 = feesFromPool0.mul(_protocolFee).div(1e6);
686	 feesToProtocol1 = feesFromPool1.mul(_protocolFee).div(1e6);
687	 accruedProtocolFees0 = accruedProtocolFees0.add(feesToProtocol0);
688	 accruedProtocolFees1 = accruedProtocolFees1.add(feesToProtocol1);
689	 }
690	 emit CollectFees(feesFromPool0, feesFromPool1, feesToProtocol0, feesToProtocol1);
691	 }
692	 function _mintLiquidity( int24 tickLower, int24 tickUpper, uint128 liquidity ) internal {
693	 if (liquidity > 0) {
694	 pool.mint(address(this), tickLower, tickUpper, liquidity, "");
695	 }
696	 }
697	 function getTotalAmounts() public view override returns (uint256 total0, uint256 total1) {
698	 (uint256 baseAmount0, uint256 baseAmount1) = _positionAmounts(baseLower, baseUpper);
699	 (uint256 limitAmount0, uint256 limitAmount1) = _positionAmounts(limitLower, limitUpper);
700	 total0 = _balance0().add(baseAmount0).add(limitAmount0);
701	 total1 = _balance1().add(baseAmount1).add(limitAmount1);
702	 }
703	 function _balance0() internal view returns (uint256) {
704	 return token0.balanceOf(address(this)).sub(accruedProtocolFees0);
705	 }
706	 function _balance1() internal view returns (uint256) {
707	 return token1.balanceOf(address(this)).sub(accruedProtocolFees1);
708	 }
709	 function _positionLiquidity(int24 tickLower, int24 tickUpper) internal view returns (uint128 liquidity) {
710	 bytes32 positionKey = PositionKey.compute(address(this), tickLower, tickUpper);
711	 (liquidity, , , , ) = pool.positions(positionKey);
712	 }
713	 function _positionAmounts(int24 tickLower, int24 tickUpper) internal view returns (uint256 amount0, uint256 amount1) {
714	 bytes32 positionKey = PositionKey.compute(address(this), tickLower, tickUpper);
715	 (uint128 liquidity, , , uint128 tokensOwed0, uint128 tokensOwed1) = pool.positions(positionKey);
716	 (amount0, amount1) = _amountsForLiquidity(tickLower, tickUpper, liquidity);
717	 amount0 = amount0.add(uint256(tokensOwed0));
718	 amount1 = amount1.add(uint256(tokensOwed1));
719	 }
720	 function _amountsForLiquidity( int24 tickLower, int24 tickUpper, uint128 liquidity ) internal view returns (uint256, uint256) {
721	 (uint160 sqrtRatioX96, , , , , , ) = pool.slot0();
722	 return LiquidityAmounts.getAmountsForLiquidity( sqrtRatioX96, TickMath.getSqrtRatioAtTick(tickLower), TickMath.getSqrtRatioAtTick(tickUpper), liquidity );
723	 }
724	 function _liquidityForAmounts( int24 tickLower, int24 tickUpper, uint256 amount0, uint256 amount1 ) internal view returns (uint128) {
725	 (uint160 sqrtRatioX96, , , , , , ) = pool.slot0();
726	 return LiquidityAmounts.getLiquidityForAmounts( sqrtRatioX96, TickMath.getSqrtRatioAtTick(tickLower), TickMath.getSqrtRatioAtTick(tickUpper), amount0, amount1 );
727	 }
728	 function _toUint128(uint256 x) internal pure returns (uint128) {
729	 assert(x <= type(uint128).max);
730	 return uint128(x);
731	 }
732	 function uniswapV3MintCallback( uint256 amount0, uint256 amount1, bytes calldata data ) external override {
733	 require(msg.sender == address(pool));
734	 if (amount0 > 0) token0.safeTransfer(msg.sender, amount0);
735	 if (amount1 > 0) token1.safeTransfer(msg.sender, amount1);
736	 }
737	 function collectProtocol( uint256 amount0, uint256 amount1, address to ) external onlyGovernance {
738	 accruedProtocolFees0 = accruedProtocolFees0.sub(amount0);
739	 accruedProtocolFees1 = accruedProtocolFees1.sub(amount1);
740	 if (amount0 > 0) token0.safeTransfer(to, amount0);
741	 if (amount1 > 0) token1.safeTransfer(to, amount1);
742	 }
743	 function sweep( IERC20 token, uint256 amount, address to ) external onlyGovernance {
744	 require(token != token0 && token != token1, "token");
745	 token.safeTransfer(to, amount);
746	 }
747	 function setStrategy(address _strategy) external onlyGovernance {
748	 strategy = _strategy;
749	 }
750	 function setProtocolFee(uint256 _protocolFee) external onlyGovernance {
751	 require(_protocolFee < 1e6, "protocolFee");
752	 protocolFee = _protocolFee;
753	 }
754	 function setMaxTotalSupply(uint256 _maxTotalSupply) external onlyGovernance {
755	 maxTotalSupply = _maxTotalSupply;
756	 }
757	 function finalize() external onlyGovernance {
758	 finalized = true;
759	 }
760	 function emergencyWithdraw(IERC20 token, uint256 amount) external onlyGovernance {
761	 require(!finalized, "finalized");
762	 token.safeTransfer(msg.sender, amount);
763	 }
764	 function emergencyBurn( int24 tickLower, int24 tickUpper, uint128 liquidity ) external onlyGovernance {
765	 require(!finalized, "finalized");
766	 pool.burn(tickLower, tickUpper, liquidity);
767	 pool.collect(msg.sender, tickLower, tickUpper, type(uint128).max, type(uint128).max);
768	 }
769	 function setGovernance(address _governance) external onlyGovernance {
770	 pendingGovernance = _governance;
771	 }
772	 function acceptGovernance() external {
773	 require(msg.sender == pendingGovernance, "pendingGovernance");
774	 governance = msg.sender;
775	 }
776	 modifier onlyGovernance {
777	 require(msg.sender == governance, "governance");
778	 _;
779	 }
780	 }
781	 contract AlphaStrategy {
782	 AlphaVault public vault;
783	 IUniswapV3Pool public pool;
784	 int24 public tickSpacing;
785	 int24 public baseThreshold;
786	 int24 public limitThreshold;
787	 int24 public maxTwapDeviation;
788	 uint32 public twapDuration;
789	 address public keeper;
790	 uint256 public lastRebalance;
791	 int24 public lastTick;
792	 constructor( address _vault, int24 _baseThreshold, int24 _limitThreshold, int24 _maxTwapDeviation, uint32 _twapDuration, address _keeper ) {
793	 vault = AlphaVault(_vault);
794	 pool = vault.pool();
795	 tickSpacing = pool.tickSpacing();
796	 baseThreshold = _baseThreshold;
797	 limitThreshold = _limitThreshold;
798	 maxTwapDeviation = _maxTwapDeviation;
799	 twapDuration = _twapDuration;
800	 keeper = _keeper;
801	 _checkThreshold(_baseThreshold);
802	 _checkThreshold(_limitThreshold);
803	 require(_maxTwapDeviation >= 0, "maxTwapDeviation");
804	 require(_twapDuration > 0, "twapDuration");
805	 (, lastTick, , , , , ) = pool.slot0();
806	 }
807	 function rebalance() external {
808	 require(msg.sender == keeper, "keeper");
809	 int24 tick = getTick();
810	 int24 maxThreshold = baseThreshold > limitThreshold ? baseThreshold : limitThreshold;
811	 require(tick > TickMath.MIN_TICK + maxThreshold + tickSpacing, "tick too low");
812	 require(tick < TickMath.MAX_TICK - maxThreshold - tickSpacing, "tick too high");
813	 int24 twap = getTwap();
814	 int24 deviation = tick > twap ? tick - twap : twap - tick;
815	 require(deviation <= maxTwapDeviation, "maxTwapDeviation");
816	 int24 tickFloor = _floor(tick);
817	 int24 tickCeil = tickFloor + tickSpacing;
818	 vault.rebalance( tickFloor - baseThreshold, tickCeil + baseThreshold, tickFloor - limitThreshold, tickFloor, tickCeil, tickCeil + limitThreshold );
819	 lastRebalance = block.timestamp;
820	 lastTick = tick;
821	 }
822	 function getTick() public view returns (int24 tick) {
823	 (, tick, , , , , ) = pool.slot0();
824	 }
825	 function getTwap() public view returns (int24) {
826	 uint32 _twapDuration = twapDuration;
827	 uint32[] memory secondsAgo = new uint32[](2);
828	 secondsAgo[0] = _twapDuration;
829	 secondsAgo[1] = 0;
830	 (int56[] memory tickCumulatives, ) = pool.observe(secondsAgo);
831	 return int24((tickCumulatives[1] - tickCumulatives[0]) / _twapDuration);
832	 }
833	 function _floor(int24 tick) internal view returns (int24) {
834	 int24 compressed = tick / tickSpacing;
835	 if (tick < 0 && tick % tickSpacing != 0) compressed--;
836	 return compressed * tickSpacing;
837	 }
838	 function _checkThreshold(int24 threshold) internal view {
839	 require(threshold > 0, "threshold > 0");
840	 require(threshold < TickMath.MAX_TICK, "threshold too high");
841	 require(threshold % tickSpacing == 0, "threshold % tickSpacing");
842	 }
843	 function setKeeper(address _keeper) external onlyGovernance {
844	 keeper = _keeper;
845	 }
846	 function setBaseThreshold(int24 _baseThreshold) external onlyGovernance {
847	 _checkThreshold(_baseThreshold);
848	 baseThreshold = _baseThreshold;
849	 }
850	 function setLimitThreshold(int24 _limitThreshold) external onlyGovernance {
851	 _checkThreshold(_limitThreshold);
852	 limitThreshold = _limitThreshold;
853	 }
854	 function setMaxTwapDeviation(int24 _maxTwapDeviation) external onlyGovernance {
855	 require(_maxTwapDeviation >= 0, "maxTwapDeviation");
856	 maxTwapDeviation = _maxTwapDeviation;
857	 }
858	 function setTwapDuration(uint32 _twapDuration) external onlyGovernance {
859	 require(_twapDuration > 0, "twapDuration");
860	 twapDuration = _twapDuration;
861	 }
862	 modifier onlyGovernance {
863	 require(msg.sender == vault.governance(), "governance");
864	 _;
865	 }
866	 }
