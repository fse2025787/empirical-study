row number 
1	  pragma abicoder v2;
2	 pragma solidity >=0.6.0 <0.8.0;
3	 abstract contract Context {
4	 function _msgSender() internal view virtual returns (address payable) {
5	 return msg.sender;
6	 }
7	 function _msgData() internal view virtual returns (bytes memory) {
8	 this;
9	 return msg.data;
10	 }
11	 }
12	 pragma solidity >=0.6.0 <0.8.0;
13	 pragma solidity >=0.6.0 <0.8.0;
14	 abstract contract AccessControl is Context {
15	 using EnumerableSet for EnumerableSet.AddressSet;
16	 using Address for address;
17	 struct RoleData {
18	 EnumerableSet.AddressSet members;
19	 bytes32 adminRole;
20	 }
21	 mapping (bytes32 => RoleData) private _roles;
22	 bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;
23	 event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
24	 event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
25	 event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
26	 function hasRole(bytes32 role, address account) public view returns (bool) {
27	 return _roles[role].members.contains(account);
28	 }
29	 function getRoleMemberCount(bytes32 role) public view returns (uint256) {
30	 return _roles[role].members.length();
31	 }
32	 function getRoleMember(bytes32 role, uint256 index) public view returns (address) {
33	 return _roles[role].members.at(index);
34	 }
35	 function getRoleAdmin(bytes32 role) public view returns (bytes32) {
36	 return _roles[role].adminRole;
37	 }
38	 function grantRole(bytes32 role, address account) public virtual {
39	 require(hasRole(_roles[role].adminRole, _msgSender()), "AccessControl: sender must be an admin to grant");
40	 _grantRole(role, account);
41	 }
42	 function revokeRole(bytes32 role, address account) public virtual {
43	 require(hasRole(_roles[role].adminRole, _msgSender()), "AccessControl: sender must be an admin to revoke");
44	 _revokeRole(role, account);
45	 }
46	 function renounceRole(bytes32 role, address account) public virtual {
47	 require(account == _msgSender(), "AccessControl: can only renounce roles for self");
48	 _revokeRole(role, account);
49	 }
50	 function _setupRole(bytes32 role, address account) internal virtual {
51	 _grantRole(role, account);
52	 }
53	 function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
54	 emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);
55	 _roles[role].adminRole = adminRole;
56	 }
57	 function _grantRole(bytes32 role, address account) private {
58	 if (_roles[role].members.add(account)) {
59	 emit RoleGranted(role, account, _msgSender());
60	 }
61	 }
62	 function _revokeRole(bytes32 role, address account) private {
63	 if (_roles[role].members.remove(account)) {
64	 emit RoleRevoked(role, account, _msgSender());
65	 }
66	 }
67	 }
68	 pragma solidity >=0.6.0 <0.8.0;
69	 abstract contract Pausable is Context {
70	 event Paused(address account);
71	 event Unpaused(address account);
72	 bool private _paused;
73	 constructor () internal {
74	 _paused = false;
75	 }
76	 function paused() public view virtual returns (bool) {
77	 return _paused;
78	 }
79	 modifier whenNotPaused() {
80	 require(!paused(), "Pausable: paused");
81	 _;
82	 }
83	 modifier whenPaused() {
84	 require(paused(), "Pausable: not paused");
85	 _;
86	 }
87	 function _pause() internal virtual whenNotPaused {
88	 _paused = true;
89	 emit Paused(_msgSender());
90	 }
91	 function _unpause() internal virtual whenPaused {
92	 _paused = false;
93	 emit Unpaused(_msgSender());
94	 }
95	 }
96	 pragma solidity ^0.7.6;
97	 abstract contract StandardToken is Context, AccessControl, Pausable {
98	 using SafeMath for uint256;
99	 uint256 private _totalSupply = 0;
100	 string private _name;
101	 string private _symbol;
102	 uint8 private _decimals;
103	 bytes32 public constant PAUSE_MANAGER_ROLE = keccak256("PAUSE_MANAGER_ROLE");
104	 constructor(string memory name_, string memory symbol_) {
105	 _name = name_;
106	 _symbol = symbol_;
107	 _decimals = 18;
108	 }
109	 function name() public view returns(string memory) {
110	 return _name;
111	 }
112	 function symbol() public view returns(string memory) {
113	 return _symbol;
114	 }
115	 function decimals() public view returns(uint8) {
116	 return _decimals;
117	 }
118	 function totalSupply() public view returns(uint256) {
119	 return _totalSupply;
120	 }
121	 function balanceOf(address account) public virtual view returns(uint256);
122	 function transfer(address recipient, uint256 amount) public virtual returns(bool);
123	 function pause() public {
124	 require(hasRole(PAUSE_MANAGER_ROLE, msg.sender), "StandardToken: must have pauser manager role to pause");
125	 _pause();
126	 }
127	 function unpause() public {
128	 require(hasRole(PAUSE_MANAGER_ROLE, msg.sender), "StandardToken: must have pauser manager role to unpause");
129	 _unpause();
130	 }
131	 function _beforeTokenTransfer(address from, address to, uint256 amount) internal view {
132	 require(!paused(), "StandardToken: token transfer while paused");
133	 require(from != address(0), "StandardToken: transfer from the zero address");
134	 require(to != address(0), "StandardToken: transfer to the zero address");
135	 }
136	 function setTotalSupply(uint256 amount) internal {
137	 _totalSupply = amount;
138	 }
139	 function increaseTotalSupply(uint256 amount) internal {
140	 _totalSupply = _totalSupply.add(amount);
141	 }
142	 function decreaseTotalSupply(uint256 amount) internal {
143	 _totalSupply = _totalSupply.sub(amount);
144	 }
145	 }
146	 pragma solidity ^0.7.6;
147	 abstract contract AccountStorage is StandardToken {
148	 using EnumerableSet for EnumerableSet.AddressSet;
149	 using SafeMath for uint256;
150	 struct AccountData {
151	 address sponsor;
152	 uint256 balance;
153	 uint256 selfBuy;
154	 uint256 directBonus;
155	 uint256 reinvestedAmount;
156	 uint256 withdrawnAmount;
157	 int256 stakingValue;
158	 }
159	 struct MigrationData {
160	 address account;
161	 address sponsor;
162	 uint256 tokensToMint;
163	 uint256 selfBuy;
164	 }
165	 bool private _accountsMigrated = false;
166	 EnumerableSet.AddressSet private _accounts;
167	 mapping (address => AccountData) private _accountsData;
168	 bytes32 constant public ACCOUNT_MANAGER_ROLE = keccak256("ACCOUNT_MANAGER_ROLE");
169	 event AccountCreation(address indexed account, address indexed sponsor);
170	 event AccountMigrationFinished();
171	 event DirectBonusPaid(address indexed account, address indexed fromAccount, uint256 amountOfEthereum);
172	 event AccountSponsorUpdated(address indexed account, address indexed oldSponsor, address indexed newSponsor);
173	 modifier isRegistered(address account) {
174	 require(_accountsMigrated, "AccountStorage: account data isn't migrated yet, try later");
175	 require(hasAccount(account), "AccountStorage: account must be registered first");
176	 _;
177	 }
178	 modifier hasEnoughBalance(uint256 amount) {
179	 require(amount <= balanceOf(msg.sender), "AccountStorage: insufficient account balance");
180	 _;
181	 }
182	 modifier hasEnoughAvailableEther(uint256 amount) {
183	 uint256 totalBonus = totalBonusOf(msg.sender);
184	 require(totalBonus > 0, "AccountStorage: you don't have any available ether");
185	 require(amount <= totalBonus, "AccountStorage: you don't have enough available ether to perform operation");
186	 _;
187	 }
188	 constructor() {
189	 addAccountData(address(this), address(0));
190	 }
191	 function migrateAccount(address account, address sponsor, uint256 tokensToMint, uint256 selfBuy) public {
192	 MigrationData[] memory data = new MigrationData[](1);
193	 data[0] = MigrationData(account, sponsor, tokensToMint, selfBuy);
194	 migrateAccountsInBatch(data);
195	 }
196	 function migrateAccountsInBatch(MigrationData[] memory data) public {
197	 require(hasRole(ACCOUNT_MANAGER_ROLE, msg.sender), "AccountStorage: must have account manager role to migrate data");
198	 require(!_accountsMigrated, "AccountStorage: account data migration method is no more available");
199	 for (uint i = 0; i < data.length; i += 1) {
200	 address curAddress = data[i].account;
201	 address curSponsorAddress = data[i].sponsor;
202	 uint256 tokensToMint = data[i].tokensToMint;
203	 uint256 selfBuy = data[i].selfBuy;
204	 if (curSponsorAddress == address(0)) {
205	 curSponsorAddress = address(this);
206	 }
207	 addAccountData(curAddress, curSponsorAddress);
208	 _accounts.add(curAddress);
209	 increaseTotalSupply(tokensToMint);
210	 increaseBalanceOf(curAddress, tokensToMint);
211	 increaseSelfBuyOf(curAddress, selfBuy);
212	 emit AccountCreation(curAddress, curSponsorAddress);
213	 }
214	 }
215	 function isDataMigrated() public view returns(bool) {
216	 return _accountsMigrated;
217	 }
218	 function finishAccountMigration() public {
219	 require(hasRole(ACCOUNT_MANAGER_ROLE, msg.sender), "AccountStorage: must have account manager role to migrate data");
220	 require(!_accountsMigrated, "AccountStorage: account data migration method is no more available");
221	 _accountsMigrated = true;
222	 emit AccountMigrationFinished();
223	 }
224	 function createAccount(address sponsor) public returns(bool) {
225	 require(_accountsMigrated, "AccountStorage: account data isn't migrated yet, try later");
226	 require(!hasAccount(msg.sender), "AccountStorage: account already exists");
227	 address account = msg.sender;
228	 if (sponsor == address(0)) {
229	 sponsor = address(this);
230	 }
231	 addAccountData(account, sponsor);
232	 _accounts.add(account);
233	 emit AccountCreation(account, sponsor);
234	 return true;
235	 }
236	 function setSponsorFor(address account, address newSponsor) public {
237	 require(hasRole(ACCOUNT_MANAGER_ROLE, msg.sender), "AccountStorage: must have account manager role to change sponsor for account");
238	 address oldSponsor = _accountsData[account].sponsor;
239	 _accountsData[account].sponsor = newSponsor;
240	 emit AccountSponsorUpdated(account, oldSponsor, newSponsor);
241	 }
242	 function getAccountsCount() public view returns(uint256) {
243	 return _accounts.length();
244	 }
245	 function hasAccount(address account) public view returns(bool) {
246	 return _accounts.contains(account);
247	 }
248	 function sponsorOf(address account) public view returns(address) {
249	 return _accountsData[account].sponsor;
250	 }
251	 function selfBuyOf(address account) public view returns(uint256) {
252	 return _accountsData[account].selfBuy;
253	 }
254	 function balanceOf(address account) public override view returns(uint256) {
255	 return _accountsData[account].balance;
256	 }
257	 function directBonusOf(address account) public view returns(uint256) {
258	 return _accountsData[account].directBonus;
259	 }
260	 function withdrawnAmountOf(address account) public view returns(uint256) {
261	 return _accountsData[account].withdrawnAmount;
262	 }
263	 function reinvestedAmountOf(address account) public view returns(uint256) {
264	 return _accountsData[account].reinvestedAmount;
265	 }
266	 function stakingBonusOf(address account) public virtual view returns(uint256);
267	 function totalBonusOf(address account) public view returns(uint256) {
268	 return directBonusOf(account) + stakingBonusOf(account) - withdrawnAmountOf(account) - reinvestedAmountOf(account);
269	 }
270	 function increaseSelfBuyOf(address account, uint256 amount) internal {
271	 _accountsData[account].selfBuy =_accountsData[account].selfBuy.add(amount);
272	 }
273	 function increaseBalanceOf(address account, uint256 amount) internal {
274	 _accountsData[account].balance = _accountsData[account].balance.add(amount);
275	 }
276	 function decreaseBalanceOf(address account, uint256 amount) internal {
277	 _accountsData[account].balance = _accountsData[account].balance.sub(amount, "AccountStorage: amount exceeds balance");
278	 }
279	 function addDirectBonusTo(address account, uint256 amount) internal {
280	 _accountsData[account].directBonus = _accountsData[account].directBonus.add(amount);
281	 emit DirectBonusPaid(account, msg.sender, amount);
282	 }
283	 function addWithdrawnAmountTo(address account, uint256 amount) internal {
284	 _accountsData[account].withdrawnAmount = _accountsData[account].withdrawnAmount.add(amount);
285	 }
286	 function addReinvestedAmountTo(address account, uint256 amount) internal {
287	 _accountsData[account].reinvestedAmount = _accountsData[account].reinvestedAmount.add(amount);
288	 }
289	 function stakingValueOf(address account) internal view returns(int256) {
290	 return _accountsData[account].stakingValue;
291	 }
292	 function increaseStakingValueFor(address account, int256 amount) internal {
293	 _accountsData[account].stakingValue += amount;
294	 }
295	 function decreaseStakingValueFor(address account, int256 amount) internal {
296	 _accountsData[account].stakingValue -= amount;
297	 }
298	 function addAccountData(address account, address sponsor) private {
299	 AccountData memory accountData = AccountData({
300	 sponsor: sponsor, balance: 0, selfBuy: 0, directBonus: 0, reinvestedAmount: 0, withdrawnAmount: 0, stakingValue: 0 }
301	 );
302	 _accountsData[account] = accountData;
303	 }
304	 }
305	 pragma solidity ^0.7.6;
306	 abstract contract Founder is AccountStorage {
307	 using EnumerableSet for EnumerableSet.AddressSet;
308	 uint256 private FOUNDER_INVESTMENT_CAP_BONUS = 20 ether;
309	 bytes32 constant public FOUNDER_MANAGER_ROLE = keccak256("FOUNDER_MANAGER_ROLE");
310	 EnumerableSet.AddressSet private _founderAccounts;
311	 event FounderInvestmentCapBonusUpdate(uint256 newInvestmentCapBonus);
312	 function isFounder(address account) public view returns(bool) {
313	 return _founderAccounts.contains(account);
314	 }
315	 function getFoundersCount() public view returns(uint256) {
316	 return _founderAccounts.length();
317	 }
318	 function setFounderInvestmentCapBonus(uint256 investmentCapBonus) public {
319	 require(hasRole(FOUNDER_MANAGER_ROLE, msg.sender), "Founder: must have founder manager role set investment cap bonus for founders");
320	 FOUNDER_INVESTMENT_CAP_BONUS = investmentCapBonus;
321	 emit FounderInvestmentCapBonusUpdate(investmentCapBonus);
322	 }
323	 function getFounderInvestmentCapBonus() public view returns(uint256){
324	 return FOUNDER_INVESTMENT_CAP_BONUS;
325	 }
326	 function addFounder(address account) public returns(bool) {
327	 require(hasRole(FOUNDER_MANAGER_ROLE, msg.sender), "Founder: must have founder manager role to add founder");
328	 return _founderAccounts.add(account);
329	 }
330	 function removeFounder(address account) public returns(bool) {
331	 require(hasRole(FOUNDER_MANAGER_ROLE, msg.sender), "Founder: must have founder manager role to remove founder");
332	 return _founderAccounts.remove(account);
333	 }
334	 function dropFounderOnSell(address account) internal returns(bool) {
335	 return _founderAccounts.remove(account);
336	 }
337	 function founderInvestmentBonusCapFor(address account) internal view returns(uint256) {
338	 return isFounder(account) ? getFounderInvestmentCapBonus() : 0;
339	 }
340	 }
341	 pragma solidity ^0.7.6;
342	 abstract contract Price is StandardToken {
343	 using SafeMath for uint256;
344	 uint256 constant private INITIAL_TOKEN_PRICE = 0.0000001 ether;
345	 uint256 constant private INCREMENT_TOKEN_PRICE = 0.00000001 ether;
346	 function tokenPrice() public view returns(uint256) {
347	 return tokensToEthereum(1 ether);
348	 }
349	 function ethereumToTokens(uint256 _ethereum) internal view returns(uint256) {
350	 uint256 _tokenPriceInitial = INITIAL_TOKEN_PRICE * 1e18;
351	 uint256 _tokensReceived = ( ( SafeMath.sub( (sqrt ( (_tokenPriceInitial**2) + (2*(INCREMENT_TOKEN_PRICE * 1e18)*(_ethereum * 1e18)) + (((INCREMENT_TOKEN_PRICE)**2)*(totalSupply()**2)) + (2*(INCREMENT_TOKEN_PRICE)*_tokenPriceInitial*totalSupply()) ) ), _tokenPriceInitial ) )/(INCREMENT_TOKEN_PRICE) )-(totalSupply()) ;
352	 return _tokensReceived;
353	 }
354	 function tokensToEthereum(uint256 _tokens) internal view returns(uint256) {
355	 uint256 tokens_ = (_tokens + 1e18);
356	 uint256 _tokenSupply = (totalSupply() + 1e18);
357	 uint256 _etherReceived = ( SafeMath.add( ( ( ( INITIAL_TOKEN_PRICE + (INCREMENT_TOKEN_PRICE * (_tokenSupply / 1e18)) ) - INCREMENT_TOKEN_PRICE ) * (tokens_ - 1e18) ), (INCREMENT_TOKEN_PRICE * ((tokens_ ** 2 - tokens_) / 1e18)) / 2 ) /1e18);
358	 return _etherReceived;
359	 }
360	 function sqrt(uint x) internal pure returns(uint y) {
361	 uint z = (x + 1) / 2;
362	 y = x;
363	 while (z < y) {
364	 y = z;
365	 z = (x / z + z) / 2;
366	 }
367	 }
368	 }
369	 pragma solidity ^0.7.6;
370	 contract Company is AccessControl {
371	 using SafeMath for uint256;
372	 uint256 private COMPANY_FEE = 41;
373	 uint256 private _companyBalance = 0;
374	 event CompanyWithdraw(address indexed account, uint256 amount);
375	 event CompanyFeeUpdate(uint256 fee);
376	 bytes32 public constant COMPANY_MANAGER_ROLE = keccak256("COMPANY_MANAGER_ROLE");
377	 function companyBalance() public view returns(uint256) {
378	 return _companyBalance;
379	 }
380	 function getCompanyFee() public view returns(uint256) {
381	 return COMPANY_FEE;
382	 }
383	 function setCompanyFee(uint256 fee) public {
384	 require(hasRole(COMPANY_MANAGER_ROLE, msg.sender), "Company: must have company manager role");
385	 COMPANY_FEE = fee;
386	 emit CompanyFeeUpdate(fee);
387	 }
388	 function withdrawCompanyBalance(uint256 amount) public {
389	 require(hasRole(COMPANY_MANAGER_ROLE, msg.sender), "Company: must have company manager role");
390	 require(amount <= _companyBalance, "Company: insufficient company balance");
391	 require(amount <= address(this).balance, "Company: insufficient contract balance");
392	 msg.sender.transfer(amount);
393	 _companyBalance = _companyBalance.add(amount);
394	 emit CompanyWithdraw(msg.sender, amount);
395	 }
396	 function increaseCompanyBalance(uint256 amount) internal {
397	 _companyBalance = _companyBalance.add(amount);
398	 }
399	 function calculateCompanyFee(uint256 amount) internal view returns(uint256) {
400	 return SafeMath.div(SafeMath.mul(amount, COMPANY_FEE), 100);
401	 }
402	 }
403	 pragma solidity ^0.7.6;
404	 abstract contract DirectBonus is AccountStorage {
405	 using SafeMath for uint256;
406	 uint256 private DIRECT_BONUS_FEE = 10;
407	 uint256 private MINIMUM_SELF_BUY_FOR_DIRECT_BONUS = 0.001 ether;
408	 bytes32 public constant DIRECT_BONUS_MANAGER_ROLE = keccak256("DIRECT_BONUS_MANAGER_ROLE");
409	 event MinimumSelfBuyForDirectBonusUpdate(uint256 amount);
410	 event DirectBonusFeeUpdate(uint256 fee);
411	 function getDirectBonusFee() public view returns(uint256) {
412	 return DIRECT_BONUS_FEE;
413	 }
414	 function setDirectBonusFee(uint256 fee) public {
415	 require(hasRole(DIRECT_BONUS_MANAGER_ROLE, msg.sender), "DirectBonus: must have direct bonus manager role to set direct bonus fee");
416	 DIRECT_BONUS_FEE = fee;
417	 emit DirectBonusFeeUpdate(fee);
418	 }
419	 function getMinimumSelfBuyForDirectBonus() public view returns(uint256) {
420	 return MINIMUM_SELF_BUY_FOR_DIRECT_BONUS;
421	 }
422	 function setMinimumSelfBuyForDirectBonus(uint256 amount) public {
423	 require(hasRole(DIRECT_BONUS_MANAGER_ROLE, msg.sender), "DirectBonus: must have direct bonus manager role to set minimum self buy for direct bonus");
424	 MINIMUM_SELF_BUY_FOR_DIRECT_BONUS = amount;
425	 emit MinimumSelfBuyForDirectBonusUpdate(amount);
426	 }
427	 function calculateDirectBonus(uint256 amount) internal view returns(uint256) {
428	 return SafeMath.div(SafeMath.mul(amount, DIRECT_BONUS_FEE), 100);
429	 }
430	 function isEligibleForDirectBonus(address sponsor) internal view returns(bool) {
431	 return (selfBuyOf(sponsor) >= MINIMUM_SELF_BUY_FOR_DIRECT_BONUS);
432	 }
433	 }
434	 pragma solidity ^0.7.6;
435	 abstract contract Emergency is Founder {
436	 using EnumerableSet for EnumerableSet.AddressSet;
437	 bytes32 constant public EMERGENCY_MANAGER_ROLE = keccak256("EMERGENCY_MANAGER_ROLE");
438	 EnumerableSet.AddressSet private _emergencyVotes;
439	 uint256 private _emergencyThresholdCount;
440	 bool private _emergencyVotingStarted = false;
441	 event EmergencyVotingStarted();
442	 event EmergencyWithdraw(address account, uint256 amount);
443	 function isEmergencyCase() public view returns(bool) {
444	 return _emergencyVotingStarted;
445	 }
446	 function emergencyContractBalanceWithdraw() public {
447	 require(hasRole(EMERGENCY_MANAGER_ROLE, msg.sender), "Emergency: you're not allowed to do this");
448	 require(emergencyVotesCount() >= emergencyVotingThresholdCount(), "Emergency: not enough votes for performing emergency withdraw");
449	 msg.sender.transfer(address(this).balance);
450	 emit EmergencyWithdraw(msg.sender, address(this).balance);
451	 }
452	 function voteForEmergencyCase() public returns(bool) {
453	 require(_emergencyVotingStarted, "Emergency: emergency voting is not activated");
454	 require(isFounder(msg.sender), "Emergency: only founders have right to vote for emergency cases");
455	 return _emergencyVotes.add(msg.sender);
456	 }
457	 function emergencyVotesCount() public view returns(uint256) {
458	 return _emergencyVotes.length();
459	 }
460	 function emergencyVotingThresholdCount() public view returns(uint256) {
461	 return _emergencyThresholdCount;
462	 }
463	 function hasVotedForEmergency(address account) public view returns(bool) {
464	 return _emergencyVotes.contains(account);
465	 }
466	 function startEmergencyVote(uint256 thresholdCount) public {
467	 require(hasRole(EMERGENCY_MANAGER_ROLE, msg.sender), "Emergency: you're not allowed to start emergency vote");
468	 require(0 < thresholdCount && thresholdCount <= getFoundersCount(), "Emergency: please set right threshold");
469	 _emergencyVotingStarted = true;
470	 _emergencyThresholdCount = thresholdCount;
471	 emit EmergencyVotingStarted();
472	 }
473	 }
474	 pragma solidity ^0.7.6;
475	 abstract contract Sale is Founder {
476	 using SafeMath for uint256;
477	 uint private _saleStartBlockNumber = 0;
478	 bytes32 public constant SALE_MANAGER_ROLE = keccak256("SALE_MANAGER_ROLE");
479	 event SaleStarted(uint atBlockNumber, uint atTimestamp);
480	 event NewSaleStartBlock(uint atBlockNumber, uint atTimestamp);
481	 modifier canInvest(uint256 amount) {
482	 require(selfBuyOf(msg.sender) + amount <= getInvestmentCap() + founderInvestmentBonusCapFor(msg.sender), "Sale: you can't invest more than current investment cap");
483	 _;
484	 }
485	 function getInvestmentCap() public view returns(uint256) {
486	 if (_saleStartBlockNumber == 0) return 0 ether;
487	 uint256 currentBlockNumberFromSaleStart = block.number - _saleStartBlockNumber;
488	 if (currentBlockNumberFromSaleStart <= 1250000) return 31680000 * (currentBlockNumberFromSaleStart**2) + 1 ether;
489	 if (currentBlockNumberFromSaleStart <= 2500000) return 100 ether - 31680000 * (currentBlockNumberFromSaleStart - 2500000)**2;
490	 return 100 ether;
491	 }
492	 function startSale() public {
493	 require(hasRole(SALE_MANAGER_ROLE, msg.sender), "Sale: must have sale manager role");
494	 require(_saleStartBlockNumber == 0, "Sale: start sale method is no more available");
495	 _saleStartBlockNumber = block.number;
496	 emit SaleStarted(block.number, block.timestamp);
497	 }
498	 function moveSaleForwardBy(uint256 blocks) public {
499	 require(hasRole(SALE_MANAGER_ROLE, msg.sender), "Sale: must have sale manager role");
500	 require(_saleStartBlockNumber > 0, "Sale: sale forward move method is not available yet, start sale first");
501	 require(blocks < _saleStartBlockNumber, "Sale: you can't move sale start from zero block");
502	 _saleStartBlockNumber = _saleStartBlockNumber.sub(blocks);
503	 emit NewSaleStartBlock(_saleStartBlockNumber, block.timestamp);
504	 }
505	 }
506	 pragma solidity ^0.7.6;
507	 abstract contract Staking is AccountStorage, Price {
508	 using SafeMath for uint256;
509	 uint256 private _stakingProfitPerShare;
510	 bytes32 public constant STAKING_MANAGER_ROLE = keccak256("STAKING_MANAGER_ROLE");
511	 bytes32 public constant LOYALTY_BONUS_MANAGER_ROLE = keccak256("LOYALTY_BONUS_MANAGER_ROLE");
512	 uint256 constant private MAGNITUDE = 2 ** 64;
513	 uint256 private STAKING_FEE = 8;
514	 event StakingFeeUpdate(uint256 fee);
515	 event LoyaltyBonusStaked(uint256 amount);
516	 function getStakingFee() public view returns(uint256) {
517	 return STAKING_FEE;
518	 }
519	 function setStakingFee(uint256 fee) public {
520	 require(hasRole(STAKING_MANAGER_ROLE, msg.sender), "Staking: must have staking manager role to set staking fee");
521	 STAKING_FEE = fee;
522	 emit StakingFeeUpdate(fee);
523	 }
524	 function stakeLoyaltyBonus() public payable {
525	 require(hasRole(LOYALTY_BONUS_MANAGER_ROLE, msg.sender), "Staking: must have loyalty bonus manager role to stake bonuses");
526	 increaseStakingProfitPerShare(msg.value);
527	 emit LoyaltyBonusStaked(msg.value);
528	 }
529	 function stakingBonusOf(address account) public override view returns(uint256) {
530	 return (uint256) ((int256)(_stakingProfitPerShare * balanceOf(account)) - stakingValueOf(account)) / MAGNITUDE;
531	 }
532	 function calculateStakingFee(uint256 amount) internal view returns(uint256) {
533	 return SafeMath.div(SafeMath.mul(amount, STAKING_FEE), 100);
534	 }
535	 function increaseStakingProfitPerShare(uint256 stakingBonus) internal {
536	 _stakingProfitPerShare += (stakingBonus * MAGNITUDE / totalSupply());
537	 }
538	 function processStakingOnBuy(address account, uint256 amountOfTokens, uint256 stakingBonus) internal {
539	 uint256 stakingFee = stakingBonus * MAGNITUDE;
540	 if (totalSupply() > 0) {
541	 increaseTotalSupply(amountOfTokens);
542	 increaseStakingProfitPerShare(stakingBonus);
543	 stakingFee = amountOfTokens * (stakingBonus * MAGNITUDE / totalSupply());
544	 }
545	 else {
546	 setTotalSupply(amountOfTokens);
547	 }
548	 int256 stakingPayout = (int256) (_stakingProfitPerShare * amountOfTokens - stakingFee);
549	 increaseStakingValueFor(account, stakingPayout);
550	 }
551	 function processStakingOnSell(address account, uint256 amountOfTokens) internal returns(uint256) {
552	 uint256 ethereum = tokensToEthereum(amountOfTokens);
553	 uint256 stakingFee = calculateStakingFee(ethereum);
554	 uint256 taxedEthereum = SafeMath.sub(ethereum, stakingFee);
555	 int256 stakingValueUpdate = (int256) (_stakingProfitPerShare * amountOfTokens);
556	 decreaseStakingValueFor(account, stakingValueUpdate);
557	 if (totalSupply() > 0) {
558	 increaseStakingProfitPerShare(stakingFee);
559	 }
560	 return taxedEthereum;
561	 }
562	 function processDistributionOnTransfer(address sender, uint256 amountOfTokens, address recipient, uint256 taxedTokens) internal {
563	 uint256 stakedBonus = tokensToEthereum(SafeMath.sub(amountOfTokens, taxedTokens));
564	 decreaseStakingValueFor(sender, (int256) (_stakingProfitPerShare * amountOfTokens));
565	 increaseStakingValueFor(recipient, (int256) (_stakingProfitPerShare * taxedTokens));
566	 increaseStakingProfitPerShare(stakedBonus);
567	 }
568	 }
569	 pragma solidity ^0.7.6;
570	 contract BXFToken is Staking, Company, Sale, DirectBonus, Emergency {
571	 using SafeMath for uint256;
572	 event BXFBuy(address indexed account, uint256 ethereumInvested, uint256 taxedEthereum, uint256 tokensMinted);
573	 event BXFSell(address indexed account, uint256 tokenBurned, uint256 ethereumGot);
574	 event BXFReinvestment(address indexed account, uint256 ethereumReinvested, uint256 tokensMinted);
575	 event Withdraw(address indexed account, uint256 ethereumWithdrawn);
576	 event Transfer(address indexed from, address indexed to, uint256 value);
577	 constructor(string memory name, string memory symbol) StandardToken(name, symbol) {
578	 _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
579	 }
580	 fallback() external payable {
581	 require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), "BXFToken: you're not allowed to do this");
582	 }
583	 function buy() public payable isRegistered(msg.sender) {
584	 (uint256 taxedEthereum, uint256 amountOfTokens) = purchaseTokens(msg.sender, msg.value);
585	 emit Transfer(address(0), msg.sender, amountOfTokens);
586	 emit BXFBuy(msg.sender, msg.value, taxedEthereum, amountOfTokens);
587	 }
588	 function sell(uint256 amountOfTokens) public isRegistered(msg.sender) hasEnoughBalance(amountOfTokens) {
589	 address account = msg.sender;
590	 decreaseTotalSupply(amountOfTokens);
591	 decreaseBalanceOf(account, amountOfTokens);
592	 if (isFounder(account)) dropFounderOnSell(account);
593	 uint256 taxedEthereum = processStakingOnSell(account, amountOfTokens);
594	 msg.sender.transfer(taxedEthereum);
595	 emit Transfer(account, address(0), amountOfTokens);
596	 emit BXFSell(account, amountOfTokens, taxedEthereum);
597	 }
598	 function withdraw(uint256 amountToWithdraw) public isRegistered(msg.sender) hasEnoughAvailableEther(amountToWithdraw) {
599	 require(amountToWithdraw <= address(this).balance, "BXFToken: insufficient contract balance");
600	 address account = msg.sender;
601	 addWithdrawnAmountTo(account, amountToWithdraw);
602	 msg.sender.transfer(amountToWithdraw);
603	 emit Withdraw(account, amountToWithdraw);
604	 }
605	 function reinvest(uint256 amountToReinvest) public isRegistered(msg.sender) hasEnoughAvailableEther(amountToReinvest) {
606	 address account = msg.sender;
607	 addReinvestedAmountTo(account, amountToReinvest);
608	 (uint256 taxedEthereum, uint256 amountOfTokens) = purchaseTokens(account, amountToReinvest);
609	 emit Transfer(address(0), account, amountOfTokens);
610	 emit BXFReinvestment(account, amountToReinvest, amountOfTokens);
611	 }
612	 function exit() public isRegistered(msg.sender) {
613	 address account = msg.sender;
614	 if (balanceOf(account) > 0) {
615	 sell(balanceOf(account));
616	 }
617	 if (totalBonusOf(account) > 0) {
618	 withdraw(totalBonusOf(account));
619	 }
620	 }
621	 function transfer(address recipient, uint256 amount) public override hasEnoughBalance(amount) returns(bool) {
622	 address sender = msg.sender;
623	 _beforeTokenTransfer(sender, recipient, amount);
624	 uint256 stakingFee = calculateStakingFee(amount);
625	 uint256 taxedTokens = SafeMath.sub(amount, stakingFee);
626	 decreaseTotalSupply(stakingFee);
627	 decreaseBalanceOf(sender, amount);
628	 increaseBalanceOf(recipient, taxedTokens);
629	 processDistributionOnTransfer(sender, amount, recipient, taxedTokens);
630	 emit Transfer(sender, address(0), stakingFee);
631	 emit Transfer(sender, recipient, taxedTokens);
632	 return true;
633	 }
634	 function purchaseTokens(address senderAccount, uint256 amountOfEthereum) internal canInvest(amountOfEthereum) returns(uint256, uint256) {
635	 uint256 taxedEthereum = amountOfEthereum;
636	 uint256 companyFee = calculateCompanyFee(amountOfEthereum);
637	 uint256 directBonus = calculateDirectBonus(amountOfEthereum);
638	 uint256 stakingFee = calculateStakingFee(amountOfEthereum);
639	 taxedEthereum = taxedEthereum.sub(companyFee);
640	 increaseCompanyBalance(companyFee);
641	 address account = senderAccount;
642	 address sponsor = sponsorOf(account);
643	 increaseSelfBuyOf(account, amountOfEthereum);
644	 if (sponsor == address(this)) {
645	 increaseCompanyBalance(directBonus);
646	 taxedEthereum = taxedEthereum.sub(directBonus);
647	 }
648	 else if (isEligibleForDirectBonus(sponsor)) {
649	 addDirectBonusTo(sponsor, directBonus);
650	 taxedEthereum = taxedEthereum.sub(directBonus);
651	 }
652	 taxedEthereum = taxedEthereum.sub(stakingFee);
653	 uint256 amountOfTokens = ethereumToTokens(taxedEthereum);
654	 processStakingOnBuy(senderAccount, amountOfTokens, stakingFee);
655	 increaseBalanceOf(senderAccount, amountOfTokens);
656	 return (taxedEthereum, amountOfTokens);
657	 }
658	 }
659	 pragma solidity >=0.6.0 <0.8.0;
660	 library SafeMath {
661	 function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
662	 uint256 c = a + b;
663	 if (c < a) return (false, 0);
664	 return (true, c);
665	 }
666	 function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
667	 if (b > a) return (false, 0);
668	 return (true, a - b);
669	 }
670	 function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
671	 if (a == 0) return (true, 0);
672	 uint256 c = a * b;
673	 if (c / a != b) return (false, 0);
674	 return (true, c);
675	 }
676	 function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
677	 if (b == 0) return (false, 0);
678	 return (true, a / b);
679	 }
680	 function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
681	 if (b == 0) return (false, 0);
682	 return (true, a % b);
683	 }
684	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
685	 uint256 c = a + b;
686	 require(c >= a, "SafeMath: addition overflow");
687	 return c;
688	 }
689	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
690	 require(b <= a, "SafeMath: subtraction overflow");
691	 return a - b;
692	 }
693	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
694	 if (a == 0) return 0;
695	 uint256 c = a * b;
696	 require(c / a == b, "SafeMath: multiplication overflow");
697	 return c;
698	 }
699	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
700	 require(b > 0, "SafeMath: division by zero");
701	 return a / b;
702	 }
703	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
704	 require(b > 0, "SafeMath: modulo by zero");
705	 return a % b;
706	 }
707	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
708	 require(b <= a, errorMessage);
709	 return a - b;
710	 }
711	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
712	 require(b > 0, errorMessage);
713	 return a / b;
714	 }
715	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
716	 require(b > 0, errorMessage);
717	 return a % b;
718	 }
719	 }
720	 pragma solidity >=0.6.2 <0.8.0;
721	 library Address {
722	 function isContract(address account) internal view returns (bool) {
723	 uint256 size;
724	 assembly {
725	 size := extcodesize(account) }
726	 return size > 0;
727	 }
728	 function sendValue(address payable recipient, uint256 amount) internal {
729	 require(address(this).balance >= amount, "Address: insufficient balance");
730	 (bool success, ) = recipient.call{
731	 value: amount }
732	 ("");
733	 require(success, "Address: unable to send value, recipient may have reverted");
734	 }
735	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
736	 return functionCall(target, data, "Address: low-level call failed");
737	 }
738	 function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
739	 return functionCallWithValue(target, data, 0, errorMessage);
740	 }
741	 function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
742	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
743	 }
744	 function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
745	 require(address(this).balance >= value, "Address: insufficient balance for call");
746	 require(isContract(target), "Address: call to non-contract");
747	 (bool success, bytes memory returndata) = target.call{
748	 value: value }
749	 (data);
750	 return _verifyCallResult(success, returndata, errorMessage);
751	 }
752	 function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
753	 return functionStaticCall(target, data, "Address: low-level static call failed");
754	 }
755	 function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
756	 require(isContract(target), "Address: static call to non-contract");
757	 (bool success, bytes memory returndata) = target.staticcall(data);
758	 return _verifyCallResult(success, returndata, errorMessage);
759	 }
760	 function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
761	 return functionDelegateCall(target, data, "Address: low-level delegate call failed");
762	 }
763	 function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
764	 require(isContract(target), "Address: delegate call to non-contract");
765	 (bool success, bytes memory returndata) = target.delegatecall(data);
766	 return _verifyCallResult(success, returndata, errorMessage);
767	 }
768	 function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
769	 if (success) {
770	 return returndata;
771	 }
772	 else {
773	 if (returndata.length > 0) {
774	 assembly {
775	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
776	 }
777	 else {
778	 revert(errorMessage);
779	 }
780	 }
781	 }
782	 }
783	 pragma solidity >=0.6.0 <0.8.0;
784	 library EnumerableSet {
785	 struct Set {
786	 bytes32[] _values;
787	 mapping (bytes32 => uint256) _indexes;
788	 }
789	 function _add(Set storage set, bytes32 value) private returns (bool) {
790	 if (!_contains(set, value)) {
791	 set._values.push(value);
792	 set._indexes[value] = set._values.length;
793	 return true;
794	 }
795	 else {
796	 return false;
797	 }
798	 }
799	 function _remove(Set storage set, bytes32 value) private returns (bool) {
800	 uint256 valueIndex = set._indexes[value];
801	 if (valueIndex != 0) {
802	 uint256 toDeleteIndex = valueIndex - 1;
803	 uint256 lastIndex = set._values.length - 1;
804	 bytes32 lastvalue = set._values[lastIndex];
805	 set._values[toDeleteIndex] = lastvalue;
806	 set._indexes[lastvalue] = toDeleteIndex + 1;
807	 set._values.pop();
808	 delete set._indexes[value];
809	 return true;
810	 }
811	 else {
812	 return false;
813	 }
814	 }
815	 function _contains(Set storage set, bytes32 value) private view returns (bool) {
816	 return set._indexes[value] != 0;
817	 }
818	 function _length(Set storage set) private view returns (uint256) {
819	 return set._values.length;
820	 }
821	 function _at(Set storage set, uint256 index) private view returns (bytes32) {
822	 require(set._values.length > index, "EnumerableSet: index out of bounds");
823	 return set._values[index];
824	 }
825	 struct Bytes32Set {
826	 Set _inner;
827	 }
828	 function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {
829	 return _add(set._inner, value);
830	 }
831	 function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {
832	 return _remove(set._inner, value);
833	 }
834	 function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {
835	 return _contains(set._inner, value);
836	 }
837	 function length(Bytes32Set storage set) internal view returns (uint256) {
838	 return _length(set._inner);
839	 }
840	 function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {
841	 return _at(set._inner, index);
842	 }
843	 struct AddressSet {
844	 Set _inner;
845	 }
846	 function add(AddressSet storage set, address value) internal returns (bool) {
847	 return _add(set._inner, bytes32(uint256(uint160(value))));
848	 }
849	 function remove(AddressSet storage set, address value) internal returns (bool) {
850	 return _remove(set._inner, bytes32(uint256(uint160(value))));
851	 }
852	 function contains(AddressSet storage set, address value) internal view returns (bool) {
853	 return _contains(set._inner, bytes32(uint256(uint160(value))));
854	 }
855	 function length(AddressSet storage set) internal view returns (uint256) {
856	 return _length(set._inner);
857	 }
858	 function at(AddressSet storage set, uint256 index) internal view returns (address) {
859	 return address(uint160(uint256(_at(set._inner, index))));
860	 }
861	 struct UintSet {
862	 Set _inner;
863	 }
864	 function add(UintSet storage set, uint256 value) internal returns (bool) {
865	 return _add(set._inner, bytes32(value));
866	 }
867	 function remove(UintSet storage set, uint256 value) internal returns (bool) {
868	 return _remove(set._inner, bytes32(value));
869	 }
870	 function contains(UintSet storage set, uint256 value) internal view returns (bool) {
871	 return _contains(set._inner, bytes32(value));
872	 }
873	 function length(UintSet storage set) internal view returns (uint256) {
874	 return _length(set._inner);
875	 }
876	 function at(UintSet storage set, uint256 index) internal view returns (uint256) {
877	 return uint256(_at(set._inner, index));
878	 }
879	 }
