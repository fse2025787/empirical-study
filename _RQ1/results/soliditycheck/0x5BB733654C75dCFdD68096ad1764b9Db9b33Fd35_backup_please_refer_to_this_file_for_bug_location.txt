row number 
1	  pragma experimental ABIEncoderV2;
2	 pragma solidity =0.7.6;
3	 abstract contract ReentrancyGuard {
4	 uint256 private constant _NOT_ENTERED = 1;
5	 uint256 private constant _ENTERED = 2;
6	 AppStorage internal s;
7	 modifier nonReentrant() {
8	 require(s.reentrantStatus != _ENTERED, "ReentrancyGuard: reentrant call");
9	 s.reentrantStatus = _ENTERED;
10	 _;
11	 s.reentrantStatus = _NOT_ENTERED;
12	 }
13	 }
14	 pragma solidity =0.7.6;
15	 contract SiloExit is ReentrancyGuard {
16	 using SafeMath for uint256;
17	 using LibSafeMath32 for uint32;
18	 struct AccountSeasonOfPlenty {
19	 uint32 lastRain;
20	 uint32 lastSop;
21	 uint256 roots;
22	 uint256 plentyPerRoot;
23	 uint256 plenty;
24	 }
25	 function totalStalk() public view returns (uint256) {
26	 return s.s.stalk;
27	 }
28	 function totalRoots() public view returns (uint256) {
29	 return s.s.roots;
30	 }
31	 function totalSeeds() public view returns (uint256) {
32	 return s.s.seeds;
33	 }
34	 function totalEarnedBeans() public view returns (uint256) {
35	 return s.earnedBeans;
36	 }
37	 function balanceOfSeeds(address account) public view returns (uint256) {
38	 return s.a[account].s.seeds;
39	 }
40	 function balanceOfStalk(address account) public view returns (uint256) {
41	 return s.a[account].s.stalk.add(balanceOfEarnedStalk(account));
42	 }
43	 function balanceOfRoots(address account) public view returns (uint256) {
44	 return s.a[account].roots;
45	 }
46	 function balanceOfGrownStalk(address account) public view returns (uint256) {
47	 return LibSilo.stalkReward( s.a[account].s.seeds, season() - lastUpdate(account) );
48	 }
49	 function balanceOfEarnedBeans(address account) public view returns (uint256 beans) {
50	 beans = _balanceOfEarnedBeans(account, s.a[account].s.stalk);
51	 }
52	 function _balanceOfEarnedBeans(address account, uint256 accountStalk) internal view returns (uint256 beans) {
53	 if (s.s.roots == 0) return 0;
54	 uint256 stalk = s.s.stalk.mul(s.a[account].roots).div(s.s.roots);
55	 if (stalk <= accountStalk) return 0;
56	 beans = (stalk - accountStalk).div(C.getStalkPerBean());
57	 if (beans > s.earnedBeans) return s.earnedBeans;
58	 return beans;
59	 }
60	 function balanceOfEarnedStalk(address account) public view returns (uint256) {
61	 return balanceOfEarnedBeans(account).mul(C.getStalkPerBean());
62	 }
63	 function balanceOfEarnedSeeds(address account) public view returns (uint256) {
64	 return balanceOfEarnedBeans(account).mul(C.getSeedsPerBean());
65	 }
66	 function lastUpdate(address account) public view returns (uint32) {
67	 return s.a[account].lastUpdate;
68	 }
69	 function lastSeasonOfPlenty() public view returns (uint32) {
70	 return s.season.lastSop;
71	 }
72	 function balanceOfPlenty(address account) public view returns (uint256 plenty) {
73	 Account.State storage a = s.a[account];
74	 plenty = a.sop.plenty;
75	 uint256 previousPPR;
76	 if (s.a[account].lastRain > 0) {
77	 if (a.lastSop == a.lastRain) previousPPR = a.sop.plentyPerRoot;
78	 else previousPPR = s.sops[a.lastSop];
79	 uint256 lastRainPPR = s.sops[s.a[account].lastRain];
80	 if (lastRainPPR > previousPPR) {
81	 uint256 plentyPerRoot = lastRainPPR - previousPPR;
82	 previousPPR = lastRainPPR;
83	 plenty = plenty.add( plentyPerRoot.mul(s.a[account].sop.roots).div( C.getSopPrecision() ) );
84	 }
85	 }
86	 else {
87	 previousPPR = s.sops[s.a[account].lastSop];
88	 }
89	 if (s.season.lastSop > lastUpdate(account)) {
90	 uint256 plentyPerRoot = s.sops[s.season.lastSop].sub(previousPPR);
91	 plenty = plenty.add( plentyPerRoot.mul(balanceOfRoots(account)).div( C.getSopPrecision() ) );
92	 }
93	 }
94	 function balanceOfRainRoots(address account) public view returns (uint256) {
95	 return s.a[account].sop.roots;
96	 }
97	 function balanceOfSop(address account) external view returns (AccountSeasonOfPlenty memory sop) {
98	 sop.lastRain = s.a[account].lastRain;
99	 sop.lastSop = s.a[account].lastSop;
100	 sop.roots = s.a[account].sop.roots;
101	 sop.plenty = balanceOfPlenty(account);
102	 sop.plentyPerRoot = s.a[account].sop.plentyPerRoot;
103	 }
104	 function season() internal view returns (uint32) {
105	 return s.season.current;
106	 }
107	 }
108	 pragma solidity =0.7.6;
109	 contract Silo is SiloExit {
110	 using SafeMath for uint256;
111	 using SafeERC20 for IERC20;
112	 event Plant( address indexed account, uint256 beans );
113	 event ClaimPlenty( address indexed account, uint256 plenty );
114	 event SeedsBalanceChanged( address indexed account, int256 delta );
115	 event StalkBalanceChanged( address indexed account, int256 delta, int256 deltaRoots );
116	 function _update(address account) internal {
117	 uint32 _lastUpdate = lastUpdate(account);
118	 if (_lastUpdate >= season()) return;
119	 handleRainAndSops(account, _lastUpdate);
120	 earnGrownStalk(account);
121	 s.a[account].lastUpdate = season();
122	 }
123	 function _plant(address account) internal returns (uint256 beans) {
124	 _update(account);
125	 uint256 accountStalk = s.a[account].s.stalk;
126	 beans = _balanceOfEarnedBeans(account, accountStalk);
127	 if (beans == 0) return 0;
128	 s.earnedBeans = s.earnedBeans.sub(beans);
129	 LibTokenSilo.addDeposit( account, C.beanAddress(), season(), beans, beans );
130	 uint256 seeds = beans.mul(C.getSeedsPerBean());
131	 LibSilo.incrementBalanceOfSeeds(account, seeds);
132	 uint256 stalk = beans.mul(C.getStalkPerBean());
133	 s.a[account].s.stalk = accountStalk.add(stalk);
134	 emit StalkBalanceChanged(account, int256(stalk), 0);
135	 emit Plant(account, beans);
136	 }
137	 function _claimPlenty(address account) internal {
138	 uint256 plenty = s.a[account].sop.plenty;
139	 C.threeCrv().safeTransfer(account, plenty);
140	 delete s.a[account].sop.plenty;
141	 emit ClaimPlenty(account, plenty);
142	 }
143	 function earnGrownStalk(address account) private {
144	 if (s.a[account].s.seeds == 0) return;
145	 LibSilo.incrementBalanceOfStalk(account, balanceOfGrownStalk(account));
146	 }
147	 function handleRainAndSops(address account, uint32 _lastUpdate) private {
148	 if (s.a[account].roots == 0) {
149	 s.a[account].lastSop = s.season.rainStart;
150	 s.a[account].lastRain = 0;
151	 return;
152	 }
153	 if (s.season.lastSopSeason > _lastUpdate) {
154	 s.a[account].sop.plenty = balanceOfPlenty(account);
155	 s.a[account].lastSop = s.season.lastSop;
156	 }
157	 if (s.season.raining) {
158	 if (s.season.rainStart > _lastUpdate) {
159	 s.a[account].lastRain = s.season.rainStart;
160	 s.a[account].sop.roots = s.a[account].roots;
161	 }
162	 if (s.season.lastSop == s.season.rainStart) s.a[account].sop.plentyPerRoot = s.sops[s.season.lastSop];
163	 }
164	 else if (s.a[account].lastRain > 0) {
165	 s.a[account].lastRain = 0;
166	 }
167	 }
168	 modifier updateSilo() {
169	 _update(msg.sender);
170	 _;
171	 }
172	 }
173	 pragma solidity =0.7.6;
174	 contract TokenSilo is Silo {
175	 uint32 private constant ASSET_PADDING = 100;
176	 using SafeMath for uint256;
177	 using LibSafeMath32 for uint32;
178	 event AddDeposit( address indexed account, address indexed token, uint32 season, uint256 amount, uint256 bdv );
179	 event RemoveDeposits( address indexed account, address indexed token, uint32[] seasons, uint256[] amounts, uint256 amount );
180	 event RemoveDeposit( address indexed account, address indexed token, uint32 season, uint256 amount );
181	 event AddWithdrawal( address indexed account, address indexed token, uint32 season, uint256 amount );
182	 event RemoveWithdrawals( address indexed account, address indexed token, uint32[] seasons, uint256 amount );
183	 event RemoveWithdrawal( address indexed account, address indexed token, uint32 season, uint256 amount );
184	 struct AssetsRemoved {
185	 uint256 tokensRemoved;
186	 uint256 stalkRemoved;
187	 uint256 seedsRemoved;
188	 uint256 bdvRemoved;
189	 }
190	 function getDeposit( address account, address token, uint32 season ) external view returns (uint256, uint256) {
191	 return LibTokenSilo.tokenDeposit(account, token, season);
192	 }
193	 function getWithdrawal( address account, address token, uint32 season ) external view returns (uint256) {
194	 return LibTokenSilo.tokenWithdrawal(account, token, season);
195	 }
196	 function getTotalDeposited(address token) external view returns (uint256) {
197	 return s.siloBalances[token].deposited;
198	 }
199	 function getTotalWithdrawn(address token) external view returns (uint256) {
200	 return s.siloBalances[token].withdrawn;
201	 }
202	 function tokenSettings(address token) external view returns (Storage.SiloSettings memory) {
203	 return s.ss[token];
204	 }
205	 function withdrawFreeze() public view returns (uint8) {
206	 return s.season.withdrawSeasons;
207	 }
208	 function _deposit( address account, address token, uint256 amount ) internal {
209	 (uint256 seeds, uint256 stalk) = LibTokenSilo.deposit( account, token, _season(), amount );
210	 LibSilo.depositSiloAssets(account, seeds, stalk);
211	 }
212	 function _withdrawDeposits( address account, address token, uint32[] calldata seasons, uint256[] calldata amounts ) internal {
213	 require( seasons.length == amounts.length, "Silo: Crates, amounts are diff lengths." );
214	 AssetsRemoved memory ar = removeDeposits( account, token, seasons, amounts );
215	 _withdraw( account, token, ar.tokensRemoved, ar.stalkRemoved, ar.seedsRemoved );
216	 }
217	 function _withdrawDeposit( address account, address token, uint32 season, uint256 amount ) internal {
218	 (uint256 stalkRemoved, uint256 seedsRemoved, ) = removeDeposit( account, token, season, amount );
219	 _withdraw(account, token, amount, stalkRemoved, seedsRemoved);
220	 }
221	 function _withdraw( address account, address token, uint256 amount, uint256 stalk, uint256 seeds ) private {
222	 uint32 arrivalSeason = _season() + s.season.withdrawSeasons;
223	 addTokenWithdrawal(account, token, arrivalSeason, amount);
224	 LibTokenSilo.decrementDepositedToken(token, amount);
225	 LibSilo.withdrawSiloAssets(account, seeds, stalk);
226	 }
227	 function removeDeposit( address account, address token, uint32 season, uint256 amount ) private returns ( uint256 stalkRemoved, uint256 seedsRemoved, uint256 bdv ) {
228	 bdv = LibTokenSilo.removeDeposit(account, token, season, amount);
229	 seedsRemoved = bdv.mul(s.ss[token].seeds);
230	 stalkRemoved = bdv.mul(s.ss[token].stalk).add( LibSilo.stalkReward(seedsRemoved, _season() - season) );
231	 emit RemoveDeposit(account, token, season, amount);
232	 }
233	 function removeDeposits( address account, address token, uint32[] calldata seasons, uint256[] calldata amounts ) internal returns (AssetsRemoved memory ar) {
234	 for (uint256 i; i < seasons.length; ++i) {
235	 uint256 crateBdv = LibTokenSilo.removeDeposit( account, token, seasons[i], amounts[i] );
236	 ar.bdvRemoved = ar.bdvRemoved.add(crateBdv);
237	 ar.tokensRemoved = ar.tokensRemoved.add(amounts[i]);
238	 ar.stalkRemoved = ar.stalkRemoved.add( LibSilo.stalkReward( crateBdv.mul(s.ss[token].seeds), _season() - seasons[i] ) );
239	 }
240	 ar.seedsRemoved = ar.bdvRemoved.mul(s.ss[token].seeds);
241	 ar.stalkRemoved = ar.stalkRemoved.add( ar.bdvRemoved.mul(s.ss[token].stalk) );
242	 emit RemoveDeposits(account, token, seasons, amounts, ar.tokensRemoved);
243	 }
244	 function addTokenWithdrawal( address account, address token, uint32 arrivalSeason, uint256 amount ) private {
245	 s.a[account].withdrawals[token][arrivalSeason] = s .a[account] .withdrawals[token][arrivalSeason].add(amount);
246	 s.siloBalances[token].withdrawn = s.siloBalances[token].withdrawn.add( amount );
247	 emit AddWithdrawal(account, token, arrivalSeason, amount);
248	 }
249	 function _claimWithdrawal( address account, address token, uint32 season ) internal returns (uint256) {
250	 uint256 amount = _removeTokenWithdrawal(account, token, season);
251	 s.siloBalances[token].withdrawn = s.siloBalances[token].withdrawn.sub( amount );
252	 emit RemoveWithdrawal(msg.sender, token, season, amount);
253	 return amount;
254	 }
255	 function _claimWithdrawals( address account, address token, uint32[] calldata seasons ) internal returns (uint256 amount) {
256	 for (uint256 i; i < seasons.length; ++i) {
257	 amount = amount.add( _removeTokenWithdrawal(account, token, seasons[i]) );
258	 }
259	 s.siloBalances[token].withdrawn = s.siloBalances[token].withdrawn.sub( amount );
260	 emit RemoveWithdrawals(msg.sender, token, seasons, amount);
261	 return amount;
262	 }
263	 function _removeTokenWithdrawal( address account, address token, uint32 season ) private returns (uint256) {
264	 require( season <= s.season.current, "Claim: Withdrawal not receivable" );
265	 uint256 amount = s.a[account].withdrawals[token][season];
266	 delete s.a[account].withdrawals[token][season];
267	 return amount;
268	 }
269	 function _transferDeposit( address sender, address recipient, address token, uint32 season, uint256 amount ) internal {
270	 (uint256 stalk, uint256 seeds, uint256 bdv) = removeDeposit( sender, token, season, amount );
271	 LibTokenSilo.addDeposit(recipient, token, season, amount, bdv);
272	 LibSilo.transferSiloAssets(sender, recipient, seeds, stalk);
273	 }
274	 function _transferDeposits( address sender, address recipient, address token, uint32[] calldata seasons, uint256[] calldata amounts ) internal {
275	 require( seasons.length == amounts.length, "Silo: Crates, amounts are diff lengths." );
276	 AssetsRemoved memory ar;
277	 for (uint256 i; i < seasons.length; ++i) {
278	 uint256 crateBdv = LibTokenSilo.removeDeposit( sender, token, seasons[i], amounts[i] );
279	 LibTokenSilo.addDeposit( recipient, token, seasons[i], amounts[i], crateBdv );
280	 ar.bdvRemoved = ar.bdvRemoved.add(crateBdv);
281	 ar.tokensRemoved = ar.tokensRemoved.add(amounts[i]);
282	 ar.stalkRemoved = ar.stalkRemoved.add( LibSilo.stalkReward( crateBdv.mul(s.ss[token].seeds), _season() - seasons[i] ) );
283	 }
284	 ar.seedsRemoved = ar.bdvRemoved.mul(s.ss[token].seeds);
285	 ar.stalkRemoved = ar.stalkRemoved.add( ar.bdvRemoved.mul(s.ss[token].stalk) );
286	 emit RemoveDeposits(sender, token, seasons, amounts, ar.tokensRemoved);
287	 LibSilo.transferSiloAssets( sender, recipient, ar.seedsRemoved, ar.stalkRemoved );
288	 }
289	 function _season() private view returns (uint32) {
290	 return s.season.current;
291	 }
292	 }
293	 pragma solidity >=0.6.0 <0.8.0;
294	 interface IERC20 {
295	 function totalSupply() external view returns (uint256);
296	 function balanceOf(address account) external view returns (uint256);
297	 function transfer(address recipient, uint256 amount) external returns (bool);
298	 function allowance(address owner, address spender) external view returns (uint256);
299	 function approve(address spender, uint256 amount) external returns (bool);
300	 function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
301	 event Transfer(address indexed from, address indexed to, uint256 value);
302	 event Approval(address indexed owner, address indexed spender, uint256 value);
303	 }
304	 pragma solidity ^0.7.6;
305	 contract SiloFacet is TokenSilo {
306	 using SafeMath for uint256;
307	 using LibSafeMath32 for uint32;
308	 function deposit( address token, uint256 amount, LibTransfer.From mode ) external payable nonReentrant updateSilo {
309	 amount = LibTransfer.receiveToken( IERC20(token), amount, msg.sender, mode );
310	 _deposit(msg.sender, token, amount);
311	 }
312	 function withdrawDeposit( address token, uint32 season, uint256 amount ) external payable updateSilo {
313	 _withdrawDeposit(msg.sender, token, season, amount);
314	 }
315	 function withdrawDeposits( address token, uint32[] calldata seasons, uint256[] calldata amounts ) external payable updateSilo {
316	 _withdrawDeposits(msg.sender, token, seasons, amounts);
317	 }
318	 function claimWithdrawal( address token, uint32 season, LibTransfer.To mode ) external payable nonReentrant {
319	 uint256 amount = _claimWithdrawal(msg.sender, token, season);
320	 LibTransfer.sendToken(IERC20(token), amount, msg.sender, mode);
321	 }
322	 function claimWithdrawals( address token, uint32[] calldata seasons, LibTransfer.To mode ) external payable nonReentrant {
323	 uint256 amount = _claimWithdrawals(msg.sender, token, seasons);
324	 LibTransfer.sendToken(IERC20(token), amount, msg.sender, mode);
325	 }
326	 function transferDeposit( address recipient, address token, uint32 season, uint256 amount ) external payable nonReentrant updateSilo {
327	 _update(recipient);
328	 _transferDeposit(msg.sender, recipient, token, season, amount);
329	 }
330	 function transferDeposits( address recipient, address token, uint32[] calldata seasons, uint256[] calldata amounts ) external payable nonReentrant updateSilo {
331	 _update(recipient);
332	 _transferDeposits(msg.sender, recipient, token, seasons, amounts);
333	 }
334	 function update(address account) external payable {
335	 _update(account);
336	 }
337	 function plant() external payable returns (uint256 beans) {
338	 return _plant(msg.sender);
339	 }
340	 function claimPlenty(address account) external payable {
341	 _claimPlenty(account);
342	 }
343	 function enrootDeposits( address token, uint32[] calldata seasons, uint256[] calldata amounts ) external nonReentrant updateSilo {
344	 AssetsRemoved memory ar = removeDeposits(msg.sender, token, seasons, amounts);
345	 uint256 newBDV = LibTokenSilo.beanDenominatedValue(token, ar.tokensRemoved);
346	 uint256 newStalk;
347	 for (uint256 i; i < seasons.length; ++i) {
348	 uint256 bdv = amounts[i].mul(newBDV).div(ar.tokensRemoved);
349	 LibTokenSilo.addDeposit( msg.sender, token, seasons[i], amounts[i], bdv );
350	 newStalk = newStalk.add( bdv.mul(s.ss[token].stalk).add( LibSilo.stalkReward( bdv.mul(s.ss[token].seeds), season() - seasons[i] ) ) );
351	 }
352	 uint256 newSeeds = newBDV.mul(s.ss[token].seeds);
353	 LibSilo.depositSiloAssets( msg.sender, newSeeds.sub(ar.seedsRemoved), newStalk.sub(ar.stalkRemoved) );
354	 }
355	 function enrootDeposit( address token, uint32 _season, uint256 amount ) external nonReentrant updateSilo {
356	 uint256 ogBDV = LibTokenSilo.removeDeposit( msg.sender, token, _season, amount );
357	 emit RemoveDeposit(msg.sender, token, _season, amount);
358	 uint256 newBDV = LibTokenSilo.beanDenominatedValue(token, amount);
359	 LibTokenSilo.addDeposit(msg.sender, token, _season, amount, newBDV);
360	 uint256 deltaBDV = newBDV.sub(ogBDV);
361	 uint256 deltaSeeds = deltaBDV.mul(s.ss[token].seeds);
362	 uint256 deltaStalk = deltaBDV.mul(s.ss[token].stalk).add( LibSilo.stalkReward(deltaSeeds, season() - _season) );
363	 LibSilo.depositSiloAssets(msg.sender, deltaSeeds, deltaStalk);
364	 }
365	 }
366	 pragma solidity =0.7.6;
367	 library LibTransfer {
368	 using SafeERC20 for IERC20;
369	 using SafeMath for uint256;
370	 enum From {
371	 EXTERNAL, INTERNAL, EXTERNAL_INTERNAL, INTERNAL_TOLERANT }
372	 enum To {
373	 EXTERNAL, INTERNAL }
374	 function transferToken( IERC20 token, address recipient, uint256 amount, From fromMode, To toMode ) internal returns (uint256 transferredAmount) {
375	 if (fromMode == From.EXTERNAL && toMode == To.EXTERNAL) {
376	 uint256 beforeBalance = token.balanceOf(recipient);
377	 token.safeTransferFrom(msg.sender, recipient, amount);
378	 return token.balanceOf(recipient).sub(beforeBalance);
379	 }
380	 amount = receiveToken(token, amount, msg.sender, fromMode);
381	 sendToken(token, amount, recipient, toMode);
382	 return amount;
383	 }
384	 function receiveToken( IERC20 token, uint256 amount, address sender, From mode ) internal returns (uint256 receivedAmount) {
385	 if (amount == 0) return 0;
386	 if (mode != From.EXTERNAL) {
387	 receivedAmount = LibBalance.decreaseInternalBalance( sender, token, amount, mode != From.INTERNAL );
388	 if (amount == receivedAmount || mode == From.INTERNAL_TOLERANT) return receivedAmount;
389	 }
390	 uint256 beforeBalance = token.balanceOf(address(this));
391	 token.safeTransferFrom(sender, address(this), amount - receivedAmount);
392	 return receivedAmount.add(token.balanceOf(address(this)).sub(beforeBalance));
393	 }
394	 function sendToken( IERC20 token, uint256 amount, address recipient, To mode ) internal {
395	 if (amount == 0) return;
396	 if (mode == To.INTERNAL) LibBalance.increaseInternalBalance(recipient, token, amount);
397	 else token.safeTransfer(recipient, amount);
398	 }
399	 function burnToken( IBean token, uint256 amount, address sender, From mode ) internal returns (uint256 burnt) {
400	 if (mode == From.EXTERNAL) {
401	 token.burnFrom(sender, amount);
402	 burnt = amount;
403	 }
404	 else {
405	 burnt = LibTransfer.receiveToken(token, amount, sender, mode);
406	 token.burn(burnt);
407	 }
408	 }
409	 }
410	 pragma solidity >=0.6.0 <0.8.0;
411	 library SafeERC20 {
412	 using SafeMath for uint256;
413	 using Address for address;
414	 function safeTransfer(IERC20 token, address to, uint256 value) internal {
415	 _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
416	 }
417	 function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
418	 _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
419	 }
420	 function safeApprove(IERC20 token, address spender, uint256 value) internal {
421	 require((value == 0) || (token.allowance(address(this), spender) == 0), "SafeERC20: approve from non-zero to non-zero allowance" );
422	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
423	 }
424	 function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
425	 uint256 newAllowance = token.allowance(address(this), spender).add(value);
426	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
427	 }
428	 function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
429	 uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
430	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
431	 }
432	 function _callOptionalReturn(IERC20 token, bytes memory data) private {
433	 bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
434	 if (returndata.length > 0) {
435	 require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
436	 }
437	 }
438	 }
439	 pragma solidity =0.7.6;
440	 library LibSilo {
441	 using SafeMath for uint256;
442	 event SeedsBalanceChanged( address indexed account, int256 delta );
443	 event StalkBalanceChanged( address indexed account, int256 delta, int256 deltaRoots );
444	 function depositSiloAssets( address account, uint256 seeds, uint256 stalk ) internal {
445	 incrementBalanceOfStalk(account, stalk);
446	 incrementBalanceOfSeeds(account, seeds);
447	 }
448	 function withdrawSiloAssets( address account, uint256 seeds, uint256 stalk ) internal {
449	 decrementBalanceOfStalk(account, stalk);
450	 decrementBalanceOfSeeds(account, seeds);
451	 }
452	 function transferSiloAssets( address sender, address recipient, uint256 seeds, uint256 stalk ) internal {
453	 transferStalk(sender, recipient, stalk);
454	 transferSeeds(sender, recipient, seeds);
455	 }
456	 function incrementBalanceOfSeeds(address account, uint256 seeds) internal {
457	 AppStorage storage s = LibAppStorage.diamondStorage();
458	 s.s.seeds = s.s.seeds.add(seeds);
459	 s.a[account].s.seeds = s.a[account].s.seeds.add(seeds);
460	 emit SeedsBalanceChanged(account, int256(seeds));
461	 }
462	 function incrementBalanceOfStalk(address account, uint256 stalk) internal {
463	 AppStorage storage s = LibAppStorage.diamondStorage();
464	 uint256 roots;
465	 if (s.s.roots == 0) roots = stalk.mul(C.getRootsBase());
466	 else roots = s.s.roots.mul(stalk).div(s.s.stalk);
467	 s.s.stalk = s.s.stalk.add(stalk);
468	 s.a[account].s.stalk = s.a[account].s.stalk.add(stalk);
469	 s.s.roots = s.s.roots.add(roots);
470	 s.a[account].roots = s.a[account].roots.add(roots);
471	 emit StalkBalanceChanged(account, int256(stalk), int256(roots));
472	 }
473	 function decrementBalanceOfSeeds(address account, uint256 seeds) private {
474	 AppStorage storage s = LibAppStorage.diamondStorage();
475	 s.s.seeds = s.s.seeds.sub(seeds);
476	 s.a[account].s.seeds = s.a[account].s.seeds.sub(seeds);
477	 emit SeedsBalanceChanged(account, -int256(seeds));
478	 }
479	 function decrementBalanceOfStalk(address account, uint256 stalk) private {
480	 AppStorage storage s = LibAppStorage.diamondStorage();
481	 if (stalk == 0) return;
482	 uint256 roots = stalk == s.a[account].s.stalk ? s.a[account].roots : s.s.roots.mul(stalk).div(s.s.stalk);
483	 s.s.stalk = s.s.stalk.sub(stalk);
484	 s.a[account].s.stalk = s.a[account].s.stalk.sub(stalk);
485	 s.s.roots = s.s.roots.sub(roots);
486	 s.a[account].roots = s.a[account].roots.sub(roots);
487	 if (s.season.raining) {
488	 s.r.roots = s.r.roots.sub(roots);
489	 s.a[account].sop.roots = s.a[account].roots;
490	 }
491	 emit StalkBalanceChanged(account, -int256(stalk), -int256(roots));
492	 }
493	 function transferSeeds( address sender, address recipient, uint256 seeds ) private {
494	 AppStorage storage s = LibAppStorage.diamondStorage();
495	 s.a[sender].s.seeds = s.a[sender].s.seeds.sub(seeds);
496	 s.a[recipient].s.seeds = s.a[recipient].s.seeds.add(seeds);
497	 }
498	 function transferStalk( address sender, address recipient, uint256 stalk ) private {
499	 AppStorage storage s = LibAppStorage.diamondStorage();
500	 uint256 roots = stalk == s.a[sender].s.stalk ? s.a[sender].roots : s.s.roots.sub(1).mul(stalk).div(s.s.stalk).add(1);
501	 s.a[sender].s.stalk = s.a[sender].s.stalk.sub(stalk);
502	 s.a[sender].roots = s.a[sender].roots.sub(roots);
503	 s.a[recipient].s.stalk = s.a[recipient].s.stalk.add(stalk);
504	 s.a[recipient].roots = s.a[recipient].roots.add(roots);
505	 }
506	 function stalkReward(uint256 seeds, uint32 seasons) internal pure returns (uint256) {
507	 return seeds.mul(seasons);
508	 }
509	 }
510	 pragma solidity =0.7.6;
511	 library LibTokenSilo {
512	 using SafeMath for uint256;
513	 event AddDeposit( address indexed account, address indexed token, uint32 season, uint256 amount, uint256 bdv );
514	 function deposit( address account, address token, uint32 _s, uint256 amount ) internal returns (uint256, uint256) {
515	 uint256 bdv = beanDenominatedValue(token, amount);
516	 return depositWithBDV(account, token, _s, amount, bdv);
517	 }
518	 function depositWithBDV( address account, address token, uint32 _s, uint256 amount, uint256 bdv ) internal returns (uint256, uint256) {
519	 AppStorage storage s = LibAppStorage.diamondStorage();
520	 require(bdv > 0, "Silo: No Beans under Token.");
521	 incrementDepositedToken(token, amount);
522	 addDeposit(account, token, _s, amount, bdv);
523	 return (bdv.mul(s.ss[token].seeds), bdv.mul(s.ss[token].stalk));
524	 }
525	 function incrementDepositedToken(address token, uint256 amount) internal {
526	 AppStorage storage s = LibAppStorage.diamondStorage();
527	 s.siloBalances[token].deposited = s.siloBalances[token].deposited.add( amount );
528	 }
529	 function addDeposit( address account, address token, uint32 _s, uint256 amount, uint256 bdv ) internal {
530	 AppStorage storage s = LibAppStorage.diamondStorage();
531	 s.a[account].deposits[token][_s].amount += uint128(amount);
532	 s.a[account].deposits[token][_s].bdv += uint128(bdv);
533	 emit AddDeposit(account, token, _s, amount, bdv);
534	 }
535	 function decrementDepositedToken(address token, uint256 amount) internal {
536	 AppStorage storage s = LibAppStorage.diamondStorage();
537	 s.siloBalances[token].deposited = s.siloBalances[token].deposited.sub( amount );
538	 }
539	 function removeDeposit( address account, address token, uint32 id, uint256 amount ) internal returns (uint256 crateBDV) {
540	 AppStorage storage s = LibAppStorage.diamondStorage();
541	 uint256 crateAmount;
542	 (crateAmount, crateBDV) = ( s.a[account].deposits[token][id].amount, s.a[account].deposits[token][id].bdv );
543	 if (amount < crateAmount) {
544	 uint256 base = amount.mul(crateBDV).div(crateAmount);
545	 uint256 newBase = uint256(s.a[account].deposits[token][id].bdv).sub( base );
546	 uint256 newAmount = uint256(s.a[account].deposits[token][id].amount) .sub(amount);
547	 require( newBase <= uint128(-1) && newAmount <= uint128(-1), "Silo: uint128 overflow." );
548	 s.a[account].deposits[token][id].amount = uint128(newAmount);
549	 s.a[account].deposits[token][id].bdv = uint128(newBase);
550	 return base;
551	 }
552	 if (crateAmount > 0) delete s.a[account].deposits[token][id];
553	 if (amount > crateAmount) {
554	 amount -= crateAmount;
555	 if (LibUnripeSilo.isUnripeBean(token)) return crateBDV.add( LibUnripeSilo.removeUnripeBeanDeposit( account, id, amount ) );
556	 else if (LibUnripeSilo.isUnripeLP(token)) return crateBDV.add( LibUnripeSilo.removeUnripeLPDeposit(account, id, amount) );
557	 revert("Silo: Crate balance too low.");
558	 }
559	 }
560	 function tokenDeposit( address account, address token, uint32 id ) internal view returns (uint256, uint256) {
561	 AppStorage storage s = LibAppStorage.diamondStorage();
562	 if (LibUnripeSilo.isUnripeBean(token)) return LibUnripeSilo.unripeBeanDeposit(account, id);
563	 if (LibUnripeSilo.isUnripeLP(token)) return LibUnripeSilo.unripeLPDeposit(account, id);
564	 return ( s.a[account].deposits[token][id].amount, s.a[account].deposits[token][id].bdv );
565	 }
566	 function beanDenominatedValue(address token, uint256 amount) internal returns (uint256 bdv) {
567	 AppStorage storage s = LibAppStorage.diamondStorage();
568	 bytes memory myFunctionCall = abi.encodeWithSelector( s.ss[token].selector, amount );
569	 (bool success, bytes memory data) = address(this).call( myFunctionCall );
570	 if (!success) {
571	 if (data.length == 0) revert();
572	 assembly {
573	 revert(add(32, data), mload(data)) }
574	 }
575	 assembly {
576	 bdv := mload(add(data, add(0x20, 0))) }
577	 }
578	 function tokenWithdrawal( address account, address token, uint32 id ) internal view returns (uint256) {
579	 AppStorage storage s = LibAppStorage.diamondStorage();
580	 return s.a[account].withdrawals[token][id];
581	 }
582	 function seeds(address token) internal view returns (uint256) {
583	 AppStorage storage s = LibAppStorage.diamondStorage();
584	 return uint256(s.ss[token].seeds);
585	 }
586	 function stalk(address token) internal view returns (uint256) {
587	 AppStorage storage s = LibAppStorage.diamondStorage();
588	 return uint256(s.ss[token].stalk);
589	 }
590	 }
591	 pragma solidity >=0.6.0 <0.8.0;
592	 library SafeMath {
593	 function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
594	 uint256 c = a + b;
595	 if (c < a) return (false, 0);
596	 return (true, c);
597	 }
598	 function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
599	 if (b > a) return (false, 0);
600	 return (true, a - b);
601	 }
602	 function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
603	 if (a == 0) return (true, 0);
604	 uint256 c = a * b;
605	 if (c / a != b) return (false, 0);
606	 return (true, c);
607	 }
608	 function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
609	 if (b == 0) return (false, 0);
610	 return (true, a / b);
611	 }
612	 function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
613	 if (b == 0) return (false, 0);
614	 return (true, a % b);
615	 }
616	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
617	 uint256 c = a + b;
618	 require(c >= a, "SafeMath: addition overflow");
619	 return c;
620	 }
621	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
622	 require(b <= a, "SafeMath: subtraction overflow");
623	 return a - b;
624	 }
625	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
626	 if (a == 0) return 0;
627	 uint256 c = a * b;
628	 require(c / a == b, "SafeMath: multiplication overflow");
629	 return c;
630	 }
631	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
632	 require(b > 0, "SafeMath: division by zero");
633	 return a / b;
634	 }
635	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
636	 require(b > 0, "SafeMath: modulo by zero");
637	 return a % b;
638	 }
639	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
640	 require(b <= a, errorMessage);
641	 return a - b;
642	 }
643	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
644	 require(b > 0, errorMessage);
645	 return a / b;
646	 }
647	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
648	 require(b > 0, errorMessage);
649	 return a % b;
650	 }
651	 }
652	 pragma solidity >=0.6.2 <0.8.0;
653	 library Address {
654	 function isContract(address account) internal view returns (bool) {
655	 uint256 size;
656	 assembly {
657	 size := extcodesize(account) }
658	 return size > 0;
659	 }
660	 function sendValue(address payable recipient, uint256 amount) internal {
661	 require(address(this).balance >= amount, "Address: insufficient balance");
662	 (bool success, ) = recipient.call{
663	 value: amount }
664	 ("");
665	 require(success, "Address: unable to send value, recipient may have reverted");
666	 }
667	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
668	 return functionCall(target, data, "Address: low-level call failed");
669	 }
670	 function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
671	 return functionCallWithValue(target, data, 0, errorMessage);
672	 }
673	 function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
674	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
675	 }
676	 function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
677	 require(address(this).balance >= value, "Address: insufficient balance for call");
678	 require(isContract(target), "Address: call to non-contract");
679	 (bool success, bytes memory returndata) = target.call{
680	 value: value }
681	 (data);
682	 return _verifyCallResult(success, returndata, errorMessage);
683	 }
684	 function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
685	 return functionStaticCall(target, data, "Address: low-level static call failed");
686	 }
687	 function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
688	 require(isContract(target), "Address: static call to non-contract");
689	 (bool success, bytes memory returndata) = target.staticcall(data);
690	 return _verifyCallResult(success, returndata, errorMessage);
691	 }
692	 function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
693	 return functionDelegateCall(target, data, "Address: low-level delegate call failed");
694	 }
695	 function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
696	 require(isContract(target), "Address: delegate call to non-contract");
697	 (bool success, bytes memory returndata) = target.delegatecall(data);
698	 return _verifyCallResult(success, returndata, errorMessage);
699	 }
700	 function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
701	 if (success) {
702	 return returndata;
703	 }
704	 else {
705	 if (returndata.length > 0) {
706	 assembly {
707	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
708	 }
709	 else {
710	 revert(errorMessage);
711	 }
712	 }
713	 }
714	 }
715	 pragma solidity >=0.6.0 <0.8.0;
716	 library LibSafeMath32 {
717	 function tryAdd(uint32 a, uint32 b) internal pure returns (bool, uint32) {
718	 uint32 c = a + b;
719	 if (c < a) return (false, 0);
720	 return (true, c);
721	 }
722	 function trySub(uint32 a, uint32 b) internal pure returns (bool, uint32) {
723	 if (b > a) return (false, 0);
724	 return (true, a - b);
725	 }
726	 function tryMul(uint32 a, uint32 b) internal pure returns (bool, uint32) {
727	 if (a == 0) return (true, 0);
728	 uint32 c = a * b;
729	 if (c / a != b) return (false, 0);
730	 return (true, c);
731	 }
732	 function tryDiv(uint32 a, uint32 b) internal pure returns (bool, uint32) {
733	 if (b == 0) return (false, 0);
734	 return (true, a / b);
735	 }
736	 function tryMod(uint32 a, uint32 b) internal pure returns (bool, uint32) {
737	 if (b == 0) return (false, 0);
738	 return (true, a % b);
739	 }
740	 function add(uint32 a, uint32 b) internal pure returns (uint32) {
741	 uint32 c = a + b;
742	 require(c >= a, "SafeMath: addition overflow");
743	 return c;
744	 }
745	 function sub(uint32 a, uint32 b) internal pure returns (uint32) {
746	 require(b <= a, "SafeMath: subtraction overflow");
747	 return a - b;
748	 }
749	 function mul(uint32 a, uint32 b) internal pure returns (uint32) {
750	 if (a == 0) return 0;
751	 uint32 c = a * b;
752	 require(c / a == b, "SafeMath: multiplication overflow");
753	 return c;
754	 }
755	 function div(uint32 a, uint32 b) internal pure returns (uint32) {
756	 require(b > 0, "SafeMath: division by zero");
757	 return a / b;
758	 }
759	 function mod(uint32 a, uint32 b) internal pure returns (uint32) {
760	 require(b > 0, "SafeMath: modulo by zero");
761	 return a % b;
762	 }
763	 function sub(uint32 a, uint32 b, string memory errorMessage) internal pure returns (uint32) {
764	 require(b <= a, errorMessage);
765	 return a - b;
766	 }
767	 function div(uint32 a, uint32 b, string memory errorMessage) internal pure returns (uint32) {
768	 require(b > 0, errorMessage);
769	 return a / b;
770	 }
771	 function mod(uint32 a, uint32 b, string memory errorMessage) internal pure returns (uint32) {
772	 require(b > 0, errorMessage);
773	 return a % b;
774	 }
775	 }
776	 pragma solidity =0.7.6;
777	 library C {
778	 using Decimal for Decimal.D256;
779	 using SafeMath for uint256;
780	 uint256 private constant PERCENT_BASE = 1e18;
781	 uint256 private constant PRECISION = 1e18;
782	 uint256 private constant CHAIN_ID = 1;
783	 uint256 private constant CURRENT_SEASON_PERIOD = 3600;
784	 uint256 private constant BASE_ADVANCE_INCENTIVE = 100e6;
785	 uint256 private constant SOP_PRECISION = 1e24;
786	 uint256 private constant FERTILIZER_DENOMINATOR = 3;
787	 uint256 private constant HARVEST_DENOMINATOR = 2;
788	 uint256 private constant SOIL_COEFFICIENT_HIGH = 0.5e18;
789	 uint256 private constant SOIL_COEFFICIENT_LOW = 1.5e18;
790	 uint256 private constant POD_RATE_LOWER_BOUND = 0.05e18;
791	 uint256 private constant OPTIMAL_POD_RATE = 0.15e18;
792	 uint256 private constant POD_RATE_UPPER_BOUND = 0.25e18;
793	 uint32 private constant STEADY_SOW_TIME = 60;
794	 uint256 private constant DELTA_POD_DEMAND_LOWER_BOUND = 0.95e18;
795	 uint256 private constant DELTA_POD_DEMAND_UPPER_BOUND = 1.05e18;
796	 uint256 private constant SEEDS_PER_BEAN = 2;
797	 uint256 private constant STALK_PER_BEAN = 10000;
798	 uint256 private constant ROOTS_BASE = 1e12;
799	 uint256 private constant UNRIPE_LP_PER_DOLLAR = 1884592;
800	 uint256 private constant ADD_LP_RATIO = 866616;
801	 uint256 private constant INITIAL_HAIRCUT = 185564685220298701;
802	 address private constant BEAN = 0xBEA0000029AD1c77D3d5D23Ba2D8893dB9d1Efab;
803	 address private constant CURVE_BEAN_METAPOOL = 0xc9C32cd16Bf7eFB85Ff14e0c8603cc90F6F2eE49;
804	 address private constant CURVE_3_POOL = 0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7;
805	 address private constant THREE_CRV = 0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490;
806	 address private constant UNRIPE_BEAN = 0x1BEA0050E63e05FBb5D8BA2f10cf5800B6224449;
807	 address private constant UNRIPE_LP = 0x1BEA3CcD22F4EBd3d37d731BA31Eeca95713716D;
808	 address private constant FERTILIZER = 0x402c84De2Ce49aF88f5e2eF3710ff89bFED36cB6;
809	 address private constant FERTILIZER_ADMIN = 0xfECB01359263C12Aa9eD838F878A596F0064aa6e;
810	 address private constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
811	 address private constant TRI_CRYPTO = 0xc4AD29ba4B3c580e6D59105FFf484999997675Ff;
812	 address private constant TRI_CRYPTO_POOL = 0xD51a44d3FaE010294C616388b506AcdA1bfAAE46;
813	 address private constant CURVE_ZAP = 0xA79828DF1850E8a3A3064576f380D90aECDD3359;
814	 address private constant UNRIPE_CURVE_BEAN_LUSD_POOL = 0xD652c40fBb3f06d6B58Cb9aa9CFF063eE63d465D;
815	 address private constant UNRIPE_CURVE_BEAN_METAPOOL = 0x3a70DfA7d2262988064A2D051dd47521E43c9BdD;
816	 function getSeasonPeriod() internal pure returns (uint256) {
817	 return CURRENT_SEASON_PERIOD;
818	 }
819	 function getAdvanceIncentive() internal pure returns (uint256) {
820	 return BASE_ADVANCE_INCENTIVE;
821	 }
822	 function getFertilizerDenominator() internal pure returns (uint256) {
823	 return FERTILIZER_DENOMINATOR;
824	 }
825	 function getHarvestDenominator() internal pure returns (uint256) {
826	 return HARVEST_DENOMINATOR;
827	 }
828	 function getChainId() internal pure returns (uint256) {
829	 return CHAIN_ID;
830	 }
831	 function getOptimalPodRate() internal pure returns (Decimal.D256 memory) {
832	 return Decimal.ratio(OPTIMAL_POD_RATE, PERCENT_BASE);
833	 }
834	 function getUpperBoundPodRate() internal pure returns (Decimal.D256 memory) {
835	 return Decimal.ratio(POD_RATE_UPPER_BOUND, PERCENT_BASE);
836	 }
837	 function getLowerBoundPodRate() internal pure returns (Decimal.D256 memory) {
838	 return Decimal.ratio(POD_RATE_LOWER_BOUND, PERCENT_BASE);
839	 }
840	 function getUpperBoundDPD() internal pure returns (Decimal.D256 memory) {
841	 return Decimal.ratio(DELTA_POD_DEMAND_UPPER_BOUND, PERCENT_BASE);
842	 }
843	 function getLowerBoundDPD() internal pure returns (Decimal.D256 memory) {
844	 return Decimal.ratio(DELTA_POD_DEMAND_LOWER_BOUND, PERCENT_BASE);
845	 }
846	 function getSteadySowTime() internal pure returns (uint32) {
847	 return STEADY_SOW_TIME;
848	 }
849	 function getSeedsPerBean() internal pure returns (uint256) {
850	 return SEEDS_PER_BEAN;
851	 }
852	 function getStalkPerBean() internal pure returns (uint256) {
853	 return STALK_PER_BEAN;
854	 }
855	 function getRootsBase() internal pure returns (uint256) {
856	 return ROOTS_BASE;
857	 }
858	 function getSopPrecision() internal pure returns (uint256) {
859	 return SOP_PRECISION;
860	 }
861	 function beanAddress() internal pure returns (address) {
862	 return BEAN;
863	 }
864	 function curveMetapoolAddress() internal pure returns (address) {
865	 return CURVE_BEAN_METAPOOL;
866	 }
867	 function unripeLPPool1() internal pure returns (address) {
868	 return UNRIPE_CURVE_BEAN_METAPOOL;
869	 }
870	 function unripeLPPool2() internal pure returns (address) {
871	 return UNRIPE_CURVE_BEAN_LUSD_POOL;
872	 }
873	 function unripeBeanAddress() internal pure returns (address) {
874	 return UNRIPE_BEAN;
875	 }
876	 function unripeLPAddress() internal pure returns (address) {
877	 return UNRIPE_LP;
878	 }
879	 function unripeBean() internal pure returns (IERC20) {
880	 return IERC20(UNRIPE_BEAN);
881	 }
882	 function unripeLP() internal pure returns (IERC20) {
883	 return IERC20(UNRIPE_LP);
884	 }
885	 function bean() internal pure returns (IBean) {
886	 return IBean(BEAN);
887	 }
888	 function usdc() internal pure returns (IERC20) {
889	 return IERC20(USDC);
890	 }
891	 function curveMetapool() internal pure returns (ICurvePool) {
892	 return ICurvePool(CURVE_BEAN_METAPOOL);
893	 }
894	 function curve3Pool() internal pure returns (I3Curve) {
895	 return I3Curve(CURVE_3_POOL);
896	 }
897	 function curveZap() internal pure returns (ICurveZap) {
898	 return ICurveZap(CURVE_ZAP);
899	 }
900	 function curveZapAddress() internal pure returns (address) {
901	 return CURVE_ZAP;
902	 }
903	 function curve3PoolAddress() internal pure returns (address) {
904	 return CURVE_3_POOL;
905	 }
906	 function threeCrv() internal pure returns (IERC20) {
907	 return IERC20(THREE_CRV);
908	 }
909	 function fertilizer() internal pure returns (IFertilizer) {
910	 return IFertilizer(FERTILIZER);
911	 }
912	 function fertilizerAddress() internal pure returns (address) {
913	 return FERTILIZER;
914	 }
915	 function fertilizerAdmin() internal pure returns (IProxyAdmin) {
916	 return IProxyAdmin(FERTILIZER_ADMIN);
917	 }
918	 function triCryptoPoolAddress() internal pure returns (address) {
919	 return TRI_CRYPTO_POOL;
920	 }
921	 function triCrypto() internal pure returns (IERC20) {
922	 return IERC20(TRI_CRYPTO);
923	 }
924	 function unripeLPPerDollar() internal pure returns (uint256) {
925	 return UNRIPE_LP_PER_DOLLAR;
926	 }
927	 function dollarPerUnripeLP() internal pure returns (uint256) {
928	 return 1e12/UNRIPE_LP_PER_DOLLAR;
929	 }
930	 function exploitAddLPRatio() internal pure returns (uint256) {
931	 return ADD_LP_RATIO;
932	 }
933	 function precision() internal pure returns (uint256) {
934	 return PRECISION;
935	 }
936	 function initialRecap() internal pure returns (uint256) {
937	 return INITIAL_HAIRCUT;
938	 }
939	 function soilCoefficientHigh() internal pure returns (uint256) {
940	 return SOIL_COEFFICIENT_HIGH;
941	 }
942	 function soilCoefficientLow() internal pure returns (uint256) {
943	 return SOIL_COEFFICIENT_LOW;
944	 }
945	 }
946	 pragma solidity =0.7.6;
947	 contract Account {
948	 struct Field {
949	 mapping(uint256 => uint256) plots;
950	 mapping(address => uint256) podAllowances;
951	 }
952	 struct AssetSilo {
953	 mapping(uint32 => uint256) withdrawals;
954	 mapping(uint32 => uint256) deposits;
955	 mapping(uint32 => uint256) depositSeeds;
956	 }
957	 struct Deposit {
958	 uint128 amount;
959	 uint128 bdv;
960	 }
961	 struct Silo {
962	 uint256 stalk;
963	 uint256 seeds;
964	 }
965	 struct SeasonOfPlenty {
966	 uint256 roots;
967	 uint256 plentyPerRoot;
968	 uint256 plenty;
969	 }
970	 struct State {
971	 Field field;
972	 AssetSilo bean;
973	 AssetSilo lp;
974	 Silo s;
975	 uint32 votedUntil;
976	 uint32 lastUpdate;
977	 uint32 lastSop;
978	 uint32 lastRain;
979	 uint32 lastSIs;
980	 uint32 proposedUntil;
981	 SeasonOfPlenty deprecated;
982	 uint256 roots;
983	 uint256 wrappedBeans;
984	 mapping(address => mapping(uint32 => Deposit)) deposits;
985	 mapping(address => mapping(uint32 => uint256)) withdrawals;
986	 SeasonOfPlenty sop;
987	 }
988	 }
989	 contract Storage {
990	 struct Contracts {
991	 address bean;
992	 address pair;
993	 address pegPair;
994	 address weth;
995	 }
996	 struct Field {
997	 uint256 soil;
998	 uint256 pods;
999	 uint256 harvested;
1000	 uint256 harvestable;
1001	 }
1002	 struct Bip {
1003	 address proposer;
1004	 uint32 start;
1005	 uint32 period;
1006	 bool executed;
1007	 int pauseOrUnpause;
1008	 uint128 timestamp;
1009	 uint256 roots;
1010	 uint256 endTotalRoots;
1011	 }
1012	 struct DiamondCut {
1013	 IDiamondCut.FacetCut[] diamondCut;
1014	 address initAddress;
1015	 bytes initData;
1016	 }
1017	 struct Governance {
1018	 uint32[] activeBips;
1019	 uint32 bipIndex;
1020	 mapping(uint32 => DiamondCut) diamondCuts;
1021	 mapping(uint32 => mapping(address => bool)) voted;
1022	 mapping(uint32 => Bip) bips;
1023	 }
1024	 struct AssetSilo {
1025	 uint256 deposited;
1026	 uint256 withdrawn;
1027	 }
1028	 struct Silo {
1029	 uint256 stalk;
1030	 uint256 seeds;
1031	 uint256 roots;
1032	 }
1033	 struct Oracle {
1034	 bool initialized;
1035	 uint32 startSeason;
1036	 uint256[2] balances;
1037	 uint256 timestamp;
1038	 }
1039	 struct Rain {
1040	 uint256 depreciated;
1041	 uint256 pods;
1042	 uint256 roots;
1043	 }
1044	 struct Season {
1045	 uint32 current;
1046	 uint32 lastSop;
1047	 uint8 withdrawSeasons;
1048	 uint32 lastSopSeason;
1049	 uint32 rainStart;
1050	 bool raining;
1051	 bool fertilizing;
1052	 uint256 start;
1053	 uint256 period;
1054	 uint256 timestamp;
1055	 }
1056	 struct Weather {
1057	 uint256 startSoil;
1058	 uint256 lastDSoil;
1059	 uint96 lastSoilPercent;
1060	 uint32 lastSowTime;
1061	 uint32 nextSowTime;
1062	 uint32 yield;
1063	 bool didSowBelowMin;
1064	 bool didSowFaster;
1065	 }
1066	 struct Fundraiser {
1067	 address payee;
1068	 address token;
1069	 uint256 total;
1070	 uint256 remaining;
1071	 uint256 start;
1072	 }
1073	 struct SiloSettings {
1074	 bytes4 selector;
1075	 uint32 seeds;
1076	 uint32 stalk;
1077	 }
1078	 struct UnripeSettings {
1079	 address underlyingToken;
1080	 uint256 balanceOfUnderlying;
1081	 bytes32 merkleRoot;
1082	 }
1083	 }
1084	 struct AppStorage {
1085	 uint8 index;
1086	 int8[32] cases;
1087	 bool paused;
1088	 uint128 pausedAt;
1089	 Storage.Season season;
1090	 Storage.Contracts c;
1091	 Storage.Field f;
1092	 Storage.Governance g;
1093	 Storage.Oracle co;
1094	 Storage.Rain r;
1095	 Storage.Silo s;
1096	 uint256 reentrantStatus;
1097	 Storage.Weather w;
1098	 uint256 earnedBeans;
1099	 uint256[14] depreciated;
1100	 mapping (address => Account.State) a;
1101	 uint32 bip0Start;
1102	 uint32 hotFix3Start;
1103	 mapping (uint32 => Storage.Fundraiser) fundraisers;
1104	 uint32 fundraiserIndex;
1105	 mapping (address => bool) isBudget;
1106	 mapping(uint256 => bytes32) podListings;
1107	 mapping(bytes32 => uint256) podOrders;
1108	 mapping(address => Storage.AssetSilo) siloBalances;
1109	 mapping(address => Storage.SiloSettings) ss;
1110	 uint256[3] depreciated2;
1111	 mapping (uint32 => uint256) sops;
1112	 mapping(address => mapping(IERC20 => uint256)) internalTokenBalance;
1113	 mapping(address => mapping(address => bool)) unripeClaimed;
1114	 mapping(address => Storage.UnripeSettings) u;
1115	 mapping(uint128 => uint256) fertilizer;
1116	 mapping(uint128 => uint128) nextFid;
1117	 uint256 activeFertilizer;
1118	 uint256 fertilizedIndex;
1119	 uint256 unfertilizedIndex;
1120	 uint128 fFirst;
1121	 uint128 fLast;
1122	 uint128 bpf;
1123	 uint256 recapitalized;
1124	 uint256 isFarm;
1125	 address ownerCandidate;
1126	 }
1127	 pragma solidity =0.7.6;
1128	 interface IDiamondCut {
1129	 enum FacetCutAction {
1130	 Add, Replace, Remove}
1131	 struct FacetCut {
1132	 address facetAddress;
1133	 FacetCutAction action;
1134	 bytes4[] functionSelectors;
1135	 }
1136	 function diamondCut( FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata ) external;
1137	 event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);
1138	 }
1139	 pragma solidity =0.7.6;
1140	 library LibAppStorage {
1141	 function diamondStorage() internal pure returns (AppStorage storage ds) {
1142	 assembly {
1143	 ds.slot := 0 }
1144	 }
1145	 }
1146	 pragma solidity =0.7.6;
1147	 abstract contract IBean is IERC20 {
1148	 function burn(uint256 amount) public virtual;
1149	 function burnFrom(address account, uint256 amount) public virtual;
1150	 function mint(address account, uint256 amount) public virtual;
1151	 }
1152	 pragma solidity =0.7.6;
1153	 interface ICurvePool {
1154	 function A_precise() external view returns (uint256);
1155	 function get_balances() external view returns (uint256[2] memory);
1156	 function totalSupply() external view returns (uint256);
1157	 function add_liquidity(uint256[2] memory amounts, uint256 min_mint_amount) external returns (uint256);
1158	 function remove_liquidity_one_coin(uint256 _token_amount, int128 i, uint256 min_amount) external returns (uint256);
1159	 function balances(int128 i) external view returns (uint256);
1160	 function fee() external view returns (uint256);
1161	 function coins(uint256 i) external view returns (address);
1162	 function get_virtual_price() external view returns (uint256);
1163	 function calc_token_amount(uint256[2] calldata amounts, bool deposit) external view returns (uint256);
1164	 function calc_withdraw_one_coin(uint256 _token_amount, int128 i) external view returns (uint256);
1165	 function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external returns (uint256);
1166	 function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy) external returns (uint256);
1167	 function transfer(address recipient, uint256 amount) external returns (bool);
1168	 }
1169	 interface ICurveZap {
1170	 function add_liquidity(address _pool, uint256[4] memory _deposit_amounts, uint256 _min_mint_amount) external returns (uint256);
1171	 function calc_token_amount(address _pool, uint256[4] memory _amounts, bool _is_deposit) external returns (uint256);
1172	 }
1173	 interface ICurvePoolR {
1174	 function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);
1175	 function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);
1176	 function remove_liquidity_one_coin(uint256 _token_amount, int128 i, uint256 min_amount, address receiver) external returns (uint256);
1177	 }
1178	 interface ICurvePool2R {
1179	 function add_liquidity(uint256[2] memory amounts, uint256 min_mint_amount, address reciever) external returns (uint256);
1180	 function remove_liquidity(uint256 _burn_amount, uint256[2] memory _min_amounts, address reciever) external returns (uint256[2] calldata);
1181	 function remove_liquidity_imbalance(uint256[2] memory _amounts, uint256 _max_burn_amount, address reciever) external returns (uint256);
1182	 }
1183	 interface ICurvePool3R {
1184	 function add_liquidity(uint256[3] memory amounts, uint256 min_mint_amount, address reciever) external returns (uint256);
1185	 function remove_liquidity(uint256 _burn_amount, uint256[3] memory _min_amounts, address reciever) external returns (uint256[3] calldata);
1186	 function remove_liquidity_imbalance(uint256[3] memory _amounts, uint256 _max_burn_amount, address reciever) external returns (uint256);
1187	 }
1188	 interface ICurvePool4R {
1189	 function add_liquidity(uint256[4] memory amounts, uint256 min_mint_amount, address reciever) external returns (uint256);
1190	 function remove_liquidity(uint256 _burn_amount, uint256[4] memory _min_amounts, address reciever) external returns (uint256[4] calldata);
1191	 function remove_liquidity_imbalance(uint256[4] memory _amounts, uint256 _max_burn_amount, address reciever) external returns (uint256);
1192	 }
1193	 interface I3Curve {
1194	 function get_virtual_price() external view returns (uint256);
1195	 }
1196	 interface ICurveFactory {
1197	 function get_coins(address _pool) external view returns (address[4] calldata);
1198	 function get_underlying_coins(address _pool) external view returns (address[8] calldata);
1199	 }
1200	 interface ICurveCryptoFactory {
1201	 function get_coins(address _pool) external view returns (address[8] calldata);
1202	 }
1203	 interface ICurvePoolC {
1204	 function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external returns (uint256);
1205	 }
1206	 interface ICurvePoolNoReturn {
1207	 function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external;
1208	 function add_liquidity(uint256[3] memory amounts, uint256 min_mint_amount) external;
1209	 function remove_liquidity(uint256 _burn_amount, uint256[3] memory _min_amounts) external;
1210	 function remove_liquidity_imbalance(uint256[3] memory _amounts, uint256 _max_burn_amount) external;
1211	 function remove_liquidity_one_coin(uint256 _token_amount, uint256 i, uint256 min_amount) external;
1212	 }
1213	 interface ICurvePoolNoReturn128 {
1214	 function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external;
1215	 function remove_liquidity_one_coin(uint256 _token_amount, int128 i, uint256 min_amount) external;
1216	 }
1217	 pragma solidity =0.7.6;
1218	 interface IFertilizer {
1219	 struct Balance {
1220	 uint128 amount;
1221	 uint128 lastBpf;
1222	 }
1223	 function beanstalkUpdate( address account, uint256[] memory ids, uint128 bpf ) external returns (uint256);
1224	 function beanstalkMint(address account, uint256 id, uint128 amount, uint128 bpf) external;
1225	 function balanceOfFertilized(address account, uint256[] memory ids) external view returns (uint256);
1226	 function balanceOfUnfertilized(address account, uint256[] memory ids) external view returns (uint256);
1227	 function lastBalanceOf(address account, uint256 id) external view returns (Balance memory);
1228	 function lastBalanceOfBatch(address[] memory account, uint256[] memory id) external view returns (Balance[] memory);
1229	 function setURI(string calldata newuri) external;
1230	 }
1231	 pragma solidity =0.7.6;
1232	 interface IProxyAdmin {
1233	 function upgrade(address proxy, address implementation) external;
1234	 }
1235	 pragma solidity =0.7.6;
1236	 library Decimal {
1237	 using SafeMath for uint256;
1238	 uint256 constant BASE = 10**18;
1239	 struct D256 {
1240	 uint256 value;
1241	 }
1242	 function zero() internal pure returns (D256 memory) {
1243	 return D256({
1244	 value: 0 }
1245	 );
1246	 }
1247	 function one() internal pure returns (D256 memory) {
1248	 return D256({
1249	 value: BASE }
1250	 );
1251	 }
1252	 function from( uint256 a ) internal pure returns (D256 memory) {
1253	 return D256({
1254	 value: a.mul(BASE) }
1255	 );
1256	 }
1257	 function ratio( uint256 a, uint256 b ) internal pure returns (D256 memory) {
1258	 return D256({
1259	 value: getPartial(a, BASE, b) }
1260	 );
1261	 }
1262	 function add( D256 memory self, uint256 b ) internal pure returns (D256 memory) {
1263	 return D256({
1264	 value: self.value.add(b.mul(BASE)) }
1265	 );
1266	 }
1267	 function sub( D256 memory self, uint256 b ) internal pure returns (D256 memory) {
1268	 return D256({
1269	 value: self.value.sub(b.mul(BASE)) }
1270	 );
1271	 }
1272	 function sub( D256 memory self, uint256 b, string memory reason ) internal pure returns (D256 memory) {
1273	 return D256({
1274	 value: self.value.sub(b.mul(BASE), reason) }
1275	 );
1276	 }
1277	 function mul( D256 memory self, uint256 b ) internal pure returns (D256 memory) {
1278	 return D256({
1279	 value: self.value.mul(b) }
1280	 );
1281	 }
1282	 function div( D256 memory self, uint256 b ) internal pure returns (D256 memory) {
1283	 return D256({
1284	 value: self.value.div(b) }
1285	 );
1286	 }
1287	 function pow( D256 memory self, uint256 b ) internal pure returns (D256 memory) {
1288	 if (b == 0) {
1289	 return one();
1290	 }
1291	 D256 memory temp = D256({
1292	 value: self.value }
1293	 );
1294	 for (uint256 i = 1; i < b; ++i) {
1295	 temp = mul(temp, self);
1296	 }
1297	 return temp;
1298	 }
1299	 function add( D256 memory self, D256 memory b ) internal pure returns (D256 memory) {
1300	 return D256({
1301	 value: self.value.add(b.value) }
1302	 );
1303	 }
1304	 function sub( D256 memory self, D256 memory b ) internal pure returns (D256 memory) {
1305	 return D256({
1306	 value: self.value.sub(b.value) }
1307	 );
1308	 }
1309	 function sub( D256 memory self, D256 memory b, string memory reason ) internal pure returns (D256 memory) {
1310	 return D256({
1311	 value: self.value.sub(b.value, reason) }
1312	 );
1313	 }
1314	 function mul( D256 memory self, D256 memory b ) internal pure returns (D256 memory) {
1315	 return D256({
1316	 value: getPartial(self.value, b.value, BASE) }
1317	 );
1318	 }
1319	 function div( D256 memory self, D256 memory b ) internal pure returns (D256 memory) {
1320	 return D256({
1321	 value: getPartial(self.value, BASE, b.value) }
1322	 );
1323	 }
1324	 function equals(D256 memory self, D256 memory b) internal pure returns (bool) {
1325	 return self.value == b.value;
1326	 }
1327	 function greaterThan(D256 memory self, D256 memory b) internal pure returns (bool) {
1328	 return compareTo(self, b) == 2;
1329	 }
1330	 function lessThan(D256 memory self, D256 memory b) internal pure returns (bool) {
1331	 return compareTo(self, b) == 0;
1332	 }
1333	 function greaterThanOrEqualTo(D256 memory self, D256 memory b) internal pure returns (bool) {
1334	 return compareTo(self, b) > 0;
1335	 }
1336	 function lessThanOrEqualTo(D256 memory self, D256 memory b) internal pure returns (bool) {
1337	 return compareTo(self, b) < 2;
1338	 }
1339	 function isZero(D256 memory self) internal pure returns (bool) {
1340	 return self.value == 0;
1341	 }
1342	 function asUint256(D256 memory self) internal pure returns (uint256) {
1343	 return self.value.div(BASE);
1344	 }
1345	 function getPartial( uint256 target, uint256 numerator, uint256 denominator ) private pure returns (uint256) {
1346	 return target.mul(numerator).div(denominator);
1347	 }
1348	 function compareTo( D256 memory a, D256 memory b ) private pure returns (uint256) {
1349	 if (a.value == b.value) {
1350	 return 1;
1351	 }
1352	 return a.value > b.value ? 2 : 0;
1353	 }
1354	 }
1355	 pragma solidity =0.7.6;
1356	 library LibUnripeSilo {
1357	 using SafeMath for uint256;
1358	 using LibSafeMath128 for uint128;
1359	 uint256 private constant AMOUNT_TO_BDV_BEAN_ETH = 119894802186829;
1360	 uint256 private constant AMOUNT_TO_BDV_BEAN_3CRV = 992035;
1361	 uint256 private constant AMOUNT_TO_BDV_BEAN_LUSD = 983108;
1362	 function removeUnripeBeanDeposit( address account, uint32 id, uint256 amount ) internal returns (uint256 bdv) {
1363	 _removeUnripeBeanDeposit(account, id, amount);
1364	 bdv = amount.mul(C.initialRecap()).div(1e18);
1365	 }
1366	 function _removeUnripeBeanDeposit( address account, uint32 id, uint256 amount ) private {
1367	 AppStorage storage s = LibAppStorage.diamondStorage();
1368	 s.a[account].bean.deposits[id] = s.a[account].bean.deposits[id].sub( amount, "Silo: Crate balance too low." );
1369	 }
1370	 function isUnripeBean(address token) internal pure returns (bool b) {
1371	 b = token == C.unripeBeanAddress();
1372	 }
1373	 function unripeBeanDeposit(address account, uint32 season) internal view returns (uint256 amount, uint256 bdv) {
1374	 AppStorage storage s = LibAppStorage.diamondStorage();
1375	 uint256 legacyAmount = s.a[account].bean.deposits[season];
1376	 amount = uint256( s.a[account].deposits[C.unripeBeanAddress()][season].amount ).add(legacyAmount);
1377	 bdv = uint256(s.a[account].deposits[C.unripeBeanAddress()][season].bdv) .add(legacyAmount.mul(C.initialRecap()).div(1e18));
1378	 }
1379	 function removeUnripeLPDeposit( address account, uint32 id, uint256 amount ) internal returns (uint256 bdv) {
1380	 bdv = _removeUnripeLPDeposit(account, id, amount);
1381	 bdv = bdv.mul(C.initialRecap()).div(1e18);
1382	 }
1383	 function _removeUnripeLPDeposit( address account, uint32 id, uint256 amount ) private returns (uint256 bdv) {
1384	 AppStorage storage s = LibAppStorage.diamondStorage();
1385	 (uint256 amount1, uint256 bdv1) = getBeanEthUnripeLP(account, id);
1386	 if (amount1 >= amount) {
1387	 uint256 removed = amount.mul(s.a[account].lp.deposits[id]).div( amount1 );
1388	 s.a[account].lp.deposits[id] = s.a[account].lp.deposits[id].sub( removed );
1389	 removed = amount.mul(bdv1).div(amount1);
1390	 s.a[account].lp.depositSeeds[id] = s .a[account] .lp .depositSeeds[id] .sub(removed.mul(4));
1391	 return removed;
1392	 }
1393	 amount -= amount1;
1394	 bdv = bdv1;
1395	 delete s.a[account].lp.depositSeeds[id];
1396	 delete s.a[account].lp.deposits[id];
1397	 (amount1, bdv1) = getBean3CrvUnripeLP(account, id);
1398	 if (amount1 >= amount) {
1399	 Account.Deposit storage d = s.a[account].deposits[ C.unripeLPPool1() ][id];
1400	 uint128 removed = uint128(amount.mul(d.amount).div(amount1));
1401	 s.a[account].deposits[C.unripeLPPool1()][id].amount = d.amount.sub( removed );
1402	 removed = uint128(amount.mul(d.bdv).div(amount1));
1403	 s.a[account].deposits[C.unripeLPPool1()][id].bdv = d.bdv.sub( removed );
1404	 return bdv.add(removed);
1405	 }
1406	 amount -= amount1;
1407	 bdv = bdv.add(bdv1);
1408	 delete s.a[account].deposits[C.unripeLPPool1()][id];
1409	 (amount1, bdv1) = getBeanLusdUnripeLP(account, id);
1410	 if (amount1 >= amount) {
1411	 Account.Deposit storage d = s.a[account].deposits[ C.unripeLPPool2() ][id];
1412	 uint128 removed = uint128(amount.mul(d.amount).div(amount1));
1413	 s.a[account].deposits[C.unripeLPPool2()][id].amount = d.amount.sub( removed );
1414	 removed = uint128(amount.mul(d.bdv).div(amount1));
1415	 s.a[account].deposits[C.unripeLPPool2()][id].bdv = d.bdv.sub( removed );
1416	 return bdv.add(removed);
1417	 }
1418	 revert("Silo: Crate balance too low.");
1419	 }
1420	 function isUnripeLP(address token) internal pure returns (bool b) {
1421	 b = token == C.unripeLPAddress();
1422	 }
1423	 function unripeLPDeposit(address account, uint32 season) internal view returns (uint256 amount, uint256 bdv) {
1424	 AppStorage storage s = LibAppStorage.diamondStorage();
1425	 (amount, bdv) = getBeanEthUnripeLP(account, season);
1426	 (uint256 amount1, uint256 bdv1) = getBean3CrvUnripeLP(account, season);
1427	 (uint256 amount2, uint256 bdv2) = getBeanLusdUnripeLP(account, season);
1428	 amount = uint256( s.a[account].deposits[C.unripeLPAddress()][season].amount ).add(amount.add(amount1).add(amount2));
1429	 uint256 legBdv = bdv.add(bdv1).add(bdv2).mul(C.initialRecap()).div( C.precision() );
1430	 bdv = uint256(s.a[account].deposits[C.unripeLPAddress()][season].bdv) .add(legBdv);
1431	 }
1432	 function getBeanEthUnripeLP(address account, uint32 season) private view returns (uint256 amount, uint256 bdv) {
1433	 AppStorage storage s = LibAppStorage.diamondStorage();
1434	 bdv = s.a[account].lp.depositSeeds[season].div(4);
1435	 amount = s .a[account] .lp .deposits[season] .mul(AMOUNT_TO_BDV_BEAN_ETH) .div(1e18);
1436	 }
1437	 function getBeanLusdUnripeLP(address account, uint32 season) private view returns (uint256 amount, uint256 bdv) {
1438	 AppStorage storage s = LibAppStorage.diamondStorage();
1439	 bdv = uint256(s.a[account].deposits[C.unripeLPPool2()][season].bdv);
1440	 amount = uint256( s.a[account].deposits[C.unripeLPPool2()][season].amount ).mul(AMOUNT_TO_BDV_BEAN_LUSD).div(C.precision());
1441	 }
1442	 function getBean3CrvUnripeLP(address account, uint32 season) private view returns (uint256 amount, uint256 bdv) {
1443	 AppStorage storage s = LibAppStorage.diamondStorage();
1444	 bdv = uint256(s.a[account].deposits[C.unripeLPPool1()][season].bdv);
1445	 amount = uint256( s.a[account].deposits[C.unripeLPPool1()][season].amount ).mul(AMOUNT_TO_BDV_BEAN_3CRV).div(C.precision());
1446	 }
1447	 }
1448	 pragma solidity >=0.6.0 <0.8.0;
1449	 library LibSafeMath128 {
1450	 function tryAdd(uint128 a, uint128 b) internal pure returns (bool, uint128) {
1451	 uint128 c = a + b;
1452	 if (c < a) return (false, 0);
1453	 return (true, c);
1454	 }
1455	 function trySub(uint128 a, uint128 b) internal pure returns (bool, uint128) {
1456	 if (b > a) return (false, 0);
1457	 return (true, a - b);
1458	 }
1459	 function tryMul(uint128 a, uint128 b) internal pure returns (bool, uint128) {
1460	 if (a == 0) return (true, 0);
1461	 uint128 c = a * b;
1462	 if (c / a != b) return (false, 0);
1463	 return (true, c);
1464	 }
1465	 function tryDiv(uint128 a, uint128 b) internal pure returns (bool, uint128) {
1466	 if (b == 0) return (false, 0);
1467	 return (true, a / b);
1468	 }
1469	 function tryMod(uint128 a, uint128 b) internal pure returns (bool, uint128) {
1470	 if (b == 0) return (false, 0);
1471	 return (true, a % b);
1472	 }
1473	 function add(uint128 a, uint128 b) internal pure returns (uint128) {
1474	 uint128 c = a + b;
1475	 require(c >= a, "SafeMath: addition overflow");
1476	 return c;
1477	 }
1478	 function sub(uint128 a, uint128 b) internal pure returns (uint128) {
1479	 require(b <= a, "SafeMath: subtraction overflow");
1480	 return a - b;
1481	 }
1482	 function mul(uint128 a, uint128 b) internal pure returns (uint128) {
1483	 if (a == 0) return 0;
1484	 uint128 c = a * b;
1485	 require(c / a == b, "SafeMath: multiplication overflow");
1486	 return c;
1487	 }
1488	 function div(uint128 a, uint128 b) internal pure returns (uint128) {
1489	 require(b > 0, "SafeMath: division by zero");
1490	 return a / b;
1491	 }
1492	 function mod(uint128 a, uint128 b) internal pure returns (uint128) {
1493	 require(b > 0, "SafeMath: modulo by zero");
1494	 return a % b;
1495	 }
1496	 function sub(uint128 a, uint128 b, string memory errorMessage) internal pure returns (uint128) {
1497	 require(b <= a, errorMessage);
1498	 return a - b;
1499	 }
1500	 function div(uint128 a, uint128 b, string memory errorMessage) internal pure returns (uint128) {
1501	 require(b > 0, errorMessage);
1502	 return a / b;
1503	 }
1504	 function mod(uint128 a, uint128 b, string memory errorMessage) internal pure returns (uint128) {
1505	 require(b > 0, errorMessage);
1506	 return a % b;
1507	 }
1508	 }
1509	 pragma solidity ^0.7.6;
1510	 library LibBalance {
1511	 using SafeERC20 for IERC20;
1512	 using SafeMath for uint256;
1513	 using SafeCast for uint256;
1514	 event InternalBalanceChanged( address indexed account, IERC20 indexed token, int256 delta );
1515	 function getBalance(address account, IERC20 token) internal view returns (uint256 combined_balance) {
1516	 combined_balance = token.balanceOf(account).add( getInternalBalance(account, token) );
1517	 return combined_balance;
1518	 }
1519	 function increaseInternalBalance( address account, IERC20 token, uint256 amount ) internal {
1520	 uint256 currentBalance = getInternalBalance(account, token);
1521	 uint256 newBalance = currentBalance.add(amount);
1522	 setInternalBalance(account, token, newBalance, amount.toInt256());
1523	 }
1524	 function decreaseInternalBalance( address account, IERC20 token, uint256 amount, bool allowPartial ) internal returns (uint256 deducted) {
1525	 uint256 currentBalance = getInternalBalance(account, token);
1526	 require( allowPartial || (currentBalance >= amount), "Balance: Insufficient internal balance" );
1527	 deducted = Math.min(currentBalance, amount);
1528	 uint256 newBalance = currentBalance - deducted;
1529	 setInternalBalance(account, token, newBalance, -(deducted.toInt256()));
1530	 }
1531	 function setInternalBalance( address account, IERC20 token, uint256 newBalance, int256 delta ) private {
1532	 AppStorage storage s = LibAppStorage.diamondStorage();
1533	 s.internalTokenBalance[account][token] = newBalance;
1534	 emit InternalBalanceChanged(account, token, delta);
1535	 }
1536	 function getInternalBalance(address account, IERC20 token) internal view returns (uint256) {
1537	 AppStorage storage s = LibAppStorage.diamondStorage();
1538	 return s.internalTokenBalance[account][token];
1539	 }
1540	 }
1541	 pragma solidity >=0.6.0 <0.8.0;
1542	 library Math {
1543	 function max(uint256 a, uint256 b) internal pure returns (uint256) {
1544	 return a >= b ? a : b;
1545	 }
1546	 function min(uint256 a, uint256 b) internal pure returns (uint256) {
1547	 return a < b ? a : b;
1548	 }
1549	 function average(uint256 a, uint256 b) internal pure returns (uint256) {
1550	 return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);
1551	 }
1552	 }
1553	 pragma solidity >=0.6.0 <0.8.0;
1554	 library SafeCast {
1555	 function toUint128(uint256 value) internal pure returns (uint128) {
1556	 require(value < 2**128, "SafeCast: value doesn\'t fit in 128 bits");
1557	 return uint128(value);
1558	 }
1559	 function toUint64(uint256 value) internal pure returns (uint64) {
1560	 require(value < 2**64, "SafeCast: value doesn\'t fit in 64 bits");
1561	 return uint64(value);
1562	 }
1563	 function toUint32(uint256 value) internal pure returns (uint32) {
1564	 require(value < 2**32, "SafeCast: value doesn\'t fit in 32 bits");
1565	 return uint32(value);
1566	 }
1567	 function toUint16(uint256 value) internal pure returns (uint16) {
1568	 require(value < 2**16, "SafeCast: value doesn\'t fit in 16 bits");
1569	 return uint16(value);
1570	 }
1571	 function toUint8(uint256 value) internal pure returns (uint8) {
1572	 require(value < 2**8, "SafeCast: value doesn\'t fit in 8 bits");
1573	 return uint8(value);
1574	 }
1575	 function toUint256(int256 value) internal pure returns (uint256) {
1576	 require(value >= 0, "SafeCast: value must be positive");
1577	 return uint256(value);
1578	 }
1579	 function toInt128(int256 value) internal pure returns (int128) {
1580	 require(value >= -2**127 && value < 2**127, "SafeCast: value doesn\'t fit in 128 bits");
1581	 return int128(value);
1582	 }
1583	 function toInt64(int256 value) internal pure returns (int64) {
1584	 require(value >= -2**63 && value < 2**63, "SafeCast: value doesn\'t fit in 64 bits");
1585	 return int64(value);
1586	 }
1587	 function toInt32(int256 value) internal pure returns (int32) {
1588	 require(value >= -2**31 && value < 2**31, "SafeCast: value doesn\'t fit in 32 bits");
1589	 return int32(value);
1590	 }
1591	 function toInt16(int256 value) internal pure returns (int16) {
1592	 require(value >= -2**15 && value < 2**15, "SafeCast: value doesn\'t fit in 16 bits");
1593	 return int16(value);
1594	 }
1595	 function toInt8(int256 value) internal pure returns (int8) {
1596	 require(value >= -2**7 && value < 2**7, "SafeCast: value doesn\'t fit in 8 bits");
1597	 return int8(value);
1598	 }
1599	 function toInt256(uint256 value) internal pure returns (int256) {
1600	 require(value < 2**255, "SafeCast: value doesn't fit in an int256");
1601	 return int256(value);
1602	 }
1603	 }
