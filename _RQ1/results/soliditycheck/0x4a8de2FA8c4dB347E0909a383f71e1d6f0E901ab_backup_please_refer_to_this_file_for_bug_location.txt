row number 
1	  pragma abicoder v2;
2	 pragma solidity >=0.6.0 <0.8.0;
3	 interface IERC165Upgradeable {
4	 function supportsInterface(bytes4 interfaceId) external view returns (bool);
5	 }
6	 pragma solidity >=0.4.24 <0.8.0;
7	 abstract contract Initializable {
8	 bool private _initialized;
9	 bool private _initializing;
10	 modifier initializer() {
11	 require(_initializing || _isConstructor() || !_initialized, "Initializable: contract is already initialized");
12	 bool isTopLevelCall = !_initializing;
13	 if (isTopLevelCall) {
14	 _initializing = true;
15	 _initialized = true;
16	 }
17	 _;
18	 if (isTopLevelCall) {
19	 _initializing = false;
20	 }
21	 }
22	 function _isConstructor() private view returns (bool) {
23	 return !AddressUpgradeable.isContract(address(this));
24	 }
25	 }
26	 pragma solidity >=0.6.2 <0.8.0;
27	 interface IERC721Upgradeable is IERC165Upgradeable {
28	 event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
29	 event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
30	 event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
31	 function balanceOf(address owner) external view returns (uint256 balance);
32	 function ownerOf(uint256 tokenId) external view returns (address owner);
33	 function safeTransferFrom(address from, address to, uint256 tokenId) external;
34	 function transferFrom(address from, address to, uint256 tokenId) external;
35	 function approve(address to, uint256 tokenId) external;
36	 function getApproved(uint256 tokenId) external view returns (address operator);
37	 function setApprovalForAll(address operator, bool _approved) external;
38	 function isApprovedForAll(address owner, address operator) external view returns (bool);
39	 function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;
40	 }
41	 pragma solidity >=0.6.0 <0.8.0;
42	 abstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {
43	 bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;
44	 mapping(bytes4 => bool) private _supportedInterfaces;
45	 function __ERC165_init() internal initializer {
46	 __ERC165_init_unchained();
47	 }
48	 function __ERC165_init_unchained() internal initializer {
49	 _registerInterface(_INTERFACE_ID_ERC165);
50	 }
51	 function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
52	 return _supportedInterfaces[interfaceId];
53	 }
54	 function _registerInterface(bytes4 interfaceId) internal virtual {
55	 require(interfaceId != 0xffffffff, "ERC165: invalid interface id");
56	 _supportedInterfaces[interfaceId] = true;
57	 }
58	 uint256[49] private __gap;
59	 }
60	 pragma solidity >=0.6.2 <0.8.0;
61	 interface IERC721EnumerableUpgradeable is IERC721Upgradeable {
62	 function totalSupply() external view returns (uint256);
63	 function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);
64	 function tokenByIndex(uint256 index) external view returns (uint256);
65	 }
66	 pragma solidity >=0.6.2 <0.8.0;
67	 interface IERC721MetadataUpgradeable is IERC721Upgradeable {
68	 function name() external view returns (string memory);
69	 function symbol() external view returns (string memory);
70	 function tokenURI(uint256 tokenId) external view returns (string memory);
71	 }
72	 pragma solidity >=0.6.0 <0.8.0;
73	 abstract contract ContextUpgradeable is Initializable {
74	 function __Context_init() internal initializer {
75	 __Context_init_unchained();
76	 }
77	 function __Context_init_unchained() internal initializer {
78	 }
79	 function _msgSender() internal view virtual returns (address payable) {
80	 return msg.sender;
81	 }
82	 function _msgData() internal view virtual returns (bytes memory) {
83	 this;
84	 return msg.data;
85	 }
86	 uint256[50] private __gap;
87	 }
88	 pragma solidity >=0.6.0 <0.8.0;
89	 contract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable, IERC721EnumerableUpgradeable {
90	 using SafeMathUpgradeable for uint256;
91	 using AddressUpgradeable for address;
92	 using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;
93	 using EnumerableMapUpgradeable for EnumerableMapUpgradeable.UintToAddressMap;
94	 using StringsUpgradeable for uint256;
95	 bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;
96	 mapping (address => EnumerableSetUpgradeable.UintSet) private _holderTokens;
97	 EnumerableMapUpgradeable.UintToAddressMap private _tokenOwners;
98	 mapping (uint256 => address) private _tokenApprovals;
99	 mapping (address => mapping (address => bool)) private _operatorApprovals;
100	 string private _name;
101	 string private _symbol;
102	 mapping (uint256 => string) private _tokenURIs;
103	 string private _baseURI;
104	 bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;
105	 bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;
106	 bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;
107	 function __ERC721_init(string memory name_, string memory symbol_) internal initializer {
108	 __Context_init_unchained();
109	 __ERC165_init_unchained();
110	 __ERC721_init_unchained(name_, symbol_);
111	 }
112	 function __ERC721_init_unchained(string memory name_, string memory symbol_) internal initializer {
113	 _name = name_;
114	 _symbol = symbol_;
115	 _registerInterface(_INTERFACE_ID_ERC721);
116	 _registerInterface(_INTERFACE_ID_ERC721_METADATA);
117	 _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);
118	 }
119	 function balanceOf(address owner) public view virtual override returns (uint256) {
120	 require(owner != address(0), "ERC721: balance query for the zero address");
121	 return _holderTokens[owner].length();
122	 }
123	 function ownerOf(uint256 tokenId) public view virtual override returns (address) {
124	 return _tokenOwners.get(tokenId, "ERC721: owner query for nonexistent token");
125	 }
126	 function name() public view virtual override returns (string memory) {
127	 return _name;
128	 }
129	 function symbol() public view virtual override returns (string memory) {
130	 return _symbol;
131	 }
132	 function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
133	 require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
134	 string memory _tokenURI = _tokenURIs[tokenId];
135	 string memory base = baseURI();
136	 if (bytes(base).length == 0) {
137	 return _tokenURI;
138	 }
139	 if (bytes(_tokenURI).length > 0) {
140	 return string(abi.encodePacked(base, _tokenURI));
141	 }
142	 return string(abi.encodePacked(base, tokenId.toString()));
143	 }
144	 function baseURI() public view virtual returns (string memory) {
145	 return _baseURI;
146	 }
147	 function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {
148	 return _holderTokens[owner].at(index);
149	 }
150	 function totalSupply() public view virtual override returns (uint256) {
151	 return _tokenOwners.length();
152	 }
153	 function tokenByIndex(uint256 index) public view virtual override returns (uint256) {
154	 (uint256 tokenId, ) = _tokenOwners.at(index);
155	 return tokenId;
156	 }
157	 function approve(address to, uint256 tokenId) public virtual override {
158	 address owner = ERC721Upgradeable.ownerOf(tokenId);
159	 require(to != owner, "ERC721: approval to current owner");
160	 require(_msgSender() == owner || ERC721Upgradeable.isApprovedForAll(owner, _msgSender()), "ERC721: approve caller is not owner nor approved for all" );
161	 _approve(to, tokenId);
162	 }
163	 function getApproved(uint256 tokenId) public view virtual override returns (address) {
164	 require(_exists(tokenId), "ERC721: approved query for nonexistent token");
165	 return _tokenApprovals[tokenId];
166	 }
167	 function setApprovalForAll(address operator, bool approved) public virtual override {
168	 require(operator != _msgSender(), "ERC721: approve to caller");
169	 _operatorApprovals[_msgSender()][operator] = approved;
170	 emit ApprovalForAll(_msgSender(), operator, approved);
171	 }
172	 function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
173	 return _operatorApprovals[owner][operator];
174	 }
175	 function transferFrom(address from, address to, uint256 tokenId) public virtual override {
176	 require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");
177	 _transfer(from, to, tokenId);
178	 }
179	 function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {
180	 safeTransferFrom(from, to, tokenId, "");
181	 }
182	 function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {
183	 require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");
184	 _safeTransfer(from, to, tokenId, _data);
185	 }
186	 function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {
187	 _transfer(from, to, tokenId);
188	 require(_checkOnERC721Received(from, to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");
189	 }
190	 function _exists(uint256 tokenId) internal view virtual returns (bool) {
191	 return _tokenOwners.contains(tokenId);
192	 }
193	 function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {
194	 require(_exists(tokenId), "ERC721: operator query for nonexistent token");
195	 address owner = ERC721Upgradeable.ownerOf(tokenId);
196	 return (spender == owner || getApproved(tokenId) == spender || ERC721Upgradeable.isApprovedForAll(owner, spender));
197	 }
198	 function _safeMint(address to, uint256 tokenId) internal virtual {
199	 _safeMint(to, tokenId, "");
200	 }
201	 function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {
202	 _mint(to, tokenId);
203	 require(_checkOnERC721Received(address(0), to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");
204	 }
205	 function _mint(address to, uint256 tokenId) internal virtual {
206	 require(to != address(0), "ERC721: mint to the zero address");
207	 require(!_exists(tokenId), "ERC721: token already minted");
208	 _beforeTokenTransfer(address(0), to, tokenId);
209	 _holderTokens[to].add(tokenId);
210	 _tokenOwners.set(tokenId, to);
211	 emit Transfer(address(0), to, tokenId);
212	 }
213	 function _burn(uint256 tokenId) internal virtual {
214	 address owner = ERC721Upgradeable.ownerOf(tokenId);
215	 _beforeTokenTransfer(owner, address(0), tokenId);
216	 _approve(address(0), tokenId);
217	 if (bytes(_tokenURIs[tokenId]).length != 0) {
218	 delete _tokenURIs[tokenId];
219	 }
220	 _holderTokens[owner].remove(tokenId);
221	 _tokenOwners.remove(tokenId);
222	 emit Transfer(owner, address(0), tokenId);
223	 }
224	 function _transfer(address from, address to, uint256 tokenId) internal virtual {
225	 require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer of token that is not own");
226	 require(to != address(0), "ERC721: transfer to the zero address");
227	 _beforeTokenTransfer(from, to, tokenId);
228	 _approve(address(0), tokenId);
229	 _holderTokens[from].remove(tokenId);
230	 _holderTokens[to].add(tokenId);
231	 _tokenOwners.set(tokenId, to);
232	 emit Transfer(from, to, tokenId);
233	 }
234	 function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {
235	 require(_exists(tokenId), "ERC721Metadata: URI set of nonexistent token");
236	 _tokenURIs[tokenId] = _tokenURI;
237	 }
238	 function _setBaseURI(string memory baseURI_) internal virtual {
239	 _baseURI = baseURI_;
240	 }
241	 function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data) private returns (bool) {
242	 if (!to.isContract()) {
243	 return true;
244	 }
245	 bytes memory returndata = to.functionCall(abi.encodeWithSelector( IERC721ReceiverUpgradeable(to).onERC721Received.selector, _msgSender(), from, tokenId, _data ), "ERC721: transfer to non ERC721Receiver implementer");
246	 bytes4 retval = abi.decode(returndata, (bytes4));
247	 return (retval == _ERC721_RECEIVED);
248	 }
249	 function _approve(address to, uint256 tokenId) internal virtual {
250	 _tokenApprovals[tokenId] = to;
251	 emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);
252	 }
253	 function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual {
254	 }
255	 uint256[41] private __gap;
256	 }
257	 pragma solidity 0.7.6;
258	 interface IVNFT {
259	 event TransferUnits( address indexed from, address indexed to, uint256 indexed tokenId, uint256 targetTokenId, uint256 transferUnits );
260	 event Split( address indexed owner, uint256 indexed tokenId, uint256 newTokenId, uint256 splitUnits );
261	 event Merge( address indexed owner, uint256 indexed tokenId, uint256 indexed targetTokenId, uint256 mergeUnits );
262	 event ApprovalUnits( address indexed approval, uint256 indexed tokenId, uint256 allowance );
263	 function slotOf(uint256 tokenId) external view returns (uint256 slot);
264	 function unitDecimals() external view returns (uint8);
265	 function unitsInSlot(uint256 slot) external view returns (uint256);
266	 function tokensInSlot(uint256 slot) external view returns (uint256 tokenCount);
267	 function tokenOfSlotByIndex(uint256 slot, uint256 index) external view returns (uint256 tokenId);
268	 function unitsInToken(uint256 tokenId) external view returns (uint256 units);
269	 function approve( address to, uint256 tokenId, uint256 units ) external;
270	 function allowance(uint256 tokenId, address spender) external view returns (uint256 allowed);
271	 function split(uint256 tokenId, uint256[] calldata units) external returns (uint256[] memory newTokenIds);
272	 function merge(uint256[] calldata tokenIds, uint256 targetTokenId) external;
273	 function transferFrom( address from, address to, uint256 tokenId, uint256 units ) external returns (uint256 newTokenId);
274	 function safeTransferFrom( address from, address to, uint256 tokenId, uint256 units, bytes calldata data ) external returns (uint256 newTokenId);
275	 function transferFrom( address from, address to, uint256 tokenId, uint256 targetTokenId, uint256 units ) external;
276	 function safeTransferFrom( address from, address to, uint256 tokenId, uint256 targetTokenId, uint256 units, bytes calldata data ) external;
277	 }
278	 pragma solidity 0.7.6;
279	 interface IVNFTMetadata {
280	 function contractURI() external view returns (string memory);
281	 function slotURI(uint256 slot) external view returns (string memory);
282	 }
283	 pragma solidity 0.7.6;
284	 abstract contract AdminControl is Initializable, ContextUpgradeable {
285	 event NewAdmin(address oldAdmin, address newAdmin);
286	 event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);
287	 address public admin;
288	 address public pendingAdmin;
289	 modifier onlyAdmin() {
290	 require(_msgSender() == admin, "only admin");
291	 _;
292	 }
293	 function __AdminControl_init(address admin_) internal initializer {
294	 admin = admin_;
295	 }
296	 function setPendingAdmin(address newPendingAdmin_) external virtual onlyAdmin {
297	 emit NewPendingAdmin(pendingAdmin, newPendingAdmin_);
298	 pendingAdmin = newPendingAdmin_;
299	 }
300	 function acceptAdmin() external virtual {
301	 require(_msgSender() == pendingAdmin, "only pending admin");
302	 emit NewAdmin(admin, pendingAdmin);
303	 admin = pendingAdmin;
304	 pendingAdmin = address(0);
305	 }
306	 }
307	 pragma solidity 0.7.6;
308	 abstract contract VNFTCoreV2 is IVNFT, IVNFTMetadata, ERC721Upgradeable {
309	 using SafeMathUpgradeable for uint256;
310	 using AddressUpgradeable for address;
311	 using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;
312	 struct ApproveUnits {
313	 address[] approvals;
314	 mapping(address => uint256) allowances;
315	 }
316	 mapping(uint256 => uint256) internal _units;
317	 mapping(uint256 => ApproveUnits) private _tokenApprovalUnits;
318	 mapping(uint256 => EnumerableSetUpgradeable.UintSet) private _slotTokens;
319	 uint8 internal _unitDecimals;
320	 function _initialize( string memory name_, string memory symbol_, uint8 unitDecimals_ ) internal virtual {
321	 ERC721Upgradeable.__ERC721_init(name_, symbol_);
322	 ERC165Upgradeable._registerInterface(type(IVNFT).interfaceId);
323	 _unitDecimals = unitDecimals_;
324	 }
325	 function _safeTransferUnitsFrom( address from_, address to_, uint256 tokenId_, uint256 targetTokenId_, uint256 transferUnits_, bytes memory data_ ) internal virtual {
326	 _transferUnitsFrom( from_, to_, tokenId_, targetTokenId_, transferUnits_ );
327	 require( _checkOnVNFTReceived( from_, to_, targetTokenId_, transferUnits_, data_ ), "to non VNFTReceiver implementer" );
328	 }
329	 function _transferUnitsFrom( address from_, address to_, uint256 tokenId_, uint256 targetTokenId_, uint256 transferUnits_ ) internal virtual {
330	 require(from_ == ownerOf(tokenId_), "source token owner mismatch");
331	 require(to_ != address(0), "transfer to the zero address");
332	 _beforeTransferUnits( from_, to_, tokenId_, targetTokenId_, transferUnits_ );
333	 if (_msgSender() != from_ && !isApprovedForAll(from_, _msgSender())) {
334	 _tokenApprovalUnits[tokenId_].allowances[ _msgSender() ] = _tokenApprovalUnits[tokenId_].allowances[_msgSender()].sub( transferUnits_, "transfer units exceeds allowance" );
335	 }
336	 _units[tokenId_] = _units[tokenId_].sub( transferUnits_, "transfer excess units" );
337	 if (!_exists(targetTokenId_)) {
338	 _mintUnits(to_, targetTokenId_, _slotOf(tokenId_), transferUnits_);
339	 }
340	 else {
341	 require( ownerOf(targetTokenId_) == to_, "target token owner mismatch" );
342	 require( _slotOf(tokenId_) == _slotOf(targetTokenId_), "slot mismatch" );
343	 _units[targetTokenId_] = _units[targetTokenId_].add(transferUnits_);
344	 }
345	 emit TransferUnits( from_, to_, tokenId_, targetTokenId_, transferUnits_ );
346	 }
347	 function _merge(uint256 tokenId_, uint256 targetTokenId_) internal virtual {
348	 require( _isApprovedOrOwner(_msgSender(), tokenId_), "VNFT: not owner nor approved" );
349	 require(tokenId_ != targetTokenId_, "self merge not allowed");
350	 require(_slotOf(tokenId_) == _slotOf(targetTokenId_), "slot mismatch");
351	 address owner = ownerOf(tokenId_);
352	 require(owner == ownerOf(targetTokenId_), "not same owner");
353	 uint256 mergeUnits = _units[tokenId_];
354	 _units[targetTokenId_] = _units[tokenId_].add(_units[targetTokenId_]);
355	 _burn(tokenId_);
356	 emit Merge(owner, tokenId_, targetTokenId_, mergeUnits);
357	 }
358	 function _split( uint256 tokenId_, uint256 newTokenId_, uint256 splitUnits_ ) internal virtual {
359	 require( _isApprovedOrOwner(_msgSender(), tokenId_), "VNFT: not owner nor approved" );
360	 require(!_exists(newTokenId_), "new token already exists");
361	 _units[tokenId_] = _units[tokenId_].sub(splitUnits_);
362	 address owner = ownerOf(tokenId_);
363	 _mintUnits(owner, newTokenId_, _slotOf(tokenId_), splitUnits_);
364	 emit Split(owner, tokenId_, newTokenId_, splitUnits_);
365	 }
366	 function _mintUnits( address minter_, uint256 tokenId_, uint256 slot_, uint256 units_ ) internal virtual {
367	 if (!_exists(tokenId_)) {
368	 ERC721Upgradeable._mint(minter_, tokenId_);
369	 _slotTokens[slot_].add(tokenId_);
370	 }
371	 _units[tokenId_] = _units[tokenId_].add(units_);
372	 emit TransferUnits(address(0), minter_, 0, tokenId_, units_);
373	 }
374	 function _burn(uint256 tokenId_) internal virtual override {
375	 address owner = ownerOf(tokenId_);
376	 uint256 slot = _slotOf(tokenId_);
377	 uint256 burnUnits = _units[tokenId_];
378	 _slotTokens[slot].remove(tokenId_);
379	 delete _units[tokenId_];
380	 ERC721Upgradeable._burn(tokenId_);
381	 emit TransferUnits(owner, address(0), tokenId_, 0, burnUnits);
382	 }
383	 function _burnUnits(uint256 tokenId_, uint256 burnUnits_) internal virtual returns (uint256 balance) {
384	 address owner = ownerOf(tokenId_);
385	 _units[tokenId_] = _units[tokenId_].sub( burnUnits_, "burn excess units" );
386	 emit TransferUnits(owner, address(0), tokenId_, 0, burnUnits_);
387	 return _units[tokenId_];
388	 }
389	 function approve( address to_, uint256 tokenId_, uint256 allowance_ ) public virtual override {
390	 require(_msgSender() == ownerOf(tokenId_), "VNFT: only owner");
391	 _approveUnits(to_, tokenId_, allowance_);
392	 }
393	 function allowance(uint256 tokenId_, address spender_) public view virtual override returns (uint256) {
394	 return _tokenApprovalUnits[tokenId_].allowances[spender_];
395	 }
396	 function _approveUnits( address to_, uint256 tokenId_, uint256 allowance_ ) internal virtual {
397	 if (_tokenApprovalUnits[tokenId_].allowances[to_] == 0) {
398	 _tokenApprovalUnits[tokenId_].approvals.push(to_);
399	 }
400	 _tokenApprovalUnits[tokenId_].allowances[to_] = allowance_;
401	 emit ApprovalUnits(to_, tokenId_, allowance_);
402	 }
403	 function _clearApproveUnits(uint256 tokenId_) internal virtual {
404	 ApproveUnits storage approveUnits = _tokenApprovalUnits[tokenId_];
405	 for (uint256 i = 0; i < approveUnits.approvals.length; i++) {
406	 delete approveUnits.allowances[approveUnits.approvals[i]];
407	 delete approveUnits.approvals[i];
408	 }
409	 }
410	 function unitDecimals() public view override returns (uint8) {
411	 return _unitDecimals;
412	 }
413	 function unitsInSlot(uint256 slot_) public view override returns (uint256 units_) {
414	 for (uint256 i = 0; i < tokensInSlot(slot_); i++) {
415	 units_ = units_.add(unitsInToken(tokenOfSlotByIndex(slot_, i)));
416	 }
417	 }
418	 function unitsInToken(uint256 tokenId_) public view virtual override returns (uint256) {
419	 return _units[tokenId_];
420	 }
421	 function tokensInSlot(uint256 slot_) public view override returns (uint256) {
422	 return _slotTokens[slot_].length();
423	 }
424	 function tokenOfSlotByIndex(uint256 slot_, uint256 index_) public view override returns (uint256) {
425	 return _slotTokens[slot_].at(index_);
426	 }
427	 function slotOf(uint256 tokenId_) public view override returns (uint256) {
428	 return _slotOf(tokenId_);
429	 }
430	 function _slotOf(uint256 tokenId_) internal view virtual returns (uint256);
431	 function _beforeTokenTransfer( address from_, address to_, uint256 tokenId_ ) internal virtual override {
432	 if (from_ != address(0)) {
433	 _clearApproveUnits(tokenId_);
434	 }
435	 }
436	 function _beforeTransferUnits( address from_, address to_, uint256 tokenId_, uint256 targetTokenId_, uint256 transferUnits_ ) internal virtual {
437	 }
438	 function _checkOnVNFTReceived( address from_, address to_, uint256 tokenId_, uint256 units_, bytes memory _data ) internal returns (bool) {
439	 if (!to_.isContract()) {
440	 return true;
441	 }
442	 bytes memory returndata = to_.functionCall( abi.encodeWithSelector( IVNFTReceiver(to_).onVNFTReceived.selector, _msgSender(), from_, tokenId_, units_, _data ), "non VNFTReceiver implementer" );
443	 bytes4 retval = abi.decode(returndata, (bytes4));
444	 return (retval == type(IVNFTReceiver).interfaceId);
445	 }
446	 }
447	 pragma solidity >=0.6.0 <0.8.0;
448	 interface IERC20Upgradeable {
449	 function totalSupply() external view returns (uint256);
450	 function balanceOf(address account) external view returns (uint256);
451	 function transfer(address recipient, uint256 amount) external returns (bool);
452	 function allowance(address owner, address spender) external view returns (uint256);
453	 function approve(address spender, uint256 amount) external returns (bool);
454	 function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
455	 event Transfer(address indexed from, address indexed to, uint256 value);
456	 event Approval(address indexed owner, address indexed spender, uint256 value);
457	 }
458	 pragma solidity >=0.6.0 <0.8.0;
459	 abstract contract ReentrancyGuardUpgradeable is Initializable {
460	 uint256 private constant _NOT_ENTERED = 1;
461	 uint256 private constant _ENTERED = 2;
462	 uint256 private _status;
463	 function __ReentrancyGuard_init() internal initializer {
464	 __ReentrancyGuard_init_unchained();
465	 }
466	 function __ReentrancyGuard_init_unchained() internal initializer {
467	 _status = _NOT_ENTERED;
468	 }
469	 modifier nonReentrant() {
470	 require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
471	 _status = _ENTERED;
472	 _;
473	 _status = _NOT_ENTERED;
474	 }
475	 uint256[49] private __gap;
476	 }
477	 pragma solidity 0.7.6;
478	 abstract contract VoucherCore is VNFTCoreV2, AdminControl {
479	 mapping(uint256 => uint256) public voucherSlotMapping;
480	 uint32 public nextTokenId;
481	 function _initialize( string memory name_, string memory symbol_, uint8 unitDecimals_ ) internal override {
482	 AdminControl.__AdminControl_init(_msgSender());
483	 VNFTCoreV2._initialize(name_, symbol_, unitDecimals_);
484	 nextTokenId = 1;
485	 }
486	 function _generateTokenId() internal virtual returns (uint256) {
487	 return nextTokenId++;
488	 }
489	 function split(uint256 tokenId_, uint256[] calldata splitUnits_) public virtual override returns (uint256[] memory newTokenIds) {
490	 require(splitUnits_.length > 0, "empty splitUnits");
491	 newTokenIds = new uint256[](splitUnits_.length);
492	 for (uint256 i = 0; i < splitUnits_.length; i++) {
493	 uint256 newTokenId = _generateTokenId();
494	 newTokenIds[i] = newTokenId;
495	 VNFTCoreV2._split(tokenId_, newTokenId, splitUnits_[i]);
496	 voucherSlotMapping[newTokenId] = voucherSlotMapping[tokenId_];
497	 }
498	 }
499	 function merge(uint256[] calldata tokenIds_, uint256 targetTokenId_) public virtual override {
500	 require(tokenIds_.length > 0, "empty tokenIds");
501	 for (uint256 i = 0; i < tokenIds_.length; i++) {
502	 VNFTCoreV2._merge(tokenIds_[i], targetTokenId_);
503	 delete voucherSlotMapping[tokenIds_[i]];
504	 }
505	 }
506	 function transferFrom( address from_, address to_, uint256 tokenId_, uint256 transferUnits_ ) public virtual override returns (uint256 newTokenId) {
507	 newTokenId = _generateTokenId();
508	 _transferUnitsFrom(from_, to_, tokenId_, newTokenId, transferUnits_);
509	 }
510	 function transferFrom( address from_, address to_, uint256 tokenId_, uint256 targetTokenId_, uint256 transferUnits_ ) public virtual override {
511	 require(_exists(targetTokenId_), "target token not exists");
512	 _transferUnitsFrom( from_, to_, tokenId_, targetTokenId_, transferUnits_ );
513	 }
514	 function safeTransferFrom( address from_, address to_, uint256 tokenId_, uint256 transferUnits_, bytes memory data_ ) public virtual override returns (uint256 newTokenId) {
515	 newTokenId = transferFrom(from_, to_, tokenId_, transferUnits_);
516	 require( _checkOnVNFTReceived(from_, to_, newTokenId, transferUnits_, data_), "to non VNFTReceiver" );
517	 return newTokenId;
518	 }
519	 function safeTransferFrom( address from_, address to_, uint256 tokenId_, uint256 targetTokenId_, uint256 transferUnits_, bytes memory data_ ) public virtual override {
520	 transferFrom(from_, to_, tokenId_, targetTokenId_, transferUnits_);
521	 require( _checkOnVNFTReceived( from_, to_, targetTokenId_, transferUnits_, data_ ), "to non VNFTReceiver" );
522	 }
523	 function _transferUnitsFrom( address from_, address to_, uint256 tokenId_, uint256 targetTokenId_, uint256 transferUnits_ ) internal virtual override {
524	 VNFTCoreV2._transferUnitsFrom( from_, to_, tokenId_, targetTokenId_, transferUnits_ );
525	 voucherSlotMapping[targetTokenId_] = voucherSlotMapping[tokenId_];
526	 }
527	 function _mint( address minter_, uint256 slot_, uint256 units_ ) internal virtual returns (uint256 tokenId) {
528	 tokenId = _generateTokenId();
529	 voucherSlotMapping[tokenId] = slot_;
530	 VNFTCoreV2._mintUnits(minter_, tokenId, slot_, units_);
531	 }
532	 function burn(uint256 tokenId_) external virtual {
533	 require(_msgSender() == ownerOf(tokenId_), "only owner");
534	 _burnVoucher(tokenId_);
535	 }
536	 function _burnVoucher(uint256 tokenId_) internal virtual {
537	 delete voucherSlotMapping[tokenId_];
538	 VNFTCoreV2._burn(tokenId_);
539	 }
540	 function _slotOf(uint256 tokenId_) internal view virtual override returns (uint256) {
541	 return voucherSlotMapping[tokenId_];
542	 }
543	 function owner() external view virtual returns (address) {
544	 return admin;
545	 }
546	 function voucherType() external view virtual returns (Constants.VoucherType) {
547	 }
548	 }
549	 pragma solidity 0.7.6;
550	 interface IConvertiblePool {
551	 enum CollateralType {
552	 ERC20, VESTING_VOUCHER }
553	 struct SlotDetail {
554	 address issuer;
555	 address fundCurrency;
556	 uint256 totalValue;
557	 uint128 lowestPrice;
558	 uint128 highestPrice;
559	 uint128 settlePrice;
560	 uint64 effectiveTime;
561	 uint64 maturity;
562	 CollateralType collateralType;
563	 bool isIssuerRefunded;
564	 bool isIssuerWithdrawn;
565	 bool isClaimed;
566	 bool isValid;
567	 }
568	 event NewVoucher(address oldVoucher, address newVoucher);
569	 event SetFundCurrency(address indexed currency, bool enabled);
570	 event CreateSlot( uint256 indexed slot, address indexed issuer, address fundCurrency, uint128 lowestPrice, uint128 highestPrice, uint64 effectiveTime, uint64 maturity, CollateralType collateralType );
571	 event Mint( address indexed minter, uint256 indexed slot, uint256 totalValue );
572	 event Refund(uint256 indexed slot, address sender, uint256 refundAmount);
573	 event Withdraw( uint256 indexed slot, address sender, uint256 redeemCurrencyAmount, uint256 redeemUnderlyingTokenAmount );
574	 event SettlePrice(uint256 indexed slot, uint128 settlePrice);
575	 function mintWithUnderlyingToken( address minter_, uint256 slot_, uint256 tokenInAmount_ ) external returns (uint256 totalValue);
576	 function refund(uint256 slot_) external;
577	 function withdraw(uint256 slot_) external returns (uint256, uint256);
578	 function claim( uint256 slot_, address to_, uint256 claimValue_ ) external returns (uint256, uint256);
579	 function settleConvertiblePrice(uint256 slot_) external;
580	 function getSettlePrice(uint256 slot_) external view returns (uint128);
581	 }
582	 pragma solidity 0.7.6;
583	 interface IConvertibleVoucher {
584	 struct ConvertibleVoucherSnapshot {
585	 IConvertiblePool.SlotDetail slotDetail;
586	 uint256 tokenId;
587	 uint256 parValue;
588	 }
589	 event SetDescriptor(address oldDescriptor, address newDescriptor);
590	 event SetSolver(address oldSolver, address newSolver);
591	 event Claim ( uint256 indexed tokenId, address indexed to, uint256 claimUnits, uint256 claimCurrencyAmount, uint256 claimTokenAmount );
592	 function mint( address issuer_, address fundCurrency_, uint128 lowestPrice_, uint128 highestPrice_, uint64 effectiveTime_, uint64 maturity_, uint256 tokenInAmount_ ) external returns (uint256 slot, uint256 tokenId);
593	 function claimAll(uint256 tokenId_) external;
594	 function claim(uint256 tokenId_, uint256 claimUnits_) external;
595	 function claimTo(uint256 tokenId_, address to_, uint256 claimUnits_) external;
596	 function getSlot( address issuer_, address fundCurrency_, uint128 lowestPrice_, uint128 highestPrice_, uint64 effectiveTime_, uint64 maturity_, uint8 collateralType_ ) external view returns (uint256 slot);
597	 function getSlotDetail(uint256 slot_) external view returns (IConvertiblePool.SlotDetail memory);
598	 function getIssuerSlots(address issuer_) external view returns (uint256[] memory slots);
599	 function getSnapshot(uint256 tokenId_) external view returns (ConvertibleVoucherSnapshot memory);
600	 function underlying() external view returns (address);
601	 function underlyingVestingVoucher() external view returns (address);
602	 }
603	 pragma solidity 0.7.6;
604	 interface IVoucherSVG {
605	 function generateSVG(address voucher_, uint256 tokenId_) external view returns (string memory);
606	 }
607	 pragma solidity >=0.6.0 <0.8.0;
608	 library SafeMath {
609	 function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
610	 uint256 c = a + b;
611	 if (c < a) return (false, 0);
612	 return (true, c);
613	 }
614	 function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
615	 if (b > a) return (false, 0);
616	 return (true, a - b);
617	 }
618	 function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
619	 if (a == 0) return (true, 0);
620	 uint256 c = a * b;
621	 if (c / a != b) return (false, 0);
622	 return (true, c);
623	 }
624	 function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
625	 if (b == 0) return (false, 0);
626	 return (true, a / b);
627	 }
628	 function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
629	 if (b == 0) return (false, 0);
630	 return (true, a % b);
631	 }
632	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
633	 uint256 c = a + b;
634	 require(c >= a, "SafeMath: addition overflow");
635	 return c;
636	 }
637	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
638	 require(b <= a, "SafeMath: subtraction overflow");
639	 return a - b;
640	 }
641	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
642	 if (a == 0) return 0;
643	 uint256 c = a * b;
644	 require(c / a == b, "SafeMath: multiplication overflow");
645	 return c;
646	 }
647	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
648	 require(b > 0, "SafeMath: division by zero");
649	 return a / b;
650	 }
651	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
652	 require(b > 0, "SafeMath: modulo by zero");
653	 return a % b;
654	 }
655	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
656	 require(b <= a, errorMessage);
657	 return a - b;
658	 }
659	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
660	 require(b > 0, errorMessage);
661	 return a / b;
662	 }
663	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
664	 require(b > 0, errorMessage);
665	 return a % b;
666	 }
667	 }
668	 pragma solidity >=0.6.0 <0.8.0;
669	 library Strings {
670	 function toString(uint256 value) internal pure returns (string memory) {
671	 if (value == 0) {
672	 return "0";
673	 }
674	 uint256 temp = value;
675	 uint256 digits;
676	 while (temp != 0) {
677	 digits++;
678	 temp /= 10;
679	 }
680	 bytes memory buffer = new bytes(digits);
681	 uint256 index = digits - 1;
682	 temp = value;
683	 while (temp != 0) {
684	 buffer[index--] = bytes1(uint8(48 + temp % 10));
685	 temp /= 10;
686	 }
687	 return string(buffer);
688	 }
689	 }
690	 pragma solidity 0.7.6;
691	 interface ERC20Interface {
692	 function balanceOf(address account) external view returns (uint256);
693	 function transfer(address recipient, uint256 amount) external returns (bool);
694	 function transferFrom( address sender, address recipient, uint256 amount ) external returns (bool);
695	 }
696	 library ERC20TransferHelper {
697	 function doTransferIn( address underlying, address from, uint256 amount ) internal returns (uint256) {
698	 if (underlying == Constants.ETH_ADDRESS) {
699	 require(tx.origin == from || msg.sender == from, "sender mismatch");
700	 require(msg.value == amount, "value mismatch");
701	 return amount;
702	 }
703	 else {
704	 require(msg.value == 0, "don't support msg.value");
705	 uint256 balanceBefore = ERC20Interface(underlying).balanceOf( address(this) );
706	 (bool success, bytes memory data) = underlying.call( abi.encodeWithSelector( ERC20Interface.transferFrom.selector, from, address(this), amount ) );
707	 require( success && (data.length == 0 || abi.decode(data, (bool))), "STF" );
708	 uint256 balanceAfter = ERC20Interface(underlying).balanceOf( address(this) );
709	 require( balanceAfter >= balanceBefore, "TOKEN_TRANSFER_IN_OVERFLOW" );
710	 return balanceAfter - balanceBefore;
711	 }
712	 }
713	 function doTransferOut( address underlying, address payable to, uint256 amount ) internal {
714	 if (underlying == Constants.ETH_ADDRESS) {
715	 (bool success, ) = to.call{
716	 value: amount}
717	 (new bytes(0));
718	 require(success, "STE");
719	 }
720	 else {
721	 (bool success, bytes memory data) = underlying.call( abi.encodeWithSelector( ERC20Interface.transfer.selector, to, amount ) );
722	 require( success && (data.length == 0 || abi.decode(data, (bool))), "ST" );
723	 }
724	 }
725	 function getCashPrior(address underlying_) internal view returns (uint256) {
726	 if (underlying_ == Constants.ETH_ADDRESS) {
727	 uint256 startingBalance = sub(address(this).balance, msg.value);
728	 return startingBalance;
729	 }
730	 else {
731	 ERC20Interface token = ERC20Interface(underlying_);
732	 return token.balanceOf(address(this));
733	 }
734	 }
735	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
736	 require(b <= a, "SafeMath: subtraction overflow");
737	 return a - b;
738	 }
739	 }
740	 pragma solidity 0.7.6;
741	 interface ERC721Interface {
742	 function transferFrom( address from, address to, uint256 tokenId ) external;
743	 }
744	 interface VNFTInterface {
745	 function transferFrom( address from, address to, uint256 tokenId, uint256 units ) external returns (uint256 newTokenId);
746	 function safeTransferFrom( address from, address to, uint256 tokenId, uint256 units, bytes calldata data ) external returns (uint256 newTokenId);
747	 function transferFrom( address from, address to, uint256 tokenId, uint256 targetTokenId, uint256 units ) external;
748	 function safeTransferFrom( address from, address to, uint256 tokenId, uint256 targetTokenId, uint256 units, bytes calldata data ) external;
749	 }
750	 library VNFTTransferHelper {
751	 function doTransferIn( address underlying, address from, uint256 tokenId ) internal {
752	 ERC721Interface token = ERC721Interface(underlying);
753	 token.transferFrom(from, address(this), tokenId);
754	 }
755	 function doTransferOut( address underlying, address to, uint256 tokenId ) internal {
756	 ERC721Interface token = ERC721Interface(underlying);
757	 token.transferFrom(address(this), to, tokenId);
758	 }
759	 function doTransferIn( address underlying, address from, uint256 tokenId, uint256 units ) internal {
760	 VNFTInterface token = VNFTInterface(underlying);
761	 token.safeTransferFrom(from, address(this), tokenId, units, "");
762	 }
763	 function doTransferOut( address underlying, address to, uint256 tokenId, uint256 units ) internal returns (uint256 newTokenId) {
764	 VNFTInterface token = VNFTInterface(underlying);
765	 newTokenId = token.safeTransferFrom( address(this), to, tokenId, units, "" );
766	 }
767	 function doTransferOut( address underlying, address to, uint256 tokenId, uint256 targetTokenId, uint256 units ) internal {
768	 VNFTInterface token = VNFTInterface(underlying);
769	 token.safeTransferFrom( address(this), to, tokenId, targetTokenId, units, "" );
770	 }
771	 }
772	 pragma solidity >=0.6.0 <0.9.0;
773	 library BokkyPooBahsDateTimeLibrary {
774	 uint constant SECONDS_PER_DAY = 24 * 60 * 60;
775	 uint constant SECONDS_PER_HOUR = 60 * 60;
776	 uint constant SECONDS_PER_MINUTE = 60;
777	 int constant OFFSET19700101 = 2440588;
778	 uint constant DOW_MON = 1;
779	 uint constant DOW_TUE = 2;
780	 uint constant DOW_WED = 3;
781	 uint constant DOW_THU = 4;
782	 uint constant DOW_FRI = 5;
783	 uint constant DOW_SAT = 6;
784	 uint constant DOW_SUN = 7;
785	 function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {
786	 require(year >= 1970);
787	 int _year = int(year);
788	 int _month = int(month);
789	 int _day = int(day);
790	 int __days = _day - 32075 + 1461 * (_year + 4800 + (_month - 14) / 12) / 4 + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12 - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4 - OFFSET19700101;
791	 _days = uint(__days);
792	 }
793	 function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {
794	 int __days = int(_days);
795	 int L = __days + 68569 + OFFSET19700101;
796	 int N = 4 * L / 146097;
797	 L = L - (146097 * N + 3) / 4;
798	 int _year = 4000 * (L + 1) / 1461001;
799	 L = L - 1461 * _year / 4 + 31;
800	 int _month = 80 * L / 2447;
801	 int _day = L - 2447 * _month / 80;
802	 L = _month / 11;
803	 _month = _month + 2 - 12 * L;
804	 _year = 100 * (N - 49) + _year + L;
805	 year = uint(_year);
806	 month = uint(_month);
807	 day = uint(_day);
808	 }
809	 function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {
810	 timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;
811	 }
812	 function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {
813	 timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;
814	 }
815	 function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {
816	 (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);
817	 }
818	 function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {
819	 (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);
820	 uint secs = timestamp % SECONDS_PER_DAY;
821	 hour = secs / SECONDS_PER_HOUR;
822	 secs = secs % SECONDS_PER_HOUR;
823	 minute = secs / SECONDS_PER_MINUTE;
824	 second = secs % SECONDS_PER_MINUTE;
825	 }
826	 function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {
827	 if (year >= 1970 && month > 0 && month <= 12) {
828	 uint daysInMonth = _getDaysInMonth(year, month);
829	 if (day > 0 && day <= daysInMonth) {
830	 valid = true;
831	 }
832	 }
833	 }
834	 function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {
835	 if (isValidDate(year, month, day)) {
836	 if (hour < 24 && minute < 60 && second < 60) {
837	 valid = true;
838	 }
839	 }
840	 }
841	 function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {
842	 (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);
843	 leapYear = _isLeapYear(year);
844	 }
845	 function _isLeapYear(uint year) internal pure returns (bool leapYear) {
846	 leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);
847	 }
848	 function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {
849	 weekDay = getDayOfWeek(timestamp) <= DOW_FRI;
850	 }
851	 function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {
852	 weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;
853	 }
854	 function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {
855	 (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);
856	 daysInMonth = _getDaysInMonth(year, month);
857	 }
858	 function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {
859	 if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {
860	 daysInMonth = 31;
861	 }
862	 else if (month != 2) {
863	 daysInMonth = 30;
864	 }
865	 else {
866	 daysInMonth = _isLeapYear(year) ? 29 : 28;
867	 }
868	 }
869	 function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {
870	 uint _days = timestamp / SECONDS_PER_DAY;
871	 dayOfWeek = (_days + 3) % 7 + 1;
872	 }
873	 function getYear(uint timestamp) internal pure returns (uint year) {
874	 (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);
875	 }
876	 function getMonth(uint timestamp) internal pure returns (uint month) {
877	 (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);
878	 }
879	 function getDay(uint timestamp) internal pure returns (uint day) {
880	 (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);
881	 }
882	 function getHour(uint timestamp) internal pure returns (uint hour) {
883	 uint secs = timestamp % SECONDS_PER_DAY;
884	 hour = secs / SECONDS_PER_HOUR;
885	 }
886	 function getMinute(uint timestamp) internal pure returns (uint minute) {
887	 uint secs = timestamp % SECONDS_PER_HOUR;
888	 minute = secs / SECONDS_PER_MINUTE;
889	 }
890	 function getSecond(uint timestamp) internal pure returns (uint second) {
891	 second = timestamp % SECONDS_PER_MINUTE;
892	 }
893	 function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {
894	 (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);
895	 year += _years;
896	 uint daysInMonth = _getDaysInMonth(year, month);
897	 if (day > daysInMonth) {
898	 day = daysInMonth;
899	 }
900	 newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;
901	 require(newTimestamp >= timestamp);
902	 }
903	 function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {
904	 (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);
905	 month += _months;
906	 year += (month - 1) / 12;
907	 month = (month - 1) % 12 + 1;
908	 uint daysInMonth = _getDaysInMonth(year, month);
909	 if (day > daysInMonth) {
910	 day = daysInMonth;
911	 }
912	 newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;
913	 require(newTimestamp >= timestamp);
914	 }
915	 function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {
916	 newTimestamp = timestamp + _days * SECONDS_PER_DAY;
917	 require(newTimestamp >= timestamp);
918	 }
919	 function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {
920	 newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;
921	 require(newTimestamp >= timestamp);
922	 }
923	 function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {
924	 newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;
925	 require(newTimestamp >= timestamp);
926	 }
927	 function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {
928	 newTimestamp = timestamp + _seconds;
929	 require(newTimestamp >= timestamp);
930	 }
931	 function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {
932	 (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);
933	 year -= _years;
934	 uint daysInMonth = _getDaysInMonth(year, month);
935	 if (day > daysInMonth) {
936	 day = daysInMonth;
937	 }
938	 newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;
939	 require(newTimestamp <= timestamp);
940	 }
941	 function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {
942	 (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);
943	 uint yearMonth = year * 12 + (month - 1) - _months;
944	 year = yearMonth / 12;
945	 month = yearMonth % 12 + 1;
946	 uint daysInMonth = _getDaysInMonth(year, month);
947	 if (day > daysInMonth) {
948	 day = daysInMonth;
949	 }
950	 newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;
951	 require(newTimestamp <= timestamp);
952	 }
953	 function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {
954	 newTimestamp = timestamp - _days * SECONDS_PER_DAY;
955	 require(newTimestamp <= timestamp);
956	 }
957	 function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {
958	 newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;
959	 require(newTimestamp <= timestamp);
960	 }
961	 function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {
962	 newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;
963	 require(newTimestamp <= timestamp);
964	 }
965	 function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {
966	 newTimestamp = timestamp - _seconds;
967	 require(newTimestamp <= timestamp);
968	 }
969	 function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {
970	 require(fromTimestamp <= toTimestamp);
971	 (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);
972	 (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);
973	 _years = toYear - fromYear;
974	 }
975	 function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {
976	 require(fromTimestamp <= toTimestamp);
977	 (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);
978	 (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);
979	 _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;
980	 }
981	 function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {
982	 require(fromTimestamp <= toTimestamp);
983	 _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;
984	 }
985	 function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {
986	 require(fromTimestamp <= toTimestamp);
987	 _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;
988	 }
989	 function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {
990	 require(fromTimestamp <= toTimestamp);
991	 _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;
992	 }
993	 function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {
994	 require(fromTimestamp <= toTimestamp);
995	 _seconds = toTimestamp - fromTimestamp;
996	 }
997	 }
998	 pragma solidity 0.7.6;
999	 library Constants {
1000	 enum ClaimType {
1001	 LINEAR, ONE_TIME, STAGED }
1002	 enum VoucherType {
1003	 STANDARD_VESTING, FLEXIBLE_DATE_VESTING, BOUNDING }
1004	 uint32 internal constant FULL_PERCENTAGE = 10000;
1005	 address internal constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
1006	 }
1007	 pragma solidity 0.7.6;
1008	 library StringConvertor {
1009	 using Strings for uint256;
1010	 using SafeMath for uint256;
1011	 function toString(uint256 value) internal pure returns (string memory) {
1012	 if (value == 0) {
1013	 return "0";
1014	 }
1015	 uint256 temp = value;
1016	 uint256 digits;
1017	 while (temp != 0) {
1018	 digits++;
1019	 temp /= 10;
1020	 }
1021	 bytes memory buffer = new bytes(digits);
1022	 uint256 index = digits - 1;
1023	 temp = value;
1024	 while (temp != 0) {
1025	 buffer[index--] = bytes1(uint8(48 + temp % 10));
1026	 temp /= 10;
1027	 }
1028	 return string(buffer);
1029	 }
1030	 function uint2decimal(uint256 self, uint8 decimals) internal pure returns (bytes memory) {
1031	 uint256 base = 10 ** decimals;
1032	 string memory round = self.div(base).toString();
1033	 string memory fraction = self.mod(base).toString();
1034	 uint256 fractionLength = bytes(fraction).length;
1035	 bytes memory fullStr = abi.encodePacked(round, '.');
1036	 if (fractionLength < decimals) {
1037	 for (uint8 i = 0; i < decimals - fractionLength; i++) {
1038	 fullStr = abi.encodePacked(fullStr, '0');
1039	 }
1040	 }
1041	 return abi.encodePacked(fullStr, fraction);
1042	 }
1043	 function trim(bytes memory self, uint256 cutLength) internal pure returns (bytes memory newString) {
1044	 newString = new bytes(self.length - cutLength);
1045	 uint256 index = newString.length;
1046	 while (index-- > 0) {
1047	 newString[index] = self[index];
1048	 }
1049	 }
1050	 function addThousandsSeparator(bytes memory self) internal pure returns (bytes memory newString) {
1051	 if (self.length <= 6) {
1052	 return self;
1053	 }
1054	 newString = new bytes(self.length + (self.length - 4) / 3);
1055	 uint256 oriIndex = self.length - 1;
1056	 uint256 newIndex = newString.length - 1;
1057	 for (uint256 i = 0; i < self.length; i++) {
1058	 if (i >= 6 && i % 3 == 0) {
1059	 newString[newIndex--] = ',';
1060	 }
1061	 newString[newIndex--] = self[oriIndex--];
1062	 }
1063	 }
1064	 function addressToString(address self) internal pure returns (string memory) {
1065	 bytes32 value = bytes32(uint256(self));
1066	 bytes memory alphabet = "0123456789abcdef";
1067	 bytes memory str = new bytes(42);
1068	 str[0] = '0';
1069	 str[1] = 'x';
1070	 for (uint i = 0; i < 20; i++) {
1071	 str[2+i*2] = alphabet[uint8(value[i + 12] >> 4)];
1072	 str[3+i*2] = alphabet[uint8(value[i + 12] & 0x0f)];
1073	 }
1074	 return string(str);
1075	 }
1076	 function datetimeToString(uint256 timestamp) internal pure returns (string memory) {
1077	 (uint256 year, uint256 month, uint256 day, uint256 hour, uint256 minute, uint256 second) = BokkyPooBahsDateTimeLibrary.timestampToDateTime(timestamp);
1078	 return string( abi.encodePacked( year.toString(), '/', month < 10 ? '0' : '', month.toString(), '/', day < 10 ? '0' : '', day.toString(), ' ', hour < 10 ? '0' : '', hour.toString(), ':', minute < 10 ? '0' : '', minute.toString(), ':', second < 10 ? '0' : '', second.toString() ) );
1079	 }
1080	 function dateToString(uint256 timestamp) internal pure returns (string memory) {
1081	 (uint256 year, uint256 month, uint256 day) = BokkyPooBahsDateTimeLibrary.timestampToDate(timestamp);
1082	 return string( abi.encodePacked( year.toString(), '/', month < 10 ? '0' : '', month.toString(), '/', day < 10 ? '0' : '', day.toString() ) );
1083	 }
1084	 function uintArray2str(uint64[] memory array) internal pure returns (string memory) {
1085	 bytes memory pack = abi.encodePacked('[');
1086	 for (uint256 i = 0; i < array.length; i++) {
1087	 if (i == array.length - 1) {
1088	 pack = abi.encodePacked(pack, uint256(array[i]).toString());
1089	 }
1090	 else {
1091	 pack = abi.encodePacked(pack, uint256(array[i]).toString(), ',');
1092	 }
1093	 }
1094	 return string(abi.encodePacked(pack, ']'));
1095	 }
1096	 function percentArray2str(uint32[] memory array) internal pure returns (string memory) {
1097	 bytes memory pack = abi.encodePacked('[');
1098	 for (uint256 i = 0; i < array.length; i++) {
1099	 bytes memory percent = abi.encodePacked('"', uint2decimal(array[i], 2), '%"');
1100	 if (i == array.length - 1) {
1101	 pack = abi.encodePacked(pack, percent);
1102	 }
1103	 else {
1104	 pack = abi.encodePacked(pack, percent, ',');
1105	 }
1106	 }
1107	 return string(abi.encodePacked(pack, ']'));
1108	 }
1109	 }
1110	 pragma solidity >=0.6.0 <0.8.0;
1111	 library SafeMathUpgradeable {
1112	 function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
1113	 uint256 c = a + b;
1114	 if (c < a) return (false, 0);
1115	 return (true, c);
1116	 }
1117	 function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
1118	 if (b > a) return (false, 0);
1119	 return (true, a - b);
1120	 }
1121	 function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
1122	 if (a == 0) return (true, 0);
1123	 uint256 c = a * b;
1124	 if (c / a != b) return (false, 0);
1125	 return (true, c);
1126	 }
1127	 function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
1128	 if (b == 0) return (false, 0);
1129	 return (true, a / b);
1130	 }
1131	 function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
1132	 if (b == 0) return (false, 0);
1133	 return (true, a % b);
1134	 }
1135	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
1136	 uint256 c = a + b;
1137	 require(c >= a, "SafeMath: addition overflow");
1138	 return c;
1139	 }
1140	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
1141	 require(b <= a, "SafeMath: subtraction overflow");
1142	 return a - b;
1143	 }
1144	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
1145	 if (a == 0) return 0;
1146	 uint256 c = a * b;
1147	 require(c / a == b, "SafeMath: multiplication overflow");
1148	 return c;
1149	 }
1150	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
1151	 require(b > 0, "SafeMath: division by zero");
1152	 return a / b;
1153	 }
1154	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
1155	 require(b > 0, "SafeMath: modulo by zero");
1156	 return a % b;
1157	 }
1158	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
1159	 require(b <= a, errorMessage);
1160	 return a - b;
1161	 }
1162	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
1163	 require(b > 0, errorMessage);
1164	 return a / b;
1165	 }
1166	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
1167	 require(b > 0, errorMessage);
1168	 return a % b;
1169	 }
1170	 }
1171	 pragma solidity >=0.6.0 <0.8.0;
1172	 contract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable {
1173	 using SafeMathUpgradeable for uint256;
1174	 mapping (address => uint256) private _balances;
1175	 mapping (address => mapping (address => uint256)) private _allowances;
1176	 uint256 private _totalSupply;
1177	 string private _name;
1178	 string private _symbol;
1179	 uint8 private _decimals;
1180	 function __ERC20_init(string memory name_, string memory symbol_) internal initializer {
1181	 __Context_init_unchained();
1182	 __ERC20_init_unchained(name_, symbol_);
1183	 }
1184	 function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {
1185	 _name = name_;
1186	 _symbol = symbol_;
1187	 _decimals = 18;
1188	 }
1189	 function name() public view virtual returns (string memory) {
1190	 return _name;
1191	 }
1192	 function symbol() public view virtual returns (string memory) {
1193	 return _symbol;
1194	 }
1195	 function decimals() public view virtual returns (uint8) {
1196	 return _decimals;
1197	 }
1198	 function totalSupply() public view virtual override returns (uint256) {
1199	 return _totalSupply;
1200	 }
1201	 function balanceOf(address account) public view virtual override returns (uint256) {
1202	 return _balances[account];
1203	 }
1204	 function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
1205	 _transfer(_msgSender(), recipient, amount);
1206	 return true;
1207	 }
1208	 function allowance(address owner, address spender) public view virtual override returns (uint256) {
1209	 return _allowances[owner][spender];
1210	 }
1211	 function approve(address spender, uint256 amount) public virtual override returns (bool) {
1212	 _approve(_msgSender(), spender, amount);
1213	 return true;
1214	 }
1215	 function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
1216	 _transfer(sender, recipient, amount);
1217	 _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
1218	 return true;
1219	 }
1220	 function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
1221	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
1222	 return true;
1223	 }
1224	 function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
1225	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
1226	 return true;
1227	 }
1228	 function _transfer(address sender, address recipient, uint256 amount) internal virtual {
1229	 require(sender != address(0), "ERC20: transfer from the zero address");
1230	 require(recipient != address(0), "ERC20: transfer to the zero address");
1231	 _beforeTokenTransfer(sender, recipient, amount);
1232	 _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
1233	 _balances[recipient] = _balances[recipient].add(amount);
1234	 emit Transfer(sender, recipient, amount);
1235	 }
1236	 function _mint(address account, uint256 amount) internal virtual {
1237	 require(account != address(0), "ERC20: mint to the zero address");
1238	 _beforeTokenTransfer(address(0), account, amount);
1239	 _totalSupply = _totalSupply.add(amount);
1240	 _balances[account] = _balances[account].add(amount);
1241	 emit Transfer(address(0), account, amount);
1242	 }
1243	 function _burn(address account, uint256 amount) internal virtual {
1244	 require(account != address(0), "ERC20: burn from the zero address");
1245	 _beforeTokenTransfer(account, address(0), amount);
1246	 _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
1247	 _totalSupply = _totalSupply.sub(amount);
1248	 emit Transfer(account, address(0), amount);
1249	 }
1250	 function _approve(address owner, address spender, uint256 amount) internal virtual {
1251	 require(owner != address(0), "ERC20: approve from the zero address");
1252	 require(spender != address(0), "ERC20: approve to the zero address");
1253	 _allowances[owner][spender] = amount;
1254	 emit Approval(owner, spender, amount);
1255	 }
1256	 function _setupDecimals(uint8 decimals_) internal virtual {
1257	 _decimals = decimals_;
1258	 }
1259	 function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {
1260	 }
1261	 uint256[44] private __gap;
1262	 }
1263	 pragma solidity >=0.6.0 <0.8.0;
1264	 interface IERC20 {
1265	 function totalSupply() external view returns (uint256);
1266	 function balanceOf(address account) external view returns (uint256);
1267	 function transfer(address recipient, uint256 amount) external returns (bool);
1268	 function allowance(address owner, address spender) external view returns (uint256);
1269	 function approve(address spender, uint256 amount) external returns (bool);
1270	 function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
1271	 event Transfer(address indexed from, address indexed to, uint256 value);
1272	 event Approval(address indexed owner, address indexed spender, uint256 value);
1273	 }
1274	 pragma solidity >=0.6.0 <0.8.0;
1275	 interface IERC721ReceiverUpgradeable {
1276	 function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);
1277	 }
1278	 pragma solidity >=0.6.2 <0.8.0;
1279	 library AddressUpgradeable {
1280	 function isContract(address account) internal view returns (bool) {
1281	 uint256 size;
1282	 assembly {
1283	 size := extcodesize(account) }
1284	 return size > 0;
1285	 }
1286	 function sendValue(address payable recipient, uint256 amount) internal {
1287	 require(address(this).balance >= amount, "Address: insufficient balance");
1288	 (bool success, ) = recipient.call{
1289	 value: amount }
1290	 ("");
1291	 require(success, "Address: unable to send value, recipient may have reverted");
1292	 }
1293	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
1294	 return functionCall(target, data, "Address: low-level call failed");
1295	 }
1296	 function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
1297	 return functionCallWithValue(target, data, 0, errorMessage);
1298	 }
1299	 function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
1300	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
1301	 }
1302	 function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
1303	 require(address(this).balance >= value, "Address: insufficient balance for call");
1304	 require(isContract(target), "Address: call to non-contract");
1305	 (bool success, bytes memory returndata) = target.call{
1306	 value: value }
1307	 (data);
1308	 return _verifyCallResult(success, returndata, errorMessage);
1309	 }
1310	 function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
1311	 return functionStaticCall(target, data, "Address: low-level static call failed");
1312	 }
1313	 function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
1314	 require(isContract(target), "Address: static call to non-contract");
1315	 (bool success, bytes memory returndata) = target.staticcall(data);
1316	 return _verifyCallResult(success, returndata, errorMessage);
1317	 }
1318	 function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
1319	 if (success) {
1320	 return returndata;
1321	 }
1322	 else {
1323	 if (returndata.length > 0) {
1324	 assembly {
1325	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
1326	 }
1327	 else {
1328	 revert(errorMessage);
1329	 }
1330	 }
1331	 }
1332	 }
1333	 pragma solidity >=0.6.0 <0.8.0;
1334	 library EnumerableMapUpgradeable {
1335	 struct MapEntry {
1336	 bytes32 _key;
1337	 bytes32 _value;
1338	 }
1339	 struct Map {
1340	 MapEntry[] _entries;
1341	 mapping (bytes32 => uint256) _indexes;
1342	 }
1343	 function _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {
1344	 uint256 keyIndex = map._indexes[key];
1345	 if (keyIndex == 0) {
1346	 map._entries.push(MapEntry({
1347	 _key: key, _value: value }
1348	 ));
1349	 map._indexes[key] = map._entries.length;
1350	 return true;
1351	 }
1352	 else {
1353	 map._entries[keyIndex - 1]._value = value;
1354	 return false;
1355	 }
1356	 }
1357	 function _remove(Map storage map, bytes32 key) private returns (bool) {
1358	 uint256 keyIndex = map._indexes[key];
1359	 if (keyIndex != 0) {
1360	 uint256 toDeleteIndex = keyIndex - 1;
1361	 uint256 lastIndex = map._entries.length - 1;
1362	 MapEntry storage lastEntry = map._entries[lastIndex];
1363	 map._entries[toDeleteIndex] = lastEntry;
1364	 map._indexes[lastEntry._key] = toDeleteIndex + 1;
1365	 map._entries.pop();
1366	 delete map._indexes[key];
1367	 return true;
1368	 }
1369	 else {
1370	 return false;
1371	 }
1372	 }
1373	 function _contains(Map storage map, bytes32 key) private view returns (bool) {
1374	 return map._indexes[key] != 0;
1375	 }
1376	 function _length(Map storage map) private view returns (uint256) {
1377	 return map._entries.length;
1378	 }
1379	 function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {
1380	 require(map._entries.length > index, "EnumerableMap: index out of bounds");
1381	 MapEntry storage entry = map._entries[index];
1382	 return (entry._key, entry._value);
1383	 }
1384	 function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {
1385	 uint256 keyIndex = map._indexes[key];
1386	 if (keyIndex == 0) return (false, 0);
1387	 return (true, map._entries[keyIndex - 1]._value);
1388	 }
1389	 function _get(Map storage map, bytes32 key) private view returns (bytes32) {
1390	 uint256 keyIndex = map._indexes[key];
1391	 require(keyIndex != 0, "EnumerableMap: nonexistent key");
1392	 return map._entries[keyIndex - 1]._value;
1393	 }
1394	 function _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {
1395	 uint256 keyIndex = map._indexes[key];
1396	 require(keyIndex != 0, errorMessage);
1397	 return map._entries[keyIndex - 1]._value;
1398	 }
1399	 struct UintToAddressMap {
1400	 Map _inner;
1401	 }
1402	 function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {
1403	 return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));
1404	 }
1405	 function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {
1406	 return _remove(map._inner, bytes32(key));
1407	 }
1408	 function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {
1409	 return _contains(map._inner, bytes32(key));
1410	 }
1411	 function length(UintToAddressMap storage map) internal view returns (uint256) {
1412	 return _length(map._inner);
1413	 }
1414	 function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {
1415	 (bytes32 key, bytes32 value) = _at(map._inner, index);
1416	 return (uint256(key), address(uint160(uint256(value))));
1417	 }
1418	 function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {
1419	 (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));
1420	 return (success, address(uint160(uint256(value))));
1421	 }
1422	 function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {
1423	 return address(uint160(uint256(_get(map._inner, bytes32(key)))));
1424	 }
1425	 function get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {
1426	 return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));
1427	 }
1428	 }
1429	 pragma solidity >=0.6.0 <0.8.0;
1430	 library EnumerableSetUpgradeable {
1431	 struct Set {
1432	 bytes32[] _values;
1433	 mapping (bytes32 => uint256) _indexes;
1434	 }
1435	 function _add(Set storage set, bytes32 value) private returns (bool) {
1436	 if (!_contains(set, value)) {
1437	 set._values.push(value);
1438	 set._indexes[value] = set._values.length;
1439	 return true;
1440	 }
1441	 else {
1442	 return false;
1443	 }
1444	 }
1445	 function _remove(Set storage set, bytes32 value) private returns (bool) {
1446	 uint256 valueIndex = set._indexes[value];
1447	 if (valueIndex != 0) {
1448	 uint256 toDeleteIndex = valueIndex - 1;
1449	 uint256 lastIndex = set._values.length - 1;
1450	 bytes32 lastvalue = set._values[lastIndex];
1451	 set._values[toDeleteIndex] = lastvalue;
1452	 set._indexes[lastvalue] = toDeleteIndex + 1;
1453	 set._values.pop();
1454	 delete set._indexes[value];
1455	 return true;
1456	 }
1457	 else {
1458	 return false;
1459	 }
1460	 }
1461	 function _contains(Set storage set, bytes32 value) private view returns (bool) {
1462	 return set._indexes[value] != 0;
1463	 }
1464	 function _length(Set storage set) private view returns (uint256) {
1465	 return set._values.length;
1466	 }
1467	 function _at(Set storage set, uint256 index) private view returns (bytes32) {
1468	 require(set._values.length > index, "EnumerableSet: index out of bounds");
1469	 return set._values[index];
1470	 }
1471	 struct Bytes32Set {
1472	 Set _inner;
1473	 }
1474	 function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {
1475	 return _add(set._inner, value);
1476	 }
1477	 function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {
1478	 return _remove(set._inner, value);
1479	 }
1480	 function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {
1481	 return _contains(set._inner, value);
1482	 }
1483	 function length(Bytes32Set storage set) internal view returns (uint256) {
1484	 return _length(set._inner);
1485	 }
1486	 function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {
1487	 return _at(set._inner, index);
1488	 }
1489	 struct AddressSet {
1490	 Set _inner;
1491	 }
1492	 function add(AddressSet storage set, address value) internal returns (bool) {
1493	 return _add(set._inner, bytes32(uint256(uint160(value))));
1494	 }
1495	 function remove(AddressSet storage set, address value) internal returns (bool) {
1496	 return _remove(set._inner, bytes32(uint256(uint160(value))));
1497	 }
1498	 function contains(AddressSet storage set, address value) internal view returns (bool) {
1499	 return _contains(set._inner, bytes32(uint256(uint160(value))));
1500	 }
1501	 function length(AddressSet storage set) internal view returns (uint256) {
1502	 return _length(set._inner);
1503	 }
1504	 function at(AddressSet storage set, uint256 index) internal view returns (address) {
1505	 return address(uint160(uint256(_at(set._inner, index))));
1506	 }
1507	 struct UintSet {
1508	 Set _inner;
1509	 }
1510	 function add(UintSet storage set, uint256 value) internal returns (bool) {
1511	 return _add(set._inner, bytes32(value));
1512	 }
1513	 function remove(UintSet storage set, uint256 value) internal returns (bool) {
1514	 return _remove(set._inner, bytes32(value));
1515	 }
1516	 function contains(UintSet storage set, uint256 value) internal view returns (bool) {
1517	 return _contains(set._inner, bytes32(value));
1518	 }
1519	 function length(UintSet storage set) internal view returns (uint256) {
1520	 return _length(set._inner);
1521	 }
1522	 function at(UintSet storage set, uint256 index) internal view returns (uint256) {
1523	 return uint256(_at(set._inner, index));
1524	 }
1525	 }
1526	 pragma solidity >=0.6.0 <0.8.0;
1527	 library StringsUpgradeable {
1528	 function toString(uint256 value) internal pure returns (string memory) {
1529	 if (value == 0) {
1530	 return "0";
1531	 }
1532	 uint256 temp = value;
1533	 uint256 digits;
1534	 while (temp != 0) {
1535	 digits++;
1536	 temp /= 10;
1537	 }
1538	 bytes memory buffer = new bytes(digits);
1539	 uint256 index = digits - 1;
1540	 temp = value;
1541	 while (temp != 0) {
1542	 buffer[index--] = bytes1(uint8(48 + temp % 10));
1543	 temp /= 10;
1544	 }
1545	 return string(buffer);
1546	 }
1547	 }
1548	 pragma solidity 0.7.6;
1549	 interface ISolver {
1550	 event SetOperationPaused ( address product, string operation, bool setPaused );
1551	 function isSolver() external pure returns (bool);
1552	 function setOperationPaused(address product_, string calldata operation_, bool setPaused_) external;
1553	 function operationAllowed(string calldata operation_, bytes calldata data_) external returns (uint256);
1554	 function operationVerify(string calldata operation_, bytes calldata data_) external returns (uint256);
1555	 }
1556	 interface IVNFTReceiver {
1557	 function onVNFTReceived( address operator, address from, uint256 tokenId, uint256 units, bytes calldata data ) external returns (bytes4);
1558	 }
1559	 pragma solidity 0.7.6;
1560	 interface IUnderlyingContainer {
1561	 function totalUnderlyingAmount() external view returns (uint256);
1562	 function underlying() external view returns (address);
1563	 }
1564	 pragma solidity 0.7.6;
1565	 contract ConvertiblePool is IConvertiblePool, AdminControl, ReentrancyGuardUpgradeable {
1566	 using SafeMathUpgradeable for uint256;
1567	 using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;
1568	 mapping(uint256 => SlotDetail) internal _slotDetails;
1569	 mapping(address => EnumerableSetUpgradeable.UintSet) internal _issuerSlots;
1570	 mapping(address => bool) public fundCurrencies;
1571	 mapping(uint256 => mapping(address => uint256)) public slotBalances;
1572	 IPriceOracleManager public oracle;
1573	 address public underlyingVestingVoucher;
1574	 address public underlyingToken;
1575	 uint8 public priceDecimals;
1576	 uint8 public valueDecimals;
1577	 address public voucher;
1578	 modifier onlyVoucher() {
1579	 require(_msgSender() == voucher, "only voucher");
1580	 _;
1581	 }
1582	 function initialize( address underlyingToken_, address oracle_, uint8 priceDecimals_, uint8 valueDecimals_ ) external initializer {
1583	 AdminControl.__AdminControl_init(_msgSender());
1584	 oracle = IPriceOracleManager(oracle_);
1585	 underlyingToken = underlyingToken_;
1586	 priceDecimals = priceDecimals_;
1587	 valueDecimals = valueDecimals_;
1588	 }
1589	 function createSlot( address issuer_, address fundCurrency_, uint128 lowestPrice_, uint128 highestPrice_, uint64 effectiveTime_, uint64 maturity_, uint8 collateralType_ ) external onlyVoucher returns (uint256 slot) {
1590	 validateSlotParams( issuer_, fundCurrency_, lowestPrice_, highestPrice_, effectiveTime_, maturity_, collateralType_ );
1591	 slot = getSlot( issuer_, fundCurrency_, lowestPrice_, highestPrice_, effectiveTime_, maturity_, collateralType_ );
1592	 require(!_slotDetails[slot].isValid, "slot already existed");
1593	 SlotDetail storage slotDetail = _slotDetails[slot];
1594	 slotDetail.issuer = issuer_;
1595	 slotDetail.fundCurrency = fundCurrency_;
1596	 slotDetail.lowestPrice = lowestPrice_;
1597	 slotDetail.highestPrice = highestPrice_;
1598	 slotDetail.effectiveTime = effectiveTime_;
1599	 slotDetail.maturity = maturity_;
1600	 slotDetail.collateralType = CollateralType(collateralType_);
1601	 slotDetail.isValid = true;
1602	 _issuerSlots[issuer_].add(slot);
1603	 emit CreateSlot( slot, issuer_, fundCurrency_, lowestPrice_, highestPrice_, effectiveTime_, maturity_, CollateralType(collateralType_) );
1604	 }
1605	 function validateSlotParams( address issuer_, address fundCurrency_, uint128 lowestPrice_, uint128 highestPrice_, uint64 effectiveTime_, uint64 maturity_, uint8 collateralType_ ) public view {
1606	 require(issuer_ != address(0), "issuer cannot be 0 address");
1607	 require(fundCurrencies[fundCurrency_], "unsupported fund currency");
1608	 require(collateralType_ < 2, "invalid collateral type");
1609	 require( lowestPrice_ > 0 && lowestPrice_ < highestPrice_, "invalid price bounds" );
1610	 require( effectiveTime_ > 0 && effectiveTime_ < maturity_, "invalid time setting" );
1611	 }
1612	 function mintWithUnderlyingToken( address minter_, uint256 slot_, uint256 tokenInAmount_ ) external override nonReentrant onlyVoucher returns (uint256 totalValue) {
1613	 require(minter_ != address(0), "minter cannot be 0 address");
1614	 require(tokenInAmount_ != 0, "tokenInAmount cannot be 0");
1615	 SlotDetail storage slotDetail = _slotDetails[slot_];
1616	 require(slotDetail.isValid, "invalid slot");
1617	 require( !slotDetail.isIssuerRefunded && block.timestamp < slotDetail.maturity, "non-mintable slot" );
1618	 totalValue = tokenInAmount_.mul(slotDetail.lowestPrice);
1619	 slotDetail.totalValue = slotDetail.totalValue.add(totalValue);
1620	 slotBalances[slot_][underlyingToken] = slotBalances[slot_][ underlyingToken ].add(tokenInAmount_);
1621	 ERC20TransferHelper.doTransferIn( underlyingToken, minter_, tokenInAmount_ );
1622	 emit Mint(minter_, slot_, totalValue);
1623	 }
1624	 function refund(uint256 slot_) external override nonReentrant {
1625	 require(_issuerSlots[_msgSender()].contains(slot_), "only issuer");
1626	 SlotDetail storage slotDetail = _slotDetails[slot_];
1627	 require(slotDetail.isValid, "invalid slot");
1628	 require(!slotDetail.isIssuerRefunded, "already refunded");
1629	 require(slotDetail.settlePrice == 0, "already settled");
1630	 slotDetail.isIssuerRefunded = true;
1631	 uint8 currencyDecimals = ERC20Upgradeable(slotDetail.fundCurrency) .decimals();
1632	 uint256 currencyAmount = slotDetail .totalValue .mul(10**currencyDecimals) .div(10**valueDecimals);
1633	 slotBalances[slot_][slotDetail.fundCurrency] = slotBalances[slot_][ slotDetail.fundCurrency ].add(currencyAmount);
1634	 ERC20TransferHelper.doTransferIn( slotDetail.fundCurrency, _msgSender(), currencyAmount );
1635	 emit Refund(slot_, _msgSender(), currencyAmount);
1636	 }
1637	 function getWithdrawableAmount(uint256 slot_) public view returns (uint256 withdrawCurrencyAmount, uint256 withdrawTokenAmount) {
1638	 SlotDetail storage slotDetail = _slotDetails[slot_];
1639	 if ( block.timestamp >= slotDetail.maturity && !slotDetail.isIssuerWithdrawn ) {
1640	 uint128 settlePrice = slotDetail.settlePrice;
1641	 if (settlePrice == 0) {
1642	 settlePrice = getSettlePrice(slot_);
1643	 if (settlePrice == 0) {
1644	 return (0, 0);
1645	 }
1646	 }
1647	 if (slotDetail.isIssuerRefunded && settlePrice > slotDetail.highestPrice) {
1648	 uint8 currencyDecimals = ERC20Upgradeable( slotDetail.fundCurrency ).decimals();
1649	 uint256 reservedCurrencyAmount = slotBalances[slot_][ slotDetail.fundCurrency ];
1650	 withdrawCurrencyAmount = slotDetail .totalValue .mul(10**currencyDecimals) .div(10**valueDecimals);
1651	 if (withdrawCurrencyAmount > reservedCurrencyAmount) {
1652	 withdrawCurrencyAmount = reservedCurrencyAmount;
1653	 }
1654	 }
1655	 if (slotDetail.isIssuerRefunded && settlePrice <= slotDetail.highestPrice) {
1656	 withdrawTokenAmount = slotDetail.totalValue.div(slotDetail.lowestPrice);
1657	 }
1658	 else if (settlePrice > slotDetail.lowestPrice) {
1659	 if (settlePrice > slotDetail.highestPrice) {
1660	 settlePrice = slotDetail.highestPrice;
1661	 }
1662	 withdrawTokenAmount = slotDetail .totalValue .div(slotDetail.lowestPrice) .sub(slotDetail.totalValue.div(settlePrice));
1663	 }
1664	 uint256 reservedTokenAmount = slotBalances[slot_][underlyingToken];
1665	 if (withdrawTokenAmount > reservedTokenAmount) {
1666	 withdrawTokenAmount = reservedTokenAmount;
1667	 }
1668	 }
1669	 }
1670	 function withdraw(uint256 slot_) external override nonReentrant returns (uint256 withdrawCurrencyAmount, uint256 withdrawTokenAmount) {
1671	 require(_issuerSlots[_msgSender()].contains(slot_), "only issuer");
1672	 SlotDetail storage slotDetail = _slotDetails[slot_];
1673	 require(!slotDetail.isIssuerWithdrawn, "already withdrawn");
1674	 uint128 settlePrice = slotDetail.settlePrice;
1675	 if (settlePrice == 0) {
1676	 settleConvertiblePrice(slot_);
1677	 settlePrice = slotDetail.settlePrice;
1678	 if (settlePrice == 0) {
1679	 revert("price not settled");
1680	 }
1681	 }
1682	 (withdrawCurrencyAmount, withdrawTokenAmount) = getWithdrawableAmount( slot_ );
1683	 slotDetail.isIssuerWithdrawn = true;
1684	 if (withdrawCurrencyAmount > 0) {
1685	 slotBalances[slot_][slotDetail.fundCurrency] = slotBalances[slot_][ slotDetail.fundCurrency ].sub(withdrawCurrencyAmount);
1686	 ERC20TransferHelper.doTransferOut( slotDetail.fundCurrency, _msgSender(), withdrawCurrencyAmount );
1687	 }
1688	 if (withdrawTokenAmount > 0) {
1689	 slotBalances[slot_][underlyingToken] = slotBalances[slot_][ underlyingToken ].sub(withdrawTokenAmount);
1690	 ERC20TransferHelper.doTransferOut( underlyingToken, _msgSender(), withdrawTokenAmount );
1691	 }
1692	 emit Withdraw( slot_, _msgSender(), withdrawCurrencyAmount, withdrawTokenAmount );
1693	 }
1694	 function claim( uint256 slot_, address to_, uint256 claimValue_ ) external override onlyVoucher nonReentrant returns (uint256 claimCurrencyAmount, uint256 claimTokenAmount) {
1695	 SlotDetail storage slotDetail = _slotDetails[slot_];
1696	 require(slotDetail.isValid, "invalid slot");
1697	 uint128 settlePrice = slotDetail.settlePrice;
1698	 if (settlePrice == 0) {
1699	 settleConvertiblePrice(slot_);
1700	 settlePrice = slotDetail.settlePrice;
1701	 if (settlePrice == 0) {
1702	 revert("price not settled");
1703	 }
1704	 }
1705	 if (!slotDetail.isClaimed) {
1706	 slotDetail.isClaimed = true;
1707	 }
1708	 if ( settlePrice <= slotDetail.highestPrice && slotDetail.isIssuerRefunded ) {
1709	 uint256 reservedCurrencyAmount = slotBalances[slot_][ slotDetail.fundCurrency ];
1710	 claimCurrencyAmount = claimValue_ .mul(10 ** ERC20Upgradeable(slotDetail.fundCurrency).decimals()) .div(10 ** valueDecimals);
1711	 if (claimCurrencyAmount > reservedCurrencyAmount) {
1712	 claimCurrencyAmount = reservedCurrencyAmount;
1713	 }
1714	 slotBalances[slot_][ slotDetail.fundCurrency ] = reservedCurrencyAmount.sub(claimCurrencyAmount);
1715	 ERC20TransferHelper.doTransferOut( slotDetail.fundCurrency, payable(to_), claimCurrencyAmount );
1716	 }
1717	 else {
1718	 if (settlePrice < slotDetail.lowestPrice) {
1719	 settlePrice = slotDetail.lowestPrice;
1720	 }
1721	 else if (settlePrice > slotDetail.highestPrice) {
1722	 settlePrice = slotDetail.highestPrice;
1723	 }
1724	 uint256 reservedTokenAmount = slotBalances[slot_][underlyingToken];
1725	 claimTokenAmount = claimValue_.div(settlePrice);
1726	 if (claimTokenAmount > reservedTokenAmount) {
1727	 claimTokenAmount = reservedTokenAmount;
1728	 }
1729	 slotBalances[slot_][underlyingToken] = reservedTokenAmount.sub( claimTokenAmount );
1730	 ERC20TransferHelper.doTransferOut( underlyingToken, payable(to_), claimTokenAmount );
1731	 }
1732	 }
1733	 function settleConvertiblePrice(uint256 slot_) public override {
1734	 SlotDetail storage slotDetail = _slotDetails[slot_];
1735	 uint128 price = getSettlePrice(slot_);
1736	 if (price > 0) {
1737	 slotDetail.settlePrice = price;
1738	 emit SettlePrice(slot_, slotDetail.settlePrice);
1739	 }
1740	 }
1741	 function getSettlePrice(uint256 slot_) public view override returns (uint128) {
1742	 SlotDetail storage slotDetail = _slotDetails[slot_];
1743	 require(block.timestamp >= slotDetail.maturity, "premature");
1744	 int256 iPrice = oracle.getPriceOfMaturity( voucher, slotDetail.maturity );
1745	 if (iPrice < 0) {
1746	 revert("negative price");
1747	 }
1748	 return uint128(iPrice);
1749	 }
1750	 function getSlot( address issuer_, address fundCurrency_, uint128 lowestPrice_, uint128 highestPrice_, uint64 effectiveTime_, uint64 maturity_, uint8 collateralType_ ) public view returns (uint256) {
1751	 return uint256( keccak256( abi.encode( underlyingToken, underlyingVestingVoucher, issuer_, fundCurrency_, lowestPrice_, highestPrice_, effectiveTime_, maturity_, collateralType_ ) ) );
1752	 }
1753	 function getSlotDetail(uint256 slot_) external view returns (SlotDetail memory) {
1754	 return _slotDetails[slot_];
1755	 }
1756	 function getIssuerSlots(address issuer_) external view returns (uint256[] memory slots) {
1757	 slots = new uint256[](_issuerSlots[issuer_].length());
1758	 for (uint256 i = 0; i < slots.length; i++) {
1759	 slots[i] = _issuerSlots[issuer_].at(i);
1760	 }
1761	 }
1762	 function getIssuerSlotDetails(address issuer_) external view returns (SlotDetail[] memory slotDetails) {
1763	 slotDetails = new SlotDetail[](_issuerSlots[issuer_].length());
1764	 for (uint256 i = 0; i < slotDetails.length; i++) {
1765	 slotDetails[i] = _slotDetails[_issuerSlots[issuer_].at(i)];
1766	 }
1767	 }
1768	 function setUnderlyingVestingVoucher(address underlyingVestingVoucher_) external onlyAdmin {
1769	 underlyingVestingVoucher = underlyingVestingVoucher_;
1770	 }
1771	 function setFundCurrency(address fundCurrency_, bool enable_) external onlyAdmin {
1772	 fundCurrencies[fundCurrency_] = enable_;
1773	 emit SetFundCurrency(fundCurrency_, enable_);
1774	 }
1775	 function setVoucher(address newVoucher_) external onlyAdmin {
1776	 require(newVoucher_ != address(0), "new voucher cannot be 0 address");
1777	 emit NewVoucher(voucher, newVoucher_);
1778	 voucher = newVoucher_;
1779	 }
1780	 }
1781	 pragma solidity 0.7.6;
1782	 contract ConvertibleVoucher is IConvertibleVoucher, VoucherCore, ReentrancyGuardUpgradeable {
1783	 using SafeMathUpgradeable for uint256;
1784	 ConvertiblePool public convertiblePool;
1785	 IVNFTDescriptor public voucherDescriptor;
1786	 ISolver public solver;
1787	 function initialize( address convertiblePool_, address voucherDescriptor_, address solver_, uint8 unitDecimals_, string calldata name_, string calldata symbol_ ) external initializer {
1788	 ReentrancyGuardUpgradeable.__ReentrancyGuard_init();
1789	 VoucherCore._initialize(name_, symbol_, unitDecimals_);
1790	 convertiblePool = ConvertiblePool(convertiblePool_);
1791	 voucherDescriptor = IVNFTDescriptor(voucherDescriptor_);
1792	 solver = ISolver(solver_);
1793	 ERC165Upgradeable._registerInterface(type(IConvertibleVoucher).interfaceId);
1794	 }
1795	 function mint( address issuer_, address fundCurrency_, uint128 lowestPrice_, uint128 highestPrice_, uint64 effectiveTime_, uint64 maturity_, uint256 tokenInAmount_ ) external override nonReentrant returns (uint256 slot, uint256 tokenId) {
1796	 uint256 err = solver.operationAllowed( "mint", abi.encode( _msgSender(), issuer_, fundCurrency_, lowestPrice_, highestPrice_, effectiveTime_, maturity_, tokenInAmount_ ) );
1797	 require(err == 0, "Solver: not allowed");
1798	 slot = getSlot( issuer_, fundCurrency_, lowestPrice_, highestPrice_, effectiveTime_, maturity_, 0 );
1799	 if (!getSlotDetail(slot).isValid) {
1800	 convertiblePool.createSlot( issuer_, fundCurrency_, lowestPrice_, highestPrice_, effectiveTime_, maturity_, 0 );
1801	 }
1802	 uint256 units = convertiblePool.mintWithUnderlyingToken(_msgSender(), slot, tokenInAmount_);
1803	 tokenId = VoucherCore._mint(_msgSender(), slot, units);
1804	 solver.operationVerify( "mint", abi.encode(_msgSender(), issuer_, slot, tokenId, units) );
1805	 }
1806	 function claimAll(uint256 tokenId_) external override {
1807	 claim(tokenId_, unitsInToken(tokenId_));
1808	 }
1809	 function claim(uint256 tokenId_, uint256 claimUnits_) public override {
1810	 claimTo(tokenId_, _msgSender(), claimUnits_);
1811	 }
1812	 function claimTo(uint256 tokenId_, address to_, uint256 claimUnits_) public override nonReentrant {
1813	 require(_msgSender() == ownerOf(tokenId_), "only owner");
1814	 require(claimUnits_ <= unitsInToken(tokenId_), "over claim");
1815	 uint256 err = solver.operationAllowed( "claim", abi.encode(_msgSender(), tokenId_, to_, claimUnits_) );
1816	 require(err == 0, "Solver: not allowed");
1817	 (uint256 claimCurrencyAmount, uint256 claimTokenAmount) = convertiblePool.claim(voucherSlotMapping[tokenId_], to_, claimUnits_);
1818	 if (claimUnits_ == unitsInToken(tokenId_)) {
1819	 _burnVoucher(tokenId_);
1820	 }
1821	 else {
1822	 _burnUnits(tokenId_, claimUnits_);
1823	 }
1824	 solver.operationVerify( "claim", abi.encode(_msgSender(), tokenId_, to_, claimUnits_) );
1825	 emit Claim(tokenId_, to_, claimUnits_, claimCurrencyAmount, claimTokenAmount);
1826	 }
1827	 function getSlot( address issuer_, address fundCurrency_, uint128 lowestPrice_, uint128 highestPrice_, uint64 effectiveTime_, uint64 maturity_, uint8 collateralType_ ) public view override returns (uint256) {
1828	 return convertiblePool.getSlot( issuer_, fundCurrency_, lowestPrice_, highestPrice_, effectiveTime_, maturity_, collateralType_ );
1829	 }
1830	 function getSlotDetail(uint256 slot_) public view override returns (IConvertiblePool.SlotDetail memory) {
1831	 return convertiblePool.getSlotDetail(slot_);
1832	 }
1833	 function getIssuerSlots(address issuer_) external view override returns (uint256[] memory slots) {
1834	 return convertiblePool.getIssuerSlots(issuer_);
1835	 }
1836	 function contractURI() external view override returns (string memory) {
1837	 return voucherDescriptor.contractURI();
1838	 }
1839	 function slotURI(uint256 slot_) external view override returns (string memory) {
1840	 return voucherDescriptor.slotURI(slot_);
1841	 }
1842	 function tokenURI(uint256 tokenId_) public view virtual override returns (string memory) {
1843	 require(_exists(tokenId_), "token not exists");
1844	 return voucherDescriptor.tokenURI(tokenId_);
1845	 }
1846	 function getSnapshot(uint256 tokenId_) public override view returns (ConvertibleVoucherSnapshot memory snapshot) {
1847	 snapshot.tokenId = tokenId_;
1848	 snapshot.parValue = unitsInToken(tokenId_);
1849	 snapshot.slotDetail = convertiblePool.getSlotDetail(voucherSlotMapping[tokenId_]);
1850	 }
1851	 function underlying() external view override returns (address) {
1852	 return convertiblePool.underlyingToken();
1853	 }
1854	 function underlyingVestingVoucher() external view override returns (address) {
1855	 return convertiblePool.underlyingVestingVoucher();
1856	 }
1857	 function setVoucherDescriptor(address newDescriptor_) external onlyAdmin {
1858	 require(newDescriptor_ != address(0), "newDescriptor can not be 0 address");
1859	 emit SetDescriptor(address(voucherDescriptor), newDescriptor_);
1860	 voucherDescriptor = IVNFTDescriptor(newDescriptor_);
1861	 }
1862	 function setSolver(ISolver newSolver_) external onlyAdmin {
1863	 require(newSolver_.isSolver(), "invalid solver");
1864	 emit SetSolver(address(solver), address(newSolver_));
1865	 solver = newSolver_;
1866	 }
1867	 function voucherType() external pure override returns (Constants.VoucherType) {
1868	 return Constants.VoucherType.BOUNDING;
1869	 }
1870	 function version() external pure returns (string memory) {
1871	 return "1.0.1";
1872	 }
1873	 }
1874	 pragma solidity 0.7.6;
1875	 interface IPriceOracleManager {
1876	 function getPriceOfTokenId(address voucher_, uint256 tokenId_) external view returns (int256 price_);
1877	 function getPriceOfMaturity(address voucher_, uint64 maturity_) external view returns (int256 price_);
1878	 }
1879	 pragma solidity 0.7.6;
1880	 interface IVNFTDescriptor {
1881	 function contractURI() external view returns (string memory);
1882	 function slotURI(uint256 slot) external view returns (string memory);
1883	 function tokenURI(uint256 tokenId) external view returns (string memory);
1884	 }
1885	 pragma solidity 0.7.6;
1886	 interface IICToken {
1887	 function mint( uint64 term, uint256 amount, uint64[] calldata maturities, uint32[] calldata percentages, string memory originalInvestor ) external returns (uint256 slot, uint256 tokenId);
1888	 function vestingPool() external view returns (address);
1889	 function underlying() external view returns (address);
1890	 }
1891	 pragma solidity 0.7.6;
1892	 contract DefaultConvertibleVoucherSVG is IVoucherSVG, AdminControl {
1893	 using StringConvertor for uint256;
1894	 using StringConvertor for bytes;
1895	 struct SVGParams {
1896	 address voucher;
1897	 string underlyingTokenSymbol;
1898	 string currencyTokenSymbol;
1899	 uint256 tokenId;
1900	 uint256 parValue;
1901	 uint128 highestPrice;
1902	 uint128 lowestPrice;
1903	 uint64 maturity;
1904	 uint8 valueDecimals;
1905	 uint8 priceDecimals;
1906	 uint8 underlyingTokenDecimals;
1907	 uint8 currencyTokenDecimal;
1908	 }
1909	 mapping(address => mapping(uint8 => string[])) public voucherBgColors;
1910	 constructor( string[] memory linearBgColors_, string[] memory onetimeBgColors_, string[] memory stagedBgColors_ ) {
1911	 __AdminControl_init(_msgSender());
1912	 setVoucherBgColors(address(0), linearBgColors_, onetimeBgColors_, stagedBgColors_);
1913	 }
1914	 function setVoucherBgColors( address voucher_, string[] memory linearBgColors_, string[] memory onetimeBgColors_, string[] memory stagedBgColors_ ) public onlyAdmin {
1915	 voucherBgColors[voucher_][uint8(Constants.ClaimType.LINEAR)] = linearBgColors_;
1916	 voucherBgColors[voucher_][uint8(Constants.ClaimType.ONE_TIME)] = onetimeBgColors_;
1917	 voucherBgColors[voucher_][uint8(Constants.ClaimType.STAGED)] = stagedBgColors_;
1918	 }
1919	 function generateSVG(address voucher_, uint256 tokenId_) external virtual override view returns (string memory) {
1920	 ConvertibleVoucher convertibleVoucher = ConvertibleVoucher(voucher_);
1921	 ConvertiblePool convertiblePool = convertibleVoucher.convertiblePool();
1922	 ERC20Upgradeable underlyingToken = ERC20Upgradeable(convertiblePool.underlyingToken());
1923	 ConvertibleVoucher.ConvertibleVoucherSnapshot memory snapshot = convertibleVoucher.getSnapshot(tokenId_);
1924	 ERC20Upgradeable currencyToken = ERC20Upgradeable(snapshot.slotDetail.fundCurrency);
1925	 SVGParams memory svgParams;
1926	 svgParams.voucher = voucher_;
1927	 svgParams.underlyingTokenSymbol = underlyingToken.symbol();
1928	 svgParams.currencyTokenSymbol = currencyToken.symbol();
1929	 svgParams.tokenId = tokenId_;
1930	 svgParams.parValue = snapshot.parValue;
1931	 svgParams.lowestPrice = snapshot.slotDetail.lowestPrice;
1932	 svgParams.highestPrice = snapshot.slotDetail.highestPrice;
1933	 svgParams.maturity = snapshot.slotDetail.maturity;
1934	 svgParams.valueDecimals = convertiblePool.valueDecimals();
1935	 svgParams.priceDecimals = convertiblePool.priceDecimals();
1936	 svgParams.underlyingTokenDecimals = underlyingToken.decimals();
1937	 svgParams.currencyTokenDecimal = currencyToken.decimals();
1938	 return _generateSVG(svgParams);
1939	 }
1940	 function _generateSVG(SVGParams memory params) internal virtual view returns (string memory) {
1941	 return string( abi.encodePacked( '<svg width="600px" height="400px" viewBox="0 0 600 400" xmlns="http: _generateDefs(params), '<g stroke-width="1" fill="none" fill-rule="evenodd" font-family="Arial">', _generateBackground(), _generateTitle(params), _generateMaturity(params), _generatePriceRange(params), '</g>', '</svg>' ) );
1942	 }
1943	 function _generateDefs(SVGParams memory params) internal virtual view returns (string memory) {
1944	 string memory color0 = voucherBgColors[params.voucher][1].length > 0 ? voucherBgColors[params.voucher][1][0] : voucherBgColors[address(0)][1][0];
1945	 string memory color1 = voucherBgColors[params.voucher][1].length > 1 ? voucherBgColors[params.voucher][1][1] : voucherBgColors[address(0)][1][1];
1946	 return string( abi.encodePacked( '<defs>', abi.encodePacked( '<linearGradient x1="50%" y1="30%" x2="100%" y2="75%" id="lg-1">', '<stop stop-color="', color0, '" offset="0%"></stop>', '<stop stop-color="', color1, '" offset="100%"></stop>', '</linearGradient>', '<linearGradient x1="0" y1="50%" x2="100%" y2="50%" id="lg-2">', '<stop stop-color="#000000" stop-opacity="0" offset="0%"></stop>', '<stop stop-color="#000000" offset="40%"></stop>', '<stop stop-color="#000000" offset="55%"></stop>', '<stop stop-color="#000000" stop-opacity="0" offset="100%"></stop>', '</linearGradient>' ), abi.encodePacked( '<linearGradient x1="0" y1="50%" x2="100%" y2="50%" id="lg-3">', '<stop stop-color="#FFFFFF" stop-opacity="0" offset="0%"></stop>', '<stop stop-color="#FFFFFF" offset="40%"></stop>', '<stop stop-color="#FFFFFF" offset="55%"></stop>', '<stop stop-color="#FFFFFF" stop-opacity="0" offset="100%"></stop>', '</linearGradient>', '<linearGradient x1="82%" y1="18%" x2="25%" y2="65%" id="lg-4">', '<stop stop-color="#FFFFFF" offset="0%"></stop>', '<stop stop-color="#FFFFFF" stop-opacity="0" offset="100%"></stop>', '</linearGradient>', '<linearGradient x1="65%" y1="0" x2="45%" y2="100%" id="lg-5">', '<stop stop-color="#BBBBBB" offset="0%"></stop>', '<stop stop-color="#FFFFFF" offset="100%"></stop>', '</linearGradient>', '<path id="text-path-a" d="M30 12 H570 A18 18 0 0 1 588 30 V370 A18 18 0 0 1 570 388 H30 A18 18 0 0 1 12 370 V30 A18 18 0 0 1 30 12 Z"/>' ), '</defs>' ) );
1947	 }
1948	 function _generateBackground() internal pure virtual returns (string memory) {
1949	 return string( abi.encodePacked( '<rect fill="url(#lg-1)" x="0" y="0" width="600" height="400" rx="24"></rect>', '<rect stroke="#FFFFFF" x="16.5" y="16.5" width="567" height="367" rx="16"></rect>', '<g text-rendering="optimizeSpeed" opacity="0.5" font-size="10" fill="#FFFFFF">', '<text><textPath startOffset="-100%" xlink:href="#text-path-a">In Crypto We Trust<animate additive="sum" attributeName="startOffset" from="0%" to="100%" begin="0s" dur="30s" repeatCount="indefinite"/></textPath></text>', '<text><textPath startOffset="0%" xlink:href="#text-path-a">In Crypto We Trust<animate additive="sum" attributeName="startOffset" from="0%" to="100%" begin="0s" dur="30s" repeatCount="indefinite"/></textPath></text>', '<text><textPath startOffset="50%" xlink:href="#text-path-a">Powered by Solv Protocol<animate additive="sum" attributeName="startOffset" from="0%" to="100%" begin="0s" dur="30s" repeatCount="indefinite"/></textPath></text>', '<text><textPath startOffset="-50%" xlink:href="#text-path-a">Powered by Solv Protocol<animate additive="sum" attributeName="startOffset" from="0%" to="100%" begin="0s" dur="30s" repeatCount="indefinite"/></textPath></text>', '</g>', '<g transform="translate(60, 27)">', '<path d="M0,345 L0,292 C0,226 54,172 120,172 L352,172 C418,172 472,119 472,52 L472,0 L472,0" stroke="url(#lg-2)" stroke-width="20" stroke-linecap="round" stroke-linejoin="round" opacity="0.2"></path>', '<path d="M0,345 L0,292 C0,226 54,172 120,172 L352,172 C418,172 472,119 472,52 L472,0 L472,0" stroke="url(#lg-3)" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"></path>', '<path d="M448.3,131.5 L432,153 C420,138 420,138 420,138 L446,128.5 C447.1,128 449.5,128.5 448.5,131 Z" fill="url(#lg-4)" transform="translate(435, 141) rotate(-12) translate(-435, -141)"></path>', '<circle stroke="#FFFFFF" stroke-width="4" fill="#3CBF45" cx="331" cy="172" r="7"></circle>', '<circle stroke="#FFFFFF" stroke-width="4" fill="#D75959" cx="149" cy="172" r="7"></circle>', '</g>' ) );
1950	 }
1951	 function _generateTitle(SVGParams memory params) internal pure virtual returns (string memory) {
1952	 string memory tokenIdStr = params.tokenId.toString();
1953	 uint256 tokenIdLeftMargin = 526 - 18 * bytes(tokenIdStr).length;
1954	 return string( abi.encodePacked( '<text font-size="32" fill="#FFFFFF">', '<tspan x="40" y="65" font-size="25">', params.underlyingTokenSymbol, ' Convertible Voucher</tspan>', '<tspan x="40" y="105">', _formatValue(params.parValue, params.valueDecimals), '<tspan font-size="24"> ', params.currencyTokenSymbol, '</tspan>', '</tspan>', '<tspan x="', tokenIdLeftMargin.toString(), '" y="69"># ', tokenIdStr, '</tspan>', '</text>' ) );
1955	 }
1956	 function _generateMaturity(SVGParams memory params) internal pure virtual returns (string memory) {
1957	 return string( abi.encodePacked( '<text font-size="12" fill="#FFFFFF">', '<tspan x="40" y="365">Maturity Date: ', uint256(params.maturity).dateToString(), '</tspan>', '</text>' ) );
1958	 }
1959	 function _generatePriceRange(SVGParams memory params) internal pure virtual returns (string memory) {
1960	 uint256 minTokenAmount = params.parValue / params.highestPrice;
1961	 uint256 maxTokenAmount = params.parValue / params.lowestPrice;
1962	 bytes memory minAmountStr = minTokenAmount < (10 ** (params.underlyingTokenDecimals + 6)) ? _formatValue(minTokenAmount, params.underlyingTokenDecimals) : abi.encodePacked( _formatValue(minTokenAmount, params.underlyingTokenDecimals + 6), "M" );
1963	 bytes memory maxAmountStr = maxTokenAmount < (10 ** (params.underlyingTokenDecimals + 6)) ? _formatValue(maxTokenAmount, params.underlyingTokenDecimals) : abi.encodePacked( _formatValue(maxTokenAmount, params.underlyingTokenDecimals + 6), "M" );
1964	 return string( abi.encodePacked( '<path d="M330,242 L550,242 C555,242 560,246 560,252 L560,292 C560,297 555,302 550,302 L330,302 C324,302 320,297 320,292 L320,252 C320,246 324,242 330,242 Z" fill="#000000" opacity="0.2" transform="translate(440, 272) scale(1, -1) translate(-440, -272)"></path>', '<path d="M330,309 L550,309 C555,309 560,313 560,319 L560,359 C560,364 555,369 550,369 L330,369 C324,369 320,364 320,359 L320,319 C320,313 324,309 330,309 Z" fill="#000000" opacity="0.2" transform="translate(440, 339) scale(1, -1) translate(-440, -339)"></path>', '<circle stroke="#FFFFFF" stroke-width="2" fill="#D75959" cx="336" cy="326" r="5"></circle>', '<circle stroke="#FFFFFF" stroke-width="2" fill="#3CBF45" cx="336" cy="260" r="5"></circle>', '<text font-size="14" fill="#FFFFFF" opacity="0.8">', abi.encodePacked( '<tspan x="352" y="265">Price above </tspan>', '<tspan x="432" y="266">$', _formatValue(params.highestPrice, params.priceDecimals), '</tspan>', '<tspan x="352" y="285">Claimable = </tspan>', '<tspan x="432" y="286">', minAmountStr, ' ', params.underlyingTokenSymbol, '</tspan>' ), abi.encodePacked( '<tspan x="352" y="331">Price below </tspan>', '<tspan x="432" y="332">$', _formatValue(params.lowestPrice, params.priceDecimals), '</tspan>', '<tspan x="352" y="351">Claimable = </tspan>', '<tspan x="432" y="352">', maxAmountStr, ' ', params.underlyingTokenSymbol, '</tspan>' ), '</text>' ) );
1965	 }
1966	 function _formatValue(uint256 value, uint8 decimals) private pure returns (bytes memory) {
1967	 return value.uint2decimal(decimals).trim(decimals - 2).addThousandsSeparator();
1968	 }
1969	 }
1970	 pragma solidity >= 0.4.22 <0.9.0;
1971	 library console {
1972	 address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);
1973	 function _sendLogPayload(bytes memory payload) private view {
1974	 uint256 payloadLength = payload.length;
1975	 address consoleAddress = CONSOLE_ADDRESS;
1976	 assembly {
1977	 let payloadStart := add(payload, 32) let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0) }
1978	 }
1979	 function log() internal view {
1980	 _sendLogPayload(abi.encodeWithSignature("log()"));
1981	 }
1982	 function logInt(int p0) internal view {
1983	 _sendLogPayload(abi.encodeWithSignature("log(int)", p0));
1984	 }
1985	 function logUint(uint p0) internal view {
1986	 _sendLogPayload(abi.encodeWithSignature("log(uint)", p0));
1987	 }
1988	 function logString(string memory p0) internal view {
1989	 _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
1990	 }
1991	 function logBool(bool p0) internal view {
1992	 _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
1993	 }
1994	 function logAddress(address p0) internal view {
1995	 _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
1996	 }
1997	 function logBytes(bytes memory p0) internal view {
1998	 _sendLogPayload(abi.encodeWithSignature("log(bytes)", p0));
1999	 }
2000	 function logBytes1(bytes1 p0) internal view {
2001	 _sendLogPayload(abi.encodeWithSignature("log(bytes1)", p0));
2002	 }
2003	 function logBytes2(bytes2 p0) internal view {
2004	 _sendLogPayload(abi.encodeWithSignature("log(bytes2)", p0));
2005	 }
2006	 function logBytes3(bytes3 p0) internal view {
2007	 _sendLogPayload(abi.encodeWithSignature("log(bytes3)", p0));
2008	 }
2009	 function logBytes4(bytes4 p0) internal view {
2010	 _sendLogPayload(abi.encodeWithSignature("log(bytes4)", p0));
2011	 }
2012	 function logBytes5(bytes5 p0) internal view {
2013	 _sendLogPayload(abi.encodeWithSignature("log(bytes5)", p0));
2014	 }
2015	 function logBytes6(bytes6 p0) internal view {
2016	 _sendLogPayload(abi.encodeWithSignature("log(bytes6)", p0));
2017	 }
2018	 function logBytes7(bytes7 p0) internal view {
2019	 _sendLogPayload(abi.encodeWithSignature("log(bytes7)", p0));
2020	 }
2021	 function logBytes8(bytes8 p0) internal view {
2022	 _sendLogPayload(abi.encodeWithSignature("log(bytes8)", p0));
2023	 }
2024	 function logBytes9(bytes9 p0) internal view {
2025	 _sendLogPayload(abi.encodeWithSignature("log(bytes9)", p0));
2026	 }
2027	 function logBytes10(bytes10 p0) internal view {
2028	 _sendLogPayload(abi.encodeWithSignature("log(bytes10)", p0));
2029	 }
2030	 function logBytes11(bytes11 p0) internal view {
2031	 _sendLogPayload(abi.encodeWithSignature("log(bytes11)", p0));
2032	 }
2033	 function logBytes12(bytes12 p0) internal view {
2034	 _sendLogPayload(abi.encodeWithSignature("log(bytes12)", p0));
2035	 }
2036	 function logBytes13(bytes13 p0) internal view {
2037	 _sendLogPayload(abi.encodeWithSignature("log(bytes13)", p0));
2038	 }
2039	 function logBytes14(bytes14 p0) internal view {
2040	 _sendLogPayload(abi.encodeWithSignature("log(bytes14)", p0));
2041	 }
2042	 function logBytes15(bytes15 p0) internal view {
2043	 _sendLogPayload(abi.encodeWithSignature("log(bytes15)", p0));
2044	 }
2045	 function logBytes16(bytes16 p0) internal view {
2046	 _sendLogPayload(abi.encodeWithSignature("log(bytes16)", p0));
2047	 }
2048	 function logBytes17(bytes17 p0) internal view {
2049	 _sendLogPayload(abi.encodeWithSignature("log(bytes17)", p0));
2050	 }
2051	 function logBytes18(bytes18 p0) internal view {
2052	 _sendLogPayload(abi.encodeWithSignature("log(bytes18)", p0));
2053	 }
2054	 function logBytes19(bytes19 p0) internal view {
2055	 _sendLogPayload(abi.encodeWithSignature("log(bytes19)", p0));
2056	 }
2057	 function logBytes20(bytes20 p0) internal view {
2058	 _sendLogPayload(abi.encodeWithSignature("log(bytes20)", p0));
2059	 }
2060	 function logBytes21(bytes21 p0) internal view {
2061	 _sendLogPayload(abi.encodeWithSignature("log(bytes21)", p0));
2062	 }
2063	 function logBytes22(bytes22 p0) internal view {
2064	 _sendLogPayload(abi.encodeWithSignature("log(bytes22)", p0));
2065	 }
2066	 function logBytes23(bytes23 p0) internal view {
2067	 _sendLogPayload(abi.encodeWithSignature("log(bytes23)", p0));
2068	 }
2069	 function logBytes24(bytes24 p0) internal view {
2070	 _sendLogPayload(abi.encodeWithSignature("log(bytes24)", p0));
2071	 }
2072	 function logBytes25(bytes25 p0) internal view {
2073	 _sendLogPayload(abi.encodeWithSignature("log(bytes25)", p0));
2074	 }
2075	 function logBytes26(bytes26 p0) internal view {
2076	 _sendLogPayload(abi.encodeWithSignature("log(bytes26)", p0));
2077	 }
2078	 function logBytes27(bytes27 p0) internal view {
2079	 _sendLogPayload(abi.encodeWithSignature("log(bytes27)", p0));
2080	 }
2081	 function logBytes28(bytes28 p0) internal view {
2082	 _sendLogPayload(abi.encodeWithSignature("log(bytes28)", p0));
2083	 }
2084	 function logBytes29(bytes29 p0) internal view {
2085	 _sendLogPayload(abi.encodeWithSignature("log(bytes29)", p0));
2086	 }
2087	 function logBytes30(bytes30 p0) internal view {
2088	 _sendLogPayload(abi.encodeWithSignature("log(bytes30)", p0));
2089	 }
2090	 function logBytes31(bytes31 p0) internal view {
2091	 _sendLogPayload(abi.encodeWithSignature("log(bytes31)", p0));
2092	 }
2093	 function logBytes32(bytes32 p0) internal view {
2094	 _sendLogPayload(abi.encodeWithSignature("log(bytes32)", p0));
2095	 }
2096	 function log(uint p0) internal view {
2097	 _sendLogPayload(abi.encodeWithSignature("log(uint)", p0));
2098	 }
2099	 function log(string memory p0) internal view {
2100	 _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
2101	 }
2102	 function log(bool p0) internal view {
2103	 _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
2104	 }
2105	 function log(address p0) internal view {
2106	 _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
2107	 }
2108	 function log(uint p0, uint p1) internal view {
2109	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint)", p0, p1));
2110	 }
2111	 function log(uint p0, string memory p1) internal view {
2112	 _sendLogPayload(abi.encodeWithSignature("log(uint,string)", p0, p1));
2113	 }
2114	 function log(uint p0, bool p1) internal view {
2115	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool)", p0, p1));
2116	 }
2117	 function log(uint p0, address p1) internal view {
2118	 _sendLogPayload(abi.encodeWithSignature("log(uint,address)", p0, p1));
2119	 }
2120	 function log(string memory p0, uint p1) internal view {
2121	 _sendLogPayload(abi.encodeWithSignature("log(string,uint)", p0, p1));
2122	 }
2123	 function log(string memory p0, string memory p1) internal view {
2124	 _sendLogPayload(abi.encodeWithSignature("log(string,string)", p0, p1));
2125	 }
2126	 function log(string memory p0, bool p1) internal view {
2127	 _sendLogPayload(abi.encodeWithSignature("log(string,bool)", p0, p1));
2128	 }
2129	 function log(string memory p0, address p1) internal view {
2130	 _sendLogPayload(abi.encodeWithSignature("log(string,address)", p0, p1));
2131	 }
2132	 function log(bool p0, uint p1) internal view {
2133	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint)", p0, p1));
2134	 }
2135	 function log(bool p0, string memory p1) internal view {
2136	 _sendLogPayload(abi.encodeWithSignature("log(bool,string)", p0, p1));
2137	 }
2138	 function log(bool p0, bool p1) internal view {
2139	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool)", p0, p1));
2140	 }
2141	 function log(bool p0, address p1) internal view {
2142	 _sendLogPayload(abi.encodeWithSignature("log(bool,address)", p0, p1));
2143	 }
2144	 function log(address p0, uint p1) internal view {
2145	 _sendLogPayload(abi.encodeWithSignature("log(address,uint)", p0, p1));
2146	 }
2147	 function log(address p0, string memory p1) internal view {
2148	 _sendLogPayload(abi.encodeWithSignature("log(address,string)", p0, p1));
2149	 }
2150	 function log(address p0, bool p1) internal view {
2151	 _sendLogPayload(abi.encodeWithSignature("log(address,bool)", p0, p1));
2152	 }
2153	 function log(address p0, address p1) internal view {
2154	 _sendLogPayload(abi.encodeWithSignature("log(address,address)", p0, p1));
2155	 }
2156	 function log(uint p0, uint p1, uint p2) internal view {
2157	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint)", p0, p1, p2));
2158	 }
2159	 function log(uint p0, uint p1, string memory p2) internal view {
2160	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string)", p0, p1, p2));
2161	 }
2162	 function log(uint p0, uint p1, bool p2) internal view {
2163	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool)", p0, p1, p2));
2164	 }
2165	 function log(uint p0, uint p1, address p2) internal view {
2166	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address)", p0, p1, p2));
2167	 }
2168	 function log(uint p0, string memory p1, uint p2) internal view {
2169	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint)", p0, p1, p2));
2170	 }
2171	 function log(uint p0, string memory p1, string memory p2) internal view {
2172	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,string)", p0, p1, p2));
2173	 }
2174	 function log(uint p0, string memory p1, bool p2) internal view {
2175	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool)", p0, p1, p2));
2176	 }
2177	 function log(uint p0, string memory p1, address p2) internal view {
2178	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,address)", p0, p1, p2));
2179	 }
2180	 function log(uint p0, bool p1, uint p2) internal view {
2181	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint)", p0, p1, p2));
2182	 }
2183	 function log(uint p0, bool p1, string memory p2) internal view {
2184	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string)", p0, p1, p2));
2185	 }
2186	 function log(uint p0, bool p1, bool p2) internal view {
2187	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool)", p0, p1, p2));
2188	 }
2189	 function log(uint p0, bool p1, address p2) internal view {
2190	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address)", p0, p1, p2));
2191	 }
2192	 function log(uint p0, address p1, uint p2) internal view {
2193	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint)", p0, p1, p2));
2194	 }
2195	 function log(uint p0, address p1, string memory p2) internal view {
2196	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,string)", p0, p1, p2));
2197	 }
2198	 function log(uint p0, address p1, bool p2) internal view {
2199	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool)", p0, p1, p2));
2200	 }
2201	 function log(uint p0, address p1, address p2) internal view {
2202	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,address)", p0, p1, p2));
2203	 }
2204	 function log(string memory p0, uint p1, uint p2) internal view {
2205	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint)", p0, p1, p2));
2206	 }
2207	 function log(string memory p0, uint p1, string memory p2) internal view {
2208	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,string)", p0, p1, p2));
2209	 }
2210	 function log(string memory p0, uint p1, bool p2) internal view {
2211	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool)", p0, p1, p2));
2212	 }
2213	 function log(string memory p0, uint p1, address p2) internal view {
2214	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,address)", p0, p1, p2));
2215	 }
2216	 function log(string memory p0, string memory p1, uint p2) internal view {
2217	 _sendLogPayload(abi.encodeWithSignature("log(string,string,uint)", p0, p1, p2));
2218	 }
2219	 function log(string memory p0, string memory p1, string memory p2) internal view {
2220	 _sendLogPayload(abi.encodeWithSignature("log(string,string,string)", p0, p1, p2));
2221	 }
2222	 function log(string memory p0, string memory p1, bool p2) internal view {
2223	 _sendLogPayload(abi.encodeWithSignature("log(string,string,bool)", p0, p1, p2));
2224	 }
2225	 function log(string memory p0, string memory p1, address p2) internal view {
2226	 _sendLogPayload(abi.encodeWithSignature("log(string,string,address)", p0, p1, p2));
2227	 }
2228	 function log(string memory p0, bool p1, uint p2) internal view {
2229	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint)", p0, p1, p2));
2230	 }
2231	 function log(string memory p0, bool p1, string memory p2) internal view {
2232	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,string)", p0, p1, p2));
2233	 }
2234	 function log(string memory p0, bool p1, bool p2) internal view {
2235	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool)", p0, p1, p2));
2236	 }
2237	 function log(string memory p0, bool p1, address p2) internal view {
2238	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,address)", p0, p1, p2));
2239	 }
2240	 function log(string memory p0, address p1, uint p2) internal view {
2241	 _sendLogPayload(abi.encodeWithSignature("log(string,address,uint)", p0, p1, p2));
2242	 }
2243	 function log(string memory p0, address p1, string memory p2) internal view {
2244	 _sendLogPayload(abi.encodeWithSignature("log(string,address,string)", p0, p1, p2));
2245	 }
2246	 function log(string memory p0, address p1, bool p2) internal view {
2247	 _sendLogPayload(abi.encodeWithSignature("log(string,address,bool)", p0, p1, p2));
2248	 }
2249	 function log(string memory p0, address p1, address p2) internal view {
2250	 _sendLogPayload(abi.encodeWithSignature("log(string,address,address)", p0, p1, p2));
2251	 }
2252	 function log(bool p0, uint p1, uint p2) internal view {
2253	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint)", p0, p1, p2));
2254	 }
2255	 function log(bool p0, uint p1, string memory p2) internal view {
2256	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string)", p0, p1, p2));
2257	 }
2258	 function log(bool p0, uint p1, bool p2) internal view {
2259	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool)", p0, p1, p2));
2260	 }
2261	 function log(bool p0, uint p1, address p2) internal view {
2262	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address)", p0, p1, p2));
2263	 }
2264	 function log(bool p0, string memory p1, uint p2) internal view {
2265	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint)", p0, p1, p2));
2266	 }
2267	 function log(bool p0, string memory p1, string memory p2) internal view {
2268	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,string)", p0, p1, p2));
2269	 }
2270	 function log(bool p0, string memory p1, bool p2) internal view {
2271	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool)", p0, p1, p2));
2272	 }
2273	 function log(bool p0, string memory p1, address p2) internal view {
2274	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,address)", p0, p1, p2));
2275	 }
2276	 function log(bool p0, bool p1, uint p2) internal view {
2277	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint)", p0, p1, p2));
2278	 }
2279	 function log(bool p0, bool p1, string memory p2) internal view {
2280	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string)", p0, p1, p2));
2281	 }
2282	 function log(bool p0, bool p1, bool p2) internal view {
2283	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool)", p0, p1, p2));
2284	 }
2285	 function log(bool p0, bool p1, address p2) internal view {
2286	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address)", p0, p1, p2));
2287	 }
2288	 function log(bool p0, address p1, uint p2) internal view {
2289	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint)", p0, p1, p2));
2290	 }
2291	 function log(bool p0, address p1, string memory p2) internal view {
2292	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,string)", p0, p1, p2));
2293	 }
2294	 function log(bool p0, address p1, bool p2) internal view {
2295	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool)", p0, p1, p2));
2296	 }
2297	 function log(bool p0, address p1, address p2) internal view {
2298	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,address)", p0, p1, p2));
2299	 }
2300	 function log(address p0, uint p1, uint p2) internal view {
2301	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint)", p0, p1, p2));
2302	 }
2303	 function log(address p0, uint p1, string memory p2) internal view {
2304	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,string)", p0, p1, p2));
2305	 }
2306	 function log(address p0, uint p1, bool p2) internal view {
2307	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool)", p0, p1, p2));
2308	 }
2309	 function log(address p0, uint p1, address p2) internal view {
2310	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,address)", p0, p1, p2));
2311	 }
2312	 function log(address p0, string memory p1, uint p2) internal view {
2313	 _sendLogPayload(abi.encodeWithSignature("log(address,string,uint)", p0, p1, p2));
2314	 }
2315	 function log(address p0, string memory p1, string memory p2) internal view {
2316	 _sendLogPayload(abi.encodeWithSignature("log(address,string,string)", p0, p1, p2));
2317	 }
2318	 function log(address p0, string memory p1, bool p2) internal view {
2319	 _sendLogPayload(abi.encodeWithSignature("log(address,string,bool)", p0, p1, p2));
2320	 }
2321	 function log(address p0, string memory p1, address p2) internal view {
2322	 _sendLogPayload(abi.encodeWithSignature("log(address,string,address)", p0, p1, p2));
2323	 }
2324	 function log(address p0, bool p1, uint p2) internal view {
2325	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint)", p0, p1, p2));
2326	 }
2327	 function log(address p0, bool p1, string memory p2) internal view {
2328	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,string)", p0, p1, p2));
2329	 }
2330	 function log(address p0, bool p1, bool p2) internal view {
2331	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool)", p0, p1, p2));
2332	 }
2333	 function log(address p0, bool p1, address p2) internal view {
2334	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,address)", p0, p1, p2));
2335	 }
2336	 function log(address p0, address p1, uint p2) internal view {
2337	 _sendLogPayload(abi.encodeWithSignature("log(address,address,uint)", p0, p1, p2));
2338	 }
2339	 function log(address p0, address p1, string memory p2) internal view {
2340	 _sendLogPayload(abi.encodeWithSignature("log(address,address,string)", p0, p1, p2));
2341	 }
2342	 function log(address p0, address p1, bool p2) internal view {
2343	 _sendLogPayload(abi.encodeWithSignature("log(address,address,bool)", p0, p1, p2));
2344	 }
2345	 function log(address p0, address p1, address p2) internal view {
2346	 _sendLogPayload(abi.encodeWithSignature("log(address,address,address)", p0, p1, p2));
2347	 }
2348	 function log(uint p0, uint p1, uint p2, uint p3) internal view {
2349	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,uint)", p0, p1, p2, p3));
2350	 }
2351	 function log(uint p0, uint p1, uint p2, string memory p3) internal view {
2352	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,string)", p0, p1, p2, p3));
2353	 }
2354	 function log(uint p0, uint p1, uint p2, bool p3) internal view {
2355	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,bool)", p0, p1, p2, p3));
2356	 }
2357	 function log(uint p0, uint p1, uint p2, address p3) internal view {
2358	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,address)", p0, p1, p2, p3));
2359	 }
2360	 function log(uint p0, uint p1, string memory p2, uint p3) internal view {
2361	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,uint)", p0, p1, p2, p3));
2362	 }
2363	 function log(uint p0, uint p1, string memory p2, string memory p3) internal view {
2364	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,string)", p0, p1, p2, p3));
2365	 }
2366	 function log(uint p0, uint p1, string memory p2, bool p3) internal view {
2367	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,bool)", p0, p1, p2, p3));
2368	 }
2369	 function log(uint p0, uint p1, string memory p2, address p3) internal view {
2370	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,address)", p0, p1, p2, p3));
2371	 }
2372	 function log(uint p0, uint p1, bool p2, uint p3) internal view {
2373	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,uint)", p0, p1, p2, p3));
2374	 }
2375	 function log(uint p0, uint p1, bool p2, string memory p3) internal view {
2376	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,string)", p0, p1, p2, p3));
2377	 }
2378	 function log(uint p0, uint p1, bool p2, bool p3) internal view {
2379	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,bool)", p0, p1, p2, p3));
2380	 }
2381	 function log(uint p0, uint p1, bool p2, address p3) internal view {
2382	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,address)", p0, p1, p2, p3));
2383	 }
2384	 function log(uint p0, uint p1, address p2, uint p3) internal view {
2385	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,uint)", p0, p1, p2, p3));
2386	 }
2387	 function log(uint p0, uint p1, address p2, string memory p3) internal view {
2388	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,string)", p0, p1, p2, p3));
2389	 }
2390	 function log(uint p0, uint p1, address p2, bool p3) internal view {
2391	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,bool)", p0, p1, p2, p3));
2392	 }
2393	 function log(uint p0, uint p1, address p2, address p3) internal view {
2394	 _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,address)", p0, p1, p2, p3));
2395	 }
2396	 function log(uint p0, string memory p1, uint p2, uint p3) internal view {
2397	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,uint)", p0, p1, p2, p3));
2398	 }
2399	 function log(uint p0, string memory p1, uint p2, string memory p3) internal view {
2400	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,string)", p0, p1, p2, p3));
2401	 }
2402	 function log(uint p0, string memory p1, uint p2, bool p3) internal view {
2403	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,bool)", p0, p1, p2, p3));
2404	 }
2405	 function log(uint p0, string memory p1, uint p2, address p3) internal view {
2406	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,address)", p0, p1, p2, p3));
2407	 }
2408	 function log(uint p0, string memory p1, string memory p2, uint p3) internal view {
2409	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,uint)", p0, p1, p2, p3));
2410	 }
2411	 function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {
2412	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,string)", p0, p1, p2, p3));
2413	 }
2414	 function log(uint p0, string memory p1, string memory p2, bool p3) internal view {
2415	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,bool)", p0, p1, p2, p3));
2416	 }
2417	 function log(uint p0, string memory p1, string memory p2, address p3) internal view {
2418	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,address)", p0, p1, p2, p3));
2419	 }
2420	 function log(uint p0, string memory p1, bool p2, uint p3) internal view {
2421	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,uint)", p0, p1, p2, p3));
2422	 }
2423	 function log(uint p0, string memory p1, bool p2, string memory p3) internal view {
2424	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,string)", p0, p1, p2, p3));
2425	 }
2426	 function log(uint p0, string memory p1, bool p2, bool p3) internal view {
2427	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,bool)", p0, p1, p2, p3));
2428	 }
2429	 function log(uint p0, string memory p1, bool p2, address p3) internal view {
2430	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,address)", p0, p1, p2, p3));
2431	 }
2432	 function log(uint p0, string memory p1, address p2, uint p3) internal view {
2433	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,uint)", p0, p1, p2, p3));
2434	 }
2435	 function log(uint p0, string memory p1, address p2, string memory p3) internal view {
2436	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,string)", p0, p1, p2, p3));
2437	 }
2438	 function log(uint p0, string memory p1, address p2, bool p3) internal view {
2439	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,bool)", p0, p1, p2, p3));
2440	 }
2441	 function log(uint p0, string memory p1, address p2, address p3) internal view {
2442	 _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,address)", p0, p1, p2, p3));
2443	 }
2444	 function log(uint p0, bool p1, uint p2, uint p3) internal view {
2445	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,uint)", p0, p1, p2, p3));
2446	 }
2447	 function log(uint p0, bool p1, uint p2, string memory p3) internal view {
2448	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,string)", p0, p1, p2, p3));
2449	 }
2450	 function log(uint p0, bool p1, uint p2, bool p3) internal view {
2451	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,bool)", p0, p1, p2, p3));
2452	 }
2453	 function log(uint p0, bool p1, uint p2, address p3) internal view {
2454	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,address)", p0, p1, p2, p3));
2455	 }
2456	 function log(uint p0, bool p1, string memory p2, uint p3) internal view {
2457	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,uint)", p0, p1, p2, p3));
2458	 }
2459	 function log(uint p0, bool p1, string memory p2, string memory p3) internal view {
2460	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,string)", p0, p1, p2, p3));
2461	 }
2462	 function log(uint p0, bool p1, string memory p2, bool p3) internal view {
2463	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,bool)", p0, p1, p2, p3));
2464	 }
2465	 function log(uint p0, bool p1, string memory p2, address p3) internal view {
2466	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,address)", p0, p1, p2, p3));
2467	 }
2468	 function log(uint p0, bool p1, bool p2, uint p3) internal view {
2469	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,uint)", p0, p1, p2, p3));
2470	 }
2471	 function log(uint p0, bool p1, bool p2, string memory p3) internal view {
2472	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,string)", p0, p1, p2, p3));
2473	 }
2474	 function log(uint p0, bool p1, bool p2, bool p3) internal view {
2475	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,bool)", p0, p1, p2, p3));
2476	 }
2477	 function log(uint p0, bool p1, bool p2, address p3) internal view {
2478	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,address)", p0, p1, p2, p3));
2479	 }
2480	 function log(uint p0, bool p1, address p2, uint p3) internal view {
2481	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,uint)", p0, p1, p2, p3));
2482	 }
2483	 function log(uint p0, bool p1, address p2, string memory p3) internal view {
2484	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,string)", p0, p1, p2, p3));
2485	 }
2486	 function log(uint p0, bool p1, address p2, bool p3) internal view {
2487	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,bool)", p0, p1, p2, p3));
2488	 }
2489	 function log(uint p0, bool p1, address p2, address p3) internal view {
2490	 _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,address)", p0, p1, p2, p3));
2491	 }
2492	 function log(uint p0, address p1, uint p2, uint p3) internal view {
2493	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,uint)", p0, p1, p2, p3));
2494	 }
2495	 function log(uint p0, address p1, uint p2, string memory p3) internal view {
2496	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,string)", p0, p1, p2, p3));
2497	 }
2498	 function log(uint p0, address p1, uint p2, bool p3) internal view {
2499	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,bool)", p0, p1, p2, p3));
2500	 }
2501	 function log(uint p0, address p1, uint p2, address p3) internal view {
2502	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,address)", p0, p1, p2, p3));
2503	 }
2504	 function log(uint p0, address p1, string memory p2, uint p3) internal view {
2505	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,uint)", p0, p1, p2, p3));
2506	 }
2507	 function log(uint p0, address p1, string memory p2, string memory p3) internal view {
2508	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,string)", p0, p1, p2, p3));
2509	 }
2510	 function log(uint p0, address p1, string memory p2, bool p3) internal view {
2511	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,bool)", p0, p1, p2, p3));
2512	 }
2513	 function log(uint p0, address p1, string memory p2, address p3) internal view {
2514	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,address)", p0, p1, p2, p3));
2515	 }
2516	 function log(uint p0, address p1, bool p2, uint p3) internal view {
2517	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,uint)", p0, p1, p2, p3));
2518	 }
2519	 function log(uint p0, address p1, bool p2, string memory p3) internal view {
2520	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,string)", p0, p1, p2, p3));
2521	 }
2522	 function log(uint p0, address p1, bool p2, bool p3) internal view {
2523	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,bool)", p0, p1, p2, p3));
2524	 }
2525	 function log(uint p0, address p1, bool p2, address p3) internal view {
2526	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,address)", p0, p1, p2, p3));
2527	 }
2528	 function log(uint p0, address p1, address p2, uint p3) internal view {
2529	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,uint)", p0, p1, p2, p3));
2530	 }
2531	 function log(uint p0, address p1, address p2, string memory p3) internal view {
2532	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,string)", p0, p1, p2, p3));
2533	 }
2534	 function log(uint p0, address p1, address p2, bool p3) internal view {
2535	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,bool)", p0, p1, p2, p3));
2536	 }
2537	 function log(uint p0, address p1, address p2, address p3) internal view {
2538	 _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,address)", p0, p1, p2, p3));
2539	 }
2540	 function log(string memory p0, uint p1, uint p2, uint p3) internal view {
2541	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,uint)", p0, p1, p2, p3));
2542	 }
2543	 function log(string memory p0, uint p1, uint p2, string memory p3) internal view {
2544	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,string)", p0, p1, p2, p3));
2545	 }
2546	 function log(string memory p0, uint p1, uint p2, bool p3) internal view {
2547	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,bool)", p0, p1, p2, p3));
2548	 }
2549	 function log(string memory p0, uint p1, uint p2, address p3) internal view {
2550	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,address)", p0, p1, p2, p3));
2551	 }
2552	 function log(string memory p0, uint p1, string memory p2, uint p3) internal view {
2553	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,uint)", p0, p1, p2, p3));
2554	 }
2555	 function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {
2556	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,string)", p0, p1, p2, p3));
2557	 }
2558	 function log(string memory p0, uint p1, string memory p2, bool p3) internal view {
2559	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,bool)", p0, p1, p2, p3));
2560	 }
2561	 function log(string memory p0, uint p1, string memory p2, address p3) internal view {
2562	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,address)", p0, p1, p2, p3));
2563	 }
2564	 function log(string memory p0, uint p1, bool p2, uint p3) internal view {
2565	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,uint)", p0, p1, p2, p3));
2566	 }
2567	 function log(string memory p0, uint p1, bool p2, string memory p3) internal view {
2568	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,string)", p0, p1, p2, p3));
2569	 }
2570	 function log(string memory p0, uint p1, bool p2, bool p3) internal view {
2571	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,bool)", p0, p1, p2, p3));
2572	 }
2573	 function log(string memory p0, uint p1, bool p2, address p3) internal view {
2574	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,address)", p0, p1, p2, p3));
2575	 }
2576	 function log(string memory p0, uint p1, address p2, uint p3) internal view {
2577	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,uint)", p0, p1, p2, p3));
2578	 }
2579	 function log(string memory p0, uint p1, address p2, string memory p3) internal view {
2580	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,string)", p0, p1, p2, p3));
2581	 }
2582	 function log(string memory p0, uint p1, address p2, bool p3) internal view {
2583	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,bool)", p0, p1, p2, p3));
2584	 }
2585	 function log(string memory p0, uint p1, address p2, address p3) internal view {
2586	 _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,address)", p0, p1, p2, p3));
2587	 }
2588	 function log(string memory p0, string memory p1, uint p2, uint p3) internal view {
2589	 _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,uint)", p0, p1, p2, p3));
2590	 }
2591	 function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {
2592	 _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,string)", p0, p1, p2, p3));
2593	 }
2594	 function log(string memory p0, string memory p1, uint p2, bool p3) internal view {
2595	 _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,bool)", p0, p1, p2, p3));
2596	 }
2597	 function log(string memory p0, string memory p1, uint p2, address p3) internal view {
2598	 _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,address)", p0, p1, p2, p3));
2599	 }
2600	 function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {
2601	 _sendLogPayload(abi.encodeWithSignature("log(string,string,string,uint)", p0, p1, p2, p3));
2602	 }
2603	 function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {
2604	 _sendLogPayload(abi.encodeWithSignature("log(string,string,string,string)", p0, p1, p2, p3));
2605	 }
2606	 function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {
2607	 _sendLogPayload(abi.encodeWithSignature("log(string,string,string,bool)", p0, p1, p2, p3));
2608	 }
2609	 function log(string memory p0, string memory p1, string memory p2, address p3) internal view {
2610	 _sendLogPayload(abi.encodeWithSignature("log(string,string,string,address)", p0, p1, p2, p3));
2611	 }
2612	 function log(string memory p0, string memory p1, bool p2, uint p3) internal view {
2613	 _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,uint)", p0, p1, p2, p3));
2614	 }
2615	 function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {
2616	 _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,string)", p0, p1, p2, p3));
2617	 }
2618	 function log(string memory p0, string memory p1, bool p2, bool p3) internal view {
2619	 _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,bool)", p0, p1, p2, p3));
2620	 }
2621	 function log(string memory p0, string memory p1, bool p2, address p3) internal view {
2622	 _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,address)", p0, p1, p2, p3));
2623	 }
2624	 function log(string memory p0, string memory p1, address p2, uint p3) internal view {
2625	 _sendLogPayload(abi.encodeWithSignature("log(string,string,address,uint)", p0, p1, p2, p3));
2626	 }
2627	 function log(string memory p0, string memory p1, address p2, string memory p3) internal view {
2628	 _sendLogPayload(abi.encodeWithSignature("log(string,string,address,string)", p0, p1, p2, p3));
2629	 }
2630	 function log(string memory p0, string memory p1, address p2, bool p3) internal view {
2631	 _sendLogPayload(abi.encodeWithSignature("log(string,string,address,bool)", p0, p1, p2, p3));
2632	 }
2633	 function log(string memory p0, string memory p1, address p2, address p3) internal view {
2634	 _sendLogPayload(abi.encodeWithSignature("log(string,string,address,address)", p0, p1, p2, p3));
2635	 }
2636	 function log(string memory p0, bool p1, uint p2, uint p3) internal view {
2637	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,uint)", p0, p1, p2, p3));
2638	 }
2639	 function log(string memory p0, bool p1, uint p2, string memory p3) internal view {
2640	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,string)", p0, p1, p2, p3));
2641	 }
2642	 function log(string memory p0, bool p1, uint p2, bool p3) internal view {
2643	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,bool)", p0, p1, p2, p3));
2644	 }
2645	 function log(string memory p0, bool p1, uint p2, address p3) internal view {
2646	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,address)", p0, p1, p2, p3));
2647	 }
2648	 function log(string memory p0, bool p1, string memory p2, uint p3) internal view {
2649	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,uint)", p0, p1, p2, p3));
2650	 }
2651	 function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {
2652	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,string)", p0, p1, p2, p3));
2653	 }
2654	 function log(string memory p0, bool p1, string memory p2, bool p3) internal view {
2655	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,bool)", p0, p1, p2, p3));
2656	 }
2657	 function log(string memory p0, bool p1, string memory p2, address p3) internal view {
2658	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,address)", p0, p1, p2, p3));
2659	 }
2660	 function log(string memory p0, bool p1, bool p2, uint p3) internal view {
2661	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,uint)", p0, p1, p2, p3));
2662	 }
2663	 function log(string memory p0, bool p1, bool p2, string memory p3) internal view {
2664	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,string)", p0, p1, p2, p3));
2665	 }
2666	 function log(string memory p0, bool p1, bool p2, bool p3) internal view {
2667	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,bool)", p0, p1, p2, p3));
2668	 }
2669	 function log(string memory p0, bool p1, bool p2, address p3) internal view {
2670	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,address)", p0, p1, p2, p3));
2671	 }
2672	 function log(string memory p0, bool p1, address p2, uint p3) internal view {
2673	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,uint)", p0, p1, p2, p3));
2674	 }
2675	 function log(string memory p0, bool p1, address p2, string memory p3) internal view {
2676	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,string)", p0, p1, p2, p3));
2677	 }
2678	 function log(string memory p0, bool p1, address p2, bool p3) internal view {
2679	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,bool)", p0, p1, p2, p3));
2680	 }
2681	 function log(string memory p0, bool p1, address p2, address p3) internal view {
2682	 _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,address)", p0, p1, p2, p3));
2683	 }
2684	 function log(string memory p0, address p1, uint p2, uint p3) internal view {
2685	 _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,uint)", p0, p1, p2, p3));
2686	 }
2687	 function log(string memory p0, address p1, uint p2, string memory p3) internal view {
2688	 _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,string)", p0, p1, p2, p3));
2689	 }
2690	 function log(string memory p0, address p1, uint p2, bool p3) internal view {
2691	 _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,bool)", p0, p1, p2, p3));
2692	 }
2693	 function log(string memory p0, address p1, uint p2, address p3) internal view {
2694	 _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,address)", p0, p1, p2, p3));
2695	 }
2696	 function log(string memory p0, address p1, string memory p2, uint p3) internal view {
2697	 _sendLogPayload(abi.encodeWithSignature("log(string,address,string,uint)", p0, p1, p2, p3));
2698	 }
2699	 function log(string memory p0, address p1, string memory p2, string memory p3) internal view {
2700	 _sendLogPayload(abi.encodeWithSignature("log(string,address,string,string)", p0, p1, p2, p3));
2701	 }
2702	 function log(string memory p0, address p1, string memory p2, bool p3) internal view {
2703	 _sendLogPayload(abi.encodeWithSignature("log(string,address,string,bool)", p0, p1, p2, p3));
2704	 }
2705	 function log(string memory p0, address p1, string memory p2, address p3) internal view {
2706	 _sendLogPayload(abi.encodeWithSignature("log(string,address,string,address)", p0, p1, p2, p3));
2707	 }
2708	 function log(string memory p0, address p1, bool p2, uint p3) internal view {
2709	 _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,uint)", p0, p1, p2, p3));
2710	 }
2711	 function log(string memory p0, address p1, bool p2, string memory p3) internal view {
2712	 _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,string)", p0, p1, p2, p3));
2713	 }
2714	 function log(string memory p0, address p1, bool p2, bool p3) internal view {
2715	 _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,bool)", p0, p1, p2, p3));
2716	 }
2717	 function log(string memory p0, address p1, bool p2, address p3) internal view {
2718	 _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,address)", p0, p1, p2, p3));
2719	 }
2720	 function log(string memory p0, address p1, address p2, uint p3) internal view {
2721	 _sendLogPayload(abi.encodeWithSignature("log(string,address,address,uint)", p0, p1, p2, p3));
2722	 }
2723	 function log(string memory p0, address p1, address p2, string memory p3) internal view {
2724	 _sendLogPayload(abi.encodeWithSignature("log(string,address,address,string)", p0, p1, p2, p3));
2725	 }
2726	 function log(string memory p0, address p1, address p2, bool p3) internal view {
2727	 _sendLogPayload(abi.encodeWithSignature("log(string,address,address,bool)", p0, p1, p2, p3));
2728	 }
2729	 function log(string memory p0, address p1, address p2, address p3) internal view {
2730	 _sendLogPayload(abi.encodeWithSignature("log(string,address,address,address)", p0, p1, p2, p3));
2731	 }
2732	 function log(bool p0, uint p1, uint p2, uint p3) internal view {
2733	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,uint)", p0, p1, p2, p3));
2734	 }
2735	 function log(bool p0, uint p1, uint p2, string memory p3) internal view {
2736	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,string)", p0, p1, p2, p3));
2737	 }
2738	 function log(bool p0, uint p1, uint p2, bool p3) internal view {
2739	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,bool)", p0, p1, p2, p3));
2740	 }
2741	 function log(bool p0, uint p1, uint p2, address p3) internal view {
2742	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,address)", p0, p1, p2, p3));
2743	 }
2744	 function log(bool p0, uint p1, string memory p2, uint p3) internal view {
2745	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,uint)", p0, p1, p2, p3));
2746	 }
2747	 function log(bool p0, uint p1, string memory p2, string memory p3) internal view {
2748	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,string)", p0, p1, p2, p3));
2749	 }
2750	 function log(bool p0, uint p1, string memory p2, bool p3) internal view {
2751	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,bool)", p0, p1, p2, p3));
2752	 }
2753	 function log(bool p0, uint p1, string memory p2, address p3) internal view {
2754	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,address)", p0, p1, p2, p3));
2755	 }
2756	 function log(bool p0, uint p1, bool p2, uint p3) internal view {
2757	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,uint)", p0, p1, p2, p3));
2758	 }
2759	 function log(bool p0, uint p1, bool p2, string memory p3) internal view {
2760	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,string)", p0, p1, p2, p3));
2761	 }
2762	 function log(bool p0, uint p1, bool p2, bool p3) internal view {
2763	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,bool)", p0, p1, p2, p3));
2764	 }
2765	 function log(bool p0, uint p1, bool p2, address p3) internal view {
2766	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,address)", p0, p1, p2, p3));
2767	 }
2768	 function log(bool p0, uint p1, address p2, uint p3) internal view {
2769	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,uint)", p0, p1, p2, p3));
2770	 }
2771	 function log(bool p0, uint p1, address p2, string memory p3) internal view {
2772	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,string)", p0, p1, p2, p3));
2773	 }
2774	 function log(bool p0, uint p1, address p2, bool p3) internal view {
2775	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,bool)", p0, p1, p2, p3));
2776	 }
2777	 function log(bool p0, uint p1, address p2, address p3) internal view {
2778	 _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,address)", p0, p1, p2, p3));
2779	 }
2780	 function log(bool p0, string memory p1, uint p2, uint p3) internal view {
2781	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,uint)", p0, p1, p2, p3));
2782	 }
2783	 function log(bool p0, string memory p1, uint p2, string memory p3) internal view {
2784	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,string)", p0, p1, p2, p3));
2785	 }
2786	 function log(bool p0, string memory p1, uint p2, bool p3) internal view {
2787	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,bool)", p0, p1, p2, p3));
2788	 }
2789	 function log(bool p0, string memory p1, uint p2, address p3) internal view {
2790	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,address)", p0, p1, p2, p3));
2791	 }
2792	 function log(bool p0, string memory p1, string memory p2, uint p3) internal view {
2793	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,uint)", p0, p1, p2, p3));
2794	 }
2795	 function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {
2796	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,string)", p0, p1, p2, p3));
2797	 }
2798	 function log(bool p0, string memory p1, string memory p2, bool p3) internal view {
2799	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,bool)", p0, p1, p2, p3));
2800	 }
2801	 function log(bool p0, string memory p1, string memory p2, address p3) internal view {
2802	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,address)", p0, p1, p2, p3));
2803	 }
2804	 function log(bool p0, string memory p1, bool p2, uint p3) internal view {
2805	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,uint)", p0, p1, p2, p3));
2806	 }
2807	 function log(bool p0, string memory p1, bool p2, string memory p3) internal view {
2808	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,string)", p0, p1, p2, p3));
2809	 }
2810	 function log(bool p0, string memory p1, bool p2, bool p3) internal view {
2811	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,bool)", p0, p1, p2, p3));
2812	 }
2813	 function log(bool p0, string memory p1, bool p2, address p3) internal view {
2814	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,address)", p0, p1, p2, p3));
2815	 }
2816	 function log(bool p0, string memory p1, address p2, uint p3) internal view {
2817	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,uint)", p0, p1, p2, p3));
2818	 }
2819	 function log(bool p0, string memory p1, address p2, string memory p3) internal view {
2820	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,string)", p0, p1, p2, p3));
2821	 }
2822	 function log(bool p0, string memory p1, address p2, bool p3) internal view {
2823	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,bool)", p0, p1, p2, p3));
2824	 }
2825	 function log(bool p0, string memory p1, address p2, address p3) internal view {
2826	 _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,address)", p0, p1, p2, p3));
2827	 }
2828	 function log(bool p0, bool p1, uint p2, uint p3) internal view {
2829	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,uint)", p0, p1, p2, p3));
2830	 }
2831	 function log(bool p0, bool p1, uint p2, string memory p3) internal view {
2832	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,string)", p0, p1, p2, p3));
2833	 }
2834	 function log(bool p0, bool p1, uint p2, bool p3) internal view {
2835	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,bool)", p0, p1, p2, p3));
2836	 }
2837	 function log(bool p0, bool p1, uint p2, address p3) internal view {
2838	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,address)", p0, p1, p2, p3));
2839	 }
2840	 function log(bool p0, bool p1, string memory p2, uint p3) internal view {
2841	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,uint)", p0, p1, p2, p3));
2842	 }
2843	 function log(bool p0, bool p1, string memory p2, string memory p3) internal view {
2844	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,string)", p0, p1, p2, p3));
2845	 }
2846	 function log(bool p0, bool p1, string memory p2, bool p3) internal view {
2847	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,bool)", p0, p1, p2, p3));
2848	 }
2849	 function log(bool p0, bool p1, string memory p2, address p3) internal view {
2850	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,address)", p0, p1, p2, p3));
2851	 }
2852	 function log(bool p0, bool p1, bool p2, uint p3) internal view {
2853	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,uint)", p0, p1, p2, p3));
2854	 }
2855	 function log(bool p0, bool p1, bool p2, string memory p3) internal view {
2856	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,string)", p0, p1, p2, p3));
2857	 }
2858	 function log(bool p0, bool p1, bool p2, bool p3) internal view {
2859	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,bool)", p0, p1, p2, p3));
2860	 }
2861	 function log(bool p0, bool p1, bool p2, address p3) internal view {
2862	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,address)", p0, p1, p2, p3));
2863	 }
2864	 function log(bool p0, bool p1, address p2, uint p3) internal view {
2865	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,uint)", p0, p1, p2, p3));
2866	 }
2867	 function log(bool p0, bool p1, address p2, string memory p3) internal view {
2868	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,string)", p0, p1, p2, p3));
2869	 }
2870	 function log(bool p0, bool p1, address p2, bool p3) internal view {
2871	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,bool)", p0, p1, p2, p3));
2872	 }
2873	 function log(bool p0, bool p1, address p2, address p3) internal view {
2874	 _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,address)", p0, p1, p2, p3));
2875	 }
2876	 function log(bool p0, address p1, uint p2, uint p3) internal view {
2877	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,uint)", p0, p1, p2, p3));
2878	 }
2879	 function log(bool p0, address p1, uint p2, string memory p3) internal view {
2880	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,string)", p0, p1, p2, p3));
2881	 }
2882	 function log(bool p0, address p1, uint p2, bool p3) internal view {
2883	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,bool)", p0, p1, p2, p3));
2884	 }
2885	 function log(bool p0, address p1, uint p2, address p3) internal view {
2886	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,address)", p0, p1, p2, p3));
2887	 }
2888	 function log(bool p0, address p1, string memory p2, uint p3) internal view {
2889	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,uint)", p0, p1, p2, p3));
2890	 }
2891	 function log(bool p0, address p1, string memory p2, string memory p3) internal view {
2892	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,string)", p0, p1, p2, p3));
2893	 }
2894	 function log(bool p0, address p1, string memory p2, bool p3) internal view {
2895	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,bool)", p0, p1, p2, p3));
2896	 }
2897	 function log(bool p0, address p1, string memory p2, address p3) internal view {
2898	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,address)", p0, p1, p2, p3));
2899	 }
2900	 function log(bool p0, address p1, bool p2, uint p3) internal view {
2901	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,uint)", p0, p1, p2, p3));
2902	 }
2903	 function log(bool p0, address p1, bool p2, string memory p3) internal view {
2904	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,string)", p0, p1, p2, p3));
2905	 }
2906	 function log(bool p0, address p1, bool p2, bool p3) internal view {
2907	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,bool)", p0, p1, p2, p3));
2908	 }
2909	 function log(bool p0, address p1, bool p2, address p3) internal view {
2910	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,address)", p0, p1, p2, p3));
2911	 }
2912	 function log(bool p0, address p1, address p2, uint p3) internal view {
2913	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,uint)", p0, p1, p2, p3));
2914	 }
2915	 function log(bool p0, address p1, address p2, string memory p3) internal view {
2916	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,string)", p0, p1, p2, p3));
2917	 }
2918	 function log(bool p0, address p1, address p2, bool p3) internal view {
2919	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,bool)", p0, p1, p2, p3));
2920	 }
2921	 function log(bool p0, address p1, address p2, address p3) internal view {
2922	 _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,address)", p0, p1, p2, p3));
2923	 }
2924	 function log(address p0, uint p1, uint p2, uint p3) internal view {
2925	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,uint)", p0, p1, p2, p3));
2926	 }
2927	 function log(address p0, uint p1, uint p2, string memory p3) internal view {
2928	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,string)", p0, p1, p2, p3));
2929	 }
2930	 function log(address p0, uint p1, uint p2, bool p3) internal view {
2931	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,bool)", p0, p1, p2, p3));
2932	 }
2933	 function log(address p0, uint p1, uint p2, address p3) internal view {
2934	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,address)", p0, p1, p2, p3));
2935	 }
2936	 function log(address p0, uint p1, string memory p2, uint p3) internal view {
2937	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,uint)", p0, p1, p2, p3));
2938	 }
2939	 function log(address p0, uint p1, string memory p2, string memory p3) internal view {
2940	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,string)", p0, p1, p2, p3));
2941	 }
2942	 function log(address p0, uint p1, string memory p2, bool p3) internal view {
2943	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,bool)", p0, p1, p2, p3));
2944	 }
2945	 function log(address p0, uint p1, string memory p2, address p3) internal view {
2946	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,address)", p0, p1, p2, p3));
2947	 }
2948	 function log(address p0, uint p1, bool p2, uint p3) internal view {
2949	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,uint)", p0, p1, p2, p3));
2950	 }
2951	 function log(address p0, uint p1, bool p2, string memory p3) internal view {
2952	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,string)", p0, p1, p2, p3));
2953	 }
2954	 function log(address p0, uint p1, bool p2, bool p3) internal view {
2955	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,bool)", p0, p1, p2, p3));
2956	 }
2957	 function log(address p0, uint p1, bool p2, address p3) internal view {
2958	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,address)", p0, p1, p2, p3));
2959	 }
2960	 function log(address p0, uint p1, address p2, uint p3) internal view {
2961	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,uint)", p0, p1, p2, p3));
2962	 }
2963	 function log(address p0, uint p1, address p2, string memory p3) internal view {
2964	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,string)", p0, p1, p2, p3));
2965	 }
2966	 function log(address p0, uint p1, address p2, bool p3) internal view {
2967	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,bool)", p0, p1, p2, p3));
2968	 }
2969	 function log(address p0, uint p1, address p2, address p3) internal view {
2970	 _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,address)", p0, p1, p2, p3));
2971	 }
2972	 function log(address p0, string memory p1, uint p2, uint p3) internal view {
2973	 _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,uint)", p0, p1, p2, p3));
2974	 }
2975	 function log(address p0, string memory p1, uint p2, string memory p3) internal view {
2976	 _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,string)", p0, p1, p2, p3));
2977	 }
2978	 function log(address p0, string memory p1, uint p2, bool p3) internal view {
2979	 _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,bool)", p0, p1, p2, p3));
2980	 }
2981	 function log(address p0, string memory p1, uint p2, address p3) internal view {
2982	 _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,address)", p0, p1, p2, p3));
2983	 }
2984	 function log(address p0, string memory p1, string memory p2, uint p3) internal view {
2985	 _sendLogPayload(abi.encodeWithSignature("log(address,string,string,uint)", p0, p1, p2, p3));
2986	 }
2987	 function log(address p0, string memory p1, string memory p2, string memory p3) internal view {
2988	 _sendLogPayload(abi.encodeWithSignature("log(address,string,string,string)", p0, p1, p2, p3));
2989	 }
2990	 function log(address p0, string memory p1, string memory p2, bool p3) internal view {
2991	 _sendLogPayload(abi.encodeWithSignature("log(address,string,string,bool)", p0, p1, p2, p3));
2992	 }
2993	 function log(address p0, string memory p1, string memory p2, address p3) internal view {
2994	 _sendLogPayload(abi.encodeWithSignature("log(address,string,string,address)", p0, p1, p2, p3));
2995	 }
2996	 function log(address p0, string memory p1, bool p2, uint p3) internal view {
2997	 _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,uint)", p0, p1, p2, p3));
2998	 }
2999	 function log(address p0, string memory p1, bool p2, string memory p3) internal view {
3000	 _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,string)", p0, p1, p2, p3));
3001	 }
3002	 function log(address p0, string memory p1, bool p2, bool p3) internal view {
3003	 _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,bool)", p0, p1, p2, p3));
3004	 }
3005	 function log(address p0, string memory p1, bool p2, address p3) internal view {
3006	 _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,address)", p0, p1, p2, p3));
3007	 }
3008	 function log(address p0, string memory p1, address p2, uint p3) internal view {
3009	 _sendLogPayload(abi.encodeWithSignature("log(address,string,address,uint)", p0, p1, p2, p3));
3010	 }
3011	 function log(address p0, string memory p1, address p2, string memory p3) internal view {
3012	 _sendLogPayload(abi.encodeWithSignature("log(address,string,address,string)", p0, p1, p2, p3));
3013	 }
3014	 function log(address p0, string memory p1, address p2, bool p3) internal view {
3015	 _sendLogPayload(abi.encodeWithSignature("log(address,string,address,bool)", p0, p1, p2, p3));
3016	 }
3017	 function log(address p0, string memory p1, address p2, address p3) internal view {
3018	 _sendLogPayload(abi.encodeWithSignature("log(address,string,address,address)", p0, p1, p2, p3));
3019	 }
3020	 function log(address p0, bool p1, uint p2, uint p3) internal view {
3021	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,uint)", p0, p1, p2, p3));
3022	 }
3023	 function log(address p0, bool p1, uint p2, string memory p3) internal view {
3024	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,string)", p0, p1, p2, p3));
3025	 }
3026	 function log(address p0, bool p1, uint p2, bool p3) internal view {
3027	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,bool)", p0, p1, p2, p3));
3028	 }
3029	 function log(address p0, bool p1, uint p2, address p3) internal view {
3030	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,address)", p0, p1, p2, p3));
3031	 }
3032	 function log(address p0, bool p1, string memory p2, uint p3) internal view {
3033	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,uint)", p0, p1, p2, p3));
3034	 }
3035	 function log(address p0, bool p1, string memory p2, string memory p3) internal view {
3036	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,string)", p0, p1, p2, p3));
3037	 }
3038	 function log(address p0, bool p1, string memory p2, bool p3) internal view {
3039	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,bool)", p0, p1, p2, p3));
3040	 }
3041	 function log(address p0, bool p1, string memory p2, address p3) internal view {
3042	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,address)", p0, p1, p2, p3));
3043	 }
3044	 function log(address p0, bool p1, bool p2, uint p3) internal view {
3045	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,uint)", p0, p1, p2, p3));
3046	 }
3047	 function log(address p0, bool p1, bool p2, string memory p3) internal view {
3048	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,string)", p0, p1, p2, p3));
3049	 }
3050	 function log(address p0, bool p1, bool p2, bool p3) internal view {
3051	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,bool)", p0, p1, p2, p3));
3052	 }
3053	 function log(address p0, bool p1, bool p2, address p3) internal view {
3054	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,address)", p0, p1, p2, p3));
3055	 }
3056	 function log(address p0, bool p1, address p2, uint p3) internal view {
3057	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,uint)", p0, p1, p2, p3));
3058	 }
3059	 function log(address p0, bool p1, address p2, string memory p3) internal view {
3060	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,string)", p0, p1, p2, p3));
3061	 }
3062	 function log(address p0, bool p1, address p2, bool p3) internal view {
3063	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,bool)", p0, p1, p2, p3));
3064	 }
3065	 function log(address p0, bool p1, address p2, address p3) internal view {
3066	 _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,address)", p0, p1, p2, p3));
3067	 }
3068	 function log(address p0, address p1, uint p2, uint p3) internal view {
3069	 _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,uint)", p0, p1, p2, p3));
3070	 }
3071	 function log(address p0, address p1, uint p2, string memory p3) internal view {
3072	 _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,string)", p0, p1, p2, p3));
3073	 }
3074	 function log(address p0, address p1, uint p2, bool p3) internal view {
3075	 _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,bool)", p0, p1, p2, p3));
3076	 }
3077	 function log(address p0, address p1, uint p2, address p3) internal view {
3078	 _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,address)", p0, p1, p2, p3));
3079	 }
3080	 function log(address p0, address p1, string memory p2, uint p3) internal view {
3081	 _sendLogPayload(abi.encodeWithSignature("log(address,address,string,uint)", p0, p1, p2, p3));
3082	 }
3083	 function log(address p0, address p1, string memory p2, string memory p3) internal view {
3084	 _sendLogPayload(abi.encodeWithSignature("log(address,address,string,string)", p0, p1, p2, p3));
3085	 }
3086	 function log(address p0, address p1, string memory p2, bool p3) internal view {
3087	 _sendLogPayload(abi.encodeWithSignature("log(address,address,string,bool)", p0, p1, p2, p3));
3088	 }
3089	 function log(address p0, address p1, string memory p2, address p3) internal view {
3090	 _sendLogPayload(abi.encodeWithSignature("log(address,address,string,address)", p0, p1, p2, p3));
3091	 }
3092	 function log(address p0, address p1, bool p2, uint p3) internal view {
3093	 _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,uint)", p0, p1, p2, p3));
3094	 }
3095	 function log(address p0, address p1, bool p2, string memory p3) internal view {
3096	 _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,string)", p0, p1, p2, p3));
3097	 }
3098	 function log(address p0, address p1, bool p2, bool p3) internal view {
3099	 _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,bool)", p0, p1, p2, p3));
3100	 }
3101	 function log(address p0, address p1, bool p2, address p3) internal view {
3102	 _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,address)", p0, p1, p2, p3));
3103	 }
3104	 function log(address p0, address p1, address p2, uint p3) internal view {
3105	 _sendLogPayload(abi.encodeWithSignature("log(address,address,address,uint)", p0, p1, p2, p3));
3106	 }
3107	 function log(address p0, address p1, address p2, string memory p3) internal view {
3108	 _sendLogPayload(abi.encodeWithSignature("log(address,address,address,string)", p0, p1, p2, p3));
3109	 }
3110	 function log(address p0, address p1, address p2, bool p3) internal view {
3111	 _sendLogPayload(abi.encodeWithSignature("log(address,address,address,bool)", p0, p1, p2, p3));
3112	 }
3113	 function log(address p0, address p1, address p2, address p3) internal view {
3114	 _sendLogPayload(abi.encodeWithSignature("log(address,address,address,address)", p0, p1, p2, p3));
3115	 }
3116	 }
