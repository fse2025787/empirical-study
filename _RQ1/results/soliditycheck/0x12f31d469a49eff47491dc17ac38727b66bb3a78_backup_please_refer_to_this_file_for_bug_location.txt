row number 
1	 pragma experimental ABIEncoderV2;
2	 pragma solidity ^0.6.0;
3	 interface ERC20 {
4	 function totalSupply() external view returns (uint256 supply);
5	 function balanceOf(address _owner) external view returns (uint256 balance);
6	 function transfer(address _to, uint256 _value) external returns (bool success);
7	 function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);
8	 function approve(address _spender, uint256 _value) external returns (bool success);
9	 function allowance(address _owner, address _spender) external view returns (uint256 remaining);
10	 function decimals() external view returns (uint256 digits);
11	 event Approval(address indexed _owner, address indexed _spender, uint256 _value);
12	 }
13	 library Address {
14	 function isContract(address account) internal view returns (bool) {
15	 bytes32 codehash;
16	 bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
17	 assembly {
18	 codehash := extcodehash(account) }
19	 return (codehash != accountHash && codehash != 0x0);
20	 }
21	 function sendValue(address payable recipient, uint256 amount) internal {
22	 require(address(this).balance >= amount, "Address: insufficient balance");
23	 (bool success, ) = recipient.call{
24	 value: amount }
25	 ("");
26	 require(success, "Address: unable to send value, recipient may have reverted");
27	 }
28	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
29	 return functionCall(target, data, "Address: low-level call failed");
30	 }
31	 function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
32	 return _functionCallWithValue(target, data, 0, errorMessage);
33	 }
34	 function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
35	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
36	 }
37	 function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
38	 require(address(this).balance >= value, "Address: insufficient balance for call");
39	 return _functionCallWithValue(target, data, value, errorMessage);
40	 }
41	 function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {
42	 require(isContract(target), "Address: call to non-contract");
43	 (bool success, bytes memory returndata) = target.call{
44	 value: weiValue }
45	 (data);
46	 if (success) {
47	 return returndata;
48	 }
49	 else {
50	 if (returndata.length > 0) {
51	 assembly {
52	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
53	 }
54	 else {
55	 revert(errorMessage);
56	 }
57	 }
58	 }
59	 }
60	 library SafeMath {
61	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
62	 uint256 c = a + b;
63	 require(c >= a, "SafeMath: addition overflow");
64	 return c;
65	 }
66	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
67	 return sub(a, b, "SafeMath: subtraction overflow");
68	 }
69	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
70	 require(b <= a, errorMessage);
71	 uint256 c = a - b;
72	 return c;
73	 }
74	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
75	 if (a == 0) {
76	 return 0;
77	 }
78	 uint256 c = a * b;
79	 require(c / a == b, "SafeMath: multiplication overflow");
80	 return c;
81	 }
82	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
83	 return div(a, b, "SafeMath: division by zero");
84	 }
85	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
86	 require(b > 0, errorMessage);
87	 uint256 c = a / b;
88	 return c;
89	 }
90	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
91	 return mod(a, b, "SafeMath: modulo by zero");
92	 }
93	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
94	 require(b != 0, errorMessage);
95	 return a % b;
96	 }
97	 }
98	 library SafeERC20 {
99	 using SafeMath for uint256;
100	 using Address for address;
101	 function safeTransfer(ERC20 token, address to, uint256 value) internal {
102	 _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
103	 }
104	 function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {
105	 _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
106	 }
107	 function safeApprove(ERC20 token, address spender, uint256 value) internal {
108	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));
109	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
110	 }
111	 function safeIncreaseAllowance(ERC20 token, address spender, uint256 value) internal {
112	 uint256 newAllowance = token.allowance(address(this), spender).add(value);
113	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
114	 }
115	 function safeDecreaseAllowance(ERC20 token, address spender, uint256 value) internal {
116	 uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
117	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
118	 }
119	 function _callOptionalReturn(ERC20 token, bytes memory data) private {
120	 bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
121	 if (returndata.length > 0) {
122	 require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
123	 }
124	 }
125	 }
126	 abstract contract TokenInterface {
127	 address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
128	 function allowance(address, address) public virtual returns (uint256);
129	 function balanceOf(address) public virtual returns (uint256);
130	 function approve(address, uint256) public virtual;
131	 function transfer(address, uint256) public virtual returns (bool);
132	 function transferFrom(address, address, uint256) public virtual returns (bool);
133	 function deposit() public virtual payable;
134	 function withdraw(uint256) public virtual;
135	 }
136	 abstract contract DSAuthority {
137	 function canCall(address src, address dst, bytes4 sig) public virtual view returns (bool);
138	 }
139	 contract DSAuthEvents {
140	 event LogSetAuthority(address indexed authority);
141	 event LogSetOwner(address indexed owner);
142	 }
143	 contract DSAuth is DSAuthEvents {
144	 DSAuthority public authority;
145	 address public owner;
146	 constructor() public {
147	 owner = msg.sender;
148	 emit LogSetOwner(msg.sender);
149	 }
150	 function setOwner(address owner_) public auth {
151	 owner = owner_;
152	 emit LogSetOwner(owner);
153	 }
154	 function setAuthority(DSAuthority authority_) public auth {
155	 authority = authority_;
156	 emit LogSetAuthority(address(authority));
157	 }
158	 modifier auth {
159	 require(isAuthorized(msg.sender, msg.sig));
160	 _;
161	 }
162	 function isAuthorized(address src, bytes4 sig) internal view returns (bool) {
163	 if (src == address(this)) {
164	 return true;
165	 }
166	 else if (src == owner) {
167	 return true;
168	 }
169	 else if (authority == DSAuthority(0)) {
170	 return false;
171	 }
172	 else {
173	 return authority.canCall(src, address(this), sig);
174	 }
175	 }
176	 }
177	 contract DSNote {
178	 event LogNote( bytes4 indexed sig, address indexed guy, bytes32 indexed foo, bytes32 indexed bar, uint256 wad, bytes fax ) anonymous;
179	 modifier note {
180	 bytes32 foo;
181	 bytes32 bar;
182	 assembly {
183	 foo := calldataload(4) bar := calldataload(36) }
184	 emit LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);
185	 _;
186	 }
187	 }
188	 abstract contract DSProxy is DSAuth, DSNote {
189	 DSProxyCache public cache;
190	 constructor(address _cacheAddr) public {
191	 require(setCache(_cacheAddr));
192	 }
193	 receive() external payable {
194	 }
195	 function execute(address _target, bytes memory _data) public payable virtual returns (bytes32 response);
196	 function setCache(address _cacheAddr) public virtual payable returns (bool);
197	 }
198	 contract DSProxyCache {
199	 mapping(bytes32 => address) cache;
200	 function read(bytes memory _code) public view returns (address) {
201	 bytes32 hash = keccak256(_code);
202	 return cache[hash];
203	 }
204	 function write(bytes memory _code) public returns (address target) {
205	 assembly {
206	 target := create(0, add(_code, 0x20), mload(_code)) switch iszero(extcodesize(target)) case 1 {
207	 revert(0, 0) }
208	 }
209	 bytes32 hash = keccak256(_code);
210	 cache[hash] = target;
211	 }
212	 }
213	 contract DSMath {
214	 function add(uint256 x, uint256 y) internal pure returns (uint256 z) {
215	 require((z = x + y) >= x);
216	 }
217	 function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {
218	 require((z = x - y) <= x);
219	 }
220	 function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {
221	 require(y == 0 || (z = x * y) / y == x);
222	 }
223	 function div(uint256 x, uint256 y) internal pure returns (uint256 z) {
224	 return x / y;
225	 }
226	 function min(uint256 x, uint256 y) internal pure returns (uint256 z) {
227	 return x <= y ? x : y;
228	 }
229	 function max(uint256 x, uint256 y) internal pure returns (uint256 z) {
230	 return x >= y ? x : y;
231	 }
232	 function imin(int256 x, int256 y) internal pure returns (int256 z) {
233	 return x <= y ? x : y;
234	 }
235	 function imax(int256 x, int256 y) internal pure returns (int256 z) {
236	 return x >= y ? x : y;
237	 }
238	 uint256 constant WAD = 10**18;
239	 uint256 constant RAY = 10**27;
240	 function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {
241	 z = add(mul(x, y), WAD / 2) / WAD;
242	 }
243	 function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {
244	 z = add(mul(x, y), RAY / 2) / RAY;
245	 }
246	 function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {
247	 z = add(mul(x, WAD), y / 2) / y;
248	 }
249	 function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {
250	 z = add(mul(x, RAY), y / 2) / y;
251	 }
252	 function rpow(uint256 x, uint256 n) internal pure returns (uint256 z) {
253	 z = n % 2 != 0 ? x : RAY;
254	 for (n /= 2; n != 0; n /= 2) {
255	 x = rmul(x, x);
256	 if (n % 2 != 0) {
257	 z = rmul(z, x);
258	 }
259	 }
260	 }
261	 }
262	 contract Discount {
263	 address public owner;
264	 mapping(address => CustomServiceFee) public serviceFees;
265	 uint256 constant MAX_SERVICE_FEE = 400;
266	 struct CustomServiceFee {
267	 bool active;
268	 uint256 amount;
269	 }
270	 constructor() public {
271	 owner = msg.sender;
272	 }
273	 function isCustomFeeSet(address _user) public view returns (bool) {
274	 return serviceFees[_user].active;
275	 }
276	 function getCustomServiceFee(address _user) public view returns (uint256) {
277	 return serviceFees[_user].amount;
278	 }
279	 function setServiceFee(address _user, uint256 _fee) public {
280	 require(msg.sender == owner, "Only owner");
281	 require(_fee >= MAX_SERVICE_FEE || _fee == 0);
282	 serviceFees[_user] = CustomServiceFee({
283	 active: true, amount: _fee}
284	 );
285	 }
286	 function disableServiceFee(address _user) public {
287	 require(msg.sender == owner, "Only owner");
288	 serviceFees[_user] = CustomServiceFee({
289	 active: false, amount: 0}
290	 );
291	 }
292	 }
293	 abstract contract IFeeRecipient {
294	 function getFeeAddr() public view virtual returns (address);
295	 function changeWalletAddr(address _newWallet) public virtual;
296	 }
297	 abstract contract IAToken {
298	 function redeem(uint256 _amount) external virtual;
299	 function balanceOf(address _owner) external virtual view returns (uint256 balance);
300	 }
301	 interface ILendingPoolAddressesProviderV2 {
302	 event LendingPoolUpdated(address indexed newAddress);
303	 event ConfigurationAdminUpdated(address indexed newAddress);
304	 event EmergencyAdminUpdated(address indexed newAddress);
305	 event LendingPoolConfiguratorUpdated(address indexed newAddress);
306	 event LendingPoolCollateralManagerUpdated(address indexed newAddress);
307	 event PriceOracleUpdated(address indexed newAddress);
308	 event LendingRateOracleUpdated(address indexed newAddress);
309	 event ProxyCreated(bytes32 id, address indexed newAddress);
310	 event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);
311	 function setAddress(bytes32 id, address newAddress) external;
312	 function setAddressAsProxy(bytes32 id, address impl) external;
313	 function getAddress(bytes32 id) external view returns (address);
314	 function getLendingPool() external view returns (address);
315	 function setLendingPoolImpl(address pool) external;
316	 function getLendingPoolConfigurator() external view returns (address);
317	 function setLendingPoolConfiguratorImpl(address configurator) external;
318	 function getLendingPoolCollateralManager() external view returns (address);
319	 function setLendingPoolCollateralManager(address manager) external;
320	 function getPoolAdmin() external view returns (address);
321	 function setPoolAdmin(address admin) external;
322	 function getEmergencyAdmin() external view returns (address);
323	 function setEmergencyAdmin(address admin) external;
324	 function getPriceOracle() external view returns (address);
325	 function setPriceOracle(address priceOracle) external;
326	 function getLendingRateOracle() external view returns (address);
327	 function setLendingRateOracle(address lendingRateOracle) external;
328	 }
329	 library DataTypes {
330	 struct ReserveData {
331	 ReserveConfigurationMap configuration;
332	 uint128 liquidityIndex;
333	 uint128 variableBorrowIndex;
334	 uint128 currentLiquidityRate;
335	 uint128 currentVariableBorrowRate;
336	 uint128 currentStableBorrowRate;
337	 uint40 lastUpdateTimestamp;
338	 address aTokenAddress;
339	 address stableDebtTokenAddress;
340	 address variableDebtTokenAddress;
341	 address interestRateStrategyAddress;
342	 uint8 id;
343	 }
344	 struct ReserveConfigurationMap {
345	 uint256 data;
346	 }
347	 struct UserConfigurationMap {
348	 uint256 data;
349	 }
350	 enum InterestRateMode {
351	 NONE, STABLE, VARIABLE}
352	 }
353	 interface ILendingPoolV2 {
354	 event Deposit( address indexed reserve, address user, address indexed onBehalfOf, uint256 amount, uint16 indexed referral );
355	 event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);
356	 event Borrow( address indexed reserve, address user, address indexed onBehalfOf, uint256 amount, uint256 borrowRateMode, uint256 borrowRate, uint16 indexed referral );
357	 event Repay( address indexed reserve, address indexed user, address indexed repayer, uint256 amount );
358	 event Swap(address indexed reserve, address indexed user, uint256 rateMode);
359	 event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);
360	 event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);
361	 event RebalanceStableBorrowRate(address indexed reserve, address indexed user);
362	 event FlashLoan( address indexed target, address indexed initiator, address indexed asset, uint256 amount, uint256 premium, uint16 referralCode );
363	 event Paused();
364	 event Unpaused();
365	 event LiquidationCall( address indexed collateralAsset, address indexed debtAsset, address indexed user, uint256 debtToCover, uint256 liquidatedCollateralAmount, address liquidator, bool receiveAToken );
366	 event ReserveDataUpdated( address indexed reserve, uint256 liquidityRate, uint256 stableBorrowRate, uint256 variableBorrowRate, uint256 liquidityIndex, uint256 variableBorrowIndex );
367	 function deposit( address asset, uint256 amount, address onBehalfOf, uint16 referralCode ) external;
368	 function withdraw( address asset, uint256 amount, address to ) external;
369	 function borrow( address asset, uint256 amount, uint256 interestRateMode, uint16 referralCode, address onBehalfOf ) external;
370	 function repay( address asset, uint256 amount, uint256 rateMode, address onBehalfOf ) external;
371	 function swapBorrowRateMode(address asset, uint256 rateMode) external;
372	 function rebalanceStableBorrowRate(address asset, address user) external;
373	 function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;
374	 function liquidationCall( address collateralAsset, address debtAsset, address user, uint256 debtToCover, bool receiveAToken ) external;
375	 function flashLoan( address receiverAddress, address[] calldata assets, uint256[] calldata amounts, uint256[] calldata modes, address onBehalfOf, bytes calldata params, uint16 referralCode ) external;
376	 function getUserAccountData(address user) external view returns ( uint256 totalCollateralETH, uint256 totalDebtETH, uint256 availableBorrowsETH, uint256 currentLiquidationThreshold, uint256 ltv, uint256 healthFactor );
377	 function initReserve( address reserve, address aTokenAddress, address stableDebtAddress, address variableDebtAddress, address interestRateStrategyAddress ) external;
378	 function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress) external;
379	 function setConfiguration(address reserve, uint256 configuration) external;
380	 function getConfiguration(address asset) external view returns (DataTypes.ReserveConfigurationMap memory);
381	 function getUserConfiguration(address user) external view returns (DataTypes.UserConfigurationMap memory);
382	 function getReserveNormalizedIncome(address asset) external view returns (uint256);
383	 function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);
384	 function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);
385	 function finalizeTransfer( address asset, address from, address to, uint256 amount, uint256 balanceFromAfter, uint256 balanceToBefore ) external;
386	 function getReservesList() external view returns (address[] memory);
387	 function getAddressesProvider() external view returns (ILendingPoolAddressesProviderV2);
388	 function setPause(bool val) external;
389	 function paused() external view returns (bool);
390	 }
391	 abstract contract IPriceOracleGetterAave {
392	 function getAssetPrice(address _asset) external virtual view returns (uint256);
393	 function getAssetsPrices(address[] calldata _assets) external virtual view returns(uint256[] memory);
394	 function getSourceOfAsset(address _asset) external virtual view returns(address);
395	 function getFallbackOracle() external virtual view returns(address);
396	 }
397	 abstract contract IAaveProtocolDataProviderV2 {
398	 struct TokenData {
399	 string symbol;
400	 address tokenAddress;
401	 }
402	 function getAllReservesTokens() external virtual view returns (TokenData[] memory);
403	 function getAllATokens() external virtual view returns (TokenData[] memory);
404	 function getReserveConfigurationData(address asset) external virtual view returns ( uint256 decimals, uint256 ltv, uint256 liquidationThreshold, uint256 liquidationBonus, uint256 reserveFactor, bool usageAsCollateralEnabled, bool borrowingEnabled, bool stableBorrowRateEnabled, bool isActive, bool isFrozen );
405	 function getReserveData(address asset) external virtual view returns ( uint256 availableLiquidity, uint256 totalStableDebt, uint256 totalVariableDebt, uint256 liquidityRate, uint256 variableBorrowRate, uint256 stableBorrowRate, uint256 averageStableBorrowRate, uint256 liquidityIndex, uint256 variableBorrowIndex, uint40 lastUpdateTimestamp );
406	 function getUserReserveData(address asset, address user) external virtual view returns ( uint256 currentATokenBalance, uint256 currentStableDebt, uint256 currentVariableDebt, uint256 principalStableDebt, uint256 scaledVariableDebt, uint256 stableBorrowRate, uint256 liquidityRate, uint40 stableRateLastUpdated, bool usageAsCollateralEnabled );
407	 function getReserveTokensAddresses(address asset) external virtual view returns ( address aTokenAddress, address stableDebtTokenAddress, address variableDebtTokenAddress );
408	 }
409	 contract AdminAuth {
410	 using SafeERC20 for ERC20;
411	 address public owner;
412	 address public admin;
413	 modifier onlyOwner() {
414	 require(owner == msg.sender);
415	 _;
416	 }
417	 modifier onlyAdmin() {
418	 require(admin == msg.sender);
419	 _;
420	 }
421	 constructor() public {
422	 owner = 0xBc841B0dE0b93205e912CFBBd1D0c160A1ec6F00;
423	 admin = 0x25eFA336886C74eA8E282ac466BdCd0199f85BB9;
424	 }
425	 function setAdminByOwner(address _admin) public {
426	 require(msg.sender == owner);
427	 require(admin == address(0));
428	 admin = _admin;
429	 }
430	 function setAdminByAdmin(address _admin) public {
431	 require(msg.sender == admin);
432	 admin = _admin;
433	 }
434	 function setOwnerByAdmin(address _owner) public {
435	 require(msg.sender == admin);
436	 owner = _owner;
437	 }
438	 function kill() public onlyOwner {
439	 selfdestruct(payable(owner));
440	 }
441	 function withdrawStuckFunds(address _token, uint _amount) public onlyOwner {
442	 if (_token == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {
443	 payable(owner).transfer(_amount);
444	 }
445	 else {
446	 ERC20(_token).safeTransfer(owner, _amount);
447	 }
448	 }
449	 }
450	 contract BotRegistry is AdminAuth {
451	 mapping (address => bool) public botList;
452	 constructor() public {
453	 botList[0x776B4a13093e30B05781F97F6A4565B6aa8BE330] = true;
454	 botList[0xAED662abcC4FA3314985E67Ea993CAD064a7F5cF] = true;
455	 botList[0xa5d330F6619d6bF892A5B87D80272e1607b3e34D] = true;
456	 botList[0x5feB4DeE5150B589a7f567EA7CADa2759794A90A] = true;
457	 botList[0x7ca06417c1d6f480d3bB195B80692F95A6B66158] = true;
458	 }
459	 function setBot(address _botAddr, bool _state) public onlyOwner {
460	 botList[_botAddr] = _state;
461	 }
462	 }
463	 contract AaveHelperV2 is DSMath {
464	 using SafeERC20 for ERC20;
465	 IFeeRecipient public constant feeRecipient = IFeeRecipient(0x39C4a92Dc506300c3Ea4c67ca4CA611102ee6F2A);
466	 address public constant DISCOUNT_ADDR = 0x1b14E8D511c9A4395425314f849bD737BAF8208F;
467	 address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
468	 uint public constant MANUAL_SERVICE_FEE = 400;
469	 uint public constant AUTOMATIC_SERVICE_FEE = 333;
470	 address public constant BOT_REGISTRY_ADDRESS = 0x637726f8b08a7ABE3aE3aCaB01A80E2d8ddeF77B;
471	 address public constant ETH_ADDR = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
472	 uint public constant NINETY_NINE_PERCENT_WEI = 990000000000000000;
473	 uint16 public constant AAVE_REFERRAL_CODE = 64;
474	 uint public constant STABLE_ID = 1;
475	 uint public constant VARIABLE_ID = 2;
476	 function getGasCost(address _oracleAddress, uint _amount, uint _gasCost, address _tokenAddr) internal returns (uint gasCost) {
477	 if (_gasCost == 0) return 0;
478	 address priceToken = _tokenAddr == ETH_ADDR ? WETH_ADDRESS : _tokenAddr;
479	 uint256 price = IPriceOracleGetterAave(_oracleAddress).getAssetPrice(priceToken);
480	 _gasCost = wdiv(_gasCost, price) / (10 ** (18 - _getDecimals(_tokenAddr)));
481	 gasCost = _gasCost;
482	 if (gasCost > (_amount / 5)) {
483	 gasCost = _amount / 5;
484	 }
485	 address walletAddr = feeRecipient.getFeeAddr();
486	 if (gasCost > 0) {
487	 if (_tokenAddr == ETH_ADDR) {
488	 walletAddr.call{
489	 value: gasCost}
490	 ("");
491	 }
492	 else {
493	 ERC20(_tokenAddr).safeTransfer(walletAddr, gasCost);
494	 }
495	 }
496	 }
497	 function getUserAddress() internal view returns (address) {
498	 DSProxy proxy = DSProxy(payable(address(this)));
499	 return proxy.owner();
500	 }
501	 function approveToken(address _tokenAddr, address _caller) internal {
502	 if (_tokenAddr != ETH_ADDR) {
503	 ERC20(_tokenAddr).safeApprove(_caller, uint256(-1));
504	 }
505	 }
506	 function sendContractBalance(address _token, address _user, uint _amount) internal {
507	 if (_amount == 0) return;
508	 if (_token == ETH_ADDR) {
509	 payable(_user).transfer(_amount);
510	 }
511	 else {
512	 ERC20(_token).safeTransfer(_user, _amount);
513	 }
514	 }
515	 function sendFullContractBalance(address _token, address _user) internal {
516	 if (_token == ETH_ADDR) {
517	 sendContractBalance(_token, _user, address(this).balance);
518	 }
519	 else {
520	 sendContractBalance(_token, _user, ERC20(_token).balanceOf(address(this)));
521	 }
522	 }
523	 function _getDecimals(address _token) internal view returns (uint256) {
524	 if (_token == ETH_ADDR) return 18;
525	 return ERC20(_token).decimals();
526	 }
527	 function getDataProvider(address _market) internal view returns(IAaveProtocolDataProviderV2) {
528	 return IAaveProtocolDataProviderV2(ILendingPoolAddressesProviderV2(_market).getAddress(0x0100000000000000000000000000000000000000000000000000000000000000));
529	 }
530	 }
531	 interface ExchangeInterfaceV3 {
532	 function sell(address _srcAddr, address _destAddr, uint _srcAmount, bytes memory _additionalData) external payable returns (uint);
533	 function buy(address _srcAddr, address _destAddr, uint _destAmount, bytes memory _additionalData) external payable returns(uint);
534	 function getSellRate(address _srcAddr, address _destAddr, uint _srcAmount, bytes memory _additionalData) external returns (uint);
535	 function getBuyRate(address _srcAddr, address _destAddr, uint _srcAmount, bytes memory _additionalData) external returns (uint);
536	 }
537	 contract ZrxAllowlist is AdminAuth {
538	 mapping (address => bool) public zrxAllowlist;
539	 mapping(address => bool) private nonPayableAddrs;
540	 constructor() public {
541	 zrxAllowlist[0x6958F5e95332D93D21af0D7B9Ca85B8212fEE0A5] = true;
542	 zrxAllowlist[0x61935CbDd02287B511119DDb11Aeb42F1593b7Ef] = true;
543	 zrxAllowlist[0xDef1C0ded9bec7F1a1670819833240f027b25EfF] = true;
544	 zrxAllowlist[0x080bf510FCbF18b91105470639e9561022937712] = true;
545	 nonPayableAddrs[0x080bf510FCbF18b91105470639e9561022937712] = true;
546	 }
547	 function setAllowlistAddr(address _zrxAddr, bool _state) public onlyOwner {
548	 zrxAllowlist[_zrxAddr] = _state;
549	 }
550	 function isZrxAddr(address _zrxAddr) public view returns (bool) {
551	 return zrxAllowlist[_zrxAddr];
552	 }
553	 function addNonPayableAddr(address _nonPayableAddr) public onlyOwner {
554	 nonPayableAddrs[_nonPayableAddr] = true;
555	 }
556	 function removeNonPayableAddr(address _nonPayableAddr) public onlyOwner {
557	 nonPayableAddrs[_nonPayableAddr] = false;
558	 }
559	 function isNonPayableAddr(address _addr) public view returns(bool) {
560	 return nonPayableAddrs[_addr];
561	 }
562	 }
563	 contract DFSExchangeData {
564	 enum ExchangeType {
565	 _, OASIS, KYBER, UNISWAP, ZEROX }
566	 enum ActionType {
567	 SELL, BUY }
568	 struct OffchainData {
569	 address wrapper;
570	 address exchangeAddr;
571	 address allowanceTarget;
572	 uint256 price;
573	 uint256 protocolFee;
574	 bytes callData;
575	 }
576	 struct ExchangeData {
577	 address srcAddr;
578	 address destAddr;
579	 uint256 srcAmount;
580	 uint256 destAmount;
581	 uint256 minPrice;
582	 uint256 dfsFeeDivider;
583	 address user;
584	 address wrapper;
585	 bytes wrapperData;
586	 OffchainData offchainData;
587	 }
588	 function packExchangeData(ExchangeData memory _exData) public pure returns(bytes memory) {
589	 return abi.encode(_exData);
590	 }
591	 function unpackExchangeData(bytes memory _data) public pure returns(ExchangeData memory _exData) {
592	 _exData = abi.decode(_data, (ExchangeData));
593	 }
594	 }
595	 contract DFSExchangeHelper {
596	 string public constant ERR_OFFCHAIN_DATA_INVALID = "Offchain data invalid";
597	 using SafeERC20 for ERC20;
598	 address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
599	 address public constant EXCHANGE_WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
600	 IFeeRecipient public constant _feeRecipient = IFeeRecipient(0x39C4a92Dc506300c3Ea4c67ca4CA611102ee6F2A);
601	 address public constant DISCOUNT_ADDRESS = 0x1b14E8D511c9A4395425314f849bD737BAF8208F;
602	 address public constant SAVER_EXCHANGE_REGISTRY = 0x25dd3F51e0C3c3Ff164DDC02A8E4D65Bb9cBB12D;
603	 address public constant ZRX_ALLOWLIST_ADDR = 0x4BA1f38427b33B8ab7Bb0490200dAE1F1C36823F;
604	 function getDecimals(address _token) internal view returns (uint256) {
605	 if (_token == KYBER_ETH_ADDRESS) return 18;
606	 return ERC20(_token).decimals();
607	 }
608	 function getBalance(address _tokenAddr) internal view returns (uint balance) {
609	 if (_tokenAddr == KYBER_ETH_ADDRESS) {
610	 balance = address(this).balance;
611	 }
612	 else {
613	 balance = ERC20(_tokenAddr).balanceOf(address(this));
614	 }
615	 }
616	 function sendLeftover(address _srcAddr, address _destAddr, address payable _to) internal {
617	 if (address(this).balance > 0) {
618	 _to.transfer(address(this).balance);
619	 }
620	 if (getBalance(_srcAddr) > 0) {
621	 ERC20(_srcAddr).safeTransfer(_to, getBalance(_srcAddr));
622	 }
623	 if (getBalance(_destAddr) > 0) {
624	 ERC20(_destAddr).safeTransfer(_to, getBalance(_destAddr));
625	 }
626	 }
627	 function getFee(uint256 _amount, address _user, address _token, uint256 _dfsFeeDivider) internal returns (uint256 feeAmount) {
628	 if (_dfsFeeDivider != 0 && Discount(DISCOUNT_ADDRESS).isCustomFeeSet(_user)) {
629	 _dfsFeeDivider = Discount(DISCOUNT_ADDRESS).getCustomServiceFee(_user);
630	 }
631	 if (_dfsFeeDivider == 0) {
632	 feeAmount = 0;
633	 }
634	 else {
635	 feeAmount = _amount / _dfsFeeDivider;
636	 if (feeAmount > (_amount / 10)) {
637	 feeAmount = _amount / 10;
638	 }
639	 address walletAddr = _feeRecipient.getFeeAddr();
640	 if (_token == KYBER_ETH_ADDRESS) {
641	 payable(walletAddr).transfer(feeAmount);
642	 }
643	 else {
644	 ERC20(_token).safeTransfer(walletAddr, feeAmount);
645	 }
646	 }
647	 }
648	 function sliceUint(bytes memory bs, uint256 start) internal pure returns (uint256) {
649	 require(bs.length >= start + 32, "slicing out of range");
650	 uint256 x;
651	 assembly {
652	 x := mload(add(bs, add(0x20, start))) }
653	 return x;
654	 }
655	 function writeUint256(bytes memory _b, uint256 _index, uint _input) internal pure {
656	 if (_b.length < _index + 32) {
657	 revert(ERR_OFFCHAIN_DATA_INVALID);
658	 }
659	 bytes32 input = bytes32(_input);
660	 _index += 32;
661	 assembly {
662	 mstore(add(_b, _index), input) }
663	 }
664	 function ethToWethAddr(address _src) internal pure returns (address) {
665	 return _src == KYBER_ETH_ADDRESS ? EXCHANGE_WETH_ADDRESS : _src;
666	 }
667	 }
668	 contract SaverExchangeRegistry is AdminAuth {
669	 mapping(address => bool) private wrappers;
670	 constructor() public {
671	 wrappers[0x880A845A85F843a5c67DB2061623c6Fc3bB4c511] = true;
672	 wrappers[0x4c9B55f2083629A1F7aDa257ae984E03096eCD25] = true;
673	 wrappers[0x42A9237b872368E1bec4Ca8D26A928D7d39d338C] = true;
674	 }
675	 function addWrapper(address _wrapper) public onlyOwner {
676	 wrappers[_wrapper] = true;
677	 }
678	 function removeWrapper(address _wrapper) public onlyOwner {
679	 wrappers[_wrapper] = false;
680	 }
681	 function isWrapper(address _wrapper) public view returns(bool) {
682	 return wrappers[_wrapper];
683	 }
684	 }
685	 abstract contract OffchainWrapperInterface is DFSExchangeData {
686	 function takeOrder( ExchangeData memory _exData, ActionType _type ) virtual public payable returns (bool success, uint256);
687	 }
688	 contract DFSExchangeCore is DFSExchangeHelper, DSMath, DFSExchangeData {
689	 string public constant ERR_SLIPPAGE_HIT = "Slippage hit";
690	 string public constant ERR_DEST_AMOUNT_MISSING = "Dest amount missing";
691	 string public constant ERR_WRAPPER_INVALID = "Wrapper invalid";
692	 string public constant ERR_NOT_ZEROX_EXCHANGE = "Zerox exchange invalid";
693	 function _sell(ExchangeData memory exData) internal returns (address, uint) {
694	 address wrapper;
695	 uint swapedTokens;
696	 bool success;
697	 if (exData.srcAddr == KYBER_ETH_ADDRESS) {
698	 exData.srcAddr = ethToWethAddr(exData.srcAddr);
699	 TokenInterface(EXCHANGE_WETH_ADDRESS).deposit{
700	 value: exData.srcAmount}
701	 ();
702	 }
703	 exData.srcAmount -= getFee(exData.srcAmount, exData.user, exData.srcAddr, exData.dfsFeeDivider);
704	 if (exData.offchainData.price > 0) {
705	 (success, swapedTokens) = takeOrder(exData, ActionType.SELL);
706	 if (success) {
707	 wrapper = exData.offchainData.exchangeAddr;
708	 }
709	 }
710	 if (!success) {
711	 swapedTokens = saverSwap(exData, ActionType.SELL);
712	 wrapper = exData.wrapper;
713	 }
714	 if (getBalance(EXCHANGE_WETH_ADDRESS) > 0) {
715	 TokenInterface(EXCHANGE_WETH_ADDRESS).withdraw( TokenInterface(EXCHANGE_WETH_ADDRESS).balanceOf(address(this)) );
716	 }
717	 if (exData.destAddr == EXCHANGE_WETH_ADDRESS) {
718	 require(getBalance(KYBER_ETH_ADDRESS) >= wmul(exData.minPrice, exData.srcAmount), ERR_SLIPPAGE_HIT);
719	 }
720	 else {
721	 require(getBalance(exData.destAddr) >= wmul(exData.minPrice, exData.srcAmount), ERR_SLIPPAGE_HIT);
722	 }
723	 return (wrapper, swapedTokens);
724	 }
725	 function _buy(ExchangeData memory exData) internal returns (address, uint) {
726	 address wrapper;
727	 uint swapedTokens;
728	 bool success;
729	 require(exData.destAmount != 0, ERR_DEST_AMOUNT_MISSING);
730	 exData.srcAmount -= getFee(exData.srcAmount, exData.user, exData.srcAddr, exData.dfsFeeDivider);
731	 if (exData.srcAddr == KYBER_ETH_ADDRESS) {
732	 exData.srcAddr = ethToWethAddr(exData.srcAddr);
733	 TokenInterface(EXCHANGE_WETH_ADDRESS).deposit{
734	 value: exData.srcAmount}
735	 ();
736	 }
737	 if (exData.offchainData.price > 0) {
738	 (success, swapedTokens) = takeOrder(exData, ActionType.BUY);
739	 if (success) {
740	 wrapper = exData.offchainData.exchangeAddr;
741	 }
742	 }
743	 if (!success) {
744	 swapedTokens = saverSwap(exData, ActionType.BUY);
745	 wrapper = exData.wrapper;
746	 }
747	 if (getBalance(EXCHANGE_WETH_ADDRESS) > 0) {
748	 TokenInterface(EXCHANGE_WETH_ADDRESS).withdraw( TokenInterface(EXCHANGE_WETH_ADDRESS).balanceOf(address(this)) );
749	 }
750	 if (exData.destAddr == EXCHANGE_WETH_ADDRESS) {
751	 require(getBalance(KYBER_ETH_ADDRESS) >= exData.destAmount, ERR_SLIPPAGE_HIT);
752	 }
753	 else {
754	 require(getBalance(exData.destAddr) >= exData.destAmount, ERR_SLIPPAGE_HIT);
755	 }
756	 return (wrapper, getBalance(exData.destAddr));
757	 }
758	 function takeOrder( ExchangeData memory _exData, ActionType _type ) private returns (bool success, uint256) {
759	 if (!ZrxAllowlist(ZRX_ALLOWLIST_ADDR).isZrxAddr(_exData.offchainData.exchangeAddr)) {
760	 return (false, 0);
761	 }
762	 if (!SaverExchangeRegistry(SAVER_EXCHANGE_REGISTRY).isWrapper(_exData.offchainData.wrapper)) {
763	 return (false, 0);
764	 }
765	 ERC20(_exData.srcAddr).safeTransfer(_exData.offchainData.wrapper, _exData.srcAmount);
766	 return OffchainWrapperInterface(_exData.offchainData.wrapper).takeOrder{
767	 value: _exData.offchainData.protocolFee}
768	 (_exData, _type);
769	 }
770	 function saverSwap(ExchangeData memory _exData, ActionType _type) internal returns (uint swapedTokens) {
771	 require(SaverExchangeRegistry(SAVER_EXCHANGE_REGISTRY).isWrapper(_exData.wrapper), ERR_WRAPPER_INVALID);
772	 ERC20(_exData.srcAddr).safeTransfer(_exData.wrapper, _exData.srcAmount);
773	 if (_type == ActionType.SELL) {
774	 swapedTokens = ExchangeInterfaceV3(_exData.wrapper). sell(_exData.srcAddr, _exData.destAddr, _exData.srcAmount, _exData.wrapperData);
775	 }
776	 else {
777	 swapedTokens = ExchangeInterfaceV3(_exData.wrapper). buy(_exData.srcAddr, _exData.destAddr, _exData.destAmount, _exData.wrapperData);
778	 }
779	 }
780	 receive() external virtual payable {
781	 }
782	 }
783	 contract DefisaverLogger {
784	 event LogEvent( address indexed contractAddress, address indexed caller, string indexed logName, bytes data );
785	 function Log(address _contract, address _caller, string memory _logName, bytes memory _data) public {
786	 emit LogEvent(_contract, _caller, _logName, _data);
787	 }
788	 }
789	 contract AaveSaverReceiverOV2 is AaveHelperV2, AdminAuth, DFSExchangeCore {
790	 using SafeERC20 for ERC20;
791	 address public constant DEFISAVER_LOGGER = 0x5c55B921f590a89C1Ebe84dF170E655a82b62126;
792	 address public constant AAVE_BASIC_PROXY = 0xFF40D4FB79b3B5AD3b0cc2d29D2436A488cA45Ef;
793	 function boost( ExchangeData memory _exchangeData, address _market, uint256 _gasCost, address _proxy ) internal {
794	 uint256 swappedAmount = _exchangeData.srcAmount;
795	 if (_exchangeData.srcAddr != _exchangeData.destAddr) {
796	 (, swappedAmount) = _sell(_exchangeData);
797	 }
798	 swappedAmount = sub(swappedAmount, getGasCost( ILendingPoolAddressesProviderV2(_market).getPriceOracle(), swappedAmount, _gasCost, _exchangeData.destAddr ));
799	 uint256 msgValue = 0;
800	 address token = _exchangeData.destAddr;
801	 if (_exchangeData.destAddr == ETH_ADDR || _exchangeData.destAddr == WETH_ADDRESS) {
802	 msgValue = swappedAmount;
803	 token = ETH_ADDR;
804	 }
805	 else {
806	 ERC20(_exchangeData.destAddr).safeApprove(_proxy, swappedAmount);
807	 }
808	 DSProxy(payable(_proxy)).execute{
809	 value: msgValue}
810	 ( AAVE_BASIC_PROXY, abi.encodeWithSignature( "deposit(address,address,uint256)", _market, token, swappedAmount ) );
811	 logEvent("AaveV2Boost", _exchangeData, swappedAmount);
812	 }
813	 function repay( ExchangeData memory _exchangeData, address _market, uint256 _gasCost, address _proxy, uint256 _rateMode, uint256 _aaveFlashlLoanFee ) internal {
814	 uint256 valueToWithdraw = _exchangeData.srcAmount;
815	 _exchangeData.srcAmount = sub(_exchangeData.srcAmount, _aaveFlashlLoanFee);
816	 uint256 swappedAmount = _exchangeData.srcAmount;
817	 if (_exchangeData.srcAddr != _exchangeData.destAddr) {
818	 (, swappedAmount) = _sell(_exchangeData);
819	 }
820	 address user = DSAuth(_proxy).owner();
821	 swappedAmount = sub(swappedAmount, getGasCost( ILendingPoolAddressesProviderV2(_market).getPriceOracle(), swappedAmount, _gasCost, _exchangeData.destAddr ));
822	 uint256 protocolFeeLeft = address(this).balance;
823	 uint256 msgValue = 0;
824	 if (_exchangeData.destAddr == ETH_ADDR || _exchangeData.destAddr == WETH_ADDRESS) {
825	 protocolFeeLeft = sub(protocolFeeLeft, swappedAmount);
826	 msgValue = swappedAmount;
827	 }
828	 else {
829	 ERC20(_exchangeData.destAddr).safeApprove(_proxy, swappedAmount);
830	 }
831	 DSProxy(payable(_proxy)).execute{
832	 value: msgValue}
833	 ( AAVE_BASIC_PROXY, abi.encodeWithSignature( "paybackAndReturnToUser(address,address,uint256,uint256,address)", _market, _exchangeData.destAddr, swappedAmount, _rateMode, user ) );
834	 DSProxy(payable(_proxy)).execute( AAVE_BASIC_PROXY, abi.encodeWithSignature( "withdraw(address,address,uint256)", _market, _exchangeData.srcAddr, valueToWithdraw ) );
835	 logEvent("AaveV2Repay", _exchangeData, swappedAmount);
836	 }
837	 function executeOperation( address[] calldata, uint256[] calldata, uint256[] calldata premiums, address initiator, bytes calldata params ) public returns (bool) {
838	 ( bytes memory exchangeDataBytes, address market, uint256 gasCost, uint256 rateMode, bool isRepay, address proxy ) = abi.decode(params, (bytes, address, uint256, uint256, bool, address));
839	 address lendingPool = ILendingPoolAddressesProviderV2(market).getLendingPool();
840	 require(msg.sender == lendingPool, "Callbacks only allowed from Aave");
841	 require(initiator == proxy, "Initiator isn't proxy");
842	 ExchangeData memory exData = unpackExchangeData(exchangeDataBytes);
843	 exData.user = DSAuth(proxy).owner();
844	 exData.dfsFeeDivider = MANUAL_SERVICE_FEE;
845	 if (BotRegistry(BOT_REGISTRY_ADDRESS).botList(tx.origin)) {
846	 exData.dfsFeeDivider = AUTOMATIC_SERVICE_FEE;
847	 }
848	 uint256 fee = premiums[0];
849	 uint256 totalValueToReturn = exData.srcAmount + fee;
850	 if (isRepay) {
851	 repay(exData, market, gasCost, proxy, rateMode, fee);
852	 address token = exData.srcAddr;
853	 if (token == ETH_ADDR || token == WETH_ADDRESS) {
854	 TokenInterface(WETH_ADDRESS).deposit.value(totalValueToReturn)();
855	 token = WETH_ADDRESS;
856	 }
857	 ERC20(token).safeApprove(lendingPool, totalValueToReturn);
858	 }
859	 else {
860	 boost(exData, market, gasCost, proxy);
861	 }
862	 tx.origin.transfer(address(this).balance);
863	 return true;
864	 }
865	 function logEvent(string memory _name, ExchangeData memory _exchangeData, uint _swappedAmount) internal {
866	 DefisaverLogger(DEFISAVER_LOGGER).Log( address(this), msg.sender, _name, abi.encode(_exchangeData.srcAddr, _exchangeData.destAddr, _exchangeData.srcAmount, _swappedAmount) );
867	 }
868	 receive() external payable override {
869	 }
870	 }
