row number 
1	  pragma abicoder v2;
2	 pragma solidity >=0.6.0 <0.8.0;
3	 interface IERC20 {
4	 function totalSupply() external view returns (uint256);
5	 function balanceOf(address account) external view returns (uint256);
6	 function transfer(address recipient, uint256 amount) external returns (bool);
7	 function allowance(address owner, address spender) external view returns (uint256);
8	 function approve(address spender, uint256 amount) external returns (bool);
9	 function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
10	 event Transfer(address indexed from, address indexed to, uint256 value);
11	 event Approval(address indexed owner, address indexed spender, uint256 value);
12	 }
13	 pragma solidity >=0.6.0 <0.8.0;
14	 abstract contract Context {
15	 function _msgSender() internal view virtual returns (address payable) {
16	 return msg.sender;
17	 }
18	 function _msgData() internal view virtual returns (bytes memory) {
19	 this;
20	 return msg.data;
21	 }
22	 }
23	 pragma solidity >=0.6.0 <0.8.0;
24	 contract ERC20 is Context, IERC20 {
25	 using SafeMath for uint256;
26	 mapping (address => uint256) private _balances;
27	 mapping (address => mapping (address => uint256)) private _allowances;
28	 uint256 private _totalSupply;
29	 string private _name;
30	 string private _symbol;
31	 uint8 private _decimals;
32	 constructor (string memory name_, string memory symbol_) public {
33	 _name = name_;
34	 _symbol = symbol_;
35	 _decimals = 18;
36	 }
37	 function name() public view virtual returns (string memory) {
38	 return _name;
39	 }
40	 function symbol() public view virtual returns (string memory) {
41	 return _symbol;
42	 }
43	 function decimals() public view virtual returns (uint8) {
44	 return _decimals;
45	 }
46	 function totalSupply() public view virtual override returns (uint256) {
47	 return _totalSupply;
48	 }
49	 function balanceOf(address account) public view virtual override returns (uint256) {
50	 return _balances[account];
51	 }
52	 function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
53	 _transfer(_msgSender(), recipient, amount);
54	 return true;
55	 }
56	 function allowance(address owner, address spender) public view virtual override returns (uint256) {
57	 return _allowances[owner][spender];
58	 }
59	 function approve(address spender, uint256 amount) public virtual override returns (bool) {
60	 _approve(_msgSender(), spender, amount);
61	 return true;
62	 }
63	 function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
64	 _transfer(sender, recipient, amount);
65	 _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
66	 return true;
67	 }
68	 function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
69	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
70	 return true;
71	 }
72	 function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
73	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
74	 return true;
75	 }
76	 function _transfer(address sender, address recipient, uint256 amount) internal virtual {
77	 require(sender != address(0), "ERC20: transfer from the zero address");
78	 require(recipient != address(0), "ERC20: transfer to the zero address");
79	 _beforeTokenTransfer(sender, recipient, amount);
80	 _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
81	 _balances[recipient] = _balances[recipient].add(amount);
82	 emit Transfer(sender, recipient, amount);
83	 }
84	 function _mint(address account, uint256 amount) internal virtual {
85	 require(account != address(0), "ERC20: mint to the zero address");
86	 _beforeTokenTransfer(address(0), account, amount);
87	 _totalSupply = _totalSupply.add(amount);
88	 _balances[account] = _balances[account].add(amount);
89	 emit Transfer(address(0), account, amount);
90	 }
91	 function _burn(address account, uint256 amount) internal virtual {
92	 require(account != address(0), "ERC20: burn from the zero address");
93	 _beforeTokenTransfer(account, address(0), amount);
94	 _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
95	 _totalSupply = _totalSupply.sub(amount);
96	 emit Transfer(account, address(0), amount);
97	 }
98	 function _approve(address owner, address spender, uint256 amount) internal virtual {
99	 require(owner != address(0), "ERC20: approve from the zero address");
100	 require(spender != address(0), "ERC20: approve to the zero address");
101	 _allowances[owner][spender] = amount;
102	 emit Approval(owner, spender, amount);
103	 }
104	 function _setupDecimals(uint8 decimals_) internal virtual {
105	 _decimals = decimals_;
106	 }
107	 function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {
108	 }
109	 }
110	 pragma solidity >=0.5.0;
111	 interface IUniswapV3MintCallback {
112	 function uniswapV3MintCallback( uint256 amount0Owed, uint256 amount1Owed, bytes calldata data ) external;
113	 }
114	 pragma solidity >=0.5.0;
115	 interface IUniswapV3SwapCallback {
116	 function uniswapV3SwapCallback( int256 amount0Delta, int256 amount1Delta, bytes calldata data ) external;
117	 }
118	 pragma solidity 0.7.6;
119	 interface IVault {
120	 function deposit( uint256, uint256, address ) external returns (uint256);
121	 function withdraw( uint256, address, address ) external returns (uint256, uint256);
122	 function rebalance( int24 _baseLower, int24 _baseUpper, int24 _limitLower, int24 _limitUpper, address feeRecipient, int256 swapQuantity ) external;
123	 function getTotalAmounts() external view returns (uint256, uint256);
124	 event Deposit( address indexed sender, address indexed to, uint256 shares, uint256 amount0, uint256 amount1 );
125	 event Withdraw( address indexed sender, address indexed to, uint256 shares, uint256 amount0, uint256 amount1 );
126	 event Rebalance( int24 tick, uint256 totalAmount0, uint256 totalAmount1, uint256 feeAmount0, uint256 feeAmount1, uint256 totalSupply );
127	 }
128	 pragma solidity >=0.5.0;
129	 interface IUniswapV3PoolImmutables {
130	 function factory() external view returns (address);
131	 function token0() external view returns (address);
132	 function token1() external view returns (address);
133	 function fee() external view returns (uint24);
134	 function tickSpacing() external view returns (int24);
135	 function maxLiquidityPerTick() external view returns (uint128);
136	 }
137	 pragma solidity >=0.5.0;
138	 interface IUniswapV3PoolState {
139	 function slot0() external view returns ( uint160 sqrtPriceX96, int24 tick, uint16 observationIndex, uint16 observationCardinality, uint16 observationCardinalityNext, uint8 feeProtocol, bool unlocked );
140	 function feeGrowthGlobal0X128() external view returns (uint256);
141	 function feeGrowthGlobal1X128() external view returns (uint256);
142	 function protocolFees() external view returns (uint128 token0, uint128 token1);
143	 function liquidity() external view returns (uint128);
144	 function ticks(int24 tick) external view returns ( uint128 liquidityGross, int128 liquidityNet, uint256 feeGrowthOutside0X128, uint256 feeGrowthOutside1X128, int56 tickCumulativeOutside, uint160 secondsPerLiquidityOutsideX128, uint32 secondsOutside, bool initialized );
145	 function tickBitmap(int16 wordPosition) external view returns (uint256);
146	 function positions(bytes32 key) external view returns ( uint128 _liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, uint128 tokensOwed0, uint128 tokensOwed1 );
147	 function observations(uint256 index) external view returns ( uint32 blockTimestamp, int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128, bool initialized );
148	 }
149	 pragma solidity >=0.5.0;
150	 interface IUniswapV3PoolDerivedState {
151	 function observe(uint32[] calldata secondsAgos) external view returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);
152	 function snapshotCumulativesInside(int24 tickLower, int24 tickUpper) external view returns ( int56 tickCumulativeInside, uint160 secondsPerLiquidityInsideX128, uint32 secondsInside );
153	 }
154	 pragma solidity >=0.5.0;
155	 interface IUniswapV3PoolActions {
156	 function initialize(uint160 sqrtPriceX96) external;
157	 function mint( address recipient, int24 tickLower, int24 tickUpper, uint128 amount, bytes calldata data ) external returns (uint256 amount0, uint256 amount1);
158	 function collect( address recipient, int24 tickLower, int24 tickUpper, uint128 amount0Requested, uint128 amount1Requested ) external returns (uint128 amount0, uint128 amount1);
159	 function burn( int24 tickLower, int24 tickUpper, uint128 amount ) external returns (uint256 amount0, uint256 amount1);
160	 function swap( address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes calldata data ) external returns (int256 amount0, int256 amount1);
161	 function flash( address recipient, uint256 amount0, uint256 amount1, bytes calldata data ) external;
162	 function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;
163	 }
164	 pragma solidity >=0.5.0;
165	 interface IUniswapV3PoolOwnerActions {
166	 function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;
167	 function collectProtocol( address recipient, uint128 amount0Requested, uint128 amount1Requested ) external returns (uint128 amount0, uint128 amount1);
168	 }
169	 pragma solidity >=0.5.0;
170	 interface IUniswapV3PoolEvents {
171	 event Initialize(uint160 sqrtPriceX96, int24 tick);
172	 event Mint( address sender, address indexed owner, int24 indexed tickLower, int24 indexed tickUpper, uint128 amount, uint256 amount0, uint256 amount1 );
173	 event Collect( address indexed owner, address recipient, int24 indexed tickLower, int24 indexed tickUpper, uint128 amount0, uint128 amount1 );
174	 event Burn( address indexed owner, int24 indexed tickLower, int24 indexed tickUpper, uint128 amount, uint256 amount0, uint256 amount1 );
175	 event Swap( address indexed sender, address indexed recipient, int256 amount0, int256 amount1, uint160 sqrtPriceX96, uint128 liquidity, int24 tick );
176	 event Flash( address indexed sender, address indexed recipient, uint256 amount0, uint256 amount1, uint256 paid0, uint256 paid1 );
177	 event IncreaseObservationCardinalityNext( uint16 observationCardinalityNextOld, uint16 observationCardinalityNextNew );
178	 event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);
179	 event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);
180	 }
181	 pragma solidity 0.7.6;
182	 contract Hypervisor is IVault, IUniswapV3MintCallback, IUniswapV3SwapCallback, ERC20 {
183	 using SafeERC20 for IERC20;
184	 using SafeMath for uint256;
185	 using SignedSafeMath for int256;
186	 IUniswapV3Pool public pool;
187	 IERC20 public token0;
188	 IERC20 public token1;
189	 uint24 public fee;
190	 int24 public tickSpacing;
191	 int24 public baseLower;
192	 int24 public baseUpper;
193	 int24 public limitLower;
194	 int24 public limitUpper;
195	 address public owner;
196	 uint256 public deposit0Max;
197	 uint256 public deposit1Max;
198	 uint256 public maxTotalSupply;
199	 mapping(address=>bool) public list;
200	 bool public whitelisted;
201	 uint256 constant public PRECISION = 1e36;
202	 constructor( address _pool, address _owner, string memory name, string memory symbol ) ERC20(name, symbol) {
203	 pool = IUniswapV3Pool(_pool);
204	 token0 = IERC20(pool.token0());
205	 token1 = IERC20(pool.token1());
206	 fee = pool.fee();
207	 tickSpacing = pool.tickSpacing();
208	 owner = _owner;
209	 maxTotalSupply = 0;
210	 deposit0Max = uint256(-1);
211	 deposit1Max = uint256(-1);
212	 whitelisted = false;
213	 }
214	 function deposit( uint256 deposit0, uint256 deposit1, address to ) external override returns (uint256 shares) {
215	 require(deposit0 > 0 || deposit1 > 0, "deposits must be nonzero");
216	 require(deposit0 < deposit0Max && deposit1 < deposit1Max, "deposits must be less than maximum amounts");
217	 require(to != address(0) && to != address(this), "to");
218	 if(whitelisted) {
219	 require(list[to], "must be on the list");
220	 }
221	 (uint128 baseLiquidity,,) = _position(baseLower, baseUpper);
222	 if (baseLiquidity > 0) {
223	 pool.burn(baseLower, baseUpper, 0);
224	 }
225	 (uint128 limitLiquidity,,) = _position(limitLower, limitUpper);
226	 if (limitLiquidity > 0) {
227	 pool.burn(limitLower, limitUpper, 0);
228	 }
229	 uint160 sqrtPrice = TickMath.getSqrtRatioAtTick(currentTick());
230	 uint256 price = FullMath.mulDiv(uint256(sqrtPrice).mul(uint256(sqrtPrice)), PRECISION, 2**(96 * 2));
231	 (uint256 pool0, uint256 pool1) = getTotalAmounts();
232	 uint256 deposit0PricedInToken1 = deposit0.mul(price).div(PRECISION);
233	 shares = deposit1.add(deposit0PricedInToken1);
234	 if (deposit0 > 0) {
235	 token0.safeTransferFrom(msg.sender, address(this), deposit0);
236	 }
237	 if (deposit1 > 0) {
238	 token1.safeTransferFrom(msg.sender, address(this), deposit1);
239	 }
240	 if (totalSupply() != 0) {
241	 uint256 pool0PricedInToken1 = pool0.mul(price).div(PRECISION);
242	 shares = shares.mul(totalSupply()).div(pool0PricedInToken1.add(pool1));
243	 }
244	 _mint(to, shares);
245	 emit Deposit(msg.sender, to, shares, deposit0, deposit1);
246	 require(maxTotalSupply == 0 || totalSupply() <= maxTotalSupply, "maxTotalSupply");
247	 }
248	 function withdraw( uint256 shares, address to, address from ) external override returns (uint256 amount0, uint256 amount1) {
249	 require(shares > 0, "shares");
250	 require(to != address(0), "to");
251	 (uint256 base0, uint256 base1) = _burnLiquidity(baseLower, baseUpper, _liquidityForShares(baseLower, baseUpper, shares), to, false);
252	 (uint256 limit0, uint256 limit1) = _burnLiquidity(limitLower, limitUpper, _liquidityForShares(limitLower, limitUpper, shares), to, false);
253	 uint256 totalSupply = totalSupply();
254	 uint256 unusedAmount0 = token0.balanceOf(address(this)).mul(shares).div(totalSupply);
255	 uint256 unusedAmount1 = token1.balanceOf(address(this)).mul(shares).div(totalSupply);
256	 if (unusedAmount0 > 0) token0.safeTransfer(to, unusedAmount0);
257	 if (unusedAmount1 > 0) token1.safeTransfer(to, unusedAmount1);
258	 amount0 = base0.add(limit0).add(unusedAmount0);
259	 amount1 = base1.add(limit1).add(unusedAmount1);
260	 require(from == msg.sender || IUniversalVault(from).owner() == msg.sender, "Sender must own the tokens");
261	 _burn(from, shares);
262	 emit Withdraw(from, to, shares, amount0, amount1);
263	 }
264	 function rebalance( int24 _baseLower, int24 _baseUpper, int24 _limitLower, int24 _limitUpper, address feeRecipient, int256 swapQuantity ) external override onlyOwner {
265	 require(_baseLower < _baseUpper && _baseLower % tickSpacing == 0 && _baseUpper % tickSpacing == 0, "base position invalid");
266	 require(_limitLower < _limitUpper && _limitLower % tickSpacing == 0 && _limitUpper % tickSpacing == 0, "limit position invalid");
267	 (uint128 baseLiquidity,,) = _position(baseLower, baseUpper);
268	 if (baseLiquidity > 0) {
269	 pool.burn(baseLower, baseUpper, 0);
270	 }
271	 (uint128 limitLiquidity,,) = _position(limitLower, limitUpper);
272	 if (limitLiquidity > 0) {
273	 pool.burn(limitLower, limitUpper, 0);
274	 }
275	 (, uint256 feesLimit0, uint256 feesLimit1) = _position(baseLower, baseUpper);
276	 (, uint256 feesBase0, uint256 feesBase1) = _position(limitLower, limitUpper);
277	 uint256 fees0 = feesBase0.add(feesLimit0);
278	 uint256 fees1 = feesBase1.add(feesLimit1);
279	 _burnLiquidity(baseLower, baseUpper, baseLiquidity, address(this), true);
280	 _burnLiquidity(limitLower, limitUpper, limitLiquidity, address(this), true);
281	 if(fees0 > 0) token0.safeTransfer(feeRecipient, fees0.div(90));
282	 if(fees1 > 0) token1.safeTransfer(feeRecipient, fees1.div(90));
283	 emit Rebalance( currentTick(), token0.balanceOf(address(this)), token1.balanceOf(address(this)), fees0, fees1, totalSupply() );
284	 if (swapQuantity != 0) {
285	 pool.swap( address(this), swapQuantity > 0, swapQuantity > 0 ? swapQuantity : -swapQuantity, swapQuantity > 0 ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1, abi.encode(address(this)) );
286	 }
287	 baseLower = _baseLower;
288	 baseUpper = _baseUpper;
289	 baseLiquidity = _liquidityForAmounts( baseLower, baseUpper, token0.balanceOf(address(this)), token1.balanceOf(address(this)) );
290	 _mintLiquidity(baseLower, baseUpper, baseLiquidity, address(this));
291	 limitLower = _limitLower;
292	 limitUpper = _limitUpper;
293	 limitLiquidity = _liquidityForAmounts( limitLower, limitUpper, token0.balanceOf(address(this)), token1.balanceOf(address(this)) );
294	 _mintLiquidity(limitLower, limitUpper, limitLiquidity, address(this));
295	 }
296	 function _mintLiquidity( int24 tickLower, int24 tickUpper, uint128 liquidity, address payer ) internal returns (uint256 amount0, uint256 amount1) {
297	 if (liquidity > 0) {
298	 (amount0, amount1) = pool.mint( address(this), tickLower, tickUpper, liquidity, abi.encode(payer) );
299	 }
300	 }
301	 function _burnLiquidity( int24 tickLower, int24 tickUpper, uint128 liquidity, address to, bool collectAll ) internal returns (uint256 amount0, uint256 amount1) {
302	 if (liquidity > 0) {
303	 (uint256 owed0, uint256 owed1) = pool.burn(tickLower, tickUpper, liquidity);
304	 uint128 collect0 = collectAll ? type(uint128).max : _uint128Safe(owed0);
305	 uint128 collect1 = collectAll ? type(uint128).max : _uint128Safe(owed1);
306	 if (collect0 > 0 || collect1 > 0) {
307	 (amount0, amount1) = pool.collect(to, tickLower, tickUpper, collect0, collect1);
308	 }
309	 }
310	 }
311	 function _liquidityForShares( int24 tickLower, int24 tickUpper, uint256 shares ) internal view returns (uint128) {
312	 (uint128 position,,) = _position(tickLower, tickUpper);
313	 return _uint128Safe(uint256(position).mul(shares).div(totalSupply()));
314	 }
315	 function _position(int24 tickLower, int24 tickUpper) internal view returns (uint128 liquidity, uint128 tokensOwed0, uint128 tokensOwed1) {
316	 bytes32 positionKey = keccak256(abi.encodePacked(address(this), tickLower, tickUpper));
317	 (liquidity, , , tokensOwed0, tokensOwed1) = pool.positions(positionKey);
318	 }
319	 function uniswapV3MintCallback( uint256 amount0, uint256 amount1, bytes calldata data ) external override {
320	 require(msg.sender == address(pool));
321	 address payer = abi.decode(data, (address));
322	 if (payer == address(this)) {
323	 if (amount0 > 0) token0.safeTransfer(msg.sender, amount0);
324	 if (amount1 > 0) token1.safeTransfer(msg.sender, amount1);
325	 }
326	 else {
327	 if (amount0 > 0) token0.safeTransferFrom(payer, msg.sender, amount0);
328	 if (amount1 > 0) token1.safeTransferFrom(payer, msg.sender, amount1);
329	 }
330	 }
331	 function uniswapV3SwapCallback( int256 amount0Delta, int256 amount1Delta, bytes calldata data ) external override {
332	 require(msg.sender == address(pool));
333	 address payer = abi.decode(data, (address));
334	 if (amount0Delta > 0) {
335	 if (payer == address(this)) {
336	 token0.safeTransfer(msg.sender, uint256(amount0Delta));
337	 }
338	 else {
339	 token0.safeTransferFrom(payer, msg.sender, uint256(amount0Delta));
340	 }
341	 }
342	 else if (amount1Delta > 0) {
343	 if (payer == address(this)) {
344	 token1.safeTransfer(msg.sender, uint256(amount1Delta));
345	 }
346	 else {
347	 token1.safeTransferFrom(payer, msg.sender, uint256(amount1Delta));
348	 }
349	 }
350	 }
351	 function getTotalAmounts() public view override returns (uint256 total0, uint256 total1) {
352	 (, uint256 base0, uint256 base1) = getBasePosition();
353	 (, uint256 limit0, uint256 limit1) = getLimitPosition();
354	 total0 = token0.balanceOf(address(this)).add(base0).add(limit0);
355	 total1 = token1.balanceOf(address(this)).add(base1).add(limit1);
356	 }
357	 function getBasePosition() public view returns ( uint128 liquidity, uint256 amount0, uint256 amount1 ) {
358	 (uint128 positionLiquidity, uint128 tokensOwed0, uint128 tokensOwed1) = _position(baseLower, baseUpper);
359	 (amount0, amount1) = _amountsForLiquidity(baseLower, baseUpper, positionLiquidity);
360	 amount0 = amount0.add(uint256(tokensOwed0));
361	 amount1 = amount1.add(uint256(tokensOwed1));
362	 liquidity = positionLiquidity;
363	 }
364	 function getLimitPosition() public view returns ( uint128 liquidity, uint256 amount0, uint256 amount1 ) {
365	 (uint128 positionLiquidity, uint128 tokensOwed0, uint128 tokensOwed1) = _position(limitLower, limitUpper);
366	 (amount0, amount1) = _amountsForLiquidity(limitLower, limitUpper, positionLiquidity);
367	 amount0 = amount0.add(uint256(tokensOwed0));
368	 amount1 = amount1.add(uint256(tokensOwed1));
369	 liquidity = positionLiquidity;
370	 }
371	 function _amountsForLiquidity( int24 tickLower, int24 tickUpper, uint128 liquidity ) internal view returns (uint256, uint256) {
372	 (uint160 sqrtRatioX96, , , , , , ) = pool.slot0();
373	 return LiquidityAmounts.getAmountsForLiquidity( sqrtRatioX96, TickMath.getSqrtRatioAtTick(tickLower), TickMath.getSqrtRatioAtTick(tickUpper), liquidity );
374	 }
375	 function _liquidityForAmounts( int24 tickLower, int24 tickUpper, uint256 amount0, uint256 amount1 ) internal view returns (uint128) {
376	 (uint160 sqrtRatioX96, , , , , , ) = pool.slot0();
377	 return LiquidityAmounts.getLiquidityForAmounts( sqrtRatioX96, TickMath.getSqrtRatioAtTick(tickLower), TickMath.getSqrtRatioAtTick(tickUpper), amount0, amount1 );
378	 }
379	 function currentTick() public view returns (int24 tick) {
380	 (, tick, , , , , ) = pool.slot0();
381	 }
382	 function _uint128Safe(uint256 x) internal pure returns (uint128) {
383	 assert(x <= type(uint128).max);
384	 return uint128(x);
385	 }
386	 function setMaxTotalSupply(uint256 _maxTotalSupply) external onlyOwner {
387	 maxTotalSupply = _maxTotalSupply;
388	 }
389	 function setDepositMax(uint256 _deposit0Max, uint256 _deposit1Max) external onlyOwner {
390	 deposit0Max = _deposit0Max;
391	 deposit1Max = _deposit1Max;
392	 }
393	 function appendList(address[] memory listed) external onlyOwner {
394	 for (uint8 i; i < listed.length; i++) {
395	 list[listed[i]] = true;
396	 }
397	 }
398	 function toggleWhitelist() external onlyOwner {
399	 whitelisted = whitelisted ? false : true;
400	 }
401	 function transferOwnership(address newOwner) external onlyOwner {
402	 owner = newOwner;
403	 }
404	 modifier onlyOwner {
405	 require(msg.sender == owner, "only owner");
406	 _;
407	 }
408	 }
409	 pragma solidity >=0.6.0 <0.8.0;
410	 library SafeMath {
411	 function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
412	 uint256 c = a + b;
413	 if (c < a) return (false, 0);
414	 return (true, c);
415	 }
416	 function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
417	 if (b > a) return (false, 0);
418	 return (true, a - b);
419	 }
420	 function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
421	 if (a == 0) return (true, 0);
422	 uint256 c = a * b;
423	 if (c / a != b) return (false, 0);
424	 return (true, c);
425	 }
426	 function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
427	 if (b == 0) return (false, 0);
428	 return (true, a / b);
429	 }
430	 function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
431	 if (b == 0) return (false, 0);
432	 return (true, a % b);
433	 }
434	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
435	 uint256 c = a + b;
436	 require(c >= a, "SafeMath: addition overflow");
437	 return c;
438	 }
439	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
440	 require(b <= a, "SafeMath: subtraction overflow");
441	 return a - b;
442	 }
443	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
444	 if (a == 0) return 0;
445	 uint256 c = a * b;
446	 require(c / a == b, "SafeMath: multiplication overflow");
447	 return c;
448	 }
449	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
450	 require(b > 0, "SafeMath: division by zero");
451	 return a / b;
452	 }
453	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
454	 require(b > 0, "SafeMath: modulo by zero");
455	 return a % b;
456	 }
457	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
458	 require(b <= a, errorMessage);
459	 return a - b;
460	 }
461	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
462	 require(b > 0, errorMessage);
463	 return a / b;
464	 }
465	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
466	 require(b > 0, errorMessage);
467	 return a % b;
468	 }
469	 }
470	 pragma solidity >=0.6.0 <0.8.0;
471	 library SignedSafeMath {
472	 int256 constant private _INT256_MIN = -2**255;
473	 function mul(int256 a, int256 b) internal pure returns (int256) {
474	 if (a == 0) {
475	 return 0;
476	 }
477	 require(!(a == -1 && b == _INT256_MIN), "SignedSafeMath: multiplication overflow");
478	 int256 c = a * b;
479	 require(c / a == b, "SignedSafeMath: multiplication overflow");
480	 return c;
481	 }
482	 function div(int256 a, int256 b) internal pure returns (int256) {
483	 require(b != 0, "SignedSafeMath: division by zero");
484	 require(!(b == -1 && a == _INT256_MIN), "SignedSafeMath: division overflow");
485	 int256 c = a / b;
486	 return c;
487	 }
488	 function sub(int256 a, int256 b) internal pure returns (int256) {
489	 int256 c = a - b;
490	 require((b >= 0 && c <= a) || (b < 0 && c > a), "SignedSafeMath: subtraction overflow");
491	 return c;
492	 }
493	 function add(int256 a, int256 b) internal pure returns (int256) {
494	 int256 c = a + b;
495	 require((b >= 0 && c >= a) || (b < 0 && c < a), "SignedSafeMath: addition overflow");
496	 return c;
497	 }
498	 }
499	 pragma solidity >=0.6.0 <0.8.0;
500	 library SafeERC20 {
501	 using SafeMath for uint256;
502	 using Address for address;
503	 function safeTransfer(IERC20 token, address to, uint256 value) internal {
504	 _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
505	 }
506	 function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
507	 _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
508	 }
509	 function safeApprove(IERC20 token, address spender, uint256 value) internal {
510	 require((value == 0) || (token.allowance(address(this), spender) == 0), "SafeERC20: approve from non-zero to non-zero allowance" );
511	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
512	 }
513	 function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
514	 uint256 newAllowance = token.allowance(address(this), spender).add(value);
515	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
516	 }
517	 function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
518	 uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
519	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
520	 }
521	 function _callOptionalReturn(IERC20 token, bytes memory data) private {
522	 bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
523	 if (returndata.length > 0) {
524	 require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
525	 }
526	 }
527	 }
528	 pragma solidity >=0.5.0;
529	 interface IUniswapV3Pool is IUniswapV3PoolImmutables, IUniswapV3PoolState, IUniswapV3PoolDerivedState, IUniswapV3PoolActions, IUniswapV3PoolOwnerActions, IUniswapV3PoolEvents {
530	 }
531	 pragma solidity >=0.5.0;
532	 library TickMath {
533	 int24 internal constant MIN_TICK = -887272;
534	 int24 internal constant MAX_TICK = -MIN_TICK;
535	 uint160 internal constant MIN_SQRT_RATIO = 4295128739;
536	 uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;
537	 function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {
538	 uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));
539	 require(absTick <= uint256(MAX_TICK), 'T');
540	 uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;
541	 if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;
542	 if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;
543	 if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;
544	 if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;
545	 if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;
546	 if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;
547	 if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;
548	 if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;
549	 if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;
550	 if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;
551	 if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;
552	 if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;
553	 if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;
554	 if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;
555	 if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;
556	 if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;
557	 if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;
558	 if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;
559	 if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;
560	 if (tick > 0) ratio = type(uint256).max / ratio;
561	 sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));
562	 }
563	 function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {
564	 require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');
565	 uint256 ratio = uint256(sqrtPriceX96) << 32;
566	 uint256 r = ratio;
567	 uint256 msb = 0;
568	 assembly {
569	 let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) msb := or(msb, f) r := shr(f, r) }
570	 assembly {
571	 let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF)) msb := or(msb, f) r := shr(f, r) }
572	 assembly {
573	 let f := shl(5, gt(r, 0xFFFFFFFF)) msb := or(msb, f) r := shr(f, r) }
574	 assembly {
575	 let f := shl(4, gt(r, 0xFFFF)) msb := or(msb, f) r := shr(f, r) }
576	 assembly {
577	 let f := shl(3, gt(r, 0xFF)) msb := or(msb, f) r := shr(f, r) }
578	 assembly {
579	 let f := shl(2, gt(r, 0xF)) msb := or(msb, f) r := shr(f, r) }
580	 assembly {
581	 let f := shl(1, gt(r, 0x3)) msb := or(msb, f) r := shr(f, r) }
582	 assembly {
583	 let f := gt(r, 0x1) msb := or(msb, f) }
584	 if (msb >= 128) r = ratio >> (msb - 127);
585	 else r = ratio << (127 - msb);
586	 int256 log_2 = (int256(msb) - 128) << 64;
587	 assembly {
588	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(63, f)) r := shr(f, r) }
589	 assembly {
590	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(62, f)) r := shr(f, r) }
591	 assembly {
592	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(61, f)) r := shr(f, r) }
593	 assembly {
594	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(60, f)) r := shr(f, r) }
595	 assembly {
596	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(59, f)) r := shr(f, r) }
597	 assembly {
598	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(58, f)) r := shr(f, r) }
599	 assembly {
600	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(57, f)) r := shr(f, r) }
601	 assembly {
602	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(56, f)) r := shr(f, r) }
603	 assembly {
604	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(55, f)) r := shr(f, r) }
605	 assembly {
606	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(54, f)) r := shr(f, r) }
607	 assembly {
608	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(53, f)) r := shr(f, r) }
609	 assembly {
610	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(52, f)) r := shr(f, r) }
611	 assembly {
612	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(51, f)) r := shr(f, r) }
613	 assembly {
614	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(50, f)) }
615	 int256 log_sqrt10001 = log_2 * 255738958999603826347141;
616	 int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);
617	 int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);
618	 tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;
619	 }
620	 }
621	 pragma solidity >=0.4.0;
622	 library FullMath {
623	 function mulDiv( uint256 a, uint256 b, uint256 denominator ) internal pure returns (uint256 result) {
624	 uint256 prod0;
625	 uint256 prod1;
626	 assembly {
627	 let mm := mulmod(a, b, not(0)) prod0 := mul(a, b) prod1 := sub(sub(mm, prod0), lt(mm, prod0)) }
628	 if (prod1 == 0) {
629	 require(denominator > 0);
630	 assembly {
631	 result := div(prod0, denominator) }
632	 return result;
633	 }
634	 require(denominator > prod1);
635	 uint256 remainder;
636	 assembly {
637	 remainder := mulmod(a, b, denominator) }
638	 assembly {
639	 prod1 := sub(prod1, gt(remainder, prod0)) prod0 := sub(prod0, remainder) }
640	 uint256 twos = -denominator & denominator;
641	 assembly {
642	 denominator := div(denominator, twos) }
643	 assembly {
644	 prod0 := div(prod0, twos) }
645	 assembly {
646	 twos := add(div(sub(0, twos), twos), 1) }
647	 prod0 |= prod1 * twos;
648	 uint256 inv = (3 * denominator) ^ 2;
649	 inv *= 2 - denominator * inv;
650	 inv *= 2 - denominator * inv;
651	 inv *= 2 - denominator * inv;
652	 inv *= 2 - denominator * inv;
653	 inv *= 2 - denominator * inv;
654	 inv *= 2 - denominator * inv;
655	 result = prod0 * inv;
656	 return result;
657	 }
658	 function mulDivRoundingUp( uint256 a, uint256 b, uint256 denominator ) internal pure returns (uint256 result) {
659	 result = mulDiv(a, b, denominator);
660	 if (mulmod(a, b, denominator) > 0) {
661	 require(result < type(uint256).max);
662	 result++;
663	 }
664	 }
665	 }
666	 pragma solidity >=0.5.0;
667	 library LiquidityAmounts {
668	 function toUint128(uint256 x) private pure returns (uint128 y) {
669	 require((y = uint128(x)) == x);
670	 }
671	 function getLiquidityForAmount0( uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint256 amount0 ) internal pure returns (uint128 liquidity) {
672	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
673	 uint256 intermediate = FullMath.mulDiv(sqrtRatioAX96, sqrtRatioBX96, FixedPoint96.Q96);
674	 return toUint128(FullMath.mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));
675	 }
676	 function getLiquidityForAmount1( uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint256 amount1 ) internal pure returns (uint128 liquidity) {
677	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
678	 return toUint128(FullMath.mulDiv(amount1, FixedPoint96.Q96, sqrtRatioBX96 - sqrtRatioAX96));
679	 }
680	 function getLiquidityForAmounts( uint160 sqrtRatioX96, uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint256 amount0, uint256 amount1 ) internal pure returns (uint128 liquidity) {
681	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
682	 if (sqrtRatioX96 <= sqrtRatioAX96) {
683	 liquidity = getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);
684	 }
685	 else if (sqrtRatioX96 < sqrtRatioBX96) {
686	 uint128 liquidity0 = getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);
687	 uint128 liquidity1 = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);
688	 liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;
689	 }
690	 else {
691	 liquidity = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);
692	 }
693	 }
694	 function getAmount0ForLiquidity( uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity ) internal pure returns (uint256 amount0) {
695	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
696	 return FullMath.mulDiv( uint256(liquidity) << FixedPoint96.RESOLUTION, sqrtRatioBX96 - sqrtRatioAX96, sqrtRatioBX96 ) / sqrtRatioAX96;
697	 }
698	 function getAmount1ForLiquidity( uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity ) internal pure returns (uint256 amount1) {
699	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
700	 return FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);
701	 }
702	 function getAmountsForLiquidity( uint160 sqrtRatioX96, uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity ) internal pure returns (uint256 amount0, uint256 amount1) {
703	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
704	 if (sqrtRatioX96 <= sqrtRatioAX96) {
705	 amount0 = getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);
706	 }
707	 else if (sqrtRatioX96 < sqrtRatioBX96) {
708	 amount0 = getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);
709	 amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);
710	 }
711	 else {
712	 amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);
713	 }
714	 }
715	 }
716	 pragma solidity 0.7.6;
717	 interface IUniversalVault {
718	 event Locked(address delegate, address token, uint256 amount);
719	 event Unlocked(address delegate, address token, uint256 amount);
720	 event RageQuit(address delegate, address token, bool notified, string reason);
721	 struct LockData {
722	 address delegate;
723	 address token;
724	 uint256 balance;
725	 }
726	 function initialize() external;
727	 function lock( address token, uint256 amount, bytes calldata permission ) external;
728	 function unlock( address token, uint256 amount, bytes calldata permission ) external;
729	 function rageQuit(address delegate, address token) external returns (bool notified, string memory error);
730	 function transferERC20( address token, address to, uint256 amount ) external;
731	 function transferETH(address to, uint256 amount) external payable;
732	 function calculateLockID(address delegate, address token) external pure returns (bytes32 lockID);
733	 function getPermissionHash( bytes32 eip712TypeHash, address delegate, address token, uint256 amount, uint256 nonce ) external view returns (bytes32 permissionHash);
734	 function getNonce() external view returns (uint256 nonce);
735	 function owner() external view returns (address ownerAddress);
736	 function getLockSetCount() external view returns (uint256 count);
737	 function getLockAt(uint256 index) external view returns (LockData memory lockData);
738	 function getBalanceDelegated(address token, address delegate) external view returns (uint256 balance);
739	 function getBalanceLocked(address token) external view returns (uint256 balance);
740	 function checkBalances() external view returns (bool validity);
741	 }
742	 pragma solidity >=0.6.2 <0.8.0;
743	 library Address {
744	 function isContract(address account) internal view returns (bool) {
745	 uint256 size;
746	 assembly {
747	 size := extcodesize(account) }
748	 return size > 0;
749	 }
750	 function sendValue(address payable recipient, uint256 amount) internal {
751	 require(address(this).balance >= amount, "Address: insufficient balance");
752	 (bool success, ) = recipient.call{
753	 value: amount }
754	 ("");
755	 require(success, "Address: unable to send value, recipient may have reverted");
756	 }
757	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
758	 return functionCall(target, data, "Address: low-level call failed");
759	 }
760	 function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
761	 return functionCallWithValue(target, data, 0, errorMessage);
762	 }
763	 function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
764	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
765	 }
766	 function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
767	 require(address(this).balance >= value, "Address: insufficient balance for call");
768	 require(isContract(target), "Address: call to non-contract");
769	 (bool success, bytes memory returndata) = target.call{
770	 value: value }
771	 (data);
772	 return _verifyCallResult(success, returndata, errorMessage);
773	 }
774	 function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
775	 return functionStaticCall(target, data, "Address: low-level static call failed");
776	 }
777	 function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
778	 require(isContract(target), "Address: static call to non-contract");
779	 (bool success, bytes memory returndata) = target.staticcall(data);
780	 return _verifyCallResult(success, returndata, errorMessage);
781	 }
782	 function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
783	 return functionDelegateCall(target, data, "Address: low-level delegate call failed");
784	 }
785	 function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
786	 require(isContract(target), "Address: delegate call to non-contract");
787	 (bool success, bytes memory returndata) = target.delegatecall(data);
788	 return _verifyCallResult(success, returndata, errorMessage);
789	 }
790	 function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
791	 if (success) {
792	 return returndata;
793	 }
794	 else {
795	 if (returndata.length > 0) {
796	 assembly {
797	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
798	 }
799	 else {
800	 revert(errorMessage);
801	 }
802	 }
803	 }
804	 }
805	 pragma solidity >=0.4.0;
806	 library FixedPoint96 {
807	 uint8 internal constant RESOLUTION = 96;
808	 uint256 internal constant Q96 = 0x1000000000000000000000000;
809	 }
