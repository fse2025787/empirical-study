row number 
1	                pragma solidity ^0.6.2;
2	 pragma solidity ^0.6.2;
3	 interface IERC20 {
4	 function totalSupply() external view returns (uint256);
5	 function balanceOf(address account) external view returns (uint256);
6	 function transfer(address recipient, uint256 amount) external returns (bool);
7	 function allowance(address owner, address spender) external view returns (uint256);
8	 function approve(address spender, uint256 amount) external returns (bool);
9	 function transferFrom( address sender, address recipient, uint256 amount ) external returns (bool);
10	 event Transfer(address indexed from, address indexed to, uint256 value);
11	 event Approval(address indexed owner, address indexed spender, uint256 value);
12	 }
13	 pragma solidity ^0.6.2;
14	 abstract contract Context {
15	 function _msgSender() internal view virtual returns (address) {
16	 return msg.sender;
17	 }
18	 function _msgData() internal view virtual returns (bytes calldata) {
19	 this;
20	 return msg.data;
21	 }
22	 }
23	 pragma solidity ^0.6.2;
24	 interface IUniswapV2Router01 {
25	 function factory() external pure returns (address);
26	 function WETH() external pure returns (address);
27	 function addLiquidity( address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline ) external returns (uint amountA, uint amountB, uint liquidity);
28	 function addLiquidityETH( address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
29	 function removeLiquidity( address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline ) external returns (uint amountA, uint amountB);
30	 function removeLiquidityETH( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) external returns (uint amountToken, uint amountETH);
31	 function removeLiquidityWithPermit( address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s ) external returns (uint amountA, uint amountB);
32	 function removeLiquidityETHWithPermit( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s ) external returns (uint amountToken, uint amountETH);
33	 function swapExactTokensForTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external returns (uint[] memory amounts);
34	 function swapTokensForExactTokens( uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline ) external returns (uint[] memory amounts);
35	 function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);
36	 function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);
37	 function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);
38	 function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);
39	 function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);
40	 function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);
41	 function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);
42	 function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);
43	 function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);
44	 }
45	 interface IUniswapV2Router02 is IUniswapV2Router01 {
46	 function removeLiquidityETHSupportingFeeOnTransferTokens( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) external returns (uint amountETH);
47	 function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s ) external returns (uint amountETH);
48	 function swapExactTokensForTokensSupportingFeeOnTransferTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external;
49	 function swapExactETHForTokensSupportingFeeOnTransferTokens( uint amountOutMin, address[] calldata path, address to, uint deadline ) external payable;
50	 function swapExactTokensForETHSupportingFeeOnTransferTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external;
51	 }
52	 pragma solidity ^0.6.2;
53	 interface IUniswapV2Factory {
54	 event PairCreated(address indexed token0, address indexed token1, address pair, uint);
55	 function feeTo() external view returns (address);
56	 function feeToSetter() external view returns (address);
57	 function getPair(address tokenA, address tokenB) external view returns (address pair);
58	 function allPairs(uint) external view returns (address pair);
59	 function allPairsLength() external view returns (uint);
60	 function createPair(address tokenA, address tokenB) external returns (address pair);
61	 function setFeeTo(address) external;
62	 function setFeeToSetter(address) external;
63	 }
64	 pragma solidity ^0.6.2;
65	 interface IUniswapV2Pair {
66	 event Approval(address indexed owner, address indexed spender, uint value);
67	 event Transfer(address indexed from, address indexed to, uint value);
68	 function name() external pure returns (string memory);
69	 function symbol() external pure returns (string memory);
70	 function decimals() external pure returns (uint8);
71	 function totalSupply() external view returns (uint);
72	 function balanceOf(address owner) external view returns (uint);
73	 function allowance(address owner, address spender) external view returns (uint);
74	 function approve(address spender, uint value) external returns (bool);
75	 function transfer(address to, uint value) external returns (bool);
76	 function transferFrom(address from, address to, uint value) external returns (bool);
77	 function DOMAIN_SEPARATOR() external view returns (bytes32);
78	 function PERMIT_TYPEHASH() external pure returns (bytes32);
79	 function nonces(address owner) external view returns (uint);
80	 function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;
81	 event Mint(address indexed sender, uint amount0, uint amount1);
82	 event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
83	 event Swap( address indexed sender, uint amount0In, uint amount1In, uint amount0Out, uint amount1Out, address indexed to );
84	 event Sync(uint112 reserve0, uint112 reserve1);
85	 function MINIMUM_LIQUIDITY() external pure returns (uint);
86	 function factory() external view returns (address);
87	 function token0() external view returns (address);
88	 function token1() external view returns (address);
89	 function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
90	 function price0CumulativeLast() external view returns (uint);
91	 function price1CumulativeLast() external view returns (uint);
92	 function kLast() external view returns (uint);
93	 function mint(address to) external returns (uint liquidity);
94	 function burn(address to) external returns (uint amount0, uint amount1);
95	 function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
96	 function skim(address to) external;
97	 function sync() external;
98	 function initialize(address, address) external;
99	 }
100	 pragma solidity ^0.6.2;
101	 interface IERC20Metadata is IERC20 {
102	 function name() external view returns (string memory);
103	 function symbol() external view returns (string memory);
104	 function decimals() external view returns (uint8);
105	 }
106	 pragma solidity ^0.6.2;
107	 contract Ownable is Context {
108	 address private _owner;
109	 event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
110	 constructor () public {
111	 address msgSender = _msgSender();
112	 _owner = msgSender;
113	 emit OwnershipTransferred(address(0), msgSender);
114	 }
115	 function owner() public view returns (address) {
116	 return _owner;
117	 }
118	 modifier onlyOwner() {
119	 require(_owner == _msgSender(), "Ownable: caller is not the owner");
120	 _;
121	 }
122	 function renounceOwnership() public virtual onlyOwner {
123	 emit OwnershipTransferred(_owner, address(0));
124	 _owner = address(0);
125	 }
126	 function transferOwnership(address newOwner) public virtual onlyOwner {
127	 require(newOwner != address(0), "Ownable: new owner is the zero address");
128	 emit OwnershipTransferred(_owner, newOwner);
129	 _owner = newOwner;
130	 }
131	 }
132	 pragma solidity ^0.6.2;
133	 library SafeMath {
134	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
135	 uint256 c = a + b;
136	 require(c >= a, "SafeMath: addition overflow");
137	 return c;
138	 }
139	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
140	 return sub(a, b, "SafeMath: subtraction overflow");
141	 }
142	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
143	 require(b <= a, errorMessage);
144	 uint256 c = a - b;
145	 return c;
146	 }
147	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
148	 if (a == 0) {
149	 return 0;
150	 }
151	 uint256 c = a * b;
152	 require(c / a == b, "SafeMath: multiplication overflow");
153	 return c;
154	 }
155	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
156	 return div(a, b, "SafeMath: division by zero");
157	 }
158	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
159	 require(b > 0, errorMessage);
160	 uint256 c = a / b;
161	 return c;
162	 }
163	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
164	 return mod(a, b, "SafeMath: modulo by zero");
165	 }
166	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
167	 require(b != 0, errorMessage);
168	 return a % b;
169	 }
170	 }
171	 pragma solidity ^0.6.2;
172	 library SafeMathInt {
173	 int256 private constant MIN_INT256 = int256(1) << 255;
174	 int256 private constant MAX_INT256 = ~(int256(1) << 255);
175	 function mul(int256 a, int256 b) internal pure returns (int256) {
176	 int256 c = a * b;
177	 require(c != MIN_INT256 || (a & MIN_INT256) != (b & MIN_INT256));
178	 require((b == 0) || (c / b == a));
179	 return c;
180	 }
181	 function div(int256 a, int256 b) internal pure returns (int256) {
182	 require(b != -1 || a != MIN_INT256);
183	 return a / b;
184	 }
185	 function sub(int256 a, int256 b) internal pure returns (int256) {
186	 int256 c = a - b;
187	 require((b >= 0 && c <= a) || (b < 0 && c > a));
188	 return c;
189	 }
190	 function add(int256 a, int256 b) internal pure returns (int256) {
191	 int256 c = a + b;
192	 require((b >= 0 && c >= a) || (b < 0 && c < a));
193	 return c;
194	 }
195	 function abs(int256 a) internal pure returns (int256) {
196	 require(a != MIN_INT256);
197	 return a < 0 ? -a : a;
198	 }
199	 function toUint256Safe(int256 a) internal pure returns (uint256) {
200	 require(a >= 0);
201	 return uint256(a);
202	 }
203	 }
204	 pragma solidity ^0.6.2;
205	 library SafeMathUint {
206	 function toInt256Safe(uint256 a) internal pure returns (int256) {
207	 int256 b = int256(a);
208	 require(b >= 0);
209	 return b;
210	 }
211	 }
212	 pragma solidity ^0.6.2;
213	 library IterableMapping {
214	 struct Map {
215	 address[] keys;
216	 mapping(address => uint) values;
217	 mapping(address => uint) indexOf;
218	 mapping(address => bool) inserted;
219	 }
220	 function get(Map storage map, address key) public view returns (uint) {
221	 return map.values[key];
222	 }
223	 function getIndexOfKey(Map storage map, address key) public view returns (int) {
224	 if(!map.inserted[key]) {
225	 return -1;
226	 }
227	 return int(map.indexOf[key]);
228	 }
229	 function getKeyAtIndex(Map storage map, uint index) public view returns (address) {
230	 return map.keys[index];
231	 }
232	 function size(Map storage map) public view returns (uint) {
233	 return map.keys.length;
234	 }
235	 function set(Map storage map, address key, uint val) public {
236	 if (map.inserted[key]) {
237	 map.values[key] = val;
238	 }
239	 else {
240	 map.inserted[key] = true;
241	 map.values[key] = val;
242	 map.indexOf[key] = map.keys.length;
243	 map.keys.push(key);
244	 }
245	 }
246	 function remove(Map storage map, address key) public {
247	 if (!map.inserted[key]) {
248	 return;
249	 }
250	 delete map.inserted[key];
251	 delete map.values[key];
252	 uint index = map.indexOf[key];
253	 uint lastIndex = map.keys.length - 1;
254	 address lastKey = map.keys[lastIndex];
255	 map.indexOf[lastKey] = index;
256	 delete map.indexOf[key];
257	 map.keys[index] = lastKey;
258	 map.keys.pop();
259	 }
260	 }
261	 pragma solidity ^0.6.2;
262	 contract ERC20 is Context, IERC20, IERC20Metadata {
263	 using SafeMath for uint256;
264	 mapping(address => uint256) private _balances;
265	 mapping(address => mapping(address => uint256)) private _allowances;
266	 uint256 private _totalSupply;
267	 string private _name;
268	 string private _symbol;
269	 constructor(string memory name_, string memory symbol_) public {
270	 _name = name_;
271	 _symbol = symbol_;
272	 }
273	 function name() public view virtual override returns (string memory) {
274	 return _name;
275	 }
276	 function symbol() public view virtual override returns (string memory) {
277	 return _symbol;
278	 }
279	 function decimals() public view virtual override returns (uint8) {
280	 return 18;
281	 }
282	 function totalSupply() public view virtual override returns (uint256) {
283	 return _totalSupply;
284	 }
285	 function balanceOf(address account) public view virtual override returns (uint256) {
286	 return _balances[account];
287	 }
288	 function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
289	 _transfer(_msgSender(), recipient, amount);
290	 return true;
291	 }
292	 function allowance(address owner, address spender) public view virtual override returns (uint256) {
293	 return _allowances[owner][spender];
294	 }
295	 function approve(address spender, uint256 amount) public virtual override returns (bool) {
296	 _approve(_msgSender(), spender, amount);
297	 return true;
298	 }
299	 function transferFrom( address sender, address recipient, uint256 amount ) public virtual override returns (bool) {
300	 _transfer(sender, recipient, amount);
301	 _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
302	 return true;
303	 }
304	 function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
305	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
306	 return true;
307	 }
308	 function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
309	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
310	 return true;
311	 }
312	 function _transfer( address sender, address recipient, uint256 amount ) internal virtual {
313	 require(sender != address(0), "ERC20: transfer from the zero address");
314	 require(recipient != address(0), "ERC20: transfer to the zero address");
315	 _beforeTokenTransfer(sender, recipient, amount);
316	 _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
317	 _balances[recipient] = _balances[recipient].add(amount);
318	 emit Transfer(sender, recipient, amount);
319	 }
320	 function _mint(address account, uint256 amount) internal virtual {
321	 require(account != address(0), "ERC20: mint to the zero address");
322	 _beforeTokenTransfer(address(0), account, amount);
323	 _totalSupply = _totalSupply.add(amount);
324	 _balances[account] = _balances[account].add(amount);
325	 emit Transfer(address(0), account, amount);
326	 }
327	 function _burn(address account, uint256 amount) internal virtual {
328	 require(account != address(0), "ERC20: burn from the zero address");
329	 _beforeTokenTransfer(account, address(0), amount);
330	 _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
331	 _totalSupply = _totalSupply.sub(amount);
332	 emit Transfer(account, address(0), amount);
333	 }
334	 function _approve( address owner, address spender, uint256 amount ) internal virtual {
335	 require(owner != address(0), "ERC20: approve from the zero address");
336	 require(spender != address(0), "ERC20: approve to the zero address");
337	 _allowances[owner][spender] = amount;
338	 emit Approval(owner, spender, amount);
339	 }
340	 function _beforeTokenTransfer( address from, address to, uint256 amount ) internal virtual {
341	 }
342	 }
343	 pragma solidity ^0.6.2;
344	 interface DividendPayingTokenInterface {
345	 function dividendOf(address _owner) external view returns(uint256);
346	 function withdrawDividend() external;
347	 event DividendsDistributed( address indexed from, uint256 weiAmount );
348	 event DividendWithdrawn( address indexed to, uint256 weiAmount );
349	 }
350	 pragma solidity ^0.6.2;
351	 interface DividendPayingTokenOptionalInterface {
352	 function withdrawableDividendOf(address _owner) external view returns(uint256);
353	 function withdrawnDividendOf(address _owner) external view returns(uint256);
354	 function accumulativeDividendOf(address _owner) external view returns(uint256);
355	 }
356	 pragma solidity ^0.6.2;
357	 contract DividendPayingToken is ERC20, Ownable, DividendPayingTokenInterface, DividendPayingTokenOptionalInterface {
358	 using SafeMath for uint256;
359	 using SafeMathUint for uint256;
360	 using SafeMathInt for int256;
361	 address public immutable CAKE = address(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599);
362	 uint256 constant internal magnitude = 2**128;
363	 uint256 internal magnifiedDividendPerShare;
364	 mapping(address => int256) internal magnifiedDividendCorrections;
365	 mapping(address => uint256) internal withdrawnDividends;
366	 uint256 public totalDividendsDistributed;
367	 constructor(string memory _name, string memory _symbol) public ERC20(_name, _symbol) {
368	 }
369	 function distributeCAKEDividends(uint256 amount) public onlyOwner{
370	 require(totalSupply() > 0);
371	 if (amount > 0) {
372	 magnifiedDividendPerShare = magnifiedDividendPerShare.add( (amount).mul(magnitude) / totalSupply() );
373	 emit DividendsDistributed(msg.sender, amount);
374	 totalDividendsDistributed = totalDividendsDistributed.add(amount);
375	 }
376	 }
377	 function withdrawDividend() public virtual override {
378	 _withdrawDividendOfUser(msg.sender);
379	 }
380	 function _withdrawDividendOfUser(address payable user) internal returns (uint256) {
381	 uint256 _withdrawableDividend = withdrawableDividendOf(user);
382	 if (_withdrawableDividend > 0) {
383	 withdrawnDividends[user] = withdrawnDividends[user].add(_withdrawableDividend);
384	 emit DividendWithdrawn(user, _withdrawableDividend);
385	 bool success = IERC20(CAKE).transfer(user, _withdrawableDividend);
386	 if(!success) {
387	 withdrawnDividends[user] = withdrawnDividends[user].sub(_withdrawableDividend);
388	 return 0;
389	 }
390	 return _withdrawableDividend;
391	 }
392	 return 0;
393	 }
394	 function dividendOf(address _owner) public view override returns(uint256) {
395	 return withdrawableDividendOf(_owner);
396	 }
397	 function withdrawableDividendOf(address _owner) public view override returns(uint256) {
398	 return accumulativeDividendOf(_owner).sub(withdrawnDividends[_owner]);
399	 }
400	 function withdrawnDividendOf(address _owner) public view override returns(uint256) {
401	 return withdrawnDividends[_owner];
402	 }
403	 function accumulativeDividendOf(address _owner) public view override returns(uint256) {
404	 return magnifiedDividendPerShare.mul(balanceOf(_owner)).toInt256Safe() .add(magnifiedDividendCorrections[_owner]).toUint256Safe() / magnitude;
405	 }
406	 function _transfer(address from, address to, uint256 value) internal virtual override {
407	 require(false);
408	 int256 _magCorrection = magnifiedDividendPerShare.mul(value).toInt256Safe();
409	 magnifiedDividendCorrections[from] = magnifiedDividendCorrections[from].add(_magCorrection);
410	 magnifiedDividendCorrections[to] = magnifiedDividendCorrections[to].sub(_magCorrection);
411	 }
412	 function _mint(address account, uint256 value) internal override {
413	 super._mint(account, value);
414	 magnifiedDividendCorrections[account] = magnifiedDividendCorrections[account] .sub( (magnifiedDividendPerShare.mul(value)).toInt256Safe() );
415	 }
416	 function _burn(address account, uint256 value) internal override {
417	 super._burn(account, value);
418	 magnifiedDividendCorrections[account] = magnifiedDividendCorrections[account] .add( (magnifiedDividendPerShare.mul(value)).toInt256Safe() );
419	 }
420	 function _setBalance(address account, uint256 newBalance) internal {
421	 uint256 currentBalance = balanceOf(account);
422	 if(newBalance > currentBalance) {
423	 uint256 mintAmount = newBalance.sub(currentBalance);
424	 _mint(account, mintAmount);
425	 }
426	 else if(newBalance < currentBalance) {
427	 uint256 burnAmount = currentBalance.sub(newBalance);
428	 _burn(account, burnAmount);
429	 }
430	 }
431	 }
432	 contract SHIBABTC is ERC20, Ownable {
433	 using SafeMath for uint256;
434	 IUniswapV2Router02 public uniswapV2Router;
435	 address public uniswapV2Pair;
436	 bool private swapping;
437	 SHIBABTCDividendTracker public dividendTracker;
438	 address public deadWallet = 0x000000000000000000000000000000000000dEaD;
439	 address public immutable CAKE = address(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599);
440	 uint256 public swapTokensAtAmount = 2000000 * (10**18);
441	 uint256 public CAKERewardsFee = 7;
442	 uint256 public liquidityFee = 2;
443	 uint256 public marketingFee = 6;
444	 uint256 public totalFees = CAKERewardsFee.add(liquidityFee).add(marketingFee);
445	 address public _marketingWalletAddress = 0xC98dF0fD83714932897ECf7fab5c92b1FeF16a87;
446	 uint256 public gasForProcessing = 300000;
447	 mapping (address => bool) private _isExcludedFromFees;
448	 mapping (address => bool) public automatedMarketMakerPairs;
449	 event UpdateDividendTracker(address indexed newAddress, address indexed oldAddress);
450	 event UpdateUniswapV2Router(address indexed newAddress, address indexed oldAddress);
451	 event ExcludeFromFees(address indexed account, bool isExcluded);
452	 event ExcludeMultipleAccountsFromFees(address[] accounts, bool isExcluded);
453	 event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);
454	 event LiquidityWalletUpdated(address indexed newLiquidityWallet, address indexed oldLiquidityWallet);
455	 event GasForProcessingUpdated(uint256 indexed newValue, uint256 indexed oldValue);
456	 event SwapAndLiquify( uint256 tokensSwapped, uint256 ethReceived, uint256 tokensIntoLiqudity );
457	 event SendDividends( uint256 tokensSwapped, uint256 amount );
458	 event ProcessedDividendTracker( uint256 iterations, uint256 claims, uint256 lastProcessedIndex, bool indexed automatic, uint256 gas, address indexed processor );
459	 constructor() public ERC20("SHIBABTC (https: dividendTracker = new SHIBABTCDividendTracker();
460	 IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
461	 address _uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()) .createPair(address(this), _uniswapV2Router.WETH());
462	 uniswapV2Router = _uniswapV2Router;
463	 uniswapV2Pair = _uniswapV2Pair;
464	 _setAutomatedMarketMakerPair(_uniswapV2Pair, true);
465	 dividendTracker.excludeFromDividends(address(dividendTracker));
466	 dividendTracker.excludeFromDividends(address(this));
467	 dividendTracker.excludeFromDividends(owner());
468	 dividendTracker.excludeFromDividends(deadWallet);
469	 dividendTracker.excludeFromDividends(address(_uniswapV2Router));
470	 excludeFromFees(owner(), true);
471	 excludeFromFees(_marketingWalletAddress, true);
472	 excludeFromFees(address(this), true);
473	 _mint(owner(), 100000000000 * (10**18));
474	 }
475	 receive() external payable {
476	 }
477	 function updateDividendTracker(address newAddress) public onlyOwner {
478	 require(newAddress != address(dividendTracker), "SHIBABTC: The dividend tracker already has that address");
479	 SHIBABTCDividendTracker newDividendTracker = SHIBABTCDividendTracker(payable(newAddress));
480	 require(newDividendTracker.owner() == address(this), "SHIBABTC: The new dividend tracker must be owned by the SHIBABTC token contract");
481	 newDividendTracker.excludeFromDividends(address(newDividendTracker));
482	 newDividendTracker.excludeFromDividends(address(this));
483	 newDividendTracker.excludeFromDividends(owner());
484	 newDividendTracker.excludeFromDividends(address(uniswapV2Router));
485	 emit UpdateDividendTracker(newAddress, address(dividendTracker));
486	 dividendTracker = newDividendTracker;
487	 }
488	 function updateUniswapV2Router(address newAddress) public onlyOwner {
489	 require(newAddress != address(uniswapV2Router), "SHIBABTC: The router already has that address");
490	 emit UpdateUniswapV2Router(newAddress, address(uniswapV2Router));
491	 uniswapV2Router = IUniswapV2Router02(newAddress);
492	 address _uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()) .createPair(address(this), uniswapV2Router.WETH());
493	 uniswapV2Pair = _uniswapV2Pair;
494	 }
495	 function excludeFromFees(address account, bool excluded) public onlyOwner {
496	 require(_isExcludedFromFees[account] != excluded, "SHIBABTC: Account is already the value of 'excluded'");
497	 _isExcludedFromFees[account] = excluded;
498	 emit ExcludeFromFees(account, excluded);
499	 }
500	 function excludeMultipleAccountsFromFees(address[] calldata accounts, bool excluded) public onlyOwner {
501	 for(uint256 i = 0; i < accounts.length; i++) {
502	 _isExcludedFromFees[accounts[i]] = excluded;
503	 }
504	 emit ExcludeMultipleAccountsFromFees(accounts, excluded);
505	 }
506	 function setMarketingWallet(address payable wallet) external onlyOwner{
507	 _marketingWalletAddress = wallet;
508	 }
509	 function setCAKERewardsFee(uint256 value) external onlyOwner{
510	 CAKERewardsFee = value;
511	 totalFees = CAKERewardsFee.add(liquidityFee).add(marketingFee);
512	 }
513	 function setLiquiditFee(uint256 value) external onlyOwner{
514	 liquidityFee = value;
515	 totalFees = CAKERewardsFee.add(liquidityFee).add(marketingFee);
516	 }
517	 function setMarketingFee(uint256 value) external onlyOwner{
518	 marketingFee = value;
519	 totalFees = CAKERewardsFee.add(liquidityFee).add(marketingFee);
520	 }
521	 function setAutomatedMarketMakerPair(address pair, bool value) public onlyOwner {
522	 require(pair != uniswapV2Pair, "SHIBABTC: The PancakeSwap pair cannot be removed from automatedMarketMakerPairs");
523	 _setAutomatedMarketMakerPair(pair, value);
524	 }
525	 function _setAutomatedMarketMakerPair(address pair, bool value) private {
526	 require(automatedMarketMakerPairs[pair] != value, "SHIBABTC: Automated market maker pair is already set to that value");
527	 automatedMarketMakerPairs[pair] = value;
528	 if(value) {
529	 dividendTracker.excludeFromDividends(pair);
530	 }
531	 emit SetAutomatedMarketMakerPair(pair, value);
532	 }
533	 function updateGasForProcessing(uint256 newValue) public onlyOwner {
534	 require(newValue >= 200000 && newValue <= 500000, "SHIBABTC: gasForProcessing must be between 200,000 and 500,000");
535	 require(newValue != gasForProcessing, "SHIBABTC: Cannot update gasForProcessing to same value");
536	 emit GasForProcessingUpdated(newValue, gasForProcessing);
537	 gasForProcessing = newValue;
538	 }
539	 function updateClaimWait(uint256 claimWait) external onlyOwner {
540	 dividendTracker.updateClaimWait(claimWait);
541	 }
542	 function getClaimWait() external view returns(uint256) {
543	 return dividendTracker.claimWait();
544	 }
545	 function getTotalDividendsDistributed() external view returns (uint256) {
546	 return dividendTracker.totalDividendsDistributed();
547	 }
548	 function isExcludedFromFees(address account) public view returns(bool) {
549	 return _isExcludedFromFees[account];
550	 }
551	 function withdrawableDividendOf(address account) public view returns(uint256) {
552	 return dividendTracker.withdrawableDividendOf(account);
553	 }
554	 function dividendTokenBalanceOf(address account) public view returns (uint256) {
555	 return dividendTracker.balanceOf(account);
556	 }
557	 function excludeFromDividends(address account) external onlyOwner{
558	 dividendTracker.excludeFromDividends(account);
559	 }
560	 function getAccountDividendsInfo(address account) external view returns ( address, int256, int256, uint256, uint256, uint256, uint256, uint256) {
561	 return dividendTracker.getAccount(account);
562	 }
563	 function getAccountDividendsInfoAtIndex(uint256 index) external view returns ( address, int256, int256, uint256, uint256, uint256, uint256, uint256) {
564	 return dividendTracker.getAccountAtIndex(index);
565	 }
566	 function processDividendTracker(uint256 gas) external {
567	 (uint256 iterations, uint256 claims, uint256 lastProcessedIndex) = dividendTracker.process(gas);
568	 emit ProcessedDividendTracker(iterations, claims, lastProcessedIndex, false, gas, tx.origin);
569	 }
570	 function claim() external {
571	 dividendTracker.processAccount(msg.sender, false);
572	 }
573	 function getLastProcessedIndex() external view returns(uint256) {
574	 return dividendTracker.getLastProcessedIndex();
575	 }
576	 function getNumberOfDividendTokenHolders() external view returns(uint256) {
577	 return dividendTracker.getNumberOfTokenHolders();
578	 }
579	 function _transfer( address from, address to, uint256 amount ) internal override {
580	 require(from != address(0), "ERC20: transfer from the zero address");
581	 require(to != address(0), "ERC20: transfer to the zero address");
582	 if(amount == 0) {
583	 super._transfer(from, to, 0);
584	 return;
585	 }
586	 uint256 contractTokenBalance = balanceOf(address(this));
587	 bool canSwap = contractTokenBalance >= swapTokensAtAmount;
588	 if( canSwap && !swapping && !automatedMarketMakerPairs[from] && from != owner() && to != owner() ) {
589	 swapping = true;
590	 uint256 marketingTokens = contractTokenBalance.mul(marketingFee).div(totalFees);
591	 swapAndSendToFee(marketingTokens);
592	 uint256 swapTokens = contractTokenBalance.mul(liquidityFee).div(totalFees);
593	 swapAndLiquify(swapTokens);
594	 uint256 sellTokens = balanceOf(address(this));
595	 swapAndSendDividends(sellTokens);
596	 swapping = false;
597	 }
598	 bool takeFee = !swapping;
599	 if(_isExcludedFromFees[from] || _isExcludedFromFees[to]) {
600	 takeFee = false;
601	 }
602	 if(takeFee) {
603	 uint256 fees = amount.mul(totalFees).div(100);
604	 if(automatedMarketMakerPairs[to]){
605	 fees += amount.mul(1).div(100);
606	 }
607	 amount = amount.sub(fees);
608	 super._transfer(from, address(this), fees);
609	 }
610	 super._transfer(from, to, amount);
611	 try dividendTracker.setBalance(payable(from), balanceOf(from)) {
612	 }
613	 catch {
614	 }
615	 try dividendTracker.setBalance(payable(to), balanceOf(to)) {
616	 }
617	 catch {
618	 }
619	 if(!swapping) {
620	 uint256 gas = gasForProcessing;
621	 try dividendTracker.process(gas) returns (uint256 iterations, uint256 claims, uint256 lastProcessedIndex) {
622	 emit ProcessedDividendTracker(iterations, claims, lastProcessedIndex, true, gas, tx.origin);
623	 }
624	 catch {
625	 }
626	 }
627	 }
628	 function swapAndSendToFee(uint256 tokens) private {
629	 uint256 initialCAKEBalance = IERC20(CAKE).balanceOf(address(this));
630	 swapTokensForCake(tokens);
631	 uint256 newBalance = (IERC20(CAKE).balanceOf(address(this))).sub(initialCAKEBalance);
632	 IERC20(CAKE).transfer(_marketingWalletAddress, newBalance);
633	 }
634	 function swapAndLiquify(uint256 tokens) private {
635	 uint256 half = tokens.div(2);
636	 uint256 otherHalf = tokens.sub(half);
637	 uint256 initialBalance = address(this).balance;
638	 swapTokensForEth(half);
639	 uint256 newBalance = address(this).balance.sub(initialBalance);
640	 addLiquidity(otherHalf, newBalance);
641	 emit SwapAndLiquify(half, newBalance, otherHalf);
642	 }
643	 function swapTokensForEth(uint256 tokenAmount) private {
644	 address[] memory path = new address[](2);
645	 path[0] = address(this);
646	 path[1] = uniswapV2Router.WETH();
647	 _approve(address(this), address(uniswapV2Router), tokenAmount);
648	 uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens( tokenAmount, 0, path, address(this), block.timestamp );
649	 }
650	 function swapTokensForCake(uint256 tokenAmount) private {
651	 address[] memory path = new address[](3);
652	 path[0] = address(this);
653	 path[1] = uniswapV2Router.WETH();
654	 path[2] = CAKE;
655	 _approve(address(this), address(uniswapV2Router), tokenAmount);
656	 uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens( tokenAmount, 0, path, address(this), block.timestamp );
657	 }
658	 function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {
659	 _approve(address(this), address(uniswapV2Router), tokenAmount);
660	 uniswapV2Router.addLiquidityETH{
661	 value: ethAmount}
662	 ( address(this), tokenAmount, 0, 0, address(0), block.timestamp );
663	 }
664	 function swapAndSendDividends(uint256 tokens) private{
665	 swapTokensForCake(tokens);
666	 uint256 dividends = IERC20(CAKE).balanceOf(address(this));
667	 bool success = IERC20(CAKE).transfer(address(dividendTracker), dividends);
668	 if (success) {
669	 dividendTracker.distributeCAKEDividends(dividends);
670	 emit SendDividends(tokens, dividends);
671	 }
672	 }
673	 }
674	 contract SHIBABTCDividendTracker is Ownable, DividendPayingToken {
675	 using SafeMath for uint256;
676	 using SafeMathInt for int256;
677	 using IterableMapping for IterableMapping.Map;
678	 IterableMapping.Map private tokenHoldersMap;
679	 uint256 public lastProcessedIndex;
680	 mapping (address => bool) public excludedFromDividends;
681	 mapping (address => uint256) public lastClaimTimes;
682	 uint256 public claimWait;
683	 uint256 public immutable minimumTokenBalanceForDividends;
684	 event ExcludeFromDividends(address indexed account);
685	 event ClaimWaitUpdated(uint256 indexed newValue, uint256 indexed oldValue);
686	 event Claim(address indexed account, uint256 amount, bool indexed automatic);
687	 constructor() public DividendPayingToken("SHIBABTC_Dividen_Tracker", "SHIBABTC_Dividend_Tracker") {
688	 claimWait = 3600;
689	 minimumTokenBalanceForDividends = 200000 * (10**18);
690	 }
691	 function _transfer(address, address, uint256) internal override {
692	 require(false, "SHIBABTC_Dividend_Tracker: No transfers allowed");
693	 }
694	 function withdrawDividend() public override {
695	 require(false, "SHIBABTC_Dividend_Tracker: withdrawDividend disabled. Use the 'claim' function on the main SHIBABTC contract.");
696	 }
697	 function excludeFromDividends(address account) external onlyOwner {
698	 require(!excludedFromDividends[account]);
699	 excludedFromDividends[account] = true;
700	 _setBalance(account, 0);
701	 tokenHoldersMap.remove(account);
702	 emit ExcludeFromDividends(account);
703	 }
704	 function updateClaimWait(uint256 newClaimWait) external onlyOwner {
705	 require(newClaimWait >= 3600 && newClaimWait <= 86400, "SHIBABTC_Dividend_Tracker: claimWait must be updated to between 1 and 24 hours");
706	 require(newClaimWait != claimWait, "SHIBABTC_Dividend_Tracker: Cannot update claimWait to same value");
707	 emit ClaimWaitUpdated(newClaimWait, claimWait);
708	 claimWait = newClaimWait;
709	 }
710	 function getLastProcessedIndex() external view returns(uint256) {
711	 return lastProcessedIndex;
712	 }
713	 function getNumberOfTokenHolders() external view returns(uint256) {
714	 return tokenHoldersMap.keys.length;
715	 }
716	 function getAccount(address _account) public view returns ( address account, int256 index, int256 iterationsUntilProcessed, uint256 withdrawableDividends, uint256 totalDividends, uint256 lastClaimTime, uint256 nextClaimTime, uint256 secondsUntilAutoClaimAvailable) {
717	 account = _account;
718	 index = tokenHoldersMap.getIndexOfKey(account);
719	 iterationsUntilProcessed = -1;
720	 if(index >= 0) {
721	 if(uint256(index) > lastProcessedIndex) {
722	 iterationsUntilProcessed = index.sub(int256(lastProcessedIndex));
723	 }
724	 else {
725	 uint256 processesUntilEndOfArray = tokenHoldersMap.keys.length > lastProcessedIndex ? tokenHoldersMap.keys.length.sub(lastProcessedIndex) : 0;
726	 iterationsUntilProcessed = index.add(int256(processesUntilEndOfArray));
727	 }
728	 }
729	 withdrawableDividends = withdrawableDividendOf(account);
730	 totalDividends = accumulativeDividendOf(account);
731	 lastClaimTime = lastClaimTimes[account];
732	 nextClaimTime = lastClaimTime > 0 ? lastClaimTime.add(claimWait) : 0;
733	 secondsUntilAutoClaimAvailable = nextClaimTime > block.timestamp ? nextClaimTime.sub(block.timestamp) : 0;
734	 }
735	 function getAccountAtIndex(uint256 index) public view returns ( address, int256, int256, uint256, uint256, uint256, uint256, uint256) {
736	 if(index >= tokenHoldersMap.size()) {
737	 return (0x0000000000000000000000000000000000000000, -1, -1, 0, 0, 0, 0, 0);
738	 }
739	 address account = tokenHoldersMap.getKeyAtIndex(index);
740	 return getAccount(account);
741	 }
742	 function canAutoClaim(uint256 lastClaimTime) private view returns (bool) {
743	 if(lastClaimTime > block.timestamp) {
744	 return false;
745	 }
746	 return block.timestamp.sub(lastClaimTime) >= claimWait;
747	 }
748	 function setBalance(address payable account, uint256 newBalance) external onlyOwner {
749	 if(excludedFromDividends[account]) {
750	 return;
751	 }
752	 if(newBalance >= minimumTokenBalanceForDividends) {
753	 _setBalance(account, newBalance);
754	 tokenHoldersMap.set(account, newBalance);
755	 }
756	 else {
757	 _setBalance(account, 0);
758	 tokenHoldersMap.remove(account);
759	 }
760	 processAccount(account, true);
761	 }
762	 function process(uint256 gas) public returns (uint256, uint256, uint256) {
763	 uint256 numberOfTokenHolders = tokenHoldersMap.keys.length;
764	 if(numberOfTokenHolders == 0) {
765	 return (0, 0, lastProcessedIndex);
766	 }
767	 uint256 _lastProcessedIndex = lastProcessedIndex;
768	 uint256 gasUsed = 0;
769	 uint256 gasLeft = gasleft();
770	 uint256 iterations = 0;
771	 uint256 claims = 0;
772	 while(gasUsed < gas && iterations < numberOfTokenHolders) {
773	 _lastProcessedIndex++;
774	 if(_lastProcessedIndex >= tokenHoldersMap.keys.length) {
775	 _lastProcessedIndex = 0;
776	 }
777	 address account = tokenHoldersMap.keys[_lastProcessedIndex];
778	 if(canAutoClaim(lastClaimTimes[account])) {
779	 if(processAccount(payable(account), true)) {
780	 claims++;
781	 }
782	 }
783	 iterations++;
784	 uint256 newGasLeft = gasleft();
785	 if(gasLeft > newGasLeft) {
786	 gasUsed = gasUsed.add(gasLeft.sub(newGasLeft));
787	 }
788	 gasLeft = newGasLeft;
789	 }
790	 lastProcessedIndex = _lastProcessedIndex;
791	 return (iterations, claims, lastProcessedIndex);
792	 }
793	 function processAccount(address payable account, bool automatic) public onlyOwner returns (bool) {
794	 uint256 amount = _withdrawDividendOfUser(account);
795	 if(amount > 0) {
796	 lastClaimTimes[account] = block.timestamp;
797	 emit Claim(account, amount, automatic);
798	 return true;
799	 }
800	 return false;
801	 }
802	 }
