row number 
1	 pragma experimental ABIEncoderV2;
2	 pragma solidity ^0.5.17;
3	 library SafeMath {
4	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
5	 uint256 c = a + b;
6	 require(c >= a, "SafeMath: addition overflow");
7	 return c;
8	 }
9	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
10	 return sub(a, b, "SafeMath: subtraction overflow");
11	 }
12	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
13	 require(b <= a, errorMessage);
14	 uint256 c = a - b;
15	 return c;
16	 }
17	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
18	 if (a == 0) {
19	 return 0;
20	 }
21	 uint256 c = a * b;
22	 require(c / a == b, "SafeMath: multiplication overflow");
23	 return c;
24	 }
25	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
26	 return div(a, b, "SafeMath: division by zero");
27	 }
28	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
29	 require(b > 0, errorMessage);
30	 uint256 c = a / b;
31	 return c;
32	 }
33	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
34	 return mod(a, b, "SafeMath: modulo by zero");
35	 }
36	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
37	 require(b != 0, errorMessage);
38	 return a % b;
39	 }
40	 }
41	 interface IUniswapV2Pair {
42	 event Approval(address indexed owner, address indexed spender, uint value);
43	 event Transfer(address indexed from, address indexed to, uint value);
44	 function name() external pure returns (string memory);
45	 function symbol() external pure returns (string memory);
46	 function decimals() external pure returns (uint8);
47	 function totalSupply() external view returns (uint);
48	 function balanceOf(address owner) external view returns (uint);
49	 function allowance(address owner, address spender) external view returns (uint);
50	 function approve(address spender, uint value) external returns (bool);
51	 function transfer(address to, uint value) external returns (bool);
52	 function transferFrom(address from, address to, uint value) external returns (bool);
53	 function DOMAIN_SEPARATOR() external view returns (bytes32);
54	 function PERMIT_TYPEHASH() external pure returns (bytes32);
55	 function nonces(address owner) external view returns (uint);
56	 function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;
57	 event Mint(address indexed sender, uint amount0, uint amount1);
58	 event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
59	 event Swap( address indexed sender, uint amount0In, uint amount1In, uint amount0Out, uint amount1Out, address indexed to );
60	 event Sync(uint112 reserve0, uint112 reserve1);
61	 function MINIMUM_LIQUIDITY() external pure returns (uint);
62	 function factory() external view returns (address);
63	 function token0() external view returns (address);
64	 function token1() external view returns (address);
65	 function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
66	 function price0CumulativeLast() external view returns (uint);
67	 function price1CumulativeLast() external view returns (uint);
68	 function kLast() external view returns (uint);
69	 function mint(address to) external returns (uint liquidity);
70	 function burn(address to) external returns (uint amount0, uint amount1);
71	 function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
72	 function skim(address to) external;
73	 function sync() external;
74	 function initialize(address, address) external;
75	 }
76	 interface IERC20 {
77	 function totalSupply() external view returns (uint256);
78	 function balanceOf(address account) external view returns (uint256);
79	 function transfer(address recipient, uint256 amount) external returns (bool);
80	 function allowance(address owner, address spender) external view returns (uint256);
81	 function approve(address spender, uint256 amount) external returns (bool);
82	 function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
83	 event Transfer(address indexed from, address indexed to, uint256 value);
84	 event Approval(address indexed owner, address indexed spender, uint256 value);
85	 }
86	 contract IDollar is IERC20 {
87	 function burn(uint256 amount) public;
88	 function burnFrom(address account, uint256 amount) public;
89	 function mint(address account, uint256 amount) public returns (bool);
90	 }
91	 library Decimal {
92	 using SafeMath for uint256;
93	 uint256 constant BASE = 10**18;
94	 struct D256 {
95	 uint256 value;
96	 }
97	 function zero() internal pure returns (D256 memory) {
98	 return D256({
99	 value: 0 }
100	 );
101	 }
102	 function one() internal pure returns (D256 memory) {
103	 return D256({
104	 value: BASE }
105	 );
106	 }
107	 function from( uint256 a ) internal pure returns (D256 memory) {
108	 return D256({
109	 value: a.mul(BASE) }
110	 );
111	 }
112	 function ratio( uint256 a, uint256 b ) internal pure returns (D256 memory) {
113	 return D256({
114	 value: getPartial(a, BASE, b) }
115	 );
116	 }
117	 function add( D256 memory self, uint256 b ) internal pure returns (D256 memory) {
118	 return D256({
119	 value: self.value.add(b.mul(BASE)) }
120	 );
121	 }
122	 function sub( D256 memory self, uint256 b ) internal pure returns (D256 memory) {
123	 return D256({
124	 value: self.value.sub(b.mul(BASE)) }
125	 );
126	 }
127	 function sub( D256 memory self, uint256 b, string memory reason ) internal pure returns (D256 memory) {
128	 return D256({
129	 value: self.value.sub(b.mul(BASE), reason) }
130	 );
131	 }
132	 function mul( D256 memory self, uint256 b ) internal pure returns (D256 memory) {
133	 return D256({
134	 value: self.value.mul(b) }
135	 );
136	 }
137	 function div( D256 memory self, uint256 b ) internal pure returns (D256 memory) {
138	 return D256({
139	 value: self.value.div(b) }
140	 );
141	 }
142	 function pow( D256 memory self, uint256 b ) internal pure returns (D256 memory) {
143	 if (b == 0) {
144	 return from(1);
145	 }
146	 D256 memory temp = D256({
147	 value: self.value }
148	 );
149	 for (uint256 i = 1; i < b; i++) {
150	 temp = mul(temp, self);
151	 }
152	 return temp;
153	 }
154	 function add( D256 memory self, D256 memory b ) internal pure returns (D256 memory) {
155	 return D256({
156	 value: self.value.add(b.value) }
157	 );
158	 }
159	 function sub( D256 memory self, D256 memory b ) internal pure returns (D256 memory) {
160	 return D256({
161	 value: self.value.sub(b.value) }
162	 );
163	 }
164	 function sub( D256 memory self, D256 memory b, string memory reason ) internal pure returns (D256 memory) {
165	 return D256({
166	 value: self.value.sub(b.value, reason) }
167	 );
168	 }
169	 function mul( D256 memory self, D256 memory b ) internal pure returns (D256 memory) {
170	 return D256({
171	 value: getPartial(self.value, b.value, BASE) }
172	 );
173	 }
174	 function div( D256 memory self, D256 memory b ) internal pure returns (D256 memory) {
175	 return D256({
176	 value: getPartial(self.value, BASE, b.value) }
177	 );
178	 }
179	 function equals(D256 memory self, D256 memory b) internal pure returns (bool) {
180	 return self.value == b.value;
181	 }
182	 function greaterThan(D256 memory self, D256 memory b) internal pure returns (bool) {
183	 return compareTo(self, b) == 2;
184	 }
185	 function lessThan(D256 memory self, D256 memory b) internal pure returns (bool) {
186	 return compareTo(self, b) == 0;
187	 }
188	 function greaterThanOrEqualTo(D256 memory self, D256 memory b) internal pure returns (bool) {
189	 return compareTo(self, b) > 0;
190	 }
191	 function lessThanOrEqualTo(D256 memory self, D256 memory b) internal pure returns (bool) {
192	 return compareTo(self, b) < 2;
193	 }
194	 function isZero(D256 memory self) internal pure returns (bool) {
195	 return self.value == 0;
196	 }
197	 function asUint256(D256 memory self) internal pure returns (uint256) {
198	 return self.value.div(BASE);
199	 }
200	 function getPartial( uint256 target, uint256 numerator, uint256 denominator ) private pure returns (uint256) {
201	 return target.mul(numerator).div(denominator);
202	 }
203	 function compareTo( D256 memory a, D256 memory b ) private pure returns (uint256) {
204	 if (a.value == b.value) {
205	 return 1;
206	 }
207	 return a.value > b.value ? 2 : 0;
208	 }
209	 }
210	 contract IOracle {
211	 function setup() public;
212	 function capture() public returns (Decimal.D256 memory, bool);
213	 function pair() external view returns (address);
214	 }
215	 contract Account {
216	 enum Status {
217	 Frozen, Fluid, Locked }
218	 struct State {
219	 uint256 staged;
220	 uint256 balance;
221	 mapping(uint256 => uint256) coupons;
222	 mapping(address => uint256) couponAllowances;
223	 uint256 fluidUntil;
224	 uint256 lockedUntil;
225	 }
226	 struct State10 {
227	 uint256 depositedCDSD;
228	 uint256 interestMultiplierEntry;
229	 uint256 earnableCDSD;
230	 uint256 earnedCDSD;
231	 uint256 redeemedCDSD;
232	 uint256 redeemedThisExpansion;
233	 uint256 lastRedeemedExpansionStart;
234	 }
235	 }
236	 contract Epoch {
237	 struct Global {
238	 uint256 start;
239	 uint256 period;
240	 uint256 current;
241	 }
242	 struct Coupons {
243	 uint256 outstanding;
244	 uint256 expiration;
245	 uint256[] expiring;
246	 }
247	 struct State {
248	 uint256 bonded;
249	 Coupons coupons;
250	 }
251	 }
252	 contract Candidate {
253	 enum Vote {
254	 UNDECIDED, APPROVE, REJECT }
255	 struct State {
256	 uint256 start;
257	 uint256 period;
258	 uint256 approve;
259	 uint256 reject;
260	 mapping(address => Vote) votes;
261	 bool initialized;
262	 }
263	 }
264	 contract Storage {
265	 struct Provider {
266	 IDollar dollar;
267	 IOracle oracle;
268	 address pool;
269	 }
270	 struct Balance {
271	 uint256 supply;
272	 uint256 bonded;
273	 uint256 staged;
274	 uint256 redeemable;
275	 uint256 debt;
276	 uint256 coupons;
277	 }
278	 struct State {
279	 Epoch.Global epoch;
280	 Balance balance;
281	 Provider provider;
282	 mapping(address => Account.State) accounts;
283	 mapping(uint256 => Epoch.State) epochs;
284	 mapping(address => Candidate.State) candidates;
285	 }
286	 struct State13 {
287	 mapping(address => mapping(uint256 => uint256)) couponUnderlyingByAccount;
288	 uint256 couponUnderlying;
289	 Decimal.D256 price;
290	 }
291	 struct State16 {
292	 IOracle legacyOracle;
293	 uint256 epochStartForSushiswapPool;
294	 }
295	 struct State10 {
296	 mapping(address => Account.State10) accounts;
297	 uint256 globalInterestMultiplier;
298	 uint256 totalCDSDDeposited;
299	 uint256 totalCDSDEarnable;
300	 uint256 totalCDSDEarned;
301	 uint256 expansionStartEpoch;
302	 uint256 totalCDSDRedeemable;
303	 uint256 totalCDSDRedeemed;
304	 }
305	 }
306	 contract State {
307	 Storage.State _state;
308	 Storage.State13 _state13;
309	 Storage.State16 _state16;
310	 Storage.State10 _state10;
311	 }
312	 library Constants {
313	 uint256 private constant CHAIN_ID = 1;
314	 uint256 private constant BOOTSTRAPPING_PERIOD = 150;
315	 uint256 private constant BOOTSTRAPPING_PRICE = 154e16;
316	 address private constant USDC = address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
317	 uint256 private constant ORACLE_RESERVE_MINIMUM = 1e10;
318	 uint256 private constant INITIAL_STAKE_MULTIPLE = 1e6;
319	 struct EpochStrategy {
320	 uint256 offset;
321	 uint256 start;
322	 uint256 period;
323	 }
324	 uint256 private constant EPOCH_OFFSET = 0;
325	 uint256 private constant EPOCH_START = 1606348800;
326	 uint256 private constant EPOCH_PERIOD = 7200;
327	 uint256 private constant GOVERNANCE_PERIOD = 36;
328	 uint256 private constant GOVERNANCE_QUORUM = 20e16;
329	 uint256 private constant GOVERNANCE_PROPOSAL_THRESHOLD = 5e15;
330	 uint256 private constant GOVERNANCE_SUPER_MAJORITY = 66e16;
331	 uint256 private constant GOVERNANCE_EMERGENCY_DELAY = 6;
332	 uint256 private constant ADVANCE_INCENTIVE_PREMIUM = 125e16;
333	 uint256 private constant DAO_EXIT_LOCKUP_EPOCHS = 36;
334	 uint256 private constant POOL_EXIT_LOCKUP_EPOCHS = 12;
335	 address private constant POOL_ADDRESS = address(0xf929fc6eC25850ce00e457c4F28cDE88A94415D8);
336	 address private constant CONTRACTION_POOL_ADDRESS = address(0x170cec2070399B85363b788Af2FB059DB8Ef8aeD);
337	 uint256 private constant CONTRACTION_POOL_TARGET_SUPPLY = 10e16;
338	 uint256 private constant CONTRACTION_POOL_TARGET_REWARD = 29e13;
339	 uint256 private constant SUPPLY_CHANGE_LIMIT = 2e16;
340	 uint256 private constant SUPPLY_CHANGE_DIVISOR = 25e18;
341	 uint256 private constant ORACLE_POOL_RATIO = 35;
342	 uint256 private constant TREASURY_RATIO = 3;
343	 address private constant DAO_ADDRESS = address(0x6Bf977ED1A09214E6209F4EA5f525261f1A2690a);
344	 address private constant DOLLAR_ADDRESS = address(0xBD2F0Cd039E0BFcf88901C98c0bFAc5ab27566e3);
345	 address private constant CONTRACTION_DOLLAR_ADDRESS = address(0xDe25486CCb4588Ce5D9fB188fb6Af72E768a466a);
346	 address private constant PAIR_ADDRESS = address(0x26d8151e631608570F3c28bec769C3AfEE0d73a3);
347	 address private constant CONTRACTION_PAIR_ADDRESS = address(0x4a4572D92Daf14D29C3b8d001A2d965c6A2b1515);
348	 address private constant TREASURY_ADDRESS = address(0xC7DA8087b8BA11f0892f1B0BFacfD44C116B303e);
349	 uint256 private constant EARNABLE_FACTOR = 1e18;
350	 uint256 private constant CDSD_REDEMPTION_RATIO = 50;
351	 uint256 private constant CONTRACTION_BONDING_REWARDS = 51000000000000;
352	 uint256 private constant MAX_CDSD_BONDING_REWARDS = 2750000000000000;
353	 uint256 private constant MAX_CDSD_REWARDS_THRESHOLD = 75e16;
354	 function getUsdcAddress() internal pure returns (address) {
355	 return USDC;
356	 }
357	 function getOracleReserveMinimum() internal pure returns (uint256) {
358	 return ORACLE_RESERVE_MINIMUM;
359	 }
360	 function getEpochStrategy() internal pure returns (EpochStrategy memory) {
361	 return EpochStrategy({
362	 offset: EPOCH_OFFSET, start: EPOCH_START, period: EPOCH_PERIOD }
363	 );
364	 }
365	 function getInitialStakeMultiple() internal pure returns (uint256) {
366	 return INITIAL_STAKE_MULTIPLE;
367	 }
368	 function getBootstrappingPeriod() internal pure returns (uint256) {
369	 return BOOTSTRAPPING_PERIOD;
370	 }
371	 function getBootstrappingPrice() internal pure returns (Decimal.D256 memory) {
372	 return Decimal.D256({
373	 value: BOOTSTRAPPING_PRICE }
374	 );
375	 }
376	 function getGovernancePeriod() internal pure returns (uint256) {
377	 return GOVERNANCE_PERIOD;
378	 }
379	 function getGovernanceQuorum() internal pure returns (Decimal.D256 memory) {
380	 return Decimal.D256({
381	 value: GOVERNANCE_QUORUM }
382	 );
383	 }
384	 function getGovernanceProposalThreshold() internal pure returns (Decimal.D256 memory) {
385	 return Decimal.D256({
386	 value: GOVERNANCE_PROPOSAL_THRESHOLD }
387	 );
388	 }
389	 function getGovernanceSuperMajority() internal pure returns (Decimal.D256 memory) {
390	 return Decimal.D256({
391	 value: GOVERNANCE_SUPER_MAJORITY }
392	 );
393	 }
394	 function getGovernanceEmergencyDelay() internal pure returns (uint256) {
395	 return GOVERNANCE_EMERGENCY_DELAY;
396	 }
397	 function getAdvanceIncentivePremium() internal pure returns (Decimal.D256 memory) {
398	 return Decimal.D256({
399	 value: ADVANCE_INCENTIVE_PREMIUM }
400	 );
401	 }
402	 function getDAOExitLockupEpochs() internal pure returns (uint256) {
403	 return DAO_EXIT_LOCKUP_EPOCHS;
404	 }
405	 function getPoolExitLockupEpochs() internal pure returns (uint256) {
406	 return POOL_EXIT_LOCKUP_EPOCHS;
407	 }
408	 function getPoolAddress() internal pure returns (address) {
409	 return POOL_ADDRESS;
410	 }
411	 function getContractionPoolAddress() internal pure returns (address) {
412	 return CONTRACTION_POOL_ADDRESS;
413	 }
414	 function getContractionPoolTargetSupply() internal pure returns (Decimal.D256 memory) {
415	 return Decimal.D256({
416	 value: CONTRACTION_POOL_TARGET_SUPPLY}
417	 );
418	 }
419	 function getContractionPoolTargetReward() internal pure returns (Decimal.D256 memory) {
420	 return Decimal.D256({
421	 value: CONTRACTION_POOL_TARGET_REWARD}
422	 );
423	 }
424	 function getSupplyChangeLimit() internal pure returns (Decimal.D256 memory) {
425	 return Decimal.D256({
426	 value: SUPPLY_CHANGE_LIMIT }
427	 );
428	 }
429	 function getSupplyChangeDivisor() internal pure returns (Decimal.D256 memory) {
430	 return Decimal.D256({
431	 value: SUPPLY_CHANGE_DIVISOR }
432	 );
433	 }
434	 function getOraclePoolRatio() internal pure returns (uint256) {
435	 return ORACLE_POOL_RATIO;
436	 }
437	 function getTreasuryRatio() internal pure returns (uint256) {
438	 return TREASURY_RATIO;
439	 }
440	 function getChainId() internal pure returns (uint256) {
441	 return CHAIN_ID;
442	 }
443	 function getDaoAddress() internal pure returns (address) {
444	 return DAO_ADDRESS;
445	 }
446	 function getDollarAddress() internal pure returns (address) {
447	 return DOLLAR_ADDRESS;
448	 }
449	 function getContractionDollarAddress() internal pure returns (address) {
450	 return CONTRACTION_DOLLAR_ADDRESS;
451	 }
452	 function getPairAddress() internal pure returns (address) {
453	 return PAIR_ADDRESS;
454	 }
455	 function getContractionPairAddress() internal pure returns (address) {
456	 return CONTRACTION_PAIR_ADDRESS;
457	 }
458	 function getTreasuryAddress() internal pure returns (address) {
459	 return TREASURY_ADDRESS;
460	 }
461	 function getEarnableFactor() internal pure returns (Decimal.D256 memory) {
462	 return Decimal.D256({
463	 value: EARNABLE_FACTOR}
464	 );
465	 }
466	 function getCDSDRedemptionRatio() internal pure returns (uint256) {
467	 return CDSD_REDEMPTION_RATIO;
468	 }
469	 function getContractionBondingRewards() internal pure returns (Decimal.D256 memory) {
470	 return Decimal.D256({
471	 value: CONTRACTION_BONDING_REWARDS}
472	 );
473	 }
474	 function maxCDSDBondingRewards() internal pure returns (Decimal.D256 memory) {
475	 return Decimal.D256({
476	 value: MAX_CDSD_BONDING_REWARDS}
477	 );
478	 }
479	 function maxCDSDRewardsThreshold() internal pure returns (Decimal.D256 memory) {
480	 return Decimal.D256({
481	 value: MAX_CDSD_REWARDS_THRESHOLD}
482	 );
483	 }
484	 }
485	 contract Getters is State {
486	 using SafeMath for uint256;
487	 using Decimal for Decimal.D256;
488	 bytes32 private constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
489	 function name() public view returns (string memory) {
490	 return "Dynamic Set Dollar Stake";
491	 }
492	 function symbol() public view returns (string memory) {
493	 return "DSDS";
494	 }
495	 function decimals() public view returns (uint8) {
496	 return 18;
497	 }
498	 function balanceOf(address account) public view returns (uint256) {
499	 return _state.accounts[account].balance;
500	 }
501	 function totalSupply() public view returns (uint256) {
502	 return _state.balance.supply;
503	 }
504	 function allowance(address owner, address spender) external view returns (uint256) {
505	 return 0;
506	 }
507	 function dollar() public view returns (IDollar) {
508	 return _state.provider.dollar;
509	 }
510	 function oracle() public view returns (IOracle) {
511	 if (epoch() < _state16.epochStartForSushiswapPool) {
512	 return _state16.legacyOracle;
513	 }
514	 else {
515	 return _state.provider.oracle;
516	 }
517	 }
518	 function pool() public view returns (address) {
519	 return Constants.getPoolAddress();
520	 }
521	 function cpool() public view returns (address) {
522	 return Constants.getContractionPoolAddress();
523	 }
524	 function totalBonded() public view returns (uint256) {
525	 return _state.balance.bonded;
526	 }
527	 function totalStaged() public view returns (uint256) {
528	 return _state.balance.staged;
529	 }
530	 function totalDebt() public view returns (uint256) {
531	 return _state.balance.debt;
532	 }
533	 function totalRedeemable() public view returns (uint256) {
534	 return _state.balance.redeemable;
535	 }
536	 function totalCouponUnderlying() public view returns (uint256) {
537	 return _state13.couponUnderlying;
538	 }
539	 function totalCoupons() public view returns (uint256) {
540	 return _state.balance.coupons;
541	 }
542	 function treasury() public view returns (address) {
543	 return Constants.getTreasuryAddress();
544	 }
545	 function totalCDSDBonded() public view returns (uint256) {
546	 return cdsd().balanceOf(address(this));
547	 }
548	 function globalInterestMultiplier() public view returns (uint256) {
549	 return _state10.globalInterestMultiplier;
550	 }
551	 function expansionStartEpoch() public view returns (uint256) {
552	 return _state10.expansionStartEpoch;
553	 }
554	 function totalCDSD() public view returns (uint256) {
555	 return cdsd().totalSupply();
556	 }
557	 function cdsd() public view returns (IDollar) {
558	 return IDollar(Constants.getContractionDollarAddress());
559	 }
560	 function getPrice() public view returns (Decimal.D256 memory price) {
561	 return _state13.price;
562	 }
563	 function balanceOfStaged(address account) public view returns (uint256) {
564	 return _state.accounts[account].staged;
565	 }
566	 function balanceOfBonded(address account) public view returns (uint256) {
567	 uint256 totalSupplyAmount = totalSupply();
568	 if (totalSupplyAmount == 0) {
569	 return 0;
570	 }
571	 return totalBonded().mul(balanceOf(account)).div(totalSupplyAmount);
572	 }
573	 function balanceOfCoupons(address account, uint256 epoch) public view returns (uint256) {
574	 if (outstandingCoupons(epoch) == 0) {
575	 return 0;
576	 }
577	 return _state.accounts[account].coupons[epoch];
578	 }
579	 function balanceOfCouponUnderlying(address account, uint256 epoch) public view returns (uint256) {
580	 uint256 underlying = _state13.couponUnderlyingByAccount[account][epoch];
581	 if (underlying == 0 && outstandingCoupons(epoch) == 0) {
582	 return _state.accounts[account].coupons[epoch].div(2);
583	 }
584	 return underlying;
585	 }
586	 function statusOf(address account) public view returns (Account.Status) {
587	 if (_state.accounts[account].lockedUntil > epoch()) {
588	 return Account.Status.Locked;
589	 }
590	 return epoch() >= _state.accounts[account].fluidUntil ? Account.Status.Frozen : Account.Status.Fluid;
591	 }
592	 function fluidUntil(address account) public view returns (uint256) {
593	 return _state.accounts[account].fluidUntil;
594	 }
595	 function lockedUntil(address account) public view returns (uint256) {
596	 return _state.accounts[account].lockedUntil;
597	 }
598	 function allowanceCoupons(address owner, address spender) public view returns (uint256) {
599	 return _state.accounts[owner].couponAllowances[spender];
600	 }
601	 function balanceOfCDSDBonded(address account) public view returns (uint256) {
602	 uint256 entry = interestMultiplierEntryByAccount(account);
603	 if (entry == 0) {
604	 return 0;
605	 }
606	 uint256 amount = depositedCDSDByAccount(account).mul(_state10.globalInterestMultiplier).div(entry);
607	 uint256 cappedAmount = cDSDBondedCap(account);
608	 return amount > cappedAmount ? cappedAmount : amount;
609	 }
610	 function cDSDBondedCap(address account) public view returns (uint256) {
611	 return depositedCDSDByAccount(account).add(earnableCDSDByAccount(account)).sub(earnedCDSDByAccount(account));
612	 }
613	 function depositedCDSDByAccount(address account) public view returns (uint256) {
614	 return _state10.accounts[account].depositedCDSD;
615	 }
616	 function interestMultiplierEntryByAccount(address account) public view returns (uint256) {
617	 return _state10.accounts[account].interestMultiplierEntry;
618	 }
619	 function earnableCDSDByAccount(address account) public view returns (uint256) {
620	 return _state10.accounts[account].earnableCDSD;
621	 }
622	 function earnedCDSDByAccount(address account) public view returns (uint256) {
623	 return _state10.accounts[account].earnedCDSD;
624	 }
625	 function redeemedCDSDByAccount(address account) public view returns (uint256) {
626	 return _state10.accounts[account].redeemedCDSD;
627	 }
628	 function getRedeemedThisExpansion(address account) public view returns (uint256) {
629	 uint256 currentExpansion = _state10.expansionStartEpoch;
630	 uint256 accountExpansion = _state10.accounts[account].lastRedeemedExpansionStart;
631	 if (currentExpansion != accountExpansion) {
632	 return 0;
633	 }
634	 else {
635	 return _state10.accounts[account].redeemedThisExpansion;
636	 }
637	 }
638	 function getCurrentRedeemableCDSDByAccount(address account) public view returns (uint256) {
639	 uint256 total = totalCDSDBonded();
640	 if (total == 0) {
641	 return 0;
642	 }
643	 return totalCDSDRedeemable().mul(balanceOfCDSDBonded(account)).div(total).sub(getRedeemedThisExpansion(account));
644	 }
645	 function totalCDSDDeposited() public view returns (uint256) {
646	 return _state10.totalCDSDDeposited;
647	 }
648	 function totalCDSDEarnable() public view returns (uint256) {
649	 return _state10.totalCDSDEarnable;
650	 }
651	 function totalCDSDEarned() public view returns (uint256) {
652	 return _state10.totalCDSDEarned;
653	 }
654	 function totalCDSDRedeemed() public view returns (uint256) {
655	 return _state10.totalCDSDRedeemed;
656	 }
657	 function totalCDSDRedeemable() public view returns (uint256) {
658	 return _state10.totalCDSDRedeemable;
659	 }
660	 function maxCDSDOutstanding() public view returns (uint256) {
661	 return totalCDSDDeposited().add(totalCDSDEarnable()).sub(totalCDSDEarned());
662	 }
663	 function epoch() public view returns (uint256) {
664	 return _state.epoch.current;
665	 }
666	 function epochTime() public view returns (uint256) {
667	 Constants.EpochStrategy memory current = Constants.getEpochStrategy();
668	 return epochTimeWithStrategy(current);
669	 }
670	 function epochTimeWithStrategy(Constants.EpochStrategy memory strategy) private view returns (uint256) {
671	 return blockTimestamp().sub(strategy.start).div(strategy.period).add(strategy.offset);
672	 }
673	 function blockTimestamp() internal view returns (uint256) {
674	 return block.timestamp;
675	 }
676	 function outstandingCoupons(uint256 epoch) public view returns (uint256) {
677	 return _state.epochs[epoch].coupons.outstanding;
678	 }
679	 function couponsExpiration(uint256 epoch) public view returns (uint256) {
680	 return _state.epochs[epoch].coupons.expiration;
681	 }
682	 function expiringCoupons(uint256 epoch) public view returns (uint256) {
683	 return _state.epochs[epoch].coupons.expiring.length;
684	 }
685	 function expiringCouponsAtIndex(uint256 epoch, uint256 i) public view returns (uint256) {
686	 return _state.epochs[epoch].coupons.expiring[i];
687	 }
688	 function totalBondedAt(uint256 epoch) public view returns (uint256) {
689	 return _state.epochs[epoch].bonded;
690	 }
691	 function bootstrappingAt(uint256 epoch) public view returns (bool) {
692	 return epoch <= Constants.getBootstrappingPeriod();
693	 }
694	 function recordedVote(address account, address candidate) public view returns (Candidate.Vote) {
695	 return _state.candidates[candidate].votes[account];
696	 }
697	 function startFor(address candidate) public view returns (uint256) {
698	 return _state.candidates[candidate].start;
699	 }
700	 function periodFor(address candidate) public view returns (uint256) {
701	 return _state.candidates[candidate].period;
702	 }
703	 function approveFor(address candidate) public view returns (uint256) {
704	 return _state.candidates[candidate].approve;
705	 }
706	 function rejectFor(address candidate) public view returns (uint256) {
707	 return _state.candidates[candidate].reject;
708	 }
709	 function votesFor(address candidate) public view returns (uint256) {
710	 return approveFor(candidate).add(rejectFor(candidate));
711	 }
712	 function isNominated(address candidate) public view returns (bool) {
713	 return _state.candidates[candidate].start > 0;
714	 }
715	 function isInitialized(address candidate) public view returns (bool) {
716	 return _state.candidates[candidate].initialized;
717	 }
718	 function implementation() public view returns (address impl) {
719	 bytes32 slot = IMPLEMENTATION_SLOT;
720	 assembly {
721	 impl := sload(slot) }
722	 }
723	 }
724	 contract Setters is State, Getters {
725	 using SafeMath for uint256;
726	 event Transfer(address indexed from, address indexed to, uint256 value);
727	 function transfer(address recipient, uint256 amount) external returns (bool) {
728	 return false;
729	 }
730	 function approve(address spender, uint256 amount) external returns (bool) {
731	 return false;
732	 }
733	 function transferFrom( address sender, address recipient, uint256 amount ) external returns (bool) {
734	 return false;
735	 }
736	 function incrementTotalBonded(uint256 amount) internal {
737	 _state.balance.bonded = _state.balance.bonded.add(amount);
738	 }
739	 function decrementTotalBonded(uint256 amount, string memory reason) internal {
740	 _state.balance.bonded = _state.balance.bonded.sub(amount, reason);
741	 }
742	 function incrementTotalDebt(uint256 amount) internal {
743	 _state.balance.debt = _state.balance.debt.add(amount);
744	 }
745	 function decrementTotalDebt(uint256 amount, string memory reason) internal {
746	 _state.balance.debt = _state.balance.debt.sub(amount, reason);
747	 }
748	 function setDebtToZero() internal {
749	 _state.balance.debt = 0;
750	 }
751	 function incrementTotalRedeemable(uint256 amount) internal {
752	 _state.balance.redeemable = _state.balance.redeemable.add(amount);
753	 }
754	 function decrementTotalRedeemable(uint256 amount, string memory reason) internal {
755	 _state.balance.redeemable = _state.balance.redeemable.sub(amount, reason);
756	 }
757	 function setGlobalInterestMultiplier(uint256 multiplier) internal {
758	 _state10.globalInterestMultiplier = multiplier;
759	 }
760	 function setExpansionStartEpoch(uint256 epoch) internal {
761	 _state10.expansionStartEpoch = epoch;
762	 }
763	 function incrementTotalCDSDRedeemable(uint256 amount) internal {
764	 _state10.totalCDSDRedeemable = _state10.totalCDSDRedeemable.add(amount);
765	 }
766	 function decrementTotalCDSDRedeemable(uint256 amount, string memory reason) internal {
767	 _state10.totalCDSDRedeemable = _state10.totalCDSDRedeemable.sub(amount, reason);
768	 }
769	 function incrementTotalCDSDRedeemed(uint256 amount) internal {
770	 _state10.totalCDSDRedeemed = _state10.totalCDSDRedeemed.add(amount);
771	 }
772	 function decrementTotalCDSDRedeemed(uint256 amount, string memory reason) internal {
773	 _state10.totalCDSDRedeemed = _state10.totalCDSDRedeemed.sub(amount, reason);
774	 }
775	 function clearCDSDRedeemable() internal {
776	 _state10.totalCDSDRedeemable = 0;
777	 _state10.totalCDSDRedeemed = 0;
778	 }
779	 function incrementTotalCDSDDeposited(uint256 amount) internal {
780	 _state10.totalCDSDDeposited = _state10.totalCDSDDeposited.add(amount);
781	 }
782	 function decrementTotalCDSDDeposited(uint256 amount, string memory reason) internal {
783	 _state10.totalCDSDDeposited = _state10.totalCDSDDeposited.sub(amount, reason);
784	 }
785	 function incrementTotalCDSDEarnable(uint256 amount) internal {
786	 _state10.totalCDSDEarnable = _state10.totalCDSDEarnable.add(amount);
787	 }
788	 function decrementTotalCDSDEarnable(uint256 amount, string memory reason) internal {
789	 _state10.totalCDSDEarnable = _state10.totalCDSDEarnable.sub(amount, reason);
790	 }
791	 function incrementTotalCDSDEarned(uint256 amount) internal {
792	 _state10.totalCDSDEarned = _state10.totalCDSDEarned.add(amount);
793	 }
794	 function decrementTotalCDSDEarned(uint256 amount, string memory reason) internal {
795	 _state10.totalCDSDEarned = _state10.totalCDSDEarned.sub(amount, reason);
796	 }
797	 function incrementBalanceOf(address account, uint256 amount) internal {
798	 _state.accounts[account].balance = _state.accounts[account].balance.add(amount);
799	 _state.balance.supply = _state.balance.supply.add(amount);
800	 emit Transfer(address(0), account, amount);
801	 }
802	 function decrementBalanceOf( address account, uint256 amount, string memory reason ) internal {
803	 _state.accounts[account].balance = _state.accounts[account].balance.sub(amount, reason);
804	 _state.balance.supply = _state.balance.supply.sub(amount, reason);
805	 emit Transfer(account, address(0), amount);
806	 }
807	 function incrementBalanceOfStaged(address account, uint256 amount) internal {
808	 _state.accounts[account].staged = _state.accounts[account].staged.add(amount);
809	 _state.balance.staged = _state.balance.staged.add(amount);
810	 }
811	 function decrementBalanceOfStaged( address account, uint256 amount, string memory reason ) internal {
812	 _state.accounts[account].staged = _state.accounts[account].staged.sub(amount, reason);
813	 _state.balance.staged = _state.balance.staged.sub(amount, reason);
814	 }
815	 function incrementBalanceOfCoupons( address account, uint256 epoch, uint256 amount ) internal {
816	 _state.accounts[account].coupons[epoch] = _state.accounts[account].coupons[epoch].add(amount);
817	 _state.epochs[epoch].coupons.outstanding = _state.epochs[epoch].coupons.outstanding.add(amount);
818	 _state.balance.coupons = _state.balance.coupons.add(amount);
819	 }
820	 function incrementBalanceOfCouponUnderlying( address account, uint256 epoch, uint256 amount ) internal {
821	 _state13.couponUnderlyingByAccount[account][epoch] = _state13.couponUnderlyingByAccount[account][epoch].add( amount );
822	 _state13.couponUnderlying = _state13.couponUnderlying.add(amount);
823	 }
824	 function decrementBalanceOfCoupons( address account, uint256 epoch, uint256 amount, string memory reason ) internal {
825	 _state.accounts[account].coupons[epoch] = _state.accounts[account].coupons[epoch].sub(amount, reason);
826	 _state.epochs[epoch].coupons.outstanding = _state.epochs[epoch].coupons.outstanding.sub(amount, reason);
827	 _state.balance.coupons = _state.balance.coupons.sub(amount, reason);
828	 }
829	 function decrementBalanceOfCouponUnderlying( address account, uint256 epoch, uint256 amount, string memory reason ) internal {
830	 _state13.couponUnderlyingByAccount[account][epoch] = _state13.couponUnderlyingByAccount[account][epoch].sub( amount, reason );
831	 _state13.couponUnderlying = _state13.couponUnderlying.sub(amount, reason);
832	 }
833	 function unfreeze(address account) internal {
834	 _state.accounts[account].fluidUntil = epoch().add(Constants.getDAOExitLockupEpochs());
835	 }
836	 function updateAllowanceCoupons( address owner, address spender, uint256 amount ) internal {
837	 _state.accounts[owner].couponAllowances[spender] = amount;
838	 }
839	 function decrementAllowanceCoupons( address owner, address spender, uint256 amount, string memory reason ) internal {
840	 _state.accounts[owner].couponAllowances[spender] = _state.accounts[owner].couponAllowances[spender].sub( amount, reason );
841	 }
842	 function incrementBalanceOfDepositedCDSD(address account, uint256 amount) internal {
843	 _state10.accounts[account].depositedCDSD = _state10.accounts[account].depositedCDSD.add(amount);
844	 }
845	 function decrementBalanceOfDepositedCDSD(address account, uint256 amount, string memory reason) internal {
846	 _state10.accounts[account].depositedCDSD = _state10.accounts[account].depositedCDSD.sub(amount, reason);
847	 }
848	 function incrementBalanceOfEarnableCDSD(address account, uint256 amount) internal {
849	 _state10.accounts[account].earnableCDSD = _state10.accounts[account].earnableCDSD.add(amount);
850	 }
851	 function decrementBalanceOfEarnableCDSD(address account, uint256 amount, string memory reason) internal {
852	 _state10.accounts[account].earnableCDSD = _state10.accounts[account].earnableCDSD.sub(amount, reason);
853	 }
854	 function incrementBalanceOfEarnedCDSD(address account, uint256 amount) internal {
855	 _state10.accounts[account].earnedCDSD = _state10.accounts[account].earnedCDSD.add(amount);
856	 }
857	 function decrementBalanceOfEarnedCDSD(address account, uint256 amount, string memory reason) internal {
858	 _state10.accounts[account].earnedCDSD = _state10.accounts[account].earnedCDSD.sub(amount, reason);
859	 }
860	 function incrementBalanceOfRedeemedCDSD(address account, uint256 amount) internal {
861	 _state10.accounts[account].redeemedCDSD = _state10.accounts[account].redeemedCDSD.add(amount);
862	 }
863	 function decrementBalanceOfRedeemedCDSD(address account, uint256 amount, string memory reason) internal {
864	 _state10.accounts[account].redeemedCDSD = _state10.accounts[account].redeemedCDSD.sub(amount, reason);
865	 }
866	 function addRedeemedThisExpansion(address account, uint256 amount) internal returns (uint256) {
867	 uint256 currentExpansion = _state10.expansionStartEpoch;
868	 uint256 accountExpansion = _state10.accounts[account].lastRedeemedExpansionStart;
869	 if (currentExpansion != accountExpansion) {
870	 _state10.accounts[account].redeemedThisExpansion = amount;
871	 _state10.accounts[account].lastRedeemedExpansionStart = currentExpansion;
872	 }
873	 else{
874	 _state10.accounts[account].redeemedThisExpansion = _state10.accounts[account].redeemedThisExpansion.add(amount);
875	 }
876	 }
877	 function setCurrentInterestMultiplier(address account) internal returns (uint256) {
878	 _state10.accounts[account].interestMultiplierEntry = _state10.globalInterestMultiplier;
879	 }
880	 function setDepositedCDSDAmount(address account, uint256 amount) internal returns (uint256) {
881	 _state10.accounts[account].depositedCDSD = amount;
882	 }
883	 function incrementEpoch() internal {
884	 _state.epoch.current = _state.epoch.current.add(1);
885	 }
886	 function snapshotTotalBonded() internal {
887	 _state.epochs[epoch()].bonded = totalSupply();
888	 }
889	 function initializeCouponsExpiration(uint256 epoch, uint256 expiration) internal {
890	 _state.epochs[epoch].coupons.expiration = expiration;
891	 _state.epochs[expiration].coupons.expiring.push(epoch);
892	 }
893	 function createCandidate(address candidate, uint256 period) internal {
894	 _state.candidates[candidate].start = epoch();
895	 _state.candidates[candidate].period = period;
896	 }
897	 function recordVote( address account, address candidate, Candidate.Vote vote ) internal {
898	 _state.candidates[candidate].votes[account] = vote;
899	 }
900	 function incrementApproveFor(address candidate, uint256 amount) internal {
901	 _state.candidates[candidate].approve = _state.candidates[candidate].approve.add(amount);
902	 }
903	 function decrementApproveFor( address candidate, uint256 amount, string memory reason ) internal {
904	 _state.candidates[candidate].approve = _state.candidates[candidate].approve.sub(amount, reason);
905	 }
906	 function incrementRejectFor(address candidate, uint256 amount) internal {
907	 _state.candidates[candidate].reject = _state.candidates[candidate].reject.add(amount);
908	 }
909	 function decrementRejectFor( address candidate, uint256 amount, string memory reason ) internal {
910	 _state.candidates[candidate].reject = _state.candidates[candidate].reject.sub(amount, reason);
911	 }
912	 function placeLock(address account, address candidate) internal {
913	 uint256 currentLock = _state.accounts[account].lockedUntil;
914	 uint256 newLock = startFor(candidate).add(periodFor(candidate));
915	 if (newLock > currentLock) {
916	 _state.accounts[account].lockedUntil = newLock;
917	 }
918	 }
919	 function initialized(address candidate) internal {
920	 _state.candidates[candidate].initialized = true;
921	 }
922	 }
923	 library Require {
924	 uint256 constant ASCII_ZERO = 48;
925	 uint256 constant ASCII_RELATIVE_ZERO = 87;
926	 uint256 constant ASCII_LOWER_EX = 120;
927	 bytes2 constant COLON = 0x3a20;
928	 bytes2 constant COMMA = 0x2c20;
929	 bytes2 constant LPAREN = 0x203c;
930	 byte constant RPAREN = 0x3e;
931	 uint256 constant FOUR_BIT_MASK = 0xf;
932	 function that( bool must, bytes32 file, bytes32 reason ) internal pure {
933	 if (!must) {
934	 revert( string( abi.encodePacked( stringifyTruncated(file), COLON, stringifyTruncated(reason) ) ) );
935	 }
936	 }
937	 function that( bool must, bytes32 file, bytes32 reason, uint256 payloadA ) internal pure {
938	 if (!must) {
939	 revert( string( abi.encodePacked( stringifyTruncated(file), COLON, stringifyTruncated(reason), LPAREN, stringify(payloadA), RPAREN ) ) );
940	 }
941	 }
942	 function that( bool must, bytes32 file, bytes32 reason, uint256 payloadA, uint256 payloadB ) internal pure {
943	 if (!must) {
944	 revert( string( abi.encodePacked( stringifyTruncated(file), COLON, stringifyTruncated(reason), LPAREN, stringify(payloadA), COMMA, stringify(payloadB), RPAREN ) ) );
945	 }
946	 }
947	 function that( bool must, bytes32 file, bytes32 reason, address payloadA ) internal pure {
948	 if (!must) {
949	 revert( string( abi.encodePacked( stringifyTruncated(file), COLON, stringifyTruncated(reason), LPAREN, stringify(payloadA), RPAREN ) ) );
950	 }
951	 }
952	 function that( bool must, bytes32 file, bytes32 reason, address payloadA, uint256 payloadB ) internal pure {
953	 if (!must) {
954	 revert( string( abi.encodePacked( stringifyTruncated(file), COLON, stringifyTruncated(reason), LPAREN, stringify(payloadA), COMMA, stringify(payloadB), RPAREN ) ) );
955	 }
956	 }
957	 function that( bool must, bytes32 file, bytes32 reason, address payloadA, uint256 payloadB, uint256 payloadC ) internal pure {
958	 if (!must) {
959	 revert( string( abi.encodePacked( stringifyTruncated(file), COLON, stringifyTruncated(reason), LPAREN, stringify(payloadA), COMMA, stringify(payloadB), COMMA, stringify(payloadC), RPAREN ) ) );
960	 }
961	 }
962	 function that( bool must, bytes32 file, bytes32 reason, bytes32 payloadA ) internal pure {
963	 if (!must) {
964	 revert( string( abi.encodePacked( stringifyTruncated(file), COLON, stringifyTruncated(reason), LPAREN, stringify(payloadA), RPAREN ) ) );
965	 }
966	 }
967	 function that( bool must, bytes32 file, bytes32 reason, bytes32 payloadA, uint256 payloadB, uint256 payloadC ) internal pure {
968	 if (!must) {
969	 revert( string( abi.encodePacked( stringifyTruncated(file), COLON, stringifyTruncated(reason), LPAREN, stringify(payloadA), COMMA, stringify(payloadB), COMMA, stringify(payloadC), RPAREN ) ) );
970	 }
971	 }
972	 function stringifyTruncated( bytes32 input ) private pure returns (bytes memory) {
973	 bytes memory result = abi.encodePacked(input);
974	 for (uint256 i = 32; i > 0; ) {
975	 i--;
976	 if (result[i] != 0) {
977	 uint256 length = i + 1;
978	 assembly {
979	 mstore(result, length) }
980	 return result;
981	 }
982	 }
983	 return new bytes(0);
984	 }
985	 function stringify( uint256 input ) private pure returns (bytes memory) {
986	 if (input == 0) {
987	 return "0";
988	 }
989	 uint256 j = input;
990	 uint256 length;
991	 while (j != 0) {
992	 length++;
993	 j /= 10;
994	 }
995	 bytes memory bstr = new bytes(length);
996	 j = input;
997	 for (uint256 i = length; i > 0; ) {
998	 i--;
999	 bstr[i] = byte(uint8(ASCII_ZERO + (j % 10)));
1000	 j /= 10;
1001	 }
1002	 return bstr;
1003	 }
1004	 function stringify( address input ) private pure returns (bytes memory) {
1005	 uint256 z = uint256(input);
1006	 bytes memory result = new bytes(42);
1007	 result[0] = byte(uint8(ASCII_ZERO));
1008	 result[1] = byte(uint8(ASCII_LOWER_EX));
1009	 for (uint256 i = 0; i < 20; i++) {
1010	 uint256 shift = i * 2;
1011	 result[41 - shift] = char(z & FOUR_BIT_MASK);
1012	 z = z >> 4;
1013	 result[40 - shift] = char(z & FOUR_BIT_MASK);
1014	 z = z >> 4;
1015	 }
1016	 return result;
1017	 }
1018	 function stringify( bytes32 input ) private pure returns (bytes memory) {
1019	 uint256 z = uint256(input);
1020	 bytes memory result = new bytes(66);
1021	 result[0] = byte(uint8(ASCII_ZERO));
1022	 result[1] = byte(uint8(ASCII_LOWER_EX));
1023	 for (uint256 i = 0; i < 32; i++) {
1024	 uint256 shift = i * 2;
1025	 result[65 - shift] = char(z & FOUR_BIT_MASK);
1026	 z = z >> 4;
1027	 result[64 - shift] = char(z & FOUR_BIT_MASK);
1028	 z = z >> 4;
1029	 }
1030	 return result;
1031	 }
1032	 function char( uint256 input ) private pure returns (byte) {
1033	 if (input < 10) {
1034	 return byte(uint8(input + ASCII_ZERO));
1035	 }
1036	 return byte(uint8(input + ASCII_RELATIVE_ZERO));
1037	 }
1038	 }
1039	 contract Comptroller is Setters {
1040	 using SafeMath for uint256;
1041	 bytes32 private constant FILE = "Comptroller";
1042	 function setPrice(Decimal.D256 memory price) internal {
1043	 _state13.price = price;
1044	 if (price.greaterThan(Decimal.one())) {
1045	 if(_state10.expansionStartEpoch == 0){
1046	 _state10.expansionStartEpoch = epoch();
1047	 }
1048	 }
1049	 else {
1050	 _state10.expansionStartEpoch = 0;
1051	 }
1052	 }
1053	 function mintToAccount(address account, uint256 amount) internal {
1054	 dollar().mint(account, amount);
1055	 balanceCheck();
1056	 }
1057	 function burnFromAccount(address account, uint256 amount) internal {
1058	 dollar().transferFrom(account, address(this), amount);
1059	 dollar().burn(amount);
1060	 balanceCheck();
1061	 }
1062	 function burnRedeemable(uint256 amount) internal {
1063	 dollar().burn(amount);
1064	 decrementTotalRedeemable(amount, "Comptroller: not enough redeemable balance");
1065	 balanceCheck();
1066	 }
1067	 function contractionIncentives(Decimal.D256 memory price) internal returns (uint256) {
1068	 uint256 redeemable = totalCDSDRedeemable();
1069	 if (redeemable != 0) {
1070	 clearCDSDRedeemable();
1071	 }
1072	 uint256 currentMultiplier = globalInterestMultiplier();
1073	 Decimal.D256 memory interest = Constants.maxCDSDBondingRewards();
1074	 if (price.greaterThan(Constants.maxCDSDRewardsThreshold())) {
1075	 Decimal.D256 memory maxDelta = Decimal.one().sub(Constants.maxCDSDRewardsThreshold());
1076	 interest = interest .mul( maxDelta.sub(price.sub(Constants.maxCDSDRewardsThreshold())) ) .div(maxDelta);
1077	 }
1078	 uint256 newMultiplier = Decimal.D256({
1079	 value:currentMultiplier}
1080	 ).mul(Decimal.one().add(interest)).value;
1081	 setGlobalInterestMultiplier(newMultiplier);
1082	 Decimal.D256 memory cPoolReward = Decimal.D256({
1083	 value:cdsd().totalSupply()}
1084	 ) .mul(Constants.getContractionPoolTargetSupply()) .mul(Constants.getContractionPoolTargetReward());
1085	 cdsd().mint(Constants.getContractionPoolAddress(), cPoolReward.value);
1086	 uint256 daoBondingRewards;
1087	 if (totalBonded() != 0) {
1088	 daoBondingRewards = Decimal.D256(totalBonded()).mul(Constants.getContractionBondingRewards()).value;
1089	 mintToDAO(daoBondingRewards);
1090	 }
1091	 balanceCheck();
1092	 return daoBondingRewards;
1093	 }
1094	 function increaseSupply(uint256 newSupply) internal returns (uint256, uint256) {
1095	 uint256 poolReward = newSupply.mul(Constants.getOraclePoolRatio()).div(100);
1096	 mintToPool(poolReward);
1097	 uint256 treasuryReward = newSupply.mul(Constants.getTreasuryRatio()).div(100);
1098	 mintToTreasury(treasuryReward);
1099	 uint256 newCDSDRedeemable = 0;
1100	 uint256 outstanding = maxCDSDOutstanding();
1101	 uint256 redeemable = totalCDSDRedeemable().sub(totalCDSDRedeemed());
1102	 if (redeemable < outstanding ) {
1103	 uint256 newRedeemable = newSupply.mul(Constants.getCDSDRedemptionRatio()).div(100);
1104	 uint256 newRedeemableCap = outstanding.sub(redeemable);
1105	 newCDSDRedeemable = newRedeemableCap > newRedeemable ? newRedeemableCap : newRedeemable;
1106	 incrementTotalCDSDRedeemable(newCDSDRedeemable);
1107	 }
1108	 uint256 rewards = poolReward.add(treasuryReward).add(newCDSDRedeemable);
1109	 uint256 amount = newSupply > rewards ? newSupply.sub(rewards) : 0;
1110	 if (totalBonded() == 0) {
1111	 amount = 0;
1112	 }
1113	 if (amount > 0) {
1114	 mintToDAO(amount);
1115	 }
1116	 balanceCheck();
1117	 return (newCDSDRedeemable, amount.add(rewards));
1118	 }
1119	 function balanceCheck() internal view {
1120	 Require.that( dollar().balanceOf(address(this)) >= totalBonded().add(totalStaged()).add(totalRedeemable()), FILE, "Inconsistent balances" );
1121	 }
1122	 function mintToDAO(uint256 amount) private {
1123	 if (amount > 0) {
1124	 dollar().mint(address(this), amount);
1125	 incrementTotalBonded(amount);
1126	 }
1127	 }
1128	 function mintToTreasury(uint256 amount) private {
1129	 if (amount > 0) {
1130	 dollar().mint(Constants.getTreasuryAddress(), amount);
1131	 }
1132	 }
1133	 function mintToPool(uint256 amount) private {
1134	 if (amount > 0) {
1135	 dollar().mint(pool(), amount);
1136	 }
1137	 }
1138	 }
1139	 contract CDSDMarket is Comptroller {
1140	 using SafeMath for uint256;
1141	 event DSDBurned(address indexed account, uint256 amount);
1142	 event CDSDMinted(address indexed account, uint256 amount);
1143	 event CDSDRedeemed(address indexed account, uint256 amount);
1144	 event BondCDSD(address indexed account, uint256 start, uint256 amount);
1145	 event UnbondCDSD(address indexed account, uint256 start, uint256 amount);
1146	 function burnDSDForCDSD(uint256 amount) public {
1147	 require(_state13.price.lessThan(Decimal.one()), "Market: not in contraction");
1148	 dollar().transferFrom(msg.sender, address(this), amount);
1149	 dollar().burn(amount);
1150	 balanceCheck();
1151	 cdsd().mint(msg.sender, amount);
1152	 uint256 earnable = Decimal.D256({
1153	 value: amount}
1154	 ).mul(Constants.getEarnableFactor()).value;
1155	 incrementBalanceOfEarnableCDSD(msg.sender, earnable);
1156	 incrementTotalCDSDEarnable(earnable);
1157	 emit DSDBurned(msg.sender, amount);
1158	 emit CDSDMinted(msg.sender, amount);
1159	 }
1160	 function migrateCouponsToCDSD(uint256 couponEpoch) public returns (uint256) {
1161	 uint256 couponAmount = balanceOfCoupons(msg.sender, couponEpoch);
1162	 uint256 couponUnderlyingAmount = balanceOfCouponUnderlying(msg.sender, couponEpoch);
1163	 if (couponAmount == 0 && couponUnderlyingAmount == 0 && outstandingCoupons(couponEpoch) == 0){
1164	 couponUnderlyingAmount = _state.accounts[msg.sender].coupons[couponEpoch].div(2);
1165	 }
1166	 _state13.couponUnderlyingByAccount[msg.sender][couponEpoch] = 0;
1167	 _state.accounts[msg.sender].coupons[couponEpoch] = 0;
1168	 uint256 totalAmount = couponAmount.add(couponUnderlyingAmount);
1169	 cdsd().mint(msg.sender, totalAmount);
1170	 emit CDSDMinted(msg.sender, totalAmount);
1171	 return totalAmount;
1172	 }
1173	 function burnDSDForCDSDAndBond(uint256 amount) external {
1174	 burnDSDForCDSD(amount);
1175	 bondCDSD(amount);
1176	 }
1177	 function migrateCouponsToCDSDAndBond(uint256 couponEpoch) external {
1178	 uint256 amountToBond = migrateCouponsToCDSD(couponEpoch);
1179	 bondCDSD(amountToBond);
1180	 }
1181	 function bondCDSD(uint256 amount) public {
1182	 require(amount > 0, "Market: bound must be greater than 0");
1183	 (uint256 userBonded, uint256 userDeposited,) = updateUserEarned(msg.sender);
1184	 cdsd().transferFrom(msg.sender, address(this), amount);
1185	 uint256 totalAmount = userBonded.add(amount);
1186	 setDepositedCDSDAmount(msg.sender, totalAmount);
1187	 decrementTotalCDSDDeposited(userDeposited, "Market: insufficient total deposited");
1188	 incrementTotalCDSDDeposited(totalAmount);
1189	 emit BondCDSD(msg.sender, epoch().add(1), amount);
1190	 }
1191	 function unbondCDSD(uint256 amount) external {
1192	 require(_state13.price.lessThan(Decimal.one()), "Market: not in contraction");
1193	 _unbondCDSD(amount);
1194	 cdsd().transfer(msg.sender, amount);
1195	 emit UnbondCDSD(msg.sender, epoch().add(1), amount);
1196	 }
1197	 function _unbondCDSD(uint256 amount) internal {
1198	 (uint256 userBonded, uint256 userDeposited,) = updateUserEarned(msg.sender);
1199	 require(amount > 0 && userBonded > 0, "Market: amounts > 0!");
1200	 require(amount <= userBonded, "Market: insufficient amount to unbound");
1201	 uint256 userTotalAmount = userBonded.sub(amount);
1202	 setDepositedCDSDAmount(msg.sender, userTotalAmount);
1203	 decrementTotalCDSDDeposited(userDeposited, "Market: insufficient deposited");
1204	 incrementTotalCDSDDeposited(userTotalAmount);
1205	 }
1206	 function redeemBondedCDSDForDSD(uint256 amount) external {
1207	 require(_state13.price.greaterThan(Decimal.one()), "Market: not in expansion");
1208	 require(amount > 0, "Market: amounts > 0!");
1209	 require(amount <= getCurrentRedeemableCDSDByAccount(msg.sender), "Market: not enough redeemable");
1210	 _unbondCDSD(amount);
1211	 cdsd().burn(amount);
1212	 mintToAccount(msg.sender, amount);
1213	 addRedeemedThisExpansion(msg.sender, amount);
1214	 incrementTotalCDSDRedeemed(amount);
1215	 emit CDSDRedeemed(msg.sender, amount);
1216	 }
1217	 function updateUserEarned(address account) internal returns (uint256 userBonded, uint256 userDeposited, uint256 userEarned) {
1218	 userBonded = balanceOfCDSDBonded(account);
1219	 userDeposited = depositedCDSDByAccount(account);
1220	 userEarned = userBonded.sub(userDeposited);
1221	 if (userEarned > 0) {
1222	 incrementBalanceOfEarnedCDSD(account, userEarned);
1223	 cdsd().mint(address(this), userEarned);
1224	 incrementTotalCDSDEarned(userEarned);
1225	 }
1226	 setCurrentInterestMultiplier(account);
1227	 }
1228	 }
1229	 contract Regulator is Comptroller {
1230	 using SafeMath for uint256;
1231	 using Decimal for Decimal.D256;
1232	 event SupplyIncrease(uint256 indexed epoch, uint256 price, uint256 newRedeemable, uint256 newBonded);
1233	 event ContractionIncentives(uint256 indexed epoch, uint256 price, uint256 delta);
1234	 event SupplyNeutral(uint256 indexed epoch);
1235	 function step() internal {
1236	 Decimal.D256 memory price = oracleCapture();
1237	 setPrice(price);
1238	 if (price.greaterThan(Decimal.one())) {
1239	 expansion(price);
1240	 return;
1241	 }
1242	 if (price.lessThan(Decimal.one())) {
1243	 contraction(price);
1244	 return;
1245	 }
1246	 emit SupplyNeutral(epoch());
1247	 }
1248	 function expansion(Decimal.D256 memory price) private {
1249	 Decimal.D256 memory delta = limit(price.sub(Decimal.one()).div(Constants.getSupplyChangeDivisor()), price);
1250	 uint256 newSupply = delta.mul(dollar().totalSupply()).asUint256();
1251	 (uint256 newRedeemable, uint256 newBonded) = increaseSupply(newSupply);
1252	 emit SupplyIncrease(epoch(), price.value, newRedeemable, newBonded);
1253	 }
1254	 function contraction(Decimal.D256 memory price) private {
1255	 (uint256 newDSDSupply) = contractionIncentives(price);
1256	 emit ContractionIncentives(epoch(), price.value, newDSDSupply);
1257	 }
1258	 function limit(Decimal.D256 memory delta, Decimal.D256 memory price) private view returns (Decimal.D256 memory) {
1259	 Decimal.D256 memory supplyChangeLimit = Constants.getSupplyChangeLimit();
1260	 return delta.greaterThan(supplyChangeLimit) ? supplyChangeLimit : delta;
1261	 }
1262	 function oracleCapture() private returns (Decimal.D256 memory) {
1263	 (Decimal.D256 memory price, bool valid) = oracle().capture();
1264	 if (bootstrappingAt(epoch().sub(1))) {
1265	 return Constants.getBootstrappingPrice();
1266	 }
1267	 if (!valid) {
1268	 return Decimal.one();
1269	 }
1270	 return price;
1271	 }
1272	 }
1273	 contract Permission is Setters {
1274	 bytes32 private constant FILE = "Permission";
1275	 modifier onlyFrozenOrFluid(address account) {
1276	 Require.that( statusOf(account) != Account.Status.Locked, FILE, "Not frozen or fluid" );
1277	 _;
1278	 }
1279	 modifier onlyFrozenOrLocked(address account) {
1280	 Require.that( statusOf(account) != Account.Status.Fluid, FILE, "Not frozen or locked" );
1281	 _;
1282	 }
1283	 modifier initializer() {
1284	 Require.that( !isInitialized(implementation()), FILE, "Already initialized" );
1285	 initialized(implementation());
1286	 _;
1287	 }
1288	 }
1289	 contract Bonding is Setters, Permission {
1290	 using SafeMath for uint256;
1291	 bytes32 private constant FILE = "Bonding";
1292	 event Deposit(address indexed account, uint256 value);
1293	 event Withdraw(address indexed account, uint256 value);
1294	 event Bond(address indexed account, uint256 start, uint256 value, uint256 valueUnderlying);
1295	 event Unbond(address indexed account, uint256 start, uint256 value, uint256 valueUnderlying);
1296	 function step() internal {
1297	 Require.that( epochTime() > epoch(), FILE, "Still current epoch" );
1298	 snapshotTotalBonded();
1299	 incrementEpoch();
1300	 }
1301	 function deposit(uint256 value) external {
1302	 dollar().transferFrom(msg.sender, address(this), value);
1303	 incrementBalanceOfStaged(msg.sender, value);
1304	 emit Deposit(msg.sender, value);
1305	 }
1306	 function withdraw(uint256 value) external onlyFrozenOrLocked(msg.sender) {
1307	 dollar().transfer(msg.sender, value);
1308	 decrementBalanceOfStaged(msg.sender, value, "Bonding: insufficient staged balance");
1309	 emit Withdraw(msg.sender, value);
1310	 }
1311	 function bond(uint256 value) external onlyFrozenOrFluid(msg.sender) {
1312	 unfreeze(msg.sender);
1313	 uint256 balance = totalBonded() == 0 ? value.mul(Constants.getInitialStakeMultiple()) : value.mul(totalSupply()).div(totalBonded());
1314	 incrementBalanceOf(msg.sender, balance);
1315	 incrementTotalBonded(value);
1316	 decrementBalanceOfStaged(msg.sender, value, "Bonding: insufficient staged balance");
1317	 emit Bond(msg.sender, epoch().add(1), balance, value);
1318	 }
1319	 function unbond(uint256 value) external onlyFrozenOrFluid(msg.sender) {
1320	 unfreeze(msg.sender);
1321	 uint256 staged = value.mul(balanceOfBonded(msg.sender)).div(balanceOf(msg.sender));
1322	 incrementBalanceOfStaged(msg.sender, staged);
1323	 decrementTotalBonded(staged, "Bonding: insufficient total bonded");
1324	 decrementBalanceOf(msg.sender, value, "Bonding: insufficient balance");
1325	 emit Unbond(msg.sender, epoch().add(1), value, staged);
1326	 }
1327	 function unbondUnderlying(uint256 value) external onlyFrozenOrFluid(msg.sender) {
1328	 unfreeze(msg.sender);
1329	 uint256 balance = value.mul(totalSupply()).div(totalBonded());
1330	 incrementBalanceOfStaged(msg.sender, value);
1331	 decrementTotalBonded(value, "Bonding: insufficient total bonded");
1332	 decrementBalanceOf(msg.sender, balance, "Bonding: insufficient balance");
1333	 emit Unbond(msg.sender, epoch().add(1), balance, value);
1334	 }
1335	 }
1336	 library OpenZeppelinUpgradesAddress {
1337	 function isContract(address account) internal view returns (bool) {
1338	 uint256 size;
1339	 assembly {
1340	 size := extcodesize(account) }
1341	 return size > 0;
1342	 }
1343	 }
1344	 contract Upgradeable is State {
1345	 bytes32 private constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
1346	 event Upgraded(address indexed implementation);
1347	 function initialize() public;
1348	 function upgradeTo(address newImplementation) internal {
1349	 setImplementation(newImplementation);
1350	 (bool success, bytes memory reason) = newImplementation.delegatecall(abi.encodeWithSignature("initialize()"));
1351	 require(success, string(reason));
1352	 emit Upgraded(newImplementation);
1353	 }
1354	 function setImplementation(address newImplementation) private {
1355	 require(OpenZeppelinUpgradesAddress.isContract(newImplementation), "Cannot set a proxy implementation to a non-contract address");
1356	 bytes32 slot = IMPLEMENTATION_SLOT;
1357	 assembly {
1358	 sstore(slot, newImplementation) }
1359	 }
1360	 }
1361	 contract Govern is Setters, Permission, Upgradeable {
1362	 using SafeMath for uint256;
1363	 using Decimal for Decimal.D256;
1364	 bytes32 private constant FILE = "Govern";
1365	 event Proposal(address indexed candidate, address indexed account, uint256 indexed start, uint256 period);
1366	 event Vote(address indexed account, address indexed candidate, Candidate.Vote vote, uint256 bonded);
1367	 event Commit(address indexed account, address indexed candidate);
1368	 function vote(address candidate, Candidate.Vote vote) external onlyFrozenOrLocked(msg.sender) {
1369	 Require.that( balanceOf(msg.sender) > 0, FILE, "Must have stake" );
1370	 if (!isNominated(candidate)) {
1371	 Require.that( canPropose(msg.sender), FILE, "Not enough stake to propose" );
1372	 createCandidate(candidate, Constants.getGovernancePeriod());
1373	 emit Proposal(candidate, msg.sender, epoch(), Constants.getGovernancePeriod());
1374	 }
1375	 Require.that( epoch() < startFor(candidate).add(periodFor(candidate)), FILE, "Ended" );
1376	 uint256 bonded = balanceOf(msg.sender);
1377	 Candidate.Vote recordedVote = recordedVote(msg.sender, candidate);
1378	 if (vote == recordedVote) {
1379	 return;
1380	 }
1381	 if (recordedVote == Candidate.Vote.REJECT) {
1382	 decrementRejectFor(candidate, bonded, "Govern: Insufficient reject");
1383	 }
1384	 if (recordedVote == Candidate.Vote.APPROVE) {
1385	 decrementApproveFor(candidate, bonded, "Govern: Insufficient approve");
1386	 }
1387	 if (vote == Candidate.Vote.REJECT) {
1388	 incrementRejectFor(candidate, bonded);
1389	 }
1390	 if (vote == Candidate.Vote.APPROVE) {
1391	 incrementApproveFor(candidate, bonded);
1392	 }
1393	 recordVote(msg.sender, candidate, vote);
1394	 placeLock(msg.sender, candidate);
1395	 emit Vote(msg.sender, candidate, vote, bonded);
1396	 }
1397	 function commit(address candidate) external {
1398	 Require.that( isNominated(candidate), FILE, "Not nominated" );
1399	 uint256 endsAfter = startFor(candidate).add(periodFor(candidate)).sub(1);
1400	 Require.that( epoch() > endsAfter, FILE, "Not ended" );
1401	 Require.that( Decimal.ratio(votesFor(candidate), totalBondedAt(endsAfter)).greaterThan(Constants.getGovernanceQuorum()), FILE, "Must have quorum" );
1402	 Require.that( approveFor(candidate) > rejectFor(candidate), FILE, "Not approved" );
1403	 upgradeTo(candidate);
1404	 emit Commit(msg.sender, candidate);
1405	 }
1406	 function emergencyCommit(address candidate) external {
1407	 Require.that( isNominated(candidate), FILE, "Not nominated" );
1408	 Require.that( epochTime() > epoch().add(Constants.getGovernanceEmergencyDelay()), FILE, "Epoch synced" );
1409	 Require.that( Decimal.ratio(approveFor(candidate), totalSupply()).greaterThan(Constants.getGovernanceSuperMajority()), FILE, "Must have super majority" );
1410	 Require.that( approveFor(candidate) > rejectFor(candidate), FILE, "Not approved" );
1411	 upgradeTo(candidate);
1412	 emit Commit(msg.sender, candidate);
1413	 }
1414	 function canPropose(address account) private view returns (bool) {
1415	 if (totalBonded() == 0) {
1416	 return false;
1417	 }
1418	 Decimal.D256 memory stake = Decimal.ratio(balanceOf(account), totalSupply());
1419	 return stake.greaterThan(Constants.getGovernanceProposalThreshold());
1420	 }
1421	 }
1422	 contract Context {
1423	 constructor () internal {
1424	 }
1425	 function _msgSender() internal view returns (address payable) {
1426	 return msg.sender;
1427	 }
1428	 function _msgData() internal view returns (bytes memory) {
1429	 this;
1430	 return msg.data;
1431	 }
1432	 }
1433	 contract ERC20 is Context, IERC20 {
1434	 using SafeMath for uint256;
1435	 mapping (address => uint256) private _balances;
1436	 mapping (address => mapping (address => uint256)) private _allowances;
1437	 uint256 private _totalSupply;
1438	 function totalSupply() public view returns (uint256) {
1439	 return _totalSupply;
1440	 }
1441	 function balanceOf(address account) public view returns (uint256) {
1442	 return _balances[account];
1443	 }
1444	 function transfer(address recipient, uint256 amount) public returns (bool) {
1445	 _transfer(_msgSender(), recipient, amount);
1446	 return true;
1447	 }
1448	 function allowance(address owner, address spender) public view returns (uint256) {
1449	 return _allowances[owner][spender];
1450	 }
1451	 function approve(address spender, uint256 amount) public returns (bool) {
1452	 _approve(_msgSender(), spender, amount);
1453	 return true;
1454	 }
1455	 function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
1456	 _transfer(sender, recipient, amount);
1457	 _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
1458	 return true;
1459	 }
1460	 function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
1461	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
1462	 return true;
1463	 }
1464	 function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
1465	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
1466	 return true;
1467	 }
1468	 function _transfer(address sender, address recipient, uint256 amount) internal {
1469	 require(sender != address(0), "ERC20: transfer from the zero address");
1470	 require(recipient != address(0), "ERC20: transfer to the zero address");
1471	 _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
1472	 _balances[recipient] = _balances[recipient].add(amount);
1473	 emit Transfer(sender, recipient, amount);
1474	 }
1475	 function _mint(address account, uint256 amount) internal {
1476	 require(account != address(0), "ERC20: mint to the zero address");
1477	 _totalSupply = _totalSupply.add(amount);
1478	 _balances[account] = _balances[account].add(amount);
1479	 emit Transfer(address(0), account, amount);
1480	 }
1481	 function _burn(address account, uint256 amount) internal {
1482	 require(account != address(0), "ERC20: burn from the zero address");
1483	 _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
1484	 _totalSupply = _totalSupply.sub(amount);
1485	 emit Transfer(account, address(0), amount);
1486	 }
1487	 function _approve(address owner, address spender, uint256 amount) internal {
1488	 require(owner != address(0), "ERC20: approve from the zero address");
1489	 require(spender != address(0), "ERC20: approve to the zero address");
1490	 _allowances[owner][spender] = amount;
1491	 emit Approval(owner, spender, amount);
1492	 }
1493	 function _burnFrom(address account, uint256 amount) internal {
1494	 _burn(account, amount);
1495	 _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, "ERC20: burn amount exceeds allowance"));
1496	 }
1497	 }
1498	 contract ERC20Burnable is Context, ERC20 {
1499	 function burn(uint256 amount) public {
1500	 _burn(_msgSender(), amount);
1501	 }
1502	 function burnFrom(address account, uint256 amount) public {
1503	 _burnFrom(account, amount);
1504	 }
1505	 }
1506	 contract ERC20Detailed is IERC20 {
1507	 string private _name;
1508	 string private _symbol;
1509	 uint8 private _decimals;
1510	 constructor (string memory name, string memory symbol, uint8 decimals) public {
1511	 _name = name;
1512	 _symbol = symbol;
1513	 _decimals = decimals;
1514	 }
1515	 function name() public view returns (string memory) {
1516	 return _name;
1517	 }
1518	 function symbol() public view returns (string memory) {
1519	 return _symbol;
1520	 }
1521	 function decimals() public view returns (uint8) {
1522	 return _decimals;
1523	 }
1524	 }
1525	 library LibEIP712 {
1526	 bytes32 constant internal _EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;
1527	 function hashEIP712Domain( string memory name, string memory version, uint256 chainId, address verifyingContract ) internal pure returns (bytes32 result) {
1528	 bytes32 schemaHash = _EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH;
1529	 assembly {
1530	 let nameHash := keccak256(add(name, 32), mload(name)) let versionHash := keccak256(add(version, 32), mload(version)) let memPtr := mload(64) mstore(memPtr, schemaHash) mstore(add(memPtr, 32), nameHash) mstore(add(memPtr, 64), versionHash) mstore(add(memPtr, 96), chainId) mstore(add(memPtr, 128), verifyingContract) result := keccak256(memPtr, 160) }
1531	 return result;
1532	 }
1533	 function hashEIP712Message(bytes32 eip712DomainHash, bytes32 hashStruct) internal pure returns (bytes32 result) {
1534	 assembly {
1535	 let memPtr := mload(64) mstore(memPtr, 0x1901000000000000000000000000000000000000000000000000000000000000) mstore(add(memPtr, 2), eip712DomainHash) mstore(add(memPtr, 34), hashStruct) result := keccak256(memPtr, 66) }
1536	 return result;
1537	 }
1538	 }
1539	 contract Permittable is ERC20Detailed, ERC20 {
1540	 bytes32 constant FILE = "Permittable";
1541	 bytes32 public constant EIP712_PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;
1542	 string private constant EIP712_VERSION = "1";
1543	 bytes32 public EIP712_DOMAIN_SEPARATOR;
1544	 mapping(address => uint256) nonces;
1545	 constructor() public {
1546	 EIP712_DOMAIN_SEPARATOR = LibEIP712.hashEIP712Domain(name(), EIP712_VERSION, Constants.getChainId(), address(this));
1547	 }
1548	 function permit( address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s ) external {
1549	 bytes32 digest = LibEIP712.hashEIP712Message( EIP712_DOMAIN_SEPARATOR, keccak256(abi.encode( EIP712_PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline )) );
1550	 address recovered = ecrecover(digest, v, r, s);
1551	 Require.that( recovered == owner, FILE, "Invalid signature" );
1552	 Require.that( recovered != address(0), FILE, "Zero address" );
1553	 Require.that( now <= deadline, FILE, "Expired" );
1554	 _approve(owner, spender, value);
1555	 }
1556	 }
1557	 contract ContractionDollar is IDollar, ERC20Detailed, Permittable, ERC20Burnable {
1558	 constructor() public ERC20Detailed("Contraction Dynamic Set Dollar", "CDSD", 18) Permittable() {
1559	 }
1560	 function mint(address account, uint256 amount) public returns (bool) {
1561	 require(_msgSender() == Constants.getDaoAddress(), "CDSD: only DAO is allowed to mint");
1562	 _mint(account, amount);
1563	 return true;
1564	 }
1565	 function transferFrom( address sender, address recipient, uint256 amount ) public returns (bool) {
1566	 _transfer(sender, recipient, amount);
1567	 if ( _msgSender() != Constants.getDaoAddress() && allowance(sender, _msgSender()) != uint256(-1) ) {
1568	 _approve( sender, _msgSender(), allowance(sender, _msgSender()).sub(amount, "CDSD: transfer amount exceeds allowance") );
1569	 }
1570	 return true;
1571	 }
1572	 }
1573	 interface AggregatorV3Interface {
1574	 function decimals() external view returns (uint8);
1575	 function description() external view returns (string memory);
1576	 function version() external view returns (uint256);
1577	 function getRoundData(uint80 _roundId) external view returns ( uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound );
1578	 function latestRoundData() external view returns ( uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound );
1579	 }
1580	 contract Implementation is State, Bonding, CDSDMarket, Regulator, Govern {
1581	 using SafeMath for uint256;
1582	 event Advance(uint256 indexed epoch, uint256 block, uint256 timestamp);
1583	 event Incentivization(address indexed account, uint256 amount);
1584	 function initialize() public initializer {
1585	 mintToAccount(msg.sender, 1000e18);
1586	 mintToAccount(0xF414CFf71eCC35320Df0BB577E3Bc9B69c9E1f07, 5000e18);
1587	 }
1588	 function advance() external incentivized {
1589	 Bonding.step();
1590	 Regulator.step();
1591	 emit Advance(epoch(), block.number, block.timestamp);
1592	 }
1593	 modifier incentivized {
1594	 uint256 startGas = gasleft();
1595	 _;
1596	 (, int256 ethPrice, , , ) = AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419).latestRoundData();
1597	 (, int256 fastGasPrice, , , ) = AggregatorV3Interface(0x169E633A2D1E6c10dD91238Ba11c4A708dfEF37C).latestRoundData();
1598	 Decimal.D256 memory ethSpent = Decimal.D256({
1599	 value: (startGas - gasleft() + 41000).mul(uint256(fastGasPrice)) }
1600	 );
1601	 Decimal.D256 memory usdCost = ethSpent.mul( Decimal.D256({
1602	 value: uint256(ethPrice).mul(1e10) }
1603	 ) );
1604	 Decimal.D256 memory dsdCost = usdCost.div(getPrice());
1605	 Decimal.D256 memory incentive = dsdCost.mul(Constants.getAdvanceIncentivePremium());
1606	 mintToAccount(msg.sender, incentive.value);
1607	 emit Incentivization(msg.sender, incentive.value);
1608	 }
1609	 }
