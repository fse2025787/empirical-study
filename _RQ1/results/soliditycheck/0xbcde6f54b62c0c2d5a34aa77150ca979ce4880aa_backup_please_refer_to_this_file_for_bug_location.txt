row number 
1	  pragma experimental ABIEncoderV2;
2	 pragma solidity >=0.4.24 <0.8.0;
3	 abstract contract Initializable {
4	 bool private _initialized;
5	 bool private _initializing;
6	 modifier initializer() {
7	 require(_initializing || _isConstructor() || !_initialized, "Initializable: contract is already initialized");
8	 bool isTopLevelCall = !_initializing;
9	 if (isTopLevelCall) {
10	 _initializing = true;
11	 _initialized = true;
12	 }
13	 _;
14	 if (isTopLevelCall) {
15	 _initializing = false;
16	 }
17	 }
18	 function _isConstructor() private view returns (bool) {
19	 return !AddressUpgradeable.isContract(address(this));
20	 }
21	 }
22	 pragma solidity >=0.6.0 <0.8.0;
23	 abstract contract ContextUpgradeable is Initializable {
24	 function __Context_init() internal initializer {
25	 __Context_init_unchained();
26	 }
27	 function __Context_init_unchained() internal initializer {
28	 }
29	 function _msgSender() internal view virtual returns (address payable) {
30	 return msg.sender;
31	 }
32	 function _msgData() internal view virtual returns (bytes memory) {
33	 this;
34	 return msg.data;
35	 }
36	 uint256[50] private __gap;
37	 }
38	 pragma solidity >=0.6.0 <0.8.0;
39	 abstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable {
40	 function __AccessControl_init() internal initializer {
41	 __Context_init_unchained();
42	 __AccessControl_init_unchained();
43	 }
44	 function __AccessControl_init_unchained() internal initializer {
45	 }
46	 using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;
47	 using AddressUpgradeable for address;
48	 struct RoleData {
49	 EnumerableSetUpgradeable.AddressSet members;
50	 bytes32 adminRole;
51	 }
52	 mapping (bytes32 => RoleData) private _roles;
53	 bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;
54	 event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
55	 event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
56	 event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
57	 function hasRole(bytes32 role, address account) public view returns (bool) {
58	 return _roles[role].members.contains(account);
59	 }
60	 function getRoleMemberCount(bytes32 role) public view returns (uint256) {
61	 return _roles[role].members.length();
62	 }
63	 function getRoleMember(bytes32 role, uint256 index) public view returns (address) {
64	 return _roles[role].members.at(index);
65	 }
66	 function getRoleAdmin(bytes32 role) public view returns (bytes32) {
67	 return _roles[role].adminRole;
68	 }
69	 function grantRole(bytes32 role, address account) public virtual {
70	 require(hasRole(_roles[role].adminRole, _msgSender()), "AccessControl: sender must be an admin to grant");
71	 _grantRole(role, account);
72	 }
73	 function revokeRole(bytes32 role, address account) public virtual {
74	 require(hasRole(_roles[role].adminRole, _msgSender()), "AccessControl: sender must be an admin to revoke");
75	 _revokeRole(role, account);
76	 }
77	 function renounceRole(bytes32 role, address account) public virtual {
78	 require(account == _msgSender(), "AccessControl: can only renounce roles for self");
79	 _revokeRole(role, account);
80	 }
81	 function _setupRole(bytes32 role, address account) internal virtual {
82	 _grantRole(role, account);
83	 }
84	 function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
85	 emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);
86	 _roles[role].adminRole = adminRole;
87	 }
88	 function _grantRole(bytes32 role, address account) private {
89	 if (_roles[role].members.add(account)) {
90	 emit RoleGranted(role, account, _msgSender());
91	 }
92	 }
93	 function _revokeRole(bytes32 role, address account) private {
94	 if (_roles[role].members.remove(account)) {
95	 emit RoleRevoked(role, account, _msgSender());
96	 }
97	 }
98	 uint256[49] private __gap;
99	 }
100	 pragma solidity 0.7.6;
101	 contract RoleCheckable is AccessControlUpgradeable {
102	 bytes32 internal constant ADMIN_ROLE = 0x1effbbff9c66c5e59634f24fe842750c60d18891155c32dd155fc2d661a4c86d;
103	 bytes32 internal constant CONTROLLER_ROLE = 0x7b765e0e932d348852a6f810bfa1ab891e259123f02db8cdcde614c570223357;
104	 bytes32 internal constant START_FUTURE = 0xeb5092aab714e6356486bc97f25dd7a5c1dc5c7436a9d30e8d4a527fba24de1c;
105	 bytes32 internal constant FUTURE_ROLE = 0x52d2dbc4d362e84c42bdfb9941433968ba41423559d7559b32db1183b22b148f;
106	 bytes32 internal constant HARVEST_REWARDS = 0xf2683e58e5a2a04c1ed32509bfdbf1e9ebc725c63f4c95425d2afd482bfdb0f8;
107	 modifier onlyAdmin() {
108	 require(hasRole(ADMIN_ROLE, msg.sender), "RoleCheckable: Caller should be ADMIN");
109	 _;
110	 }
111	 modifier onlyStartFuture() {
112	 require(hasRole(START_FUTURE, msg.sender), "RoleCheckable: Caller should have START FUTURE Role");
113	 _;
114	 }
115	 modifier onlyHarvestReward() {
116	 require(hasRole(HARVEST_REWARDS, msg.sender), "RoleCheckable: Caller should have HARVEST REWARDS Role");
117	 _;
118	 }
119	 modifier onlyController() {
120	 require(hasRole(CONTROLLER_ROLE, msg.sender), "RoleCheckable: Caller should be CONTROLLER");
121	 _;
122	 }
123	 }
124	 pragma solidity >=0.6.0 <0.8.0;
125	 abstract contract ReentrancyGuardUpgradeable is Initializable {
126	 uint256 private constant _NOT_ENTERED = 1;
127	 uint256 private constant _ENTERED = 2;
128	 uint256 private _status;
129	 function __ReentrancyGuard_init() internal initializer {
130	 __ReentrancyGuard_init_unchained();
131	 }
132	 function __ReentrancyGuard_init_unchained() internal initializer {
133	 _status = _NOT_ENTERED;
134	 }
135	 modifier nonReentrant() {
136	 require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
137	 _status = _ENTERED;
138	 _;
139	 _status = _NOT_ENTERED;
140	 }
141	 uint256[49] private __gap;
142	 }
143	 pragma solidity 0.7.6;
144	 contract RegistryStorage is RoleCheckable {
145	 IRegistry internal registry;
146	 event RegistryChanged(IRegistry _registry);
147	 function setRegistry(IRegistry _registry) external onlyAdmin {
148	 registry = _registry;
149	 emit RegistryChanged(_registry);
150	 }
151	 }
152	 pragma solidity 0.7.6;
153	 abstract contract FutureVault is Initializable, RegistryStorage, ReentrancyGuardUpgradeable {
154	 using SafeMathUpgradeable for uint256;
155	 using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;
156	 using SafeERC20Upgradeable for IERC20;
157	 mapping(uint256 => uint256) internal collectedFYTSByPeriod;
158	 mapping(uint256 => uint256) internal premiumsTotal;
159	 mapping(address => uint256) internal lastPeriodClaimed;
160	 mapping(address => uint256) internal premiumToBeRedeemed;
161	 mapping(address => uint256) internal FYTsOfUserPremium;
162	 mapping(address => uint256) internal claimableFYTByUser;
163	 mapping(uint256 => uint256) internal yieldOfPeriod;
164	 uint256 internal totalUnderlyingDeposited;
165	 bool private terminated;
166	 uint256 internal performanceFeeFactor;
167	 IFutureYieldToken[] internal fyts;
168	 struct Delegation {
169	 address receiver;
170	 uint256 delegatedAmount;
171	 }
172	 mapping(address => Delegation[]) internal delegationsByDelegator;
173	 mapping(address => uint256) internal totalDelegationsReceived;
174	 IFutureWallet internal futureWallet;
175	 IERC20 internal ibt;
176	 IPT internal pt;
177	 IController internal controller;
178	 uint256 public PERIOD_DURATION;
179	 string public PLATFORM_NAME;
180	 uint256 internal IBT_UNIT;
181	 uint256 internal IBT_UNITS_MULTIPLIED_VALUE;
182	 uint256 constant UNIT = 10**18;
183	 event NewPeriodStarted(uint256 _newPeriodIndex);
184	 event FutureWalletSet(IFutureWallet _futureWallet);
185	 event FundsDeposited(address _user, uint256 _amount);
186	 event FundsWithdrawn(address _user, uint256 _amount);
187	 event PTSet(IPT _pt);
188	 event LiquidityTransfersPaused();
189	 event LiquidityTransfersResumed();
190	 event DelegationCreated(address _delegator, address _receiver, uint256 _amount);
191	 event DelegationRemoved(address _delegator, address _receiver, uint256 _amount);
192	 modifier nextPeriodAvailable() {
193	 uint256 controllerDelay = controller.STARTING_DELAY();
194	 require( controller.getNextPeriodStart(PERIOD_DURATION) < block.timestamp.add(controllerDelay), "FutureVault: ERR_PERIOD_RANGE" );
195	 _;
196	 }
197	 modifier periodsActive() {
198	 require(!terminated, "PERIOD_TERMINATED");
199	 _;
200	 }
201	 modifier withdrawalsEnabled() {
202	 require(!controller.isWithdrawalsPaused(address(this)), "FutureVault: WITHDRAWALS_DISABLED");
203	 _;
204	 }
205	 modifier depositsEnabled() {
206	 require( !controller.isDepositsPaused(address(this)) && getCurrentPeriodIndex() != 0, "FutureVault: DEPOSITS_DISABLED" );
207	 _;
208	 }
209	 function initialize( IController _controller, IERC20 _ibt, uint256 _periodDuration, string memory _platformName, address _admin ) public virtual initializer {
210	 controller = _controller;
211	 ibt = _ibt;
212	 IBT_UNIT = 10**ibt.decimals();
213	 IBT_UNITS_MULTIPLIED_VALUE = UNIT * IBT_UNIT;
214	 PERIOD_DURATION = _periodDuration * (1 days);
215	 PLATFORM_NAME = _platformName;
216	 _setupRole(DEFAULT_ADMIN_ROLE, _admin);
217	 _setupRole(ADMIN_ROLE, _admin);
218	 _setupRole(CONTROLLER_ROLE, address(_controller));
219	 fyts.push();
220	 registry = IRegistry(controller.getRegistryAddress());
221	 pt = IPT( ITokensFactory(IRegistry(controller.getRegistryAddress()).getTokensFactoryAddress()).deployPT( ibt.symbol(), ibt.decimals(), PLATFORM_NAME, PERIOD_DURATION ) );
222	 emit PTSet(pt);
223	 }
224	 function startNewPeriod() public virtual;
225	 function _switchPeriod() internal periodsActive {
226	 uint256 nextPeriodID = getNextPeriodIndex();
227	 uint256 yield = getUnrealisedYieldPerPT().mul(totalUnderlyingDeposited) / IBT_UNIT;
228	 uint256 reinvestedYield;
229	 if (yield > 0) {
230	 uint256 currentPeriodIndex = getCurrentPeriodIndex();
231	 uint256 premiums = convertUnderlyingtoIBT(premiumsTotal[currentPeriodIndex]);
232	 uint256 performanceFee = (yield.mul(performanceFeeFactor) / UNIT).sub(premiums);
233	 uint256 remainingYield = yield.sub(performanceFee);
234	 yieldOfPeriod[currentPeriodIndex] = convertIBTToUnderlying( remainingYield.mul(UNIT).div(totalUnderlyingDeposited) );
235	 uint256 collectedYield = remainingYield.mul(collectedFYTSByPeriod[currentPeriodIndex]).div( totalUnderlyingDeposited );
236	 reinvestedYield = remainingYield.sub(collectedYield);
237	 futureWallet.registerExpiredFuture(collectedYield);
238	 if (performanceFee > 0) ibt.safeTransfer(registry.getTreasuryAddress(), performanceFee);
239	 if (remainingYield > 0) ibt.safeTransfer(address(futureWallet), collectedYield);
240	 }
241	 else {
242	 futureWallet.registerExpiredFuture(0);
243	 }
244	 totalUnderlyingDeposited = totalUnderlyingDeposited.add(convertIBTToUnderlying(reinvestedYield));
245	 if (!controller.isFutureSetToBeTerminated(address(this))) {
246	 _deployNewFutureYieldToken(nextPeriodID);
247	 emit NewPeriodStarted(nextPeriodID);
248	 }
249	 else {
250	 terminated = true;
251	 }
252	 uint256 nextPerformanceFeeFactor = controller.getNextPerformanceFeeFactor(address(this));
253	 if (nextPerformanceFeeFactor != performanceFeeFactor) performanceFeeFactor = nextPerformanceFeeFactor;
254	 }
255	 function updateUserState(address _user) public {
256	 uint256 currentPeriodIndex = getCurrentPeriodIndex();
257	 uint256 lastPeriodClaimedOfUser = lastPeriodClaimed[_user];
258	 if (lastPeriodClaimedOfUser < currentPeriodIndex && lastPeriodClaimedOfUser != 0) {
259	 pt.mint(_user, _preparePTClaim(_user));
260	 }
261	 if (lastPeriodClaimedOfUser != currentPeriodIndex) lastPeriodClaimed[_user] = currentPeriodIndex;
262	 }
263	 function _preparePTClaim(address _user) internal virtual returns (uint256 claimablePT) {
264	 uint256 currentPeriodIndex = getCurrentPeriodIndex();
265	 if (lastPeriodClaimed[_user] < currentPeriodIndex) {
266	 claimablePT = getClaimablePT(_user);
267	 delete premiumToBeRedeemed[_user];
268	 delete FYTsOfUserPremium[_user];
269	 lastPeriodClaimed[_user] = currentPeriodIndex;
270	 claimableFYTByUser[_user] = pt.balanceOf(_user).add(totalDelegationsReceived[_user]).sub( getTotalDelegated(_user) );
271	 }
272	 }
273	 function deposit(address _user, uint256 _amount) external virtual periodsActive depositsEnabled onlyController {
274	 require((_amount > 0) && (_amount <= ibt.balanceOf(_user)), "FutureVault: ERR_AMOUNT");
275	 _deposit(_user, _amount);
276	 emit FundsDeposited(_user, _amount);
277	 }
278	 function _deposit(address _user, uint256 _amount) internal {
279	 uint256 underlyingDeposited = getPTPerAmountDeposited(_amount);
280	 uint256 ptToMint = _preparePTClaim(_user).add(underlyingDeposited);
281	 uint256 currentPeriodIndex = getCurrentPeriodIndex();
282	 uint256 redeemable = getPremiumPerUnderlyingDeposited(convertIBTToUnderlying(_amount));
283	 premiumToBeRedeemed[_user] = premiumToBeRedeemed[_user].add(redeemable);
284	 FYTsOfUserPremium[_user] = FYTsOfUserPremium[_user].add(ptToMint);
285	 premiumsTotal[currentPeriodIndex] = premiumsTotal[currentPeriodIndex].add(redeemable);
286	 totalUnderlyingDeposited = totalUnderlyingDeposited.add(underlyingDeposited);
287	 claimableFYTByUser[_user] = claimableFYTByUser[_user].add(ptToMint);
288	 pt.mint(_user, ptToMint);
289	 }
290	 function withdraw(address _user, uint256 _amount) external virtual nonReentrant withdrawalsEnabled onlyController {
291	 require((_amount > 0) && (_amount <= pt.balanceOf(_user)), "FutureVault: ERR_AMOUNT");
292	 require(_amount <= fyts[getCurrentPeriodIndex()].balanceOf(_user), "FutureVault: ERR_FYT_AMOUNT");
293	 _withdraw(_user, _amount);
294	 uint256 FYTsToBurn;
295	 uint256 currentPeriodIndex = getCurrentPeriodIndex();
296	 uint256 FYTSMinted = fyts[currentPeriodIndex].recordedBalanceOf(_user);
297	 if (_amount > FYTSMinted) {
298	 FYTsToBurn = FYTSMinted;
299	 uint256 ClaimableFYTsToBurn = _amount - FYTsToBurn;
300	 claimableFYTByUser[_user] = claimableFYTByUser[_user].sub(ClaimableFYTsToBurn, "FutureVault: ERR_AMOUNT");
301	 collectedFYTSByPeriod[currentPeriodIndex] = collectedFYTSByPeriod[currentPeriodIndex].add(ClaimableFYTsToBurn);
302	 }
303	 else {
304	 FYTsToBurn = _amount;
305	 }
306	 if (FYTsToBurn > 0) fyts[currentPeriodIndex].burnFrom(_user, FYTsToBurn);
307	 emit FundsWithdrawn(_user, _amount);
308	 }
309	 function _withdraw(address _user, uint256 _amount) internal virtual {
310	 updateUserState(_user);
311	 uint256 fundsToBeUnlocked = _amount.mul(getUnlockableFunds(_user)).div(pt.balanceOf(_user));
312	 uint256 yieldToBeUnlocked = _amount.mul(getUnrealisedYieldPerPT()) / IBT_UNIT;
313	 uint256 premiumToBeUnlocked = _prepareUserEarlyPremiumUnlock(_user, _amount);
314	 uint256 treasuryFee = (yieldToBeUnlocked.mul(performanceFeeFactor) / UNIT).sub(premiumToBeUnlocked);
315	 uint256 yieldToBeRedeemed = yieldToBeUnlocked - treasuryFee;
316	 ibt.safeTransfer(_user, fundsToBeUnlocked.add(yieldToBeRedeemed).add(premiumToBeUnlocked));
317	 if (treasuryFee > 0) {
318	 ibt.safeTransfer(registry.getTreasuryAddress(), treasuryFee);
319	 }
320	 totalUnderlyingDeposited = totalUnderlyingDeposited.sub(_amount);
321	 pt.burnFrom(_user, _amount);
322	 }
323	 function _prepareUserEarlyPremiumUnlock(address _user, uint256 _ptShares) internal returns (uint256 premiumToBeUnlocked) {
324	 uint256 unlockablePremium = premiumToBeRedeemed[_user];
325	 uint256 userFYTsInPremium = FYTsOfUserPremium[_user];
326	 if (unlockablePremium > 0) {
327	 if (_ptShares > userFYTsInPremium) {
328	 premiumToBeUnlocked = convertUnderlyingtoIBT(unlockablePremium);
329	 delete premiumToBeRedeemed[_user];
330	 delete FYTsOfUserPremium[_user];
331	 }
332	 else {
333	 uint256 premiumForAmount = unlockablePremium.mul(_ptShares).div(userFYTsInPremium);
334	 premiumToBeUnlocked = convertUnderlyingtoIBT(premiumForAmount);
335	 premiumToBeRedeemed[_user] = unlockablePremium - premiumForAmount;
336	 FYTsOfUserPremium[_user] = userFYTsInPremium - _ptShares;
337	 }
338	 }
339	 }
340	 function getUserEarlyUnlockablePremium(address _user) public view returns (uint256 premiumLocked, uint256 amountRequired) {
341	 premiumLocked = premiumToBeRedeemed[_user];
342	 amountRequired = FYTsOfUserPremium[_user];
343	 }
344	 function createFYTDelegationTo( address _delegator, address _receiver, uint256 _amount ) public nonReentrant periodsActive {
345	 require(hasRole(CONTROLLER_ROLE, msg.sender), "ERR_CALLER");
346	 updateUserState(_delegator);
347	 updateUserState(_receiver);
348	 uint256 totalDelegated = getTotalDelegated(_delegator);
349	 uint256 numberOfDelegations = delegationsByDelegator[_delegator].length;
350	 require(_amount > 0 && _amount <= pt.balanceOf(_delegator).sub(totalDelegated), "FutureVault: ERR_AMOUNT");
351	 bool delegated;
352	 for (uint256 i = 0; i < numberOfDelegations; i++) {
353	 if (delegationsByDelegator[_delegator][i].receiver == _receiver) {
354	 delegationsByDelegator[_delegator][i].delegatedAmount = delegationsByDelegator[_delegator][i] .delegatedAmount .add(_amount);
355	 delegated = true;
356	 break;
357	 }
358	 }
359	 if (!delegated) {
360	 delegationsByDelegator[_delegator].push(Delegation({
361	 receiver: _receiver, delegatedAmount: _amount }
362	 ));
363	 }
364	 totalDelegationsReceived[_receiver] = totalDelegationsReceived[_receiver].add(_amount);
365	 emit DelegationCreated(_delegator, _receiver, _amount);
366	 }
367	 function withdrawFYTDelegationFrom( address _delegator, address _receiver, uint256 _amount ) public {
368	 require(hasRole(CONTROLLER_ROLE, msg.sender), "ERR_CALLER");
369	 updateUserState(_delegator);
370	 updateUserState(_receiver);
371	 uint256 numberOfDelegations = delegationsByDelegator[_delegator].length;
372	 bool removed;
373	 for (uint256 i = 0; i < numberOfDelegations; i++) {
374	 if (delegationsByDelegator[_delegator][i].receiver == _receiver) {
375	 delegationsByDelegator[_delegator][i].delegatedAmount = delegationsByDelegator[_delegator][i] .delegatedAmount .sub(_amount, "ERR_AMOUNT");
376	 removed = true;
377	 break;
378	 }
379	 }
380	 require(_amount > 0 && removed, "FutureVault: ERR_AMOUNT");
381	 totalDelegationsReceived[_receiver] = totalDelegationsReceived[_receiver].sub(_amount);
382	 emit DelegationRemoved(_delegator, _receiver, _amount);
383	 }
384	 function getTotalDelegated(address _delegator) public view returns (uint256 totalDelegated) {
385	 uint256 numberOfDelegations = delegationsByDelegator[_delegator].length;
386	 for (uint256 i = 0; i < numberOfDelegations; i++) {
387	 totalDelegated = totalDelegated.add(delegationsByDelegator[_delegator][i].delegatedAmount);
388	 }
389	 }
390	 function claimFYT(address _user, uint256 _amount) external virtual nonReentrant {
391	 require(msg.sender == address(fyts[getCurrentPeriodIndex()]), "FutureVault: ERR_CALLER");
392	 updateUserState(_user);
393	 _claimFYT(_user, _amount);
394	 }
395	 function _claimFYT(address _user, uint256 _amount) internal virtual {
396	 uint256 currentPeriodIndex = getCurrentPeriodIndex();
397	 claimableFYTByUser[_user] = claimableFYTByUser[_user].sub(_amount, "ERR_CLAIMED_FYT_AMOUNT");
398	 fyts[currentPeriodIndex].mint(_user, _amount);
399	 collectedFYTSByPeriod[currentPeriodIndex] = collectedFYTSByPeriod[currentPeriodIndex].add(_amount);
400	 }
401	 function exitTerminatedFuture(address _user) external nonReentrant onlyController {
402	 require(terminated, "FutureVault: ERR_NOT_TERMINATED");
403	 uint256 amount = pt.balanceOf(_user);
404	 require(amount > 0, "FutureVault: ERR_PT_BALANCE");
405	 _withdraw(_user, amount);
406	 emit FundsWithdrawn(_user, amount);
407	 }
408	 function convertIBTToUnderlying(uint256 _amount) public view virtual returns (uint256);
409	 function convertUnderlyingtoIBT(uint256 _amount) public view virtual returns (uint256);
410	 function _deployNewFutureYieldToken(uint256 newPeriodIndex) internal {
411	 IFutureYieldToken newToken = IFutureYieldToken( ITokensFactory(registry.getTokensFactoryAddress()).deployNextFutureYieldToken(newPeriodIndex) );
412	 fyts.push(newToken);
413	 }
414	 function getClaimablePT(address _user) public view virtual returns (uint256) {
415	 uint256 currentPeriodIndex = getCurrentPeriodIndex();
416	 if (lastPeriodClaimed[_user] < currentPeriodIndex) {
417	 uint256 recordedBalance = pt.recordedBalanceOf(_user);
418	 uint256 mintablePT = (recordedBalance).add(premiumToBeRedeemed[_user]);
419	 mintablePT = mintablePT.add(totalDelegationsReceived[_user]).sub(getTotalDelegated(_user));
420	 uint256 userStackingGrowthFactor = yieldOfPeriod[lastPeriodClaimed[_user]];
421	 if (userStackingGrowthFactor > 0) {
422	 mintablePT = mintablePT.add(claimableFYTByUser[_user].mul(userStackingGrowthFactor) / IBT_UNIT);
423	 }
424	 for (uint256 i = lastPeriodClaimed[_user] + 1; i < currentPeriodIndex; i++) {
425	 mintablePT = mintablePT.add(yieldOfPeriod[i].mul(mintablePT) / IBT_UNIT);
426	 }
427	 return mintablePT.add(getTotalDelegated(_user)).sub(recordedBalance).sub(totalDelegationsReceived[_user]);
428	 }
429	 else {
430	 return 0;
431	 }
432	 }
433	 function getUnlockableFunds(address _user) public view virtual returns (uint256) {
434	 return pt.balanceOf(_user);
435	 }
436	 function getClaimableFYTForPeriod(address _user, uint256 _periodIndex) external view virtual returns (uint256) {
437	 uint256 currentPeriodIndex = getCurrentPeriodIndex();
438	 if (_periodIndex != currentPeriodIndex || _user == address(this)) {
439	 return 0;
440	 }
441	 else if (_periodIndex == currentPeriodIndex && lastPeriodClaimed[_user] == currentPeriodIndex) {
442	 return claimableFYTByUser[_user];
443	 }
444	 else {
445	 return pt.balanceOf(_user).add(totalDelegationsReceived[_user]).sub(getTotalDelegated(_user));
446	 }
447	 }
448	 function getUnrealisedYieldPerPT() public view virtual returns (uint256);
449	 function getPTPerAmountDeposited(uint256 _amount) public view virtual returns (uint256);
450	 function getPremiumPerUnderlyingDeposited(uint256 _amount) public view virtual returns (uint256) {
451	 if (totalUnderlyingDeposited == 0) {
452	 return 0;
453	 }
454	 uint256 yieldPerFYT = getUnrealisedYieldPerPT();
455	 uint256 premiumToRefundInIBT = _amount.mul(yieldPerFYT).mul(performanceFeeFactor) / IBT_UNITS_MULTIPLIED_VALUE;
456	 return convertIBTToUnderlying(premiumToRefundInIBT);
457	 }
458	 function getUnlockablePremium(address _user) public view returns (uint256) {
459	 if (lastPeriodClaimed[_user] != getCurrentPeriodIndex()) {
460	 return 0;
461	 }
462	 else {
463	 return premiumToBeRedeemed[_user];
464	 }
465	 }
466	 function getYieldOfPeriod(uint256 _periodID) external view returns (uint256) {
467	 require(getCurrentPeriodIndex() > _periodID, "FutureVault: Invalid period ID");
468	 return yieldOfPeriod[_periodID];
469	 }
470	 function getNextPeriodIndex() public view virtual returns (uint256) {
471	 return fyts.length;
472	 }
473	 function getCurrentPeriodIndex() public view virtual returns (uint256) {
474	 return fyts.length - 1;
475	 }
476	 function getTotalUnderlyingDeposited() external view returns (uint256) {
477	 return totalUnderlyingDeposited;
478	 }
479	 function getControllerAddress() public view returns (address) {
480	 return address(controller);
481	 }
482	 function getFutureWalletAddress() public view returns (address) {
483	 return address(futureWallet);
484	 }
485	 function getIBTAddress() public view returns (address) {
486	 return address(ibt);
487	 }
488	 function getPTAddress() public view returns (address) {
489	 return address(pt);
490	 }
491	 function getFYTofPeriod(uint256 _periodIndex) public view returns (address) {
492	 return address(fyts[_periodIndex]);
493	 }
494	 function isTerminated() public view returns (bool) {
495	 return terminated;
496	 }
497	 function getPerformanceFeeFactor() external view returns (uint256) {
498	 return performanceFeeFactor;
499	 }
500	 function setFutureWallet(IFutureWallet _futureWallet) external onlyAdmin {
501	 futureWallet = _futureWallet;
502	 emit FutureWalletSet(_futureWallet);
503	 }
504	 function pauseLiquidityTransfers() public {
505	 require(hasRole(ADMIN_ROLE, msg.sender), "ERR_CALLER");
506	 pt.pause();
507	 emit LiquidityTransfersPaused();
508	 }
509	 function resumeLiquidityTransfers() public {
510	 require(hasRole(ADMIN_ROLE, msg.sender), "ERR_CALLER");
511	 pt.unpause();
512	 emit LiquidityTransfersResumed();
513	 }
514	 }
515	 pragma solidity 0.7.6;
516	 abstract contract RewardsFutureVault is FutureVault {
517	 using SafeERC20Upgradeable for IERC20;
518	 using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;
519	 EnumerableSetUpgradeable.AddressSet internal rewardTokens;
520	 address internal rewardsRecipient;
521	 event RewardsHarvested();
522	 event RewardTokenAdded(address _token);
523	 event RewardTokenRedeemed(IERC20 _token, uint256 _amount);
524	 event RewardsRecipientUpdated(address _recipient);
525	 function harvestRewards() public virtual {
526	 require(hasRole(CONTROLLER_ROLE, msg.sender), "ERR_CALLER");
527	 _harvestRewards();
528	 emit RewardsHarvested();
529	 }
530	 function _harvestRewards() internal virtual {
531	 }
532	 function redeemAllVaultRewards() external virtual onlyController {
533	 require(rewardsRecipient != address(0), "RewardsFutureVault: ERR_RECIPIENT");
534	 uint256 numberOfRewardTokens = rewardTokens.length();
535	 for (uint256 i; i < numberOfRewardTokens; i++) {
536	 IERC20 rewardToken = IERC20(rewardTokens.at(i));
537	 uint256 rewardTokenBalance = rewardToken.balanceOf(address(this));
538	 rewardToken.safeTransfer(rewardsRecipient, rewardTokenBalance);
539	 emit RewardTokenRedeemed(rewardToken, rewardTokenBalance);
540	 }
541	 }
542	 function redeemVaultRewards(IERC20 _rewardToken) external virtual onlyController {
543	 require(rewardsRecipient != address(0), "RewardsFutureVault: ERR_RECIPIENT");
544	 require(rewardTokens.contains(address(_rewardToken)), "RewardsFutureVault: ERR_TOKEN_ADDRESS");
545	 uint256 rewardTokenBalance = _rewardToken.balanceOf(address(this));
546	 _rewardToken.safeTransfer(rewardsRecipient, rewardTokenBalance);
547	 emit RewardTokenRedeemed(_rewardToken, rewardTokenBalance);
548	 }
549	 function addRewardsToken(address _token) external onlyAdmin {
550	 require(_token != address(ibt), "RewardsFutureVault: ERR_TOKEN_ADDRESS");
551	 rewardTokens.add(_token);
552	 emit RewardTokenAdded(_token);
553	 }
554	 function setRewardRecipient(address _recipient) external {
555	 require(hasRole(ADMIN_ROLE, msg.sender), "ERR_CALLER");
556	 rewardsRecipient = _recipient;
557	 emit RewardsRecipientUpdated(_recipient);
558	 }
559	 function isRewardToken(IERC20 _token) external view returns (bool) {
560	 return rewardTokens.contains(address(_token));
561	 }
562	 function getRewardTokenAt(uint256 _index) external view returns (address) {
563	 return rewardTokens.at(_index);
564	 }
565	 function getRewardTokensCount() external view returns (uint256) {
566	 return rewardTokens.length();
567	 }
568	 function getRewardsRecipient() external view returns (address) {
569	 return rewardsRecipient;
570	 }
571	 }
572	 pragma solidity 0.7.6;
573	 abstract contract RateFutureVault is RewardsFutureVault {
574	 using SafeMathUpgradeable for uint256;
575	 mapping(uint256 => uint256) internal IBTRates;
576	 function initialize( IController _controller, IERC20 _ibt, uint256 _periodDuration, string memory _platformName, address _admin ) public virtual override initializer {
577	 super.initialize(_controller, _ibt, _periodDuration, _platformName, _admin);
578	 IBTRates[getCurrentPeriodIndex()] = getIBTRate();
579	 }
580	 function startNewPeriod() public virtual override nextPeriodAvailable periodsActive nonReentrant {
581	 require(hasRole(CONTROLLER_ROLE, msg.sender), "ERR_CALLER");
582	 _switchPeriod();
583	 IBTRates[getCurrentPeriodIndex()] = getIBTRate();
584	 }
585	 function convertIBTToUnderlying(uint256 _amount) public view virtual override returns (uint256) {
586	 return _convertIBTToUnderlyingAtRate(_amount, getIBTRate());
587	 }
588	 function _convertIBTToUnderlyingAtRate(uint256 _amount, uint256 _rate) internal view virtual returns (uint256) {
589	 return (_amount.mul(_rate) / IBT_UNIT);
590	 }
591	 function convertUnderlyingtoIBT(uint256 _amount) public view virtual override returns (uint256) {
592	 return _convertUnderlyingtoIBTAtRate(_amount, getIBTRate());
593	 }
594	 function _convertUnderlyingtoIBTAtRate(uint256 _amount, uint256 _rate) internal view virtual returns (uint256) {
595	 return _amount.mul(IBT_UNIT).div(_rate);
596	 }
597	 function getUnlockableFunds(address _user) public view virtual override returns (uint256) {
598	 return convertUnderlyingtoIBT(super.getUnlockableFunds(_user));
599	 }
600	 function getUnrealisedYieldPerPT() public view virtual override returns (uint256) {
601	 uint256 currRate = getIBTRate();
602	 uint256 currPeriodStartRate = IBTRates[getCurrentPeriodIndex()];
603	 if (currRate == currPeriodStartRate) return 0;
604	 uint256 amountOfIBTsAtStart = _convertUnderlyingtoIBTAtRate(IBT_UNIT, currPeriodStartRate);
605	 uint256 amountOfIBTsNow = _convertUnderlyingtoIBTAtRate(IBT_UNIT, currRate);
606	 return amountOfIBTsAtStart.sub(amountOfIBTsNow);
607	 }
608	 function getIBTRate() public view virtual returns (uint256);
609	 function getPTPerAmountDeposited(uint256 _amount) public view virtual override returns (uint256) {
610	 return _convertIBTToUnderlyingAtRate(_amount, IBTRates[getCurrentPeriodIndex()]);
611	 }
612	 }
613	 pragma solidity >=0.6.0 <0.8.0;
614	 interface IERC20Upgradeable {
615	 function totalSupply() external view returns (uint256);
616	 function balanceOf(address account) external view returns (uint256);
617	 function transfer(address recipient, uint256 amount) external returns (bool);
618	 function allowance(address owner, address spender) external view returns (uint256);
619	 function approve(address spender, uint256 amount) external returns (bool);
620	 function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
621	 event Transfer(address indexed from, address indexed to, uint256 value);
622	 event Approval(address indexed owner, address indexed spender, uint256 value);
623	 }
624	 pragma solidity 0.7.6;
625	 abstract contract HybridFutureVault is RateFutureVault {
626	 using SafeMathUpgradeable for uint256;
627	 mapping(uint256 => uint256) internal scaledTotals;
628	 function deposit(address _user, uint256 _amount) external virtual override periodsActive depositsEnabled onlyController {
629	 require((_amount > 0) && (_amount <= ibt.balanceOf(_user)), "HybridFutureVault: ERR_AMOUNT");
630	 _deposit(_user, _amount);
631	 uint256 currScaledTotals = scaledTotals[getCurrentPeriodIndex()];
632	 if (currScaledTotals == 0) {
633	 require(_amount > IBT_UNIT, "HybridFutureVault: ERR_FUTURE_INIT");
634	 scaledTotals[getCurrentPeriodIndex()] = _amount;
635	 }
636	 else {
637	 scaledTotals[getCurrentPeriodIndex()] = currScaledTotals.add( convertUnderlyingtoIBT(getPTPerAmountDeposited(_amount)) );
638	 }
639	 emit FundsDeposited(_user, _amount);
640	 }
641	 function _withdraw(address _user, uint256 _amount) internal virtual override {
642	 uint256 scaledAmountToRemove = convertUnderlyingtoIBT(getPTPerAmountDeposited(_amount));
643	 super._withdraw(_user, _amount);
644	 uint256 currentPeriodIndex = getCurrentPeriodIndex();
645	 scaledTotals[currentPeriodIndex] = scaledTotals[currentPeriodIndex].sub(scaledAmountToRemove);
646	 }
647	 function startNewPeriod() public virtual override nextPeriodAvailable periodsActive nonReentrant {
648	 require(hasRole(CONTROLLER_ROLE, msg.sender), "ERR_CALLER");
649	 _switchPeriod();
650	 IBTRates[getCurrentPeriodIndex()] = getIBTRate();
651	 scaledTotals[getCurrentPeriodIndex()] = ibt.balanceOf(address(this));
652	 }
653	 function getUnrealisedYieldPerPT() public view override returns (uint256) {
654	 uint256 totalUnderlyingAtStart = totalUnderlyingDeposited;
655	 if (totalUnderlyingAtStart == 0) return 0;
656	 uint256 totalUnderlyingNow = convertIBTToUnderlying(ibt.balanceOf(address(this)));
657	 uint256 yieldForAllPT = convertUnderlyingtoIBT(totalUnderlyingNow.sub(totalUnderlyingAtStart));
658	 return yieldForAllPT.mul(IBT_UNIT).div(totalUnderlyingAtStart);
659	 }
660	 function getPTPerAmountDeposited(uint256 _amount) public view override returns (uint256) {
661	 uint256 scaledAmount = APWineMaths.getScaledInput( _amount, scaledTotals[getCurrentPeriodIndex()], ibt.balanceOf(address(this)) );
662	 return _convertIBTToUnderlyingAtRate(scaledAmount, IBTRates[getCurrentPeriodIndex()]);
663	 }
664	 }
665	 pragma solidity 0.7.6;
666	 interface IERC20 is IERC20Upgradeable {
667	 function name() external returns (string memory);
668	 function symbol() external returns (string memory);
669	 function decimals() external view returns (uint8);
670	 function increaseAllowance(address spender, uint256 addedValue) external returns (bool);
671	 function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);
672	 }
673	 pragma solidity 0.7.6;
674	 contract PaladinFutureVault is HybridFutureVault {
675	 IpalStTokenPool public constant POOL_CONTRACT = IpalStTokenPool(0xCDc3DD86C99b58749de0F697dfc1ABE4bE22216d);
676	 function getIBTRate() public view virtual override returns (uint256) {
677	 return POOL_CONTRACT.exchangeRateStored();
678	 }
679	 }
680	 pragma solidity 0.7.6;
681	 interface IpalStTokenPool {
682	 function exchangeRateStored() external view returns (uint256);
683	 }
684	 pragma solidity >=0.6.0 <0.8.0;
685	 library SafeMathUpgradeable {
686	 function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
687	 uint256 c = a + b;
688	 if (c < a) return (false, 0);
689	 return (true, c);
690	 }
691	 function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
692	 if (b > a) return (false, 0);
693	 return (true, a - b);
694	 }
695	 function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
696	 if (a == 0) return (true, 0);
697	 uint256 c = a * b;
698	 if (c / a != b) return (false, 0);
699	 return (true, c);
700	 }
701	 function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
702	 if (b == 0) return (false, 0);
703	 return (true, a / b);
704	 }
705	 function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
706	 if (b == 0) return (false, 0);
707	 return (true, a % b);
708	 }
709	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
710	 uint256 c = a + b;
711	 require(c >= a, "SafeMath: addition overflow");
712	 return c;
713	 }
714	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
715	 require(b <= a, "SafeMath: subtraction overflow");
716	 return a - b;
717	 }
718	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
719	 if (a == 0) return 0;
720	 uint256 c = a * b;
721	 require(c / a == b, "SafeMath: multiplication overflow");
722	 return c;
723	 }
724	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
725	 require(b > 0, "SafeMath: division by zero");
726	 return a / b;
727	 }
728	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
729	 require(b > 0, "SafeMath: modulo by zero");
730	 return a % b;
731	 }
732	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
733	 require(b <= a, errorMessage);
734	 return a - b;
735	 }
736	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
737	 require(b > 0, errorMessage);
738	 return a / b;
739	 }
740	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
741	 require(b > 0, errorMessage);
742	 return a % b;
743	 }
744	 }
745	 pragma solidity >=0.6.0 <0.8.0;
746	 library SafeERC20Upgradeable {
747	 using SafeMathUpgradeable for uint256;
748	 using AddressUpgradeable for address;
749	 function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {
750	 _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
751	 }
752	 function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {
753	 _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
754	 }
755	 function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {
756	 require((value == 0) || (token.allowance(address(this), spender) == 0), "SafeERC20: approve from non-zero to non-zero allowance" );
757	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
758	 }
759	 function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {
760	 uint256 newAllowance = token.allowance(address(this), spender).add(value);
761	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
762	 }
763	 function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {
764	 uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
765	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
766	 }
767	 function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {
768	 bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
769	 if (returndata.length > 0) {
770	 require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
771	 }
772	 }
773	 }
774	 pragma solidity 0.7.6;
775	 interface IFutureYieldToken is IERC20 {
776	 function burn(uint256 amount) external;
777	 function burnFrom(address account, uint256 amount) external;
778	 function mint(address to, uint256 amount) external;
779	 function recordedBalanceOf(address account) external view returns (uint256);
780	 function balanceOf(address account) external view override returns (uint256);
781	 function futureVault() external view returns (address);
782	 function internalPeriodID() external view returns (uint256);
783	 }
784	 pragma solidity 0.7.6;
785	 interface IPT is IERC20 {
786	 function burn(uint256 amount) external;
787	 function mint(address to, uint256 amount) external;
788	 function burnFrom(address account, uint256 amount) external;
789	 function pause() external;
790	 function unpause() external;
791	 function recordedBalanceOf(address account) external view returns (uint256);
792	 function balanceOf(address account) external view override returns (uint256);
793	 function futureVault() external view returns (address);
794	 }
795	 pragma solidity 0.7.6;
796	 interface IFutureWallet {
797	 event YieldRedeemed(address _user, uint256 _periodIndex);
798	 event WithdrawalsPaused();
799	 event WithdrawalsResumed();
800	 function registerExpiredFuture(uint256 _amount) external;
801	 function redeemYield(uint256 _periodIndex) external;
802	 function getRedeemableYield(uint256 _periodIndex, address _user) external view returns (uint256);
803	 function getFutureVaultAddress() external view returns (address);
804	 function getIBTAddress() external view returns (address);
805	 function harvestRewards() external;
806	 function redeemAllWalletRewards() external;
807	 function redeemWalletRewards(address _rewardToken) external;
808	 function getRewardsRecipient() external view returns (address);
809	 function setRewardRecipient(address _recipient) external;
810	 }
811	 pragma solidity 0.7.6;
812	 interface IController {
813	 event NextPeriodSwitchSet(uint256 _periodDuration, uint256 _nextSwitchTimestamp);
814	 event NewPeriodDurationIndexSet(uint256 _periodIndex);
815	 event FutureRegistered(IFutureVault _futureVault);
816	 event FutureUnregistered(IFutureVault _futureVault);
817	 event StartingDelaySet(uint256 _startingDelay);
818	 event NewPerformanceFeeFactor(IFutureVault _futureVault, uint256 _feeFactor);
819	 event FutureTerminated(IFutureVault _futureVault);
820	 event DepositsPaused(IFutureVault _futureVault);
821	 event DepositsResumed(IFutureVault _futureVault);
822	 event WithdrawalsPaused(IFutureVault _futureVault);
823	 event WithdrawalsResumed(IFutureVault _futureVault);
824	 event RegistryChanged(IRegistry _registry);
825	 event FutureSetToBeTerminated(IFutureVault _futureVault);
826	 function STARTING_DELAY() external view returns (uint256);
827	 function deposit(address _futureVault, uint256 _amount) external;
828	 function withdraw(address _futureVault, uint256 _amount) external;
829	 function exitTerminatedFuture(address _futureVault, address _user) external;
830	 function createFYTDelegationTo( address _futureVault, address _receiver, uint256 _amount ) external;
831	 function withdrawFYTDelegationFrom( address _futureVault, address _receiver, uint256 _amount ) external;
832	 function getRegistryAddress() external view returns (address);
833	 function getPeriodIndex(uint256 _periodDuration) external view returns (uint256);
834	 function getNextPeriodStart(uint256 _periodDuration) external view returns (uint256);
835	 function getNextPerformanceFeeFactor(address _futureVault) external view returns (uint256);
836	 function getCurrentPerformanceFeeFactor(address _futureVault) external view returns (uint256);
837	 function getDurations() external view returns (uint256[] memory durationsList);
838	 function getFuturesWithDuration(uint256 _periodDuration) external view returns (address[] memory filteredFutures);
839	 function isFutureTerminated(address _futureVault) external view returns (bool);
840	 function isFutureSetToBeTerminated(address _futureVault) external view returns (bool);
841	 function isWithdrawalsPaused(address _futureVault) external view returns (bool);
842	 function isDepositsPaused(address _futureVault) external view returns (bool);
843	 }
844	 pragma solidity 0.7.6;
845	 interface IRegistry {
846	 function setTreasury(address _newTreasury) external;
847	 function setController(address _newController) external;
848	 function setPTLogic(address _PTLogic) external;
849	 function setFYTLogic(address _FYTLogic) external;
850	 function getControllerAddress() external view returns (address);
851	 function getTreasuryAddress() external view returns (address);
852	 function getTokensFactoryAddress() external view returns (address);
853	 function getPTLogicAddress() external view returns (address);
854	 function getFYTLogicAddress() external view returns (address);
855	 function addFutureVault(address _future) external;
856	 function removeFutureVault(address _future) external;
857	 function isRegisteredFutureVault(address _future) external view returns (bool);
858	 function getFutureVaultAt(uint256 _index) external view returns (address);
859	 function futureVaultCount() external view returns (uint256);
860	 }
861	 pragma solidity 0.7.6;
862	 interface ITokensFactory {
863	 function deployNextFutureYieldToken(uint256 nextPeriodIndex) external returns (address newToken);
864	 function deployPT( string memory _ibtSymbol, uint256 _ibtDecimals, string memory _platformName, uint256 _perioDuration ) external returns (address newToken);
865	 }
866	 pragma solidity 0.7.6;
867	 library APWineMaths {
868	 using SafeMathUpgradeable for uint256;
869	 function getScaledInput( uint256 _actualValue, uint256 _initialSum, uint256 _actualSum ) internal pure returns (uint256) {
870	 if (_initialSum == 0 || _actualSum == 0) return _actualValue;
871	 return (_actualValue.mul(_initialSum)).div(_actualSum);
872	 }
873	 function getActualOutput( uint256 _scaledOutput, uint256 _initialSum, uint256 _actualSum ) internal pure returns (uint256) {
874	 if (_initialSum == 0 || _actualSum == 0) return 0;
875	 return (_scaledOutput.mul(_actualSum)).div(_initialSum);
876	 }
877	 }
878	 pragma solidity >=0.6.0 <0.8.0;
879	 library EnumerableSetUpgradeable {
880	 struct Set {
881	 bytes32[] _values;
882	 mapping (bytes32 => uint256) _indexes;
883	 }
884	 function _add(Set storage set, bytes32 value) private returns (bool) {
885	 if (!_contains(set, value)) {
886	 set._values.push(value);
887	 set._indexes[value] = set._values.length;
888	 return true;
889	 }
890	 else {
891	 return false;
892	 }
893	 }
894	 function _remove(Set storage set, bytes32 value) private returns (bool) {
895	 uint256 valueIndex = set._indexes[value];
896	 if (valueIndex != 0) {
897	 uint256 toDeleteIndex = valueIndex - 1;
898	 uint256 lastIndex = set._values.length - 1;
899	 bytes32 lastvalue = set._values[lastIndex];
900	 set._values[toDeleteIndex] = lastvalue;
901	 set._indexes[lastvalue] = toDeleteIndex + 1;
902	 set._values.pop();
903	 delete set._indexes[value];
904	 return true;
905	 }
906	 else {
907	 return false;
908	 }
909	 }
910	 function _contains(Set storage set, bytes32 value) private view returns (bool) {
911	 return set._indexes[value] != 0;
912	 }
913	 function _length(Set storage set) private view returns (uint256) {
914	 return set._values.length;
915	 }
916	 function _at(Set storage set, uint256 index) private view returns (bytes32) {
917	 require(set._values.length > index, "EnumerableSet: index out of bounds");
918	 return set._values[index];
919	 }
920	 struct Bytes32Set {
921	 Set _inner;
922	 }
923	 function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {
924	 return _add(set._inner, value);
925	 }
926	 function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {
927	 return _remove(set._inner, value);
928	 }
929	 function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {
930	 return _contains(set._inner, value);
931	 }
932	 function length(Bytes32Set storage set) internal view returns (uint256) {
933	 return _length(set._inner);
934	 }
935	 function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {
936	 return _at(set._inner, index);
937	 }
938	 struct AddressSet {
939	 Set _inner;
940	 }
941	 function add(AddressSet storage set, address value) internal returns (bool) {
942	 return _add(set._inner, bytes32(uint256(uint160(value))));
943	 }
944	 function remove(AddressSet storage set, address value) internal returns (bool) {
945	 return _remove(set._inner, bytes32(uint256(uint160(value))));
946	 }
947	 function contains(AddressSet storage set, address value) internal view returns (bool) {
948	 return _contains(set._inner, bytes32(uint256(uint160(value))));
949	 }
950	 function length(AddressSet storage set) internal view returns (uint256) {
951	 return _length(set._inner);
952	 }
953	 function at(AddressSet storage set, uint256 index) internal view returns (address) {
954	 return address(uint160(uint256(_at(set._inner, index))));
955	 }
956	 struct UintSet {
957	 Set _inner;
958	 }
959	 function add(UintSet storage set, uint256 value) internal returns (bool) {
960	 return _add(set._inner, bytes32(value));
961	 }
962	 function remove(UintSet storage set, uint256 value) internal returns (bool) {
963	 return _remove(set._inner, bytes32(value));
964	 }
965	 function contains(UintSet storage set, uint256 value) internal view returns (bool) {
966	 return _contains(set._inner, bytes32(value));
967	 }
968	 function length(UintSet storage set) internal view returns (uint256) {
969	 return _length(set._inner);
970	 }
971	 function at(UintSet storage set, uint256 index) internal view returns (uint256) {
972	 return uint256(_at(set._inner, index));
973	 }
974	 }
975	 pragma solidity >=0.6.2 <0.8.0;
976	 library AddressUpgradeable {
977	 function isContract(address account) internal view returns (bool) {
978	 uint256 size;
979	 assembly {
980	 size := extcodesize(account) }
981	 return size > 0;
982	 }
983	 function sendValue(address payable recipient, uint256 amount) internal {
984	 require(address(this).balance >= amount, "Address: insufficient balance");
985	 (bool success, ) = recipient.call{
986	 value: amount }
987	 ("");
988	 require(success, "Address: unable to send value, recipient may have reverted");
989	 }
990	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
991	 return functionCall(target, data, "Address: low-level call failed");
992	 }
993	 function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
994	 return functionCallWithValue(target, data, 0, errorMessage);
995	 }
996	 function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
997	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
998	 }
999	 function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
1000	 require(address(this).balance >= value, "Address: insufficient balance for call");
1001	 require(isContract(target), "Address: call to non-contract");
1002	 (bool success, bytes memory returndata) = target.call{
1003	 value: value }
1004	 (data);
1005	 return _verifyCallResult(success, returndata, errorMessage);
1006	 }
1007	 function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
1008	 return functionStaticCall(target, data, "Address: low-level static call failed");
1009	 }
1010	 function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
1011	 require(isContract(target), "Address: static call to non-contract");
1012	 (bool success, bytes memory returndata) = target.staticcall(data);
1013	 return _verifyCallResult(success, returndata, errorMessage);
1014	 }
1015	 function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
1016	 if (success) {
1017	 return returndata;
1018	 }
1019	 else {
1020	 if (returndata.length > 0) {
1021	 assembly {
1022	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
1023	 }
1024	 else {
1025	 revert(errorMessage);
1026	 }
1027	 }
1028	 }
1029	 }
1030	 pragma solidity 0.7.6;
1031	 interface IFutureVault {
1032	 event NewPeriodStarted(uint256 _newPeriodIndex);
1033	 event FutureWalletSet(address _futureWallet);
1034	 event RegistrySet(IRegistry _registry);
1035	 event FundsDeposited(address _user, uint256 _amount);
1036	 event FundsWithdrawn(address _user, uint256 _amount);
1037	 event PTSet(IPT _pt);
1038	 event LiquidityTransfersPaused();
1039	 event LiquidityTransfersResumed();
1040	 event DelegationCreated(address _delegator, address _receiver, uint256 _amount);
1041	 event DelegationRemoved(address _delegator, address _receiver, uint256 _amount);
1042	 function PERIOD_DURATION() external view returns (uint256);
1043	 function PLATFORM_NAME() external view returns (string memory);
1044	 function startNewPeriod() external;
1045	 function exitTerminatedFuture(address _user) external;
1046	 function updateUserState(address _user) external;
1047	 function claimFYT(address _user, uint256 _amount) external;
1048	 function deposit(address _user, uint256 _amount) external;
1049	 function withdraw(address _user, uint256 _amount) external;
1050	 function createFYTDelegationTo( address _delegator, address _receiver, uint256 _amount ) external;
1051	 function withdrawFYTDelegationFrom( address _delegator, address _receiver, uint256 _amount ) external;
1052	 function getTotalDelegated(address _delegator) external view returns (uint256 totalDelegated);
1053	 function getNextPeriodIndex() external view returns (uint256);
1054	 function getCurrentPeriodIndex() external view returns (uint256);
1055	 function getClaimablePT(address _user) external view returns (uint256);
1056	 function getUserEarlyUnlockablePremium(address _user) external view returns (uint256 premiumLocked, uint256 amountRequired);
1057	 function getUnlockableFunds(address _user) external view returns (uint256);
1058	 function getClaimableFYTForPeriod(address _user, uint256 _periodIndex) external view returns (uint256);
1059	 function getUnrealisedYieldPerPT() external view returns (uint256);
1060	 function getPTPerAmountDeposited(uint256 _amount) external view returns (uint256);
1061	 function getPremiumPerUnderlyingDeposited(uint256 _amount) external view returns (uint256);
1062	 function getTotalUnderlyingDeposited() external view returns (uint256);
1063	 function getYieldOfPeriod(uint256 _periodID) external view returns (uint256);
1064	 function getControllerAddress() external view returns (address);
1065	 function getFutureWalletAddress() external view returns (address);
1066	 function getIBTAddress() external view returns (address);
1067	 function getPTAddress() external view returns (address);
1068	 function getFYTofPeriod(uint256 _periodIndex) external view returns (address);
1069	 function isTerminated() external view returns (bool);
1070	 function getPerformanceFeeFactor() external view returns (uint256);
1071	 function harvestRewards() external;
1072	 function redeemAllVaultRewards() external;
1073	 function redeemVaultRewards(address _rewardToken) external;
1074	 function addRewardsToken(address _token) external;
1075	 function isRewardToken(address _token) external view returns (bool);
1076	 function getRewardTokenAt(uint256 _index) external view returns (address);
1077	 function getRewardTokensCount() external view returns (uint256);
1078	 function getRewardsRecipient() external view returns (address);
1079	 function setRewardRecipient(address _recipient) external;
1080	 function setFutureWallet(IFutureWallet _futureWallet) external;
1081	 function setRegistry(IRegistry _registry) external;
1082	 function pauseLiquidityTransfers() external;
1083	 function resumeLiquidityTransfers() external;
1084	 function convertIBTToUnderlying(uint256 _amount) external view returns (uint256);
1085	 function convertUnderlyingtoIBT(uint256 _amount) external view returns (uint256);
1086	 }
