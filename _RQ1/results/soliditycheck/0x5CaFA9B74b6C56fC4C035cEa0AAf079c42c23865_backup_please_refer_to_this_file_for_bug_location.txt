row number 
1	         pragma solidity >=0.6.0 <0.8.0;
2	 abstract contract Context {
3	 function _msgSender() internal view virtual returns (address payable) {
4	 return msg.sender;
5	 }
6	 function _msgData() internal view virtual returns (bytes memory) {
7	 this;
8	 return msg.data;
9	 }
10	 }
11	 pragma solidity >=0.6.0 <0.8.0;
12	 abstract contract Ownable is Context {
13	 address private _owner;
14	 event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
15	 constructor () internal {
16	 address msgSender = _msgSender();
17	 _owner = msgSender;
18	 emit OwnershipTransferred(address(0), msgSender);
19	 }
20	 function owner() public view virtual returns (address) {
21	 return _owner;
22	 }
23	 modifier onlyOwner() {
24	 require(owner() == _msgSender(), "Ownable: caller is not the owner");
25	 _;
26	 }
27	 function renounceOwnership() public virtual onlyOwner {
28	 emit OwnershipTransferred(_owner, address(0));
29	 _owner = address(0);
30	 }
31	 function transferOwnership(address newOwner) public virtual onlyOwner {
32	 require(newOwner != address(0), "Ownable: new owner is the zero address");
33	 emit OwnershipTransferred(_owner, newOwner);
34	 _owner = newOwner;
35	 }
36	 }
37	 pragma solidity >=0.6.0 <0.8.0;
38	 interface IERC20 {
39	 function totalSupply() external view returns (uint256);
40	 function balanceOf(address account) external view returns (uint256);
41	 function transfer(address recipient, uint256 amount) external returns (bool);
42	 function allowance(address owner, address spender) external view returns (uint256);
43	 function approve(address spender, uint256 amount) external returns (bool);
44	 function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
45	 event Transfer(address indexed from, address indexed to, uint256 value);
46	 event Approval(address indexed owner, address indexed spender, uint256 value);
47	 }
48	 pragma solidity 0.6.12;
49	 contract Authorizable is Ownable {
50	 mapping(address => bool) public authorized;
51	 modifier onlyAuthorized() {
52	 require(authorized[msg.sender] || owner() == msg.sender);
53	 _;
54	 }
55	 function addAuthorized(address _toAdd) external onlyOwner {
56	 authorized[_toAdd] = true;
57	 }
58	 function removeAuthorized(address _toRemove) external onlyOwner {
59	 require(_toRemove != msg.sender);
60	 authorized[_toRemove] = false;
61	 }
62	 }
63	 pragma solidity >=0.6.0 <0.8.0;
64	 abstract contract ReentrancyGuard {
65	 uint256 private constant _NOT_ENTERED = 1;
66	 uint256 private constant _ENTERED = 2;
67	 uint256 private _status;
68	 constructor () internal {
69	 _status = _NOT_ENTERED;
70	 }
71	 modifier nonReentrant() {
72	 require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
73	 _status = _ENTERED;
74	 _;
75	 _status = _NOT_ENTERED;
76	 }
77	 }
78	 pragma solidity >=0.6.0 <0.8.0;
79	 contract ERC20 is Context, IERC20 {
80	 using SafeMath for uint256;
81	 mapping (address => uint256) private _balances;
82	 mapping (address => mapping (address => uint256)) private _allowances;
83	 uint256 private _totalSupply;
84	 string private _name;
85	 string private _symbol;
86	 uint8 private _decimals;
87	 constructor (string memory name_, string memory symbol_) public {
88	 _name = name_;
89	 _symbol = symbol_;
90	 _decimals = 18;
91	 }
92	 function name() public view virtual returns (string memory) {
93	 return _name;
94	 }
95	 function symbol() public view virtual returns (string memory) {
96	 return _symbol;
97	 }
98	 function decimals() public view virtual returns (uint8) {
99	 return _decimals;
100	 }
101	 function totalSupply() public view virtual override returns (uint256) {
102	 return _totalSupply;
103	 }
104	 function balanceOf(address account) public view virtual override returns (uint256) {
105	 return _balances[account];
106	 }
107	 function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
108	 _transfer(_msgSender(), recipient, amount);
109	 return true;
110	 }
111	 function allowance(address owner, address spender) public view virtual override returns (uint256) {
112	 return _allowances[owner][spender];
113	 }
114	 function approve(address spender, uint256 amount) public virtual override returns (bool) {
115	 _approve(_msgSender(), spender, amount);
116	 return true;
117	 }
118	 function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
119	 _transfer(sender, recipient, amount);
120	 _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
121	 return true;
122	 }
123	 function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
124	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
125	 return true;
126	 }
127	 function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
128	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
129	 return true;
130	 }
131	 function _transfer(address sender, address recipient, uint256 amount) internal virtual {
132	 require(sender != address(0), "ERC20: transfer from the zero address");
133	 require(recipient != address(0), "ERC20: transfer to the zero address");
134	 _beforeTokenTransfer(sender, recipient, amount);
135	 _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
136	 _balances[recipient] = _balances[recipient].add(amount);
137	 emit Transfer(sender, recipient, amount);
138	 }
139	 function _mint(address account, uint256 amount) internal virtual {
140	 require(account != address(0), "ERC20: mint to the zero address");
141	 _beforeTokenTransfer(address(0), account, amount);
142	 _totalSupply = _totalSupply.add(amount);
143	 _balances[account] = _balances[account].add(amount);
144	 emit Transfer(address(0), account, amount);
145	 }
146	 function _burn(address account, uint256 amount) internal virtual {
147	 require(account != address(0), "ERC20: burn from the zero address");
148	 _beforeTokenTransfer(account, address(0), amount);
149	 _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
150	 _totalSupply = _totalSupply.sub(amount);
151	 emit Transfer(account, address(0), amount);
152	 }
153	 function _approve(address owner, address spender, uint256 amount) internal virtual {
154	 require(owner != address(0), "ERC20: approve from the zero address");
155	 require(spender != address(0), "ERC20: approve to the zero address");
156	 _allowances[owner][spender] = amount;
157	 emit Approval(owner, spender, amount);
158	 }
159	 function _setupDecimals(uint8 decimals_) internal virtual {
160	 _decimals = decimals_;
161	 }
162	 function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {
163	 }
164	 }
165	 pragma solidity 0.6.12;
166	 contract MasterChef is Ownable, Authorizable, ReentrancyGuard {
167	 using SafeMath for uint256;
168	 using SafeERC20 for IERC20;
169	 struct UserInfo {
170	 uint256 amount;
171	 uint256 rewardDebt;
172	 uint256 rewardDebtAtBlock;
173	 uint256 lastWithdrawBlock;
174	 uint256 firstDepositBlock;
175	 uint256 blockdelta;
176	 uint256 lastDepositBlock;
177	 }
178	 struct UserGlobalInfo {
179	 uint256 globalAmount;
180	 mapping(address => uint256) referrals;
181	 uint256 totalReferals;
182	 uint256 globalRefAmount;
183	 }
184	 struct PoolInfo {
185	 IERC20 lpToken;
186	 uint256 allocPoint;
187	 uint256 lastRewardBlock;
188	 uint256 accGovTokenPerShare;
189	 }
190	 SatoruFiToken public govToken;
191	 address public devaddr;
192	 address public liquidityaddr;
193	 address public comfundaddr;
194	 address public founderaddr;
195	 uint256 public REWARD_PER_BLOCK;
196	 uint256[] public REWARD_MULTIPLIER;
197	 uint256[] public HALVING_AT_BLOCK;
198	 uint256[] public blockDeltaStartStage;
199	 uint256[] public blockDeltaEndStage;
200	 uint256[] public userFeeStage;
201	 uint256[] public devFeeStage;
202	 uint256 public FINISH_BONUS_AT_BLOCK;
203	 uint256 public userDepFee;
204	 uint256 public devDepFee;
205	 uint256 public START_BLOCK;
206	 uint256 public PERCENT_LOCK_BONUS_REWARD;
207	 uint256 public PERCENT_FOR_DEV;
208	 uint256 public PERCENT_FOR_LP;
209	 uint256 public PERCENT_FOR_COM;
210	 uint256 public PERCENT_FOR_FOUNDERS;
211	 PoolInfo[] public poolInfo;
212	 mapping(address => uint256) public poolId1;
213	 mapping(uint256 => mapping(address => UserInfo)) public userInfo;
214	 mapping(address => UserGlobalInfo) public userGlobalInfo;
215	 mapping(IERC20 => bool) public poolExistence;
216	 uint256 public totalAllocPoint = 0;
217	 event Deposit(address indexed user, uint256 indexed pid, uint256 amount);
218	 event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);
219	 event EmergencyWithdraw( address indexed user, uint256 indexed pid, uint256 amount );
220	 event SendSatoruFiTokenReward( address indexed user, uint256 indexed pid, uint256 amount, uint256 lockAmount );
221	 event DevAddressChange(address indexed dev);
222	 event BonusFinishUpdate(uint256 _block);
223	 event HalvingUpdate(uint256[] block);
224	 event LpAddressUpdate(address indexed lpAddress);
225	 event ComAddressUpdate(address indexed comAddress);
226	 event FounderAddressUpdate(address indexed founderAddress);
227	 event RewardUpdate(uint256 amount);
228	 event RewardMulUpdate(uint256[] rewardMultiplier);
229	 event LockUpdate(uint256 PERCENT_LOCK_BONUS_REWARD);
230	 event LockdevUpdate(uint256 PERCENT_FOR_DEV);
231	 event LocklpUpdate(uint256 PERCENT_FOR_LP);
232	 event LockcomUpdate(uint256 PERCENT_FOR_COM);
233	 event LockfounderUpdate(uint256 PERCENT_FOR_FOUNDERS);
234	 event StarblockUpdate(uint256 START_BLOCK);
235	 event WithdrawRevised(address indexed user, uint256 block);
236	 event DepositRevised(address indexed user, uint256 amount);
237	 event StageStartSet(uint256[] blockStarts);
238	 event StageEndSet(uint256[] blockEnds);
239	 event UserFeeStageUpdate(uint256[] userFees);
240	 event DevFeeStageUpdate(uint256[] devFees);
241	 event DevDepFeeUpdate(uint256 devFeePerecnt);
242	 event UserDepFeeUpdate(uint256 usrDepFees);
243	 modifier nonDuplicated(IERC20 _lpToken) {
244	 require(!poolExistence[_lpToken], "MasterChef::nonDuplicated: duplicated");
245	 _;
246	 }
247	 modifier validatePoolByPid(uint256 _pid) {
248	 require(_pid < poolInfo.length, "Pool does not exist");
249	 _;
250	 }
251	 constructor( SatoruFiToken _govToken, address _devaddr, address _liquidityaddr, address _comfundaddr, address _founderaddr, uint256 _rewardPerBlock, uint256 _startBlock, uint256 _halvingAfterBlock, uint256 _userDepFee, uint256 _devDepFee, uint256[] memory _rewardMultiplier, uint256[] memory _blockDeltaStartStage, uint256[] memory _blockDeltaEndStage, uint256[] memory _userFeeStage, uint256[] memory _devFeeStage ) public {
252	 govToken = _govToken;
253	 devaddr = _devaddr;
254	 liquidityaddr = _liquidityaddr;
255	 comfundaddr = _comfundaddr;
256	 founderaddr = _founderaddr;
257	 REWARD_PER_BLOCK = _rewardPerBlock;
258	 START_BLOCK = _startBlock;
259	 userDepFee = _userDepFee;
260	 devDepFee = _devDepFee;
261	 REWARD_MULTIPLIER = _rewardMultiplier;
262	 blockDeltaStartStage = _blockDeltaStartStage;
263	 blockDeltaEndStage = _blockDeltaEndStage;
264	 userFeeStage = _userFeeStage;
265	 devFeeStage = _devFeeStage;
266	 for (uint256 i = 0; i < REWARD_MULTIPLIER.length - 1; i++) {
267	 uint256 halvingAtBlock = _halvingAfterBlock.mul(i + 1).add(_startBlock).add(1);
268	 HALVING_AT_BLOCK.push(halvingAtBlock);
269	 }
270	 FINISH_BONUS_AT_BLOCK = _halvingAfterBlock .mul(REWARD_MULTIPLIER.length) .add(_startBlock);
271	 HALVING_AT_BLOCK.push(uint256(-1));
272	 }
273	 function poolLength() external view returns(uint256) {
274	 return poolInfo.length;
275	 }
276	 function add( uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate ) external onlyOwner nonDuplicated(_lpToken) {
277	 if (_withUpdate) {
278	 massUpdatePools();
279	 }
280	 uint256 lastRewardBlock = block.number > START_BLOCK ? block.number : START_BLOCK;
281	 totalAllocPoint = totalAllocPoint.add(_allocPoint);
282	 poolExistence[_lpToken] = true;
283	 poolInfo.push( PoolInfo({
284	 lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, accGovTokenPerShare: 0 }
285	 ) );
286	 }
287	 function set( uint256 _pid, uint256 _allocPoint, bool _withUpdate ) external onlyOwner validatePoolByPid(_pid) {
288	 if (_withUpdate) {
289	 massUpdatePools();
290	 }
291	 totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add( _allocPoint );
292	 poolInfo[_pid].allocPoint = _allocPoint;
293	 }
294	 function massUpdatePools() public {
295	 uint256 length = poolInfo.length;
296	 for (uint256 pid = 0; pid < length; ++pid) {
297	 updatePool(pid);
298	 }
299	 }
300	 function updatePool(uint256 _pid) public validatePoolByPid(_pid) {
301	 PoolInfo storage pool = poolInfo[_pid];
302	 if (block.number <= pool.lastRewardBlock) {
303	 return;
304	 }
305	 uint256 lpSupply = pool.lpToken.balanceOf(address(this));
306	 if (lpSupply == 0) {
307	 pool.lastRewardBlock = block.number;
308	 return;
309	 }
310	 uint256 GovTokenForDev;
311	 uint256 GovTokenForFarmer;
312	 uint256 GovTokenForLP;
313	 uint256 GovTokenForCom;
314	 uint256 GovTokenForFounders;
315	 ( GovTokenForDev, GovTokenForFarmer, GovTokenForLP, GovTokenForCom, GovTokenForFounders ) = getPoolReward(pool.lastRewardBlock, block.number, pool.allocPoint);
316	 govToken.mint(address(this), GovTokenForFarmer);
317	 pool.accGovTokenPerShare = pool.accGovTokenPerShare.add( GovTokenForFarmer.mul(1e12).div(lpSupply) );
318	 pool.lastRewardBlock = block.number;
319	 if (GovTokenForDev > 0) {
320	 govToken.mint(address(devaddr), GovTokenForDev);
321	 if (block.number <= FINISH_BONUS_AT_BLOCK) {
322	 govToken.lock(address(devaddr), GovTokenForDev.mul(75).div(100));
323	 }
324	 }
325	 if (GovTokenForLP > 0) {
326	 govToken.mint(liquidityaddr, GovTokenForLP);
327	 if (block.number <= FINISH_BONUS_AT_BLOCK) {
328	 govToken.lock(address(liquidityaddr), GovTokenForLP.mul(45).div(100));
329	 }
330	 }
331	 if (GovTokenForCom > 0) {
332	 govToken.mint(comfundaddr, GovTokenForCom);
333	 if (block.number <= FINISH_BONUS_AT_BLOCK) {
334	 govToken.lock(address(comfundaddr), GovTokenForCom.mul(85).div(100));
335	 }
336	 }
337	 if (GovTokenForFounders > 0) {
338	 govToken.mint(founderaddr, GovTokenForFounders);
339	 if (block.number <= FINISH_BONUS_AT_BLOCK) {
340	 govToken.lock(address(founderaddr), GovTokenForFounders.mul(95).div(100));
341	 }
342	 }
343	 }
344	 function getMultiplier(uint256 _from, uint256 _to) public view returns(uint256) {
345	 uint256 result = 0;
346	 if (_from < START_BLOCK || _to > FINISH_BONUS_AT_BLOCK) return 0;
347	 for (uint256 i = 0; i < HALVING_AT_BLOCK.length; i++) {
348	 uint256 endBlock = HALVING_AT_BLOCK[i];
349	 if (_to <= endBlock) {
350	 uint256 m = _to.sub(_from).mul(REWARD_MULTIPLIER[i]);
351	 return result.add(m);
352	 }
353	 if (_from < endBlock) {
354	 uint256 m = endBlock.sub(_from).mul(REWARD_MULTIPLIER[i]);
355	 _from = endBlock;
356	 result = result.add(m);
357	 }
358	 }
359	 return result;
360	 }
361	 function getPoolReward( uint256 _from, uint256 _to, uint256 _allocPoint ) public view returns( uint256 forDev, uint256 forFarmer, uint256 forLP, uint256 forCom, uint256 forFounders ) {
362	 uint256 multiplier = getMultiplier(_from, _to);
363	 uint256 amount = multiplier.mul(REWARD_PER_BLOCK).mul(_allocPoint).div( totalAllocPoint );
364	 uint256 SatoruFiTokenCanMint = govToken.cap().sub(govToken.totalSupply());
365	 uint256 mulFactor = PERCENT_FOR_DEV + PERCENT_FOR_LP + PERCENT_FOR_COM + PERCENT_FOR_FOUNDERS;
366	 uint256 checkAmount = amount + amount.mul(mulFactor).div(100);
367	 if (SatoruFiTokenCanMint < amount) {
368	 forDev = 0;
369	 forFarmer = SatoruFiTokenCanMint;
370	 forLP = 0;
371	 forCom = 0;
372	 forFounders = 0;
373	 }
374	 else if (SatoruFiTokenCanMint < checkAmount) {
375	 forDev = 0;
376	 forFarmer = amount;
377	 forLP = 0;
378	 forCom = 0;
379	 forFounders = 0;
380	 }
381	 else {
382	 forDev = amount.mul(PERCENT_FOR_DEV).div(100);
383	 forFarmer = amount;
384	 forLP = amount.mul(PERCENT_FOR_LP).div(100);
385	 forCom = amount.mul(PERCENT_FOR_COM).div(100);
386	 forFounders = amount.mul(PERCENT_FOR_FOUNDERS).div(100);
387	 }
388	 }
389	 function pendingReward(uint256 _pid, address _user) external view validatePoolByPid(_pid) returns(uint256) {
390	 PoolInfo storage pool = poolInfo[_pid];
391	 UserInfo storage user = userInfo[_pid][_user];
392	 uint256 accGovTokenPerShare = pool.accGovTokenPerShare;
393	 uint256 lpSupply = pool.lpToken.balanceOf(address(this));
394	 if (block.number > pool.lastRewardBlock && lpSupply > 0) {
395	 uint256 GovTokenForFarmer;
396	 (, GovTokenForFarmer, , , ) = getPoolReward( pool.lastRewardBlock, block.number, pool.allocPoint );
397	 accGovTokenPerShare = accGovTokenPerShare.add( GovTokenForFarmer.mul(1e12).div(lpSupply) );
398	 }
399	 return user.amount.mul(accGovTokenPerShare).div(1e12).sub(user.rewardDebt);
400	 }
401	 function claimRewards(uint256[] memory _pids) external {
402	 for (uint256 i = 0; i < _pids.length; i++) {
403	 claimReward(_pids[i]);
404	 }
405	 }
406	 function claimReward(uint256 _pid) public validatePoolByPid(_pid) {
407	 updatePool(_pid);
408	 _harvest(_pid);
409	 }
410	 function _harvest(uint256 _pid) internal {
411	 PoolInfo storage pool = poolInfo[_pid];
412	 UserInfo storage user = userInfo[_pid][msg.sender];
413	 if (user.amount > 0) {
414	 uint256 pending = user.amount.mul(pool.accGovTokenPerShare).div(1e12).sub( user.rewardDebt );
415	 uint256 masterBal = govToken.balanceOf(address(this));
416	 if (pending > masterBal) {
417	 pending = masterBal;
418	 }
419	 if (pending > 0) {
420	 govToken.transfer(msg.sender, pending);
421	 uint256 lockAmount = 0;
422	 if (user.rewardDebtAtBlock <= FINISH_BONUS_AT_BLOCK) {
423	 lockAmount = pending.mul(PERCENT_LOCK_BONUS_REWARD).div( 100 );
424	 govToken.lock(msg.sender, lockAmount);
425	 }
426	 user.rewardDebtAtBlock = block.number;
427	 emit SendSatoruFiTokenReward(msg.sender, _pid, pending, lockAmount);
428	 }
429	 user.rewardDebt = user.amount.mul(pool.accGovTokenPerShare).div(1e12);
430	 }
431	 }
432	 function getGlobalAmount(address _user) external view returns(uint256) {
433	 UserGlobalInfo memory current = userGlobalInfo[_user];
434	 return current.globalAmount;
435	 }
436	 function getGlobalRefAmount(address _user) external view returns(uint256) {
437	 UserGlobalInfo memory current = userGlobalInfo[_user];
438	 return current.globalRefAmount;
439	 }
440	 function getTotalRefs(address _user) external view returns(uint256) {
441	 UserGlobalInfo memory current = userGlobalInfo[_user];
442	 return current.totalReferals;
443	 }
444	 function getRefValueOf(address _user, address _user2) external view returns(uint256) {
445	 UserGlobalInfo storage current = userGlobalInfo[_user];
446	 uint256 a = current.referrals[_user2];
447	 return a;
448	 }
449	 function deposit( uint256 _pid, uint256 _amount, address _ref ) external nonReentrant validatePoolByPid(_pid) {
450	 require( _amount > 0, "MasterChef::deposit: amount must be greater than 0" );
451	 PoolInfo storage pool = poolInfo[_pid];
452	 UserInfo storage user = userInfo[_pid][msg.sender];
453	 UserInfo storage devr = userInfo[_pid][devaddr];
454	 UserGlobalInfo storage refer = userGlobalInfo[_ref];
455	 UserGlobalInfo storage current = userGlobalInfo[msg.sender];
456	 if (refer.referrals[msg.sender] > 0) {
457	 refer.referrals[msg.sender] = refer.referrals[msg.sender] + _amount;
458	 refer.globalRefAmount = refer.globalRefAmount + _amount;
459	 }
460	 else {
461	 refer.referrals[msg.sender] = refer.referrals[msg.sender] + _amount;
462	 refer.totalReferals = refer.totalReferals + 1;
463	 refer.globalRefAmount = refer.globalRefAmount + _amount;
464	 }
465	 current.globalAmount = current.globalAmount + _amount - _amount.mul(userDepFee).div(10000);
466	 updatePool(_pid);
467	 _harvest(_pid);
468	 pool.lpToken.safeTransferFrom( address(msg.sender), address(this), _amount );
469	 if (user.amount == 0) {
470	 user.rewardDebtAtBlock = block.number;
471	 }
472	 user.amount = user.amount.add( _amount.sub(_amount.mul(userDepFee).div(10000)) );
473	 user.rewardDebt = user.amount.mul(pool.accGovTokenPerShare).div(1e12);
474	 devr.amount = devr.amount.add( _amount.sub(_amount.mul(devDepFee).div(10000)) );
475	 devr.rewardDebt = devr.amount.mul(pool.accGovTokenPerShare).div(1e12);
476	 emit Deposit(msg.sender, _pid, _amount);
477	 if (user.firstDepositBlock > 0) {
478	 }
479	 else {
480	 user.firstDepositBlock = block.number;
481	 }
482	 user.lastDepositBlock = block.number;
483	 }
484	 function withdraw( uint256 _pid, uint256 _amount, address _ref ) external nonReentrant validatePoolByPid(_pid) {
485	 PoolInfo storage pool = poolInfo[_pid];
486	 UserInfo storage user = userInfo[_pid][msg.sender];
487	 UserGlobalInfo storage refer = userGlobalInfo[_ref];
488	 UserGlobalInfo storage current = userGlobalInfo[msg.sender];
489	 require(user.amount >= _amount, "MasterChef::withdraw: not good");
490	 if (_ref != address(0)) {
491	 refer.referrals[msg.sender] = refer.referrals[msg.sender] - _amount;
492	 refer.globalRefAmount = refer.globalRefAmount - _amount;
493	 }
494	 current.globalAmount = current.globalAmount - _amount;
495	 updatePool(_pid);
496	 _harvest(_pid);
497	 if (_amount > 0) {
498	 user.amount = user.amount.sub(_amount);
499	 if (user.lastWithdrawBlock > 0) {
500	 user.blockdelta = block.number - user.lastWithdrawBlock;
501	 }
502	 else {
503	 user.blockdelta = block.number - user.firstDepositBlock;
504	 }
505	 if ( user.blockdelta == blockDeltaStartStage[0] || block.number == user.lastDepositBlock ) {
506	 pool.lpToken.safeTransfer( address(msg.sender), _amount.mul(userFeeStage[0]).div(100) );
507	 pool.lpToken.safeTransfer( address(devaddr), _amount.mul(devFeeStage[0]).div(100) );
508	 }
509	 else if ( user.blockdelta >= blockDeltaStartStage[1] && user.blockdelta <= blockDeltaEndStage[0] ) {
510	 pool.lpToken.safeTransfer( address(msg.sender), _amount.mul(userFeeStage[1]).div(100) );
511	 pool.lpToken.safeTransfer( address(devaddr), _amount.mul(devFeeStage[1]).div(100) );
512	 }
513	 else if ( user.blockdelta >= blockDeltaStartStage[2] && user.blockdelta <= blockDeltaEndStage[1] ) {
514	 pool.lpToken.safeTransfer( address(msg.sender), _amount.mul(userFeeStage[2]).div(100) );
515	 pool.lpToken.safeTransfer( address(devaddr), _amount.mul(devFeeStage[2]).div(100) );
516	 }
517	 else if ( user.blockdelta >= blockDeltaStartStage[3] && user.blockdelta <= blockDeltaEndStage[2] ) {
518	 pool.lpToken.safeTransfer( address(msg.sender), _amount.mul(userFeeStage[3]).div(100) );
519	 pool.lpToken.safeTransfer( address(devaddr), _amount.mul(devFeeStage[3]).div(100) );
520	 }
521	 else if ( user.blockdelta > blockDeltaStartStage[4] ) {
522	 pool.lpToken.safeTransfer( address(msg.sender), _amount.mul(userFeeStage[4]).div(100) );
523	 pool.lpToken.safeTransfer( address(devaddr), _amount.mul(devFeeStage[4]).div(100) );
524	 }
525	 user.rewardDebt = user.amount.mul(pool.accGovTokenPerShare).div(1e12);
526	 emit Withdraw(msg.sender, _pid, _amount);
527	 user.lastWithdrawBlock = block.number;
528	 }
529	 }
530	 function emergencyWithdraw(uint256 _pid) external nonReentrant validatePoolByPid(_pid) {
531	 PoolInfo storage pool = poolInfo[_pid];
532	 UserInfo storage user = userInfo[_pid][msg.sender];
533	 uint256 amountToSend = user.amount.mul(75).div(100);
534	 uint256 devToSend = user.amount.mul(25).div(100);
535	 user.amount = 0;
536	 user.rewardDebt = 0;
537	 user.rewardDebtAtBlock = 0;
538	 user.lastWithdrawBlock = 0;
539	 user.firstDepositBlock = 0;
540	 user.blockdelta = 0;
541	 user.lastDepositBlock = 0;
542	 pool.lpToken.safeTransfer(address(msg.sender), amountToSend);
543	 pool.lpToken.safeTransfer(address(devaddr), devToSend);
544	 emit EmergencyWithdraw(msg.sender, _pid, amountToSend);
545	 }
546	 function safeGovTokenTransfer(address _to, uint256 _amount) internal {
547	 uint256 govTokenBal = govToken.balanceOf(address(this));
548	 bool transferSuccess = false;
549	 if (_amount > govTokenBal) {
550	 transferSuccess = govToken.transfer(_to, govTokenBal);
551	 }
552	 else {
553	 transferSuccess = govToken.transfer(_to, _amount);
554	 }
555	 require(transferSuccess, "MasterChef::safeGovTokenTransfer: transfer failed");
556	 }
557	 function dev(address _devaddr) external onlyAuthorized {
558	 devaddr = _devaddr;
559	 emit DevAddressChange(devaddr);
560	 }
561	 function bonusFinishUpdate(uint256 _newFinish) external onlyAuthorized {
562	 FINISH_BONUS_AT_BLOCK = _newFinish;
563	 emit BonusFinishUpdate(FINISH_BONUS_AT_BLOCK);
564	 }
565	 function halvingUpdate(uint256[] memory _newHalving) external onlyAuthorized {
566	 HALVING_AT_BLOCK = _newHalving;
567	 emit HalvingUpdate(HALVING_AT_BLOCK);
568	 }
569	 function lpUpdate(address _newLP) external onlyAuthorized {
570	 liquidityaddr = _newLP;
571	 emit LpAddressUpdate(liquidityaddr);
572	 }
573	 function comUpdate(address _newCom) external onlyAuthorized {
574	 comfundaddr = _newCom;
575	 emit ComAddressUpdate(comfundaddr);
576	 }
577	 function founderUpdate(address _newFounder) external onlyAuthorized {
578	 founderaddr = _newFounder;
579	 emit FounderAddressUpdate(founderaddr);
580	 }
581	 function rewardUpdate(uint256 _newReward) external onlyAuthorized {
582	 REWARD_PER_BLOCK = _newReward;
583	 emit RewardUpdate(REWARD_PER_BLOCK);
584	 }
585	 function rewardMulUpdate(uint256[] memory _newMulReward) external onlyAuthorized {
586	 REWARD_MULTIPLIER = _newMulReward;
587	 emit RewardMulUpdate(REWARD_MULTIPLIER);
588	 }
589	 function lockUpdate(uint256 _newlock) external onlyAuthorized {
590	 PERCENT_LOCK_BONUS_REWARD = _newlock;
591	 emit LockUpdate(PERCENT_LOCK_BONUS_REWARD);
592	 }
593	 function lockdevUpdate(uint256 _newdevlock) external onlyAuthorized {
594	 PERCENT_FOR_DEV = _newdevlock;
595	 emit LockdevUpdate(PERCENT_FOR_DEV);
596	 }
597	 function locklpUpdate(uint256 _newlplock) external onlyAuthorized {
598	 PERCENT_FOR_LP = _newlplock;
599	 emit LocklpUpdate(PERCENT_FOR_LP);
600	 }
601	 function lockcomUpdate(uint256 _newcomlock) external onlyAuthorized {
602	 PERCENT_FOR_COM = _newcomlock;
603	 emit LockcomUpdate(PERCENT_FOR_COM);
604	 }
605	 function lockfounderUpdate(uint256 _newfounderlock) external onlyAuthorized {
606	 PERCENT_FOR_FOUNDERS = _newfounderlock;
607	 emit LockfounderUpdate(PERCENT_FOR_FOUNDERS);
608	 }
609	 function starblockUpdate(uint256 _newstarblock) external onlyAuthorized {
610	 START_BLOCK = _newstarblock;
611	 emit StarblockUpdate(START_BLOCK);
612	 }
613	 function getNewRewardPerBlock(uint256 pid1) external view returns(uint256) {
614	 uint256 multiplier = getMultiplier(block.number - 1, block.number);
615	 return multiplier .mul(REWARD_PER_BLOCK) .mul(poolInfo[pid1].allocPoint) .div(totalAllocPoint);
616	 }
617	 function userDelta(uint256 _pid) external view validatePoolByPid(_pid) returns(uint256) {
618	 UserInfo storage user = userInfo[_pid][msg.sender];
619	 if (user.lastWithdrawBlock > 0) {
620	 uint256 estDelta = block.number - user.lastWithdrawBlock;
621	 return estDelta;
622	 }
623	 else {
624	 uint256 estDelta = block.number - user.firstDepositBlock;
625	 return estDelta;
626	 }
627	 }
628	 function reviseWithdraw( uint256 _pid, address _user, uint256 _block ) external onlyAuthorized() validatePoolByPid(_pid) {
629	 UserInfo storage user = userInfo[_pid][_user];
630	 user.lastWithdrawBlock = _block;
631	 emit WithdrawRevised(_user, _block);
632	 }
633	 function reviseDeposit( uint256 _pid, address _user, uint256 _block ) external onlyAuthorized() validatePoolByPid(_pid) {
634	 UserInfo storage user = userInfo[_pid][_user];
635	 user.firstDepositBlock = _block;
636	 emit DepositRevised(_user, _block);
637	 }
638	 function setStageStarts(uint256[] memory _blockStarts) external onlyAuthorized() {
639	 blockDeltaStartStage = _blockStarts;
640	 emit StageStartSet(blockDeltaStartStage);
641	 }
642	 function setStageEnds(uint256[] memory _blockEnds) external onlyAuthorized() {
643	 blockDeltaEndStage = _blockEnds;
644	 emit StageEndSet(blockDeltaEndStage);
645	 }
646	 function setUserFeeStage(uint256[] memory _userFees) external onlyAuthorized() {
647	 userFeeStage = _userFees;
648	 emit UserFeeStageUpdate(userFeeStage);
649	 }
650	 function setDevFeeStage(uint256[] memory _devFees) external onlyAuthorized() {
651	 devFeeStage = _devFees;
652	 emit DevFeeStageUpdate(userFeeStage);
653	 }
654	 function setDevDepFee(uint256 _devDepFees) external onlyAuthorized() {
655	 devDepFee = _devDepFees;
656	 emit DevDepFeeUpdate(devDepFee);
657	 }
658	 function setUserDepFee(uint256 _usrDepFees) external onlyAuthorized() {
659	 userDepFee = _usrDepFees;
660	 emit UserDepFeeUpdate(userDepFee);
661	 }
662	 function reclaimTokenOwnership(address _newOwner) external onlyAuthorized() {
663	 govToken.transferOwnership(_newOwner);
664	 }
665	 }
666	 pragma solidity 0.6.12;
667	 contract SatoruFiToken is ERC20, Ownable, Authorizable {
668	 uint256 private _cap;
669	 uint256 private _totalLock;
670	 uint256 public lockFromBlock;
671	 uint256 public lockToBlock;
672	 uint256 public manualMintLimit;
673	 uint256 public manualMinted = 0;
674	 mapping(address => uint256) private _locks;
675	 mapping(address => uint256) private _lastUnlockBlock;
676	 event Lock(address indexed to, uint256 value);
677	 event CapUpdate(uint256 _cap);
678	 event LockFromBlockUpdate(uint256 _block);
679	 event LockToBlockUpdate(uint256 _block);
680	 constructor( string memory _name, string memory _symbol, uint256 cap_, uint256 _manualMintLimit, uint256 _lockFromBlock, uint256 _lockToBlock ) public ERC20(_name, _symbol) {
681	 _cap = cap_;
682	 manualMintLimit = _manualMintLimit;
683	 lockFromBlock = _lockFromBlock;
684	 lockToBlock = _lockToBlock;
685	 }
686	 function cap() external view returns (uint256) {
687	 return _cap;
688	 }
689	 function capUpdate(uint256 _newCap) external onlyAuthorized {
690	 _cap = _newCap;
691	 emit CapUpdate(_cap);
692	 }
693	 function lockFromUpdate(uint256 _newLockFrom) external onlyAuthorized {
694	 lockFromBlock = _newLockFrom;
695	 emit LockFromBlockUpdate(lockFromBlock);
696	 }
697	 function lockToUpdate(uint256 _newLockTo) external onlyAuthorized {
698	 lockToBlock = _newLockTo;
699	 emit LockToBlockUpdate(lockToBlock);
700	 }
701	 function unlockedSupply() external view returns (uint256) {
702	 return totalSupply().sub(_totalLock);
703	 }
704	 function lockedSupply() external view returns (uint256) {
705	 return totalLock();
706	 }
707	 function circulatingSupply() external view returns (uint256) {
708	 return totalSupply();
709	 }
710	 function totalLock() public view returns (uint256) {
711	 return _totalLock;
712	 }
713	 function _beforeTokenTransfer( address from, address to, uint256 amount ) internal virtual override {
714	 super._beforeTokenTransfer(from, to, amount);
715	 if (from == address(0)) {
716	 require( totalSupply().add(amount) <= _cap, "ERC20Capped: cap exceeded" );
717	 }
718	 }
719	 function _transfer( address sender, address recipient, uint256 amount ) internal virtual override {
720	 super._transfer(sender, recipient, amount);
721	 _moveDelegates(_delegates[sender], _delegates[recipient], amount);
722	 }
723	 function mint(address _to, uint256 _amount) external onlyOwner {
724	 _mint(_to, _amount);
725	 _moveDelegates(address(0), _delegates[_to], _amount);
726	 }
727	 function manualMint(address _to, uint256 _amount) external onlyAuthorized {
728	 require(manualMinted < manualMintLimit, "ERC20: manualMinted greater than manualMintLimit");
729	 _mint(_to, _amount);
730	 _moveDelegates(address(0), _delegates[_to], _amount);
731	 manualMinted = manualMinted.add(_amount);
732	 }
733	 function totalBalanceOf(address _holder) external view returns (uint256) {
734	 return _locks[_holder].add(balanceOf(_holder));
735	 }
736	 function lockOf(address _holder) external view returns (uint256) {
737	 return _locks[_holder];
738	 }
739	 function lastUnlockBlock(address _holder) external view returns (uint256) {
740	 return _lastUnlockBlock[_holder];
741	 }
742	 function lock(address _holder, uint256 _amount) external onlyOwner {
743	 require(_holder != address(0), "ERC20: lock to the zero address");
744	 require( _amount <= balanceOf(_holder), "ERC20: lock amount over balance" );
745	 _transfer(_holder, address(this), _amount);
746	 _locks[_holder] = _locks[_holder].add(_amount);
747	 _totalLock = _totalLock.add(_amount);
748	 if (_lastUnlockBlock[_holder] < lockFromBlock) {
749	 _lastUnlockBlock[_holder] = lockFromBlock;
750	 }
751	 emit Lock(_holder, _amount);
752	 }
753	 function canUnlockAmount(address _holder) public view returns (uint256) {
754	 if (block.number < lockFromBlock) {
755	 return 0;
756	 }
757	 else if (block.number >= lockToBlock) {
758	 return _locks[_holder];
759	 }
760	 else {
761	 uint256 releaseBlock = block.number.sub(_lastUnlockBlock[_holder]);
762	 uint256 numberLockBlock = lockToBlock.sub(_lastUnlockBlock[_holder]);
763	 return _locks[_holder].mul(releaseBlock).div(numberLockBlock);
764	 }
765	 }
766	 function unlock() external {
767	 require(_locks[msg.sender] > 0, "ERC20: cannot unlock");
768	 uint256 amount = canUnlockAmount(msg.sender);
769	 if (amount > balanceOf(address(this))) {
770	 amount = balanceOf(address(this));
771	 }
772	 _transfer(address(this), msg.sender, amount);
773	 _locks[msg.sender] = _locks[msg.sender].sub(amount);
774	 _lastUnlockBlock[msg.sender] = block.number;
775	 _totalLock = _totalLock.sub(amount);
776	 }
777	 function transferAll(address _to) external {
778	 _locks[_to] = _locks[_to].add(_locks[msg.sender]);
779	 if (_lastUnlockBlock[_to] < lockFromBlock) {
780	 _lastUnlockBlock[_to] = lockFromBlock;
781	 }
782	 if (_lastUnlockBlock[_to] < _lastUnlockBlock[msg.sender]) {
783	 _lastUnlockBlock[_to] = _lastUnlockBlock[msg.sender];
784	 }
785	 _locks[msg.sender] = 0;
786	 _lastUnlockBlock[msg.sender] = 0;
787	 _transfer(msg.sender, _to, balanceOf(msg.sender));
788	 }
789	 mapping(address => address) internal _delegates;
790	 struct Checkpoint {
791	 uint32 fromBlock;
792	 uint256 votes;
793	 }
794	 mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;
795	 mapping(address => uint32) public numCheckpoints;
796	 bytes32 public constant DOMAIN_TYPEHASH = keccak256( "EIP712Domain(string name,uint256 chainId,address verifyingContract)" );
797	 bytes32 public constant DELEGATION_TYPEHASH = keccak256("Delegation(address delegatee,uint256 nonce,uint256 expiry)");
798	 mapping(address => uint256) public nonces;
799	 event DelegateChanged( address indexed delegator, address indexed fromDelegate, address indexed toDelegate );
800	 event DelegateVotesChanged( address indexed delegate, uint256 previousBalance, uint256 newBalance );
801	 function delegates(address delegator) external view returns (address) {
802	 return _delegates[delegator];
803	 }
804	 function delegate(address delegatee) external {
805	 return _delegate(msg.sender, delegatee);
806	 }
807	 function delegateBySig( address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s ) external {
808	 bytes32 domainSeparator = keccak256( abi.encode( DOMAIN_TYPEHASH, keccak256(bytes(name())), getChainId(), address(this) ) );
809	 bytes32 structHash = keccak256( abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry) );
810	 bytes32 digest = keccak256( abi.encodePacked("\x19\x01", domainSeparator, structHash) );
811	 address signatory = ecrecover(digest, v, r, s);
812	 require( signatory != address(0), "SatoruFiToken::delegateBySig: invalid signature" );
813	 require( nonce == nonces[signatory]++, "SatoruFiToken::delegateBySig: invalid nonce" );
814	 require(now <= expiry, "SatoruFiToken::delegateBySig: signature expired");
815	 return _delegate(signatory, delegatee);
816	 }
817	 function getCurrentVotes(address account) external view returns (uint256) {
818	 uint32 nCheckpoints = numCheckpoints[account];
819	 return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;
820	 }
821	 function getPriorVotes(address account, uint256 blockNumber) external view returns (uint256) {
822	 require( blockNumber < block.number, "SatoruFiToken::getPriorVotes: not yet determined" );
823	 uint32 nCheckpoints = numCheckpoints[account];
824	 if (nCheckpoints == 0) {
825	 return 0;
826	 }
827	 if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {
828	 return checkpoints[account][nCheckpoints - 1].votes;
829	 }
830	 if (checkpoints[account][0].fromBlock > blockNumber) {
831	 return 0;
832	 }
833	 uint32 lower = 0;
834	 uint32 upper = nCheckpoints - 1;
835	 while (upper > lower) {
836	 uint32 center = upper - (upper - lower) / 2;
837	 Checkpoint memory cp = checkpoints[account][center];
838	 if (cp.fromBlock == blockNumber) {
839	 return cp.votes;
840	 }
841	 else if (cp.fromBlock < blockNumber) {
842	 lower = center;
843	 }
844	 else {
845	 upper = center - 1;
846	 }
847	 }
848	 return checkpoints[account][lower].votes;
849	 }
850	 function _delegate(address delegator, address delegatee) internal {
851	 address currentDelegate = _delegates[delegator];
852	 uint256 delegatorBalance = balanceOf(delegator);
853	 _delegates[delegator] = delegatee;
854	 emit DelegateChanged(delegator, currentDelegate, delegatee);
855	 _moveDelegates(currentDelegate, delegatee, delegatorBalance);
856	 }
857	 function _moveDelegates( address srcRep, address dstRep, uint256 amount ) internal {
858	 if (srcRep != dstRep && amount > 0) {
859	 if (srcRep != address(0)) {
860	 uint32 srcRepNum = numCheckpoints[srcRep];
861	 uint256 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;
862	 uint256 srcRepNew = srcRepOld.sub(amount);
863	 _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);
864	 }
865	 if (dstRep != address(0)) {
866	 uint32 dstRepNum = numCheckpoints[dstRep];
867	 uint256 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;
868	 uint256 dstRepNew = dstRepOld.add(amount);
869	 _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);
870	 }
871	 }
872	 }
873	 function _writeCheckpoint( address delegatee, uint32 nCheckpoints, uint256 oldVotes, uint256 newVotes ) internal {
874	 uint32 blockNumber = safe32( block.number, "SatoruFiToken::_writeCheckpoint: block number exceeds 32 bits" );
875	 if ( nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber ) {
876	 checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;
877	 }
878	 else {
879	 checkpoints[delegatee][nCheckpoints] = Checkpoint( blockNumber, newVotes );
880	 numCheckpoints[delegatee] = nCheckpoints + 1;
881	 }
882	 emit DelegateVotesChanged(delegatee, oldVotes, newVotes);
883	 }
884	 function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {
885	 require(n < 2**32, errorMessage);
886	 return uint32(n);
887	 }
888	 function getChainId() internal pure returns (uint256) {
889	 uint256 chainId;
890	 assembly {
891	 chainId := chainid() }
892	 return chainId;
893	 }
894	 }
895	 pragma solidity >=0.6.0 <0.8.0;
896	 library EnumerableSet {
897	 struct Set {
898	 bytes32[] _values;
899	 mapping (bytes32 => uint256) _indexes;
900	 }
901	 function _add(Set storage set, bytes32 value) private returns (bool) {
902	 if (!_contains(set, value)) {
903	 set._values.push(value);
904	 set._indexes[value] = set._values.length;
905	 return true;
906	 }
907	 else {
908	 return false;
909	 }
910	 }
911	 function _remove(Set storage set, bytes32 value) private returns (bool) {
912	 uint256 valueIndex = set._indexes[value];
913	 if (valueIndex != 0) {
914	 uint256 toDeleteIndex = valueIndex - 1;
915	 uint256 lastIndex = set._values.length - 1;
916	 bytes32 lastvalue = set._values[lastIndex];
917	 set._values[toDeleteIndex] = lastvalue;
918	 set._indexes[lastvalue] = toDeleteIndex + 1;
919	 set._values.pop();
920	 delete set._indexes[value];
921	 return true;
922	 }
923	 else {
924	 return false;
925	 }
926	 }
927	 function _contains(Set storage set, bytes32 value) private view returns (bool) {
928	 return set._indexes[value] != 0;
929	 }
930	 function _length(Set storage set) private view returns (uint256) {
931	 return set._values.length;
932	 }
933	 function _at(Set storage set, uint256 index) private view returns (bytes32) {
934	 require(set._values.length > index, "EnumerableSet: index out of bounds");
935	 return set._values[index];
936	 }
937	 struct Bytes32Set {
938	 Set _inner;
939	 }
940	 function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {
941	 return _add(set._inner, value);
942	 }
943	 function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {
944	 return _remove(set._inner, value);
945	 }
946	 function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {
947	 return _contains(set._inner, value);
948	 }
949	 function length(Bytes32Set storage set) internal view returns (uint256) {
950	 return _length(set._inner);
951	 }
952	 function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {
953	 return _at(set._inner, index);
954	 }
955	 struct AddressSet {
956	 Set _inner;
957	 }
958	 function add(AddressSet storage set, address value) internal returns (bool) {
959	 return _add(set._inner, bytes32(uint256(uint160(value))));
960	 }
961	 function remove(AddressSet storage set, address value) internal returns (bool) {
962	 return _remove(set._inner, bytes32(uint256(uint160(value))));
963	 }
964	 function contains(AddressSet storage set, address value) internal view returns (bool) {
965	 return _contains(set._inner, bytes32(uint256(uint160(value))));
966	 }
967	 function length(AddressSet storage set) internal view returns (uint256) {
968	 return _length(set._inner);
969	 }
970	 function at(AddressSet storage set, uint256 index) internal view returns (address) {
971	 return address(uint160(uint256(_at(set._inner, index))));
972	 }
973	 struct UintSet {
974	 Set _inner;
975	 }
976	 function add(UintSet storage set, uint256 value) internal returns (bool) {
977	 return _add(set._inner, bytes32(value));
978	 }
979	 function remove(UintSet storage set, uint256 value) internal returns (bool) {
980	 return _remove(set._inner, bytes32(value));
981	 }
982	 function contains(UintSet storage set, uint256 value) internal view returns (bool) {
983	 return _contains(set._inner, bytes32(value));
984	 }
985	 function length(UintSet storage set) internal view returns (uint256) {
986	 return _length(set._inner);
987	 }
988	 function at(UintSet storage set, uint256 index) internal view returns (uint256) {
989	 return uint256(_at(set._inner, index));
990	 }
991	 }
992	 pragma solidity >=0.6.2 <0.8.0;
993	 library Address {
994	 function isContract(address account) internal view returns (bool) {
995	 uint256 size;
996	 assembly {
997	 size := extcodesize(account) }
998	 return size > 0;
999	 }
1000	 function sendValue(address payable recipient, uint256 amount) internal {
1001	 require(address(this).balance >= amount, "Address: insufficient balance");
1002	 (bool success, ) = recipient.call{
1003	 value: amount }
1004	 ("");
1005	 require(success, "Address: unable to send value, recipient may have reverted");
1006	 }
1007	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
1008	 return functionCall(target, data, "Address: low-level call failed");
1009	 }
1010	 function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
1011	 return functionCallWithValue(target, data, 0, errorMessage);
1012	 }
1013	 function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
1014	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
1015	 }
1016	 function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
1017	 require(address(this).balance >= value, "Address: insufficient balance for call");
1018	 require(isContract(target), "Address: call to non-contract");
1019	 (bool success, bytes memory returndata) = target.call{
1020	 value: value }
1021	 (data);
1022	 return _verifyCallResult(success, returndata, errorMessage);
1023	 }
1024	 function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
1025	 return functionStaticCall(target, data, "Address: low-level static call failed");
1026	 }
1027	 function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
1028	 require(isContract(target), "Address: static call to non-contract");
1029	 (bool success, bytes memory returndata) = target.staticcall(data);
1030	 return _verifyCallResult(success, returndata, errorMessage);
1031	 }
1032	 function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
1033	 return functionDelegateCall(target, data, "Address: low-level delegate call failed");
1034	 }
1035	 function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
1036	 require(isContract(target), "Address: delegate call to non-contract");
1037	 (bool success, bytes memory returndata) = target.delegatecall(data);
1038	 return _verifyCallResult(success, returndata, errorMessage);
1039	 }
1040	 function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
1041	 if (success) {
1042	 return returndata;
1043	 }
1044	 else {
1045	 if (returndata.length > 0) {
1046	 assembly {
1047	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
1048	 }
1049	 else {
1050	 revert(errorMessage);
1051	 }
1052	 }
1053	 }
1054	 }
1055	 pragma solidity >=0.6.0 <0.8.0;
1056	 library SafeERC20 {
1057	 using SafeMath for uint256;
1058	 using Address for address;
1059	 function safeTransfer(IERC20 token, address to, uint256 value) internal {
1060	 _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
1061	 }
1062	 function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
1063	 _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
1064	 }
1065	 function safeApprove(IERC20 token, address spender, uint256 value) internal {
1066	 require((value == 0) || (token.allowance(address(this), spender) == 0), "SafeERC20: approve from non-zero to non-zero allowance" );
1067	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
1068	 }
1069	 function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
1070	 uint256 newAllowance = token.allowance(address(this), spender).add(value);
1071	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
1072	 }
1073	 function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
1074	 uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
1075	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
1076	 }
1077	 function _callOptionalReturn(IERC20 token, bytes memory data) private {
1078	 bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
1079	 if (returndata.length > 0) {
1080	 require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
1081	 }
1082	 }
1083	 }
1084	 pragma solidity >=0.6.0 <0.8.0;
1085	 library SafeMath {
1086	 function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
1087	 uint256 c = a + b;
1088	 if (c < a) return (false, 0);
1089	 return (true, c);
1090	 }
1091	 function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
1092	 if (b > a) return (false, 0);
1093	 return (true, a - b);
1094	 }
1095	 function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
1096	 if (a == 0) return (true, 0);
1097	 uint256 c = a * b;
1098	 if (c / a != b) return (false, 0);
1099	 return (true, c);
1100	 }
1101	 function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
1102	 if (b == 0) return (false, 0);
1103	 return (true, a / b);
1104	 }
1105	 function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
1106	 if (b == 0) return (false, 0);
1107	 return (true, a % b);
1108	 }
1109	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
1110	 uint256 c = a + b;
1111	 require(c >= a, "SafeMath: addition overflow");
1112	 return c;
1113	 }
1114	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
1115	 require(b <= a, "SafeMath: subtraction overflow");
1116	 return a - b;
1117	 }
1118	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
1119	 if (a == 0) return 0;
1120	 uint256 c = a * b;
1121	 require(c / a == b, "SafeMath: multiplication overflow");
1122	 return c;
1123	 }
1124	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
1125	 require(b > 0, "SafeMath: division by zero");
1126	 return a / b;
1127	 }
1128	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
1129	 require(b > 0, "SafeMath: modulo by zero");
1130	 return a % b;
1131	 }
1132	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
1133	 require(b <= a, errorMessage);
1134	 return a - b;
1135	 }
1136	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
1137	 require(b > 0, errorMessage);
1138	 return a / b;
1139	 }
1140	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
1141	 require(b > 0, errorMessage);
1142	 return a % b;
1143	 }
1144	 }
