row number 
1	  pragma experimental ABIEncoderV2;
2	 pragma solidity =0.7.6;
3	 abstract contract ReentrancyGuard {
4	 uint256 private constant _NOT_ENTERED = 1;
5	 uint256 private constant _ENTERED = 2;
6	 AppStorage internal s;
7	 modifier updateSilo() {
8	 LibInternal.updateSilo(msg.sender);
9	 _;
10	 }
11	 modifier updateSiloNonReentrant() {
12	 require(s.reentrantStatus != _ENTERED, "ReentrancyGuard: reentrant call");
13	 s.reentrantStatus = _ENTERED;
14	 LibInternal.updateSilo(msg.sender);
15	 _;
16	 s.reentrantStatus = _NOT_ENTERED;
17	 }
18	 modifier nonReentrant() {
19	 require(s.reentrantStatus != _ENTERED, "ReentrancyGuard: reentrant call");
20	 s.reentrantStatus = _ENTERED;
21	 _;
22	 s.reentrantStatus = _NOT_ENTERED;
23	 }
24	 }
25	 pragma solidity =0.7.6;
26	 contract BeanDibbler is ReentrancyGuard{
27	 using SafeMath for uint256;
28	 using LibSafeMath32 for uint32;
29	 using Decimal for Decimal.D256;
30	 event Sow(address indexed account, uint256 index, uint256 beans, uint256 pods);
31	 function totalPods() public view returns (uint256) {
32	 return s.f.pods.sub(s.f.harvested);
33	 }
34	 function podIndex() public view returns (uint256) {
35	 return s.f.pods;
36	 }
37	 function harvestableIndex() public view returns (uint256) {
38	 return s.f.harvestable;
39	 }
40	 function harvestedIndex() public view returns (uint256) {
41	 return s.f.harvested;
42	 }
43	 function totalHarvestable() public view returns (uint256) {
44	 return s.f.harvestable.sub(s.f.harvested);
45	 }
46	 function totalUnripenedPods() public view returns (uint256) {
47	 return s.f.pods.sub(s.f.harvestable);
48	 }
49	 function plot(address account, uint256 plotId) public view returns (uint256) {
50	 return s.a[account].field.plots[plotId];
51	 }
52	 function totalSoil() public view returns (uint256) {
53	 return s.f.soil;
54	 }
55	 function _sowBeans(uint256 amount) internal returns (uint256 pods) {
56	 pods = LibDibbler.sow(amount, msg.sender);
57	 bean().burn(amount);
58	 LibCheck.beanBalanceCheck();
59	 }
60	 function bean() internal view returns (IBean) {
61	 return IBean(s.c.bean);
62	 }
63	 }
64	 pragma solidity >=0.6.0 <0.8.0;
65	 interface IERC20 {
66	 function totalSupply() external view returns (uint256);
67	 function balanceOf(address account) external view returns (uint256);
68	 function transfer(address recipient, uint256 amount) external returns (bool);
69	 function allowance(address owner, address spender) external view returns (uint256);
70	 function approve(address spender, uint256 amount) external returns (bool);
71	 function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
72	 event Transfer(address indexed from, address indexed to, uint256 value);
73	 event Approval(address indexed owner, address indexed spender, uint256 value);
74	 }
75	 pragma solidity >=0.6.2;
76	 interface IUniswapV2Router01 {
77	 function factory() external pure returns (address);
78	 function WETH() external pure returns (address);
79	 function addLiquidity( address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline ) external returns (uint amountA, uint amountB, uint liquidity);
80	 function addLiquidityETH( address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
81	 function removeLiquidity( address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline ) external returns (uint amountA, uint amountB);
82	 function removeLiquidityETH( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) external returns (uint amountToken, uint amountETH);
83	 function removeLiquidityWithPermit( address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s ) external returns (uint amountA, uint amountB);
84	 function removeLiquidityETHWithPermit( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s ) external returns (uint amountToken, uint amountETH);
85	 function swapExactTokensForTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external returns (uint[] memory amounts);
86	 function swapTokensForExactTokens( uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline ) external returns (uint[] memory amounts);
87	 function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);
88	 function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);
89	 function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);
90	 function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);
91	 function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);
92	 function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);
93	 function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);
94	 function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);
95	 function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);
96	 }
97	 pragma solidity =0.7.6;
98	 contract FieldFacet is BeanDibbler {
99	 using SafeMath for uint256;
100	 using Decimal for Decimal.D256;
101	 function claimAndSowBeans(uint256 amount, LibClaim.Claim calldata claim) external nonReentrant returns (uint256 pods) {
102	 allocateBeans(claim, amount);
103	 pods = _sowBeans(amount);
104	 LibMarket.claimRefund(claim);
105	 }
106	 function claimBuyAndSowBeans( uint256 amount, uint256 buyAmount, LibClaim.Claim calldata claim ) external payable nonReentrant returns (uint256 pods) {
107	 allocateBeans(claim, amount);
108	 uint256 boughtAmount = LibMarket.buyAndDeposit(buyAmount);
109	 pods = _sowBeans(amount.add(boughtAmount));
110	 }
111	 function sowBeans(uint256 amount) external returns (uint256) {
112	 bean().transferFrom(msg.sender, address(this), amount);
113	 return _sowBeans(amount);
114	 }
115	 function buyAndSowBeans(uint256 amount, uint256 buyAmount) external payable nonReentrant returns (uint256 pods) {
116	 uint256 boughtAmount = LibMarket.buyAndDeposit(buyAmount);
117	 if (amount > 0) bean().transferFrom(msg.sender, address(this), amount);
118	 pods = _sowBeans(amount.add(boughtAmount));
119	 }
120	 function allocateBeans(LibClaim.Claim calldata c, uint256 transferBeans) private {
121	 LibClaim.claim(c);
122	 LibMarket.allocateBeans(transferBeans);
123	 }
124	 }
125	 pragma solidity =0.7.6;
126	 library LibClaim {
127	 using SafeMath for uint256;
128	 using LibSafeMath32 for uint32;
129	 event BeanClaim(address indexed account, uint32[] withdrawals, uint256 beans);
130	 event LPClaim(address indexed account, uint32[] withdrawals, uint256 lp);
131	 event EtherClaim(address indexed account, uint256 ethereum);
132	 event Harvest(address indexed account, uint256[] plots, uint256 beans);
133	 event PodListingCancelled(address indexed account, uint256 indexed index);
134	 struct Claim {
135	 uint32[] beanWithdrawals;
136	 uint32[] lpWithdrawals;
137	 uint256[] plots;
138	 bool claimEth;
139	 bool convertLP;
140	 uint256 minBeanAmount;
141	 uint256 minEthAmount;
142	 bool toWallet;
143	 }
144	 function claim(Claim calldata c) public returns (uint256 beansClaimed) {
145	 AppStorage storage s = LibAppStorage.diamondStorage();
146	 if (c.beanWithdrawals.length > 0) beansClaimed = beansClaimed.add(claimBeans(c.beanWithdrawals));
147	 if (c.plots.length > 0) beansClaimed = beansClaimed.add(harvest(c.plots));
148	 if (c.lpWithdrawals.length > 0) {
149	 if (c.convertLP) {
150	 if (!c.toWallet) beansClaimed = beansClaimed.add(removeClaimLPAndWrapBeans(c.lpWithdrawals, c.minBeanAmount, c.minEthAmount));
151	 else removeAndClaimLP(c.lpWithdrawals, c.minBeanAmount, c.minEthAmount);
152	 }
153	 else claimLP(c.lpWithdrawals);
154	 }
155	 if (c.claimEth) claimEth();
156	 if (beansClaimed > 0) {
157	 if (c.toWallet) IBean(s.c.bean).transfer(msg.sender, beansClaimed);
158	 else s.a[msg.sender].wrappedBeans = s.a[msg.sender].wrappedBeans.add(beansClaimed);
159	 }
160	 }
161	 function claimBeans(uint32[] calldata withdrawals) public returns (uint256 beansClaimed) {
162	 AppStorage storage s = LibAppStorage.diamondStorage();
163	 for (uint256 i = 0; i < withdrawals.length; i++) {
164	 require(withdrawals[i] <= s.season.current, "Claim: Withdrawal not recievable.");
165	 beansClaimed = beansClaimed.add(claimBeanWithdrawal(msg.sender, withdrawals[i]));
166	 }
167	 emit BeanClaim(msg.sender, withdrawals, beansClaimed);
168	 }
169	 function claimBeanWithdrawal(address account, uint32 _s) private returns (uint256) {
170	 AppStorage storage s = LibAppStorage.diamondStorage();
171	 uint256 amount = s.a[account].bean.withdrawals[_s];
172	 require(amount > 0, "Claim: Bean withdrawal is empty.");
173	 delete s.a[account].bean.withdrawals[_s];
174	 s.bean.withdrawn = s.bean.withdrawn.sub(amount);
175	 return amount;
176	 }
177	 function claimLP(uint32[] calldata withdrawals) public {
178	 AppStorage storage s = LibAppStorage.diamondStorage();
179	 uint256 lpClaimed = _claimLP(withdrawals);
180	 IUniswapV2Pair(s.c.pair).transfer(msg.sender, lpClaimed);
181	 }
182	 function removeAndClaimLP( uint32[] calldata withdrawals, uint256 minBeanAmount, uint256 minEthAmount ) public returns (uint256 beans) {
183	 uint256 lpClaimd = _claimLP(withdrawals);
184	 (beans,) = LibMarket.removeLiquidity(lpClaimd, minBeanAmount, minEthAmount);
185	 }
186	 function removeClaimLPAndWrapBeans( uint32[] calldata withdrawals, uint256 minBeanAmount, uint256 minEthAmount ) private returns (uint256 beans) {
187	 uint256 lpClaimd = _claimLP(withdrawals);
188	 (beans,) = LibMarket.removeLiquidityWithBeanAllocation(lpClaimd, minBeanAmount, minEthAmount);
189	 }
190	 function _claimLP(uint32[] calldata withdrawals) private returns (uint256) {
191	 AppStorage storage s = LibAppStorage.diamondStorage();
192	 uint256 lpClaimd = 0;
193	 for(uint256 i = 0; i < withdrawals.length; i++) {
194	 require(withdrawals[i] <= s.season.current, "Claim: Withdrawal not recievable.");
195	 lpClaimd = lpClaimd.add(claimLPWithdrawal(msg.sender, withdrawals[i]));
196	 }
197	 emit LPClaim(msg.sender, withdrawals, lpClaimd);
198	 return lpClaimd;
199	 }
200	 function claimLPWithdrawal(address account, uint32 _s) private returns (uint256) {
201	 AppStorage storage s = LibAppStorage.diamondStorage();
202	 uint256 amount = s.a[account].lp.withdrawals[_s];
203	 require(amount > 0, "Claim: LP withdrawal is empty.");
204	 delete s.a[account].lp.withdrawals[_s];
205	 s.lp.withdrawn = s.lp.withdrawn.sub(amount);
206	 return amount;
207	 }
208	 function claimEth() public {
209	 LibInternal.updateSilo(msg.sender);
210	 uint256 eth = claimPlenty(msg.sender);
211	 emit EtherClaim(msg.sender, eth);
212	 }
213	 function claimPlenty(address account) private returns (uint256) {
214	 AppStorage storage s = LibAppStorage.diamondStorage();
215	 if (s.sop.base == 0) return 0;
216	 uint256 eth = s.a[account].sop.base.mul(s.sop.weth).div(s.sop.base);
217	 s.sop.weth = s.sop.weth.sub(eth);
218	 s.sop.base = s.sop.base.sub(s.a[account].sop.base);
219	 s.a[account].sop.base = 0;
220	 IWETH(s.c.weth).withdraw(eth);
221	 (bool success, ) = account.call{
222	 value: eth}
223	 ("");
224	 require(success, "WETH: ETH transfer failed");
225	 return eth;
226	 }
227	 function harvest(uint256[] calldata plots) public returns (uint256 beansHarvested) {
228	 AppStorage storage s = LibAppStorage.diamondStorage();
229	 for (uint256 i = 0; i < plots.length; i++) {
230	 require(plots[i] < s.f.harvestable, "Claim: Plot not harvestable.");
231	 require(s.a[msg.sender].field.plots[plots[i]] > 0, "Claim: Plot not harvestable.");
232	 uint256 harvested = harvestPlot(msg.sender, plots[i]);
233	 beansHarvested = beansHarvested.add(harvested);
234	 }
235	 require(s.f.harvestable.sub(s.f.harvested) >= beansHarvested, "Claim: Not enough Harvestable.");
236	 s.f.harvested = s.f.harvested.add(beansHarvested);
237	 emit Harvest(msg.sender, plots, beansHarvested);
238	 }
239	 function harvestPlot(address account, uint256 plotId) private returns (uint256) {
240	 AppStorage storage s = LibAppStorage.diamondStorage();
241	 uint256 pods = s.a[account].field.plots[plotId];
242	 require(pods > 0, "Claim: Plot is empty.");
243	 uint256 harvestablePods = s.f.harvestable.sub(plotId);
244	 delete s.a[account].field.plots[plotId];
245	 if (s.podListings[plotId] > 0){
246	 cancelPodListing(plotId);
247	 }
248	 if (harvestablePods >= pods) return pods;
249	 s.a[account].field.plots[plotId.add(harvestablePods)] = pods.sub(harvestablePods);
250	 return harvestablePods;
251	 }
252	 function cancelPodListing(uint256 index) internal {
253	 AppStorage storage s = LibAppStorage.diamondStorage();
254	 delete s.podListings[index];
255	 emit PodListingCancelled(msg.sender, index);
256	 }
257	 }
258	 pragma solidity =0.7.6;
259	 abstract contract IBean is IERC20 {
260	 function burn(uint256 amount) public virtual;
261	 function burnFrom(address account, uint256 amount) public virtual;
262	 function mint(address account, uint256 amount) public virtual returns (bool);
263	 }
264	 pragma solidity =0.7.6;
265	 library LibDibbler {
266	 using SafeMath for uint256;
267	 using LibSafeMath32 for uint32;
268	 using Decimal for Decimal.D256;
269	 event Sow(address indexed account, uint256 index, uint256 beans, uint256 pods);
270	 function sow(uint256 amount, address account) internal returns (uint256) {
271	 AppStorage storage s = LibAppStorage.diamondStorage();
272	 s.f.soil = s.f.soil.sub(amount, "Field: Not enough outstanding Soil.");
273	 return sowNoSoil(amount, account);
274	 }
275	 function sowNoSoil(uint256 amount, address account) internal returns (uint256) {
276	 AppStorage storage s = LibAppStorage.diamondStorage();
277	 uint256 pods = beansToPods(amount, s.w.yield);
278	 require(pods > 0, "Field: Must receive non-zero Pods.");
279	 sowPlot(account, amount, pods);
280	 s.f.pods = s.f.pods.add(pods);
281	 saveSowTime();
282	 return pods;
283	 }
284	 function sowPlot(address account, uint256 beans, uint256 pods) private {
285	 AppStorage storage s = LibAppStorage.diamondStorage();
286	 s.a[account].field.plots[s.f.pods] = pods;
287	 emit Sow(account, s.f.pods, beans, pods);
288	 }
289	 function beansToPods(uint256 beanstalks, uint256 y) private pure returns (uint256) {
290	 Decimal.D256 memory rate = Decimal.ratio(y, 100).add(Decimal.one());
291	 return Decimal.from(beanstalks).mul(rate).asUint256();
292	 }
293	 function saveSowTime() private {
294	 AppStorage storage s = LibAppStorage.diamondStorage();
295	 uint256 totalBeanSupply = IBean(s.c.bean).totalSupply();
296	 uint256 soil = s.f.soil;
297	 if (soil >= totalBeanSupply.div(C.getComplexWeatherDenominator())) return;
298	 uint256 sowTime = block.timestamp.sub(s.season.timestamp);
299	 s.w.nextSowTime = uint32(sowTime);
300	 if (!s.w.didSowBelowMin) s.w.didSowBelowMin = true;
301	 if (s.w.didSowFaster || s.w.lastSowTime == type(uint32).max || s.w.lastDSoil == 0 ) return;
302	 uint256 soilPercent = soil.mul(1e18).div(totalBeanSupply);
303	 if (soilPercent <= C.getUpperBoundPodRate().mul(s.w.lastSoilPercent).asUint256()) {
304	 uint256 deltaSoil = s.w.startSoil.sub(soil);
305	 if (Decimal.ratio(deltaSoil, s.w.lastDSoil).greaterThan(C.getLowerBoundDPD())) {
306	 uint256 fasterTime = s.w.lastSowTime > C.getSteadySowTime() ? s.w.lastSowTime.sub(C.getSteadySowTime()) : 0;
307	 if (sowTime < fasterTime) s.w.didSowFaster = true;
308	 else s.w.lastSowTime = type(uint32).max;
309	 }
310	 }
311	 }
312	 }
313	 pragma solidity =0.7.6;
314	 library C {
315	 using Decimal for Decimal.D256;
316	 using SafeMath for uint256;
317	 uint256 private constant PERCENT_BASE = 1e18;
318	 uint256 private constant CHAIN_ID = 1;
319	 uint256 private constant CURRENT_SEASON_PERIOD = 3600;
320	 uint256 private constant HARVESET_PERCENTAGE = 0.5e18;
321	 uint256 private constant POD_RATE_LOWER_BOUND = 0.05e18;
322	 uint256 private constant OPTIMAL_POD_RATE = 0.15e18;
323	 uint256 private constant POD_RATE_UPPER_BOUND = 0.25e18;
324	 uint256 private constant DELTA_POD_DEMAND_LOWER_BOUND = 0.95e18;
325	 uint256 private constant DELTA_POD_DEMAND_UPPER_BOUND = 1.05e18;
326	 uint32 private constant STEADY_SOW_TIME = 60;
327	 uint256 private constant RAIN_TIME = 24;
328	 uint32 private constant GOVERNANCE_PERIOD = 168;
329	 uint32 private constant GOVERNANCE_EMERGENCY_PERIOD = 86400;
330	 uint256 private constant GOVERNANCE_PASS_THRESHOLD = 5e17;
331	 uint256 private constant GOVERNANCE_EMERGENCY_THRESHOLD_NUMERATOR = 2;
332	 uint256 private constant GOVERNANCE_EMERGENCY_THRESHOLD_DEMONINATOR = 3;
333	 uint32 private constant GOVERNANCE_EXPIRATION = 24;
334	 uint256 private constant GOVERNANCE_PROPOSAL_THRESHOLD = 0.001e18;
335	 uint256 private constant BASE_COMMIT_INCENTIVE = 100e6;
336	 uint256 private constant MAX_PROPOSITIONS = 5;
337	 uint256 private constant BASE_ADVANCE_INCENTIVE = 100e6;
338	 uint32 private constant WITHDRAW_TIME = 25;
339	 uint256 private constant SEEDS_PER_BEAN = 2;
340	 uint256 private constant SEEDS_PER_LP_BEAN = 4;
341	 uint256 private constant STALK_PER_BEAN = 10000;
342	 uint256 private constant ROOTS_BASE = 1e12;
343	 uint256 private constant MAX_SOIL_DENOMINATOR = 4;
344	 uint256 private constant COMPLEX_WEATHER_DENOMINATOR = 1000;
345	 function getSeasonPeriod() internal pure returns (uint256) {
346	 return CURRENT_SEASON_PERIOD;
347	 }
348	 function getGovernancePeriod() internal pure returns (uint32) {
349	 return GOVERNANCE_PERIOD;
350	 }
351	 function getGovernanceEmergencyPeriod() internal pure returns (uint32) {
352	 return GOVERNANCE_EMERGENCY_PERIOD;
353	 }
354	 function getGovernanceExpiration() internal pure returns (uint32) {
355	 return GOVERNANCE_EXPIRATION;
356	 }
357	 function getGovernancePassThreshold() internal pure returns (Decimal.D256 memory) {
358	 return Decimal.D256({
359	 value: GOVERNANCE_PASS_THRESHOLD}
360	 );
361	 }
362	 function getGovernanceEmergencyThreshold() internal pure returns (Decimal.D256 memory) {
363	 return Decimal.ratio(GOVERNANCE_EMERGENCY_THRESHOLD_NUMERATOR,GOVERNANCE_EMERGENCY_THRESHOLD_DEMONINATOR);
364	 }
365	 function getGovernanceProposalThreshold() internal pure returns (Decimal.D256 memory) {
366	 return Decimal.D256({
367	 value: GOVERNANCE_PROPOSAL_THRESHOLD}
368	 );
369	 }
370	 function getAdvanceIncentive() internal pure returns (uint256) {
371	 return BASE_ADVANCE_INCENTIVE;
372	 }
373	 function getCommitIncentive() internal pure returns (uint256) {
374	 return BASE_COMMIT_INCENTIVE;
375	 }
376	 function getSiloWithdrawSeasons() internal pure returns (uint32) {
377	 return WITHDRAW_TIME;
378	 }
379	 function getComplexWeatherDenominator() internal pure returns (uint256) {
380	 return COMPLEX_WEATHER_DENOMINATOR;
381	 }
382	 function getMaxSoilDenominator() internal pure returns (uint256) {
383	 return MAX_SOIL_DENOMINATOR;
384	 }
385	 function getHarvestPercentage() internal pure returns (uint256) {
386	 return HARVESET_PERCENTAGE;
387	 }
388	 function getChainId() internal pure returns (uint256) {
389	 return CHAIN_ID;
390	 }
391	 function getOptimalPodRate() internal pure returns (Decimal.D256 memory) {
392	 return Decimal.ratio(OPTIMAL_POD_RATE, PERCENT_BASE);
393	 }
394	 function getUpperBoundPodRate() internal pure returns (Decimal.D256 memory) {
395	 return Decimal.ratio(POD_RATE_UPPER_BOUND, PERCENT_BASE);
396	 }
397	 function getLowerBoundPodRate() internal pure returns (Decimal.D256 memory) {
398	 return Decimal.ratio(POD_RATE_LOWER_BOUND, PERCENT_BASE);
399	 }
400	 function getUpperBoundDPD() internal pure returns (Decimal.D256 memory) {
401	 return Decimal.ratio(DELTA_POD_DEMAND_UPPER_BOUND, PERCENT_BASE);
402	 }
403	 function getLowerBoundDPD() internal pure returns (Decimal.D256 memory) {
404	 return Decimal.ratio(DELTA_POD_DEMAND_LOWER_BOUND, PERCENT_BASE);
405	 }
406	 function getSteadySowTime() internal pure returns (uint32) {
407	 return STEADY_SOW_TIME;
408	 }
409	 function getRainTime() internal pure returns (uint256) {
410	 return RAIN_TIME;
411	 }
412	 function getMaxPropositions() internal pure returns (uint256) {
413	 return MAX_PROPOSITIONS;
414	 }
415	 function getSeedsPerBean() internal pure returns (uint256) {
416	 return SEEDS_PER_BEAN;
417	 }
418	 function getSeedsPerLPBean() internal pure returns (uint256) {
419	 return SEEDS_PER_LP_BEAN;
420	 }
421	 function getStalkPerBean() internal pure returns (uint256) {
422	 return STALK_PER_BEAN;
423	 }
424	 function getStalkPerLPSeed() internal pure returns (uint256) {
425	 return STALK_PER_BEAN/SEEDS_PER_LP_BEAN;
426	 }
427	 function getRootsBase() internal pure returns (uint256) {
428	 return ROOTS_BASE;
429	 }
430	 }
431	 pragma solidity =0.7.6;
432	 library Decimal {
433	 using SafeMath for uint256;
434	 uint256 constant BASE = 10**18;
435	 struct D256 {
436	 uint256 value;
437	 }
438	 function zero() internal pure returns (D256 memory) {
439	 return D256({
440	 value: 0 }
441	 );
442	 }
443	 function one() internal pure returns (D256 memory) {
444	 return D256({
445	 value: BASE }
446	 );
447	 }
448	 function from( uint256 a ) internal pure returns (D256 memory) {
449	 return D256({
450	 value: a.mul(BASE) }
451	 );
452	 }
453	 function ratio( uint256 a, uint256 b ) internal pure returns (D256 memory) {
454	 return D256({
455	 value: getPartial(a, BASE, b) }
456	 );
457	 }
458	 function add( D256 memory self, uint256 b ) internal pure returns (D256 memory) {
459	 return D256({
460	 value: self.value.add(b.mul(BASE)) }
461	 );
462	 }
463	 function sub( D256 memory self, uint256 b ) internal pure returns (D256 memory) {
464	 return D256({
465	 value: self.value.sub(b.mul(BASE)) }
466	 );
467	 }
468	 function sub( D256 memory self, uint256 b, string memory reason ) internal pure returns (D256 memory) {
469	 return D256({
470	 value: self.value.sub(b.mul(BASE), reason) }
471	 );
472	 }
473	 function mul( D256 memory self, uint256 b ) internal pure returns (D256 memory) {
474	 return D256({
475	 value: self.value.mul(b) }
476	 );
477	 }
478	 function div( D256 memory self, uint256 b ) internal pure returns (D256 memory) {
479	 return D256({
480	 value: self.value.div(b) }
481	 );
482	 }
483	 function pow( D256 memory self, uint256 b ) internal pure returns (D256 memory) {
484	 if (b == 0) {
485	 return one();
486	 }
487	 D256 memory temp = D256({
488	 value: self.value }
489	 );
490	 for (uint256 i = 1; i < b; i++) {
491	 temp = mul(temp, self);
492	 }
493	 return temp;
494	 }
495	 function add( D256 memory self, D256 memory b ) internal pure returns (D256 memory) {
496	 return D256({
497	 value: self.value.add(b.value) }
498	 );
499	 }
500	 function sub( D256 memory self, D256 memory b ) internal pure returns (D256 memory) {
501	 return D256({
502	 value: self.value.sub(b.value) }
503	 );
504	 }
505	 function sub( D256 memory self, D256 memory b, string memory reason ) internal pure returns (D256 memory) {
506	 return D256({
507	 value: self.value.sub(b.value, reason) }
508	 );
509	 }
510	 function mul( D256 memory self, D256 memory b ) internal pure returns (D256 memory) {
511	 return D256({
512	 value: getPartial(self.value, b.value, BASE) }
513	 );
514	 }
515	 function div( D256 memory self, D256 memory b ) internal pure returns (D256 memory) {
516	 return D256({
517	 value: getPartial(self.value, BASE, b.value) }
518	 );
519	 }
520	 function equals(D256 memory self, D256 memory b) internal pure returns (bool) {
521	 return self.value == b.value;
522	 }
523	 function greaterThan(D256 memory self, D256 memory b) internal pure returns (bool) {
524	 return compareTo(self, b) == 2;
525	 }
526	 function lessThan(D256 memory self, D256 memory b) internal pure returns (bool) {
527	 return compareTo(self, b) == 0;
528	 }
529	 function greaterThanOrEqualTo(D256 memory self, D256 memory b) internal pure returns (bool) {
530	 return compareTo(self, b) > 0;
531	 }
532	 function lessThanOrEqualTo(D256 memory self, D256 memory b) internal pure returns (bool) {
533	 return compareTo(self, b) < 2;
534	 }
535	 function isZero(D256 memory self) internal pure returns (bool) {
536	 return self.value == 0;
537	 }
538	 function asUint256(D256 memory self) internal pure returns (uint256) {
539	 return self.value.div(BASE);
540	 }
541	 function getPartial( uint256 target, uint256 numerator, uint256 denominator ) private pure returns (uint256) {
542	 return target.mul(numerator).div(denominator);
543	 }
544	 function compareTo( D256 memory a, D256 memory b ) private pure returns (uint256) {
545	 if (a.value == b.value) {
546	 return 1;
547	 }
548	 return a.value > b.value ? 2 : 0;
549	 }
550	 }
551	 pragma solidity =0.7.6;
552	 library LibCheck {
553	 using SafeMath for uint256;
554	 function beanBalanceCheck() internal view {
555	 AppStorage storage s = LibAppStorage.diamondStorage();
556	 require( IBean(s.c.bean).balanceOf(address(this)) >= s.f.harvestable.sub(s.f.harvested).add(s.bean.deposited).add(s.bean.withdrawn), "Check: Bean balance fail." );
557	 }
558	 function lpBalanceCheck() internal view {
559	 AppStorage storage s = LibAppStorage.diamondStorage();
560	 require( IUniswapV2Pair(s.c.pair).balanceOf(address(this)) >= s.lp.deposited.add(s.lp.withdrawn), "Check: LP balance fail." );
561	 }
562	 function balanceCheck() internal view {
563	 AppStorage storage s = LibAppStorage.diamondStorage();
564	 require( IBean(s.c.bean).balanceOf(address(this)) >= s.f.harvestable.sub(s.f.harvested).add(s.bean.deposited).add(s.bean.withdrawn), "Check: Bean balance fail." );
565	 require( IUniswapV2Pair(s.c.pair).balanceOf(address(this)) >= s.lp.deposited.add(s.lp.withdrawn), "Check: LP balance fail." );
566	 }
567	 }
568	 pragma solidity =0.7.6;
569	 library LibAppStorage {
570	 function diamondStorage() internal pure returns (AppStorage storage ds) {
571	 assembly {
572	 ds.slot := 0 }
573	 }
574	 }
575	 pragma solidity >=0.6.0 <0.8.0;
576	 library SafeMath {
577	 function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
578	 uint256 c = a + b;
579	 if (c < a) return (false, 0);
580	 return (true, c);
581	 }
582	 function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
583	 if (b > a) return (false, 0);
584	 return (true, a - b);
585	 }
586	 function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
587	 if (a == 0) return (true, 0);
588	 uint256 c = a * b;
589	 if (c / a != b) return (false, 0);
590	 return (true, c);
591	 }
592	 function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
593	 if (b == 0) return (false, 0);
594	 return (true, a / b);
595	 }
596	 function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
597	 if (b == 0) return (false, 0);
598	 return (true, a % b);
599	 }
600	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
601	 uint256 c = a + b;
602	 require(c >= a, "SafeMath: addition overflow");
603	 return c;
604	 }
605	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
606	 require(b <= a, "SafeMath: subtraction overflow");
607	 return a - b;
608	 }
609	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
610	 if (a == 0) return 0;
611	 uint256 c = a * b;
612	 require(c / a == b, "SafeMath: multiplication overflow");
613	 return c;
614	 }
615	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
616	 require(b > 0, "SafeMath: division by zero");
617	 return a / b;
618	 }
619	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
620	 require(b > 0, "SafeMath: modulo by zero");
621	 return a % b;
622	 }
623	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
624	 require(b <= a, errorMessage);
625	 return a - b;
626	 }
627	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
628	 require(b > 0, errorMessage);
629	 return a / b;
630	 }
631	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
632	 require(b > 0, errorMessage);
633	 return a % b;
634	 }
635	 }
636	 pragma solidity >=0.5.0;
637	 interface IUniswapV2Pair {
638	 event Approval(address indexed owner, address indexed spender, uint value);
639	 event Transfer(address indexed from, address indexed to, uint value);
640	 function name() external pure returns (string memory);
641	 function symbol() external pure returns (string memory);
642	 function decimals() external pure returns (uint8);
643	 function totalSupply() external view returns (uint);
644	 function balanceOf(address owner) external view returns (uint);
645	 function allowance(address owner, address spender) external view returns (uint);
646	 function approve(address spender, uint value) external returns (bool);
647	 function transfer(address to, uint value) external returns (bool);
648	 function transferFrom(address from, address to, uint value) external returns (bool);
649	 function DOMAIN_SEPARATOR() external view returns (bytes32);
650	 function PERMIT_TYPEHASH() external pure returns (bytes32);
651	 function nonces(address owner) external view returns (uint);
652	 function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;
653	 event Mint(address indexed sender, uint amount0, uint amount1);
654	 event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
655	 event Swap( address indexed sender, uint amount0In, uint amount1In, uint amount0Out, uint amount1Out, address indexed to );
656	 event Sync(uint112 reserve0, uint112 reserve1);
657	 function MINIMUM_LIQUIDITY() external pure returns (uint);
658	 function factory() external view returns (address);
659	 function token0() external view returns (address);
660	 function token1() external view returns (address);
661	 function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
662	 function price0CumulativeLast() external view returns (uint);
663	 function price1CumulativeLast() external view returns (uint);
664	 function kLast() external view returns (uint);
665	 function mint(address to) external returns (uint liquidity);
666	 function burn(address to) external returns (uint amount0, uint amount1);
667	 function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
668	 function skim(address to) external;
669	 function sync() external;
670	 function initialize(address, address) external;
671	 }
672	 pragma solidity >=0.6.0 <0.8.0;
673	 library LibSafeMath32 {
674	 function tryAdd(uint32 a, uint32 b) internal pure returns (bool, uint32) {
675	 uint32 c = a + b;
676	 if (c < a) return (false, 0);
677	 return (true, c);
678	 }
679	 function trySub(uint32 a, uint32 b) internal pure returns (bool, uint32) {
680	 if (b > a) return (false, 0);
681	 return (true, a - b);
682	 }
683	 function tryMul(uint32 a, uint32 b) internal pure returns (bool, uint32) {
684	 if (a == 0) return (true, 0);
685	 uint32 c = a * b;
686	 if (c / a != b) return (false, 0);
687	 return (true, c);
688	 }
689	 function tryDiv(uint32 a, uint32 b) internal pure returns (bool, uint32) {
690	 if (b == 0) return (false, 0);
691	 return (true, a / b);
692	 }
693	 function tryMod(uint32 a, uint32 b) internal pure returns (bool, uint32) {
694	 if (b == 0) return (false, 0);
695	 return (true, a % b);
696	 }
697	 function add(uint32 a, uint32 b) internal pure returns (uint32) {
698	 uint32 c = a + b;
699	 require(c >= a, "SafeMath: addition overflow");
700	 return c;
701	 }
702	 function sub(uint32 a, uint32 b) internal pure returns (uint32) {
703	 require(b <= a, "SafeMath: subtraction overflow");
704	 return a - b;
705	 }
706	 function mul(uint32 a, uint32 b) internal pure returns (uint32) {
707	 if (a == 0) return 0;
708	 uint32 c = a * b;
709	 require(c / a == b, "SafeMath: multiplication overflow");
710	 return c;
711	 }
712	 function div(uint32 a, uint32 b) internal pure returns (uint32) {
713	 require(b > 0, "SafeMath: division by zero");
714	 return a / b;
715	 }
716	 function mod(uint32 a, uint32 b) internal pure returns (uint32) {
717	 require(b > 0, "SafeMath: modulo by zero");
718	 return a % b;
719	 }
720	 function sub(uint32 a, uint32 b, string memory errorMessage) internal pure returns (uint32) {
721	 require(b <= a, errorMessage);
722	 return a - b;
723	 }
724	 function div(uint32 a, uint32 b, string memory errorMessage) internal pure returns (uint32) {
725	 require(b > 0, errorMessage);
726	 return a / b;
727	 }
728	 function mod(uint32 a, uint32 b, string memory errorMessage) internal pure returns (uint32) {
729	 require(b > 0, errorMessage);
730	 return a % b;
731	 }
732	 }
733	 pragma solidity =0.7.6;
734	 contract Account {
735	 struct Field {
736	 mapping(uint256 => uint256) plots;
737	 mapping(address => uint256) podAllowances;
738	 }
739	 struct AssetSilo {
740	 mapping(uint32 => uint256) withdrawals;
741	 mapping(uint32 => uint256) deposits;
742	 mapping(uint32 => uint256) depositSeeds;
743	 }
744	 struct Deposit {
745	 uint128 amount;
746	 uint128 bdv;
747	 }
748	 struct Silo {
749	 uint256 stalk;
750	 uint256 seeds;
751	 }
752	 struct SeasonOfPlenty {
753	 uint256 base;
754	 uint256 roots;
755	 uint256 basePerRoot;
756	 }
757	 struct State {
758	 Field field;
759	 AssetSilo bean;
760	 AssetSilo lp;
761	 Silo s;
762	 uint32 votedUntil;
763	 uint32 lastUpdate;
764	 uint32 lastSop;
765	 uint32 lastRain;
766	 uint32 lastSIs;
767	 uint32 proposedUntil;
768	 SeasonOfPlenty sop;
769	 uint256 roots;
770	 uint256 wrappedBeans;
771	 mapping(address => mapping(uint32 => Deposit)) deposits;
772	 mapping(address => mapping(uint32 => uint256)) withdrawals;
773	 }
774	 }
775	 contract Storage {
776	 struct Contracts {
777	 address bean;
778	 address pair;
779	 address pegPair;
780	 address weth;
781	 }
782	 struct Field {
783	 uint256 soil;
784	 uint256 pods;
785	 uint256 harvested;
786	 uint256 harvestable;
787	 }
788	 struct Bip {
789	 address proposer;
790	 uint32 start;
791	 uint32 period;
792	 bool executed;
793	 int pauseOrUnpause;
794	 uint128 timestamp;
795	 uint256 roots;
796	 uint256 endTotalRoots;
797	 }
798	 struct DiamondCut {
799	 IDiamondCut.FacetCut[] diamondCut;
800	 address initAddress;
801	 bytes initData;
802	 }
803	 struct Governance {
804	 uint32[] activeBips;
805	 uint32 bipIndex;
806	 mapping(uint32 => DiamondCut) diamondCuts;
807	 mapping(uint32 => mapping(address => bool)) voted;
808	 mapping(uint32 => Bip) bips;
809	 }
810	 struct AssetSilo {
811	 uint256 deposited;
812	 uint256 withdrawn;
813	 }
814	 struct IncreaseSilo {
815	 uint256 beans;
816	 uint256 stalk;
817	 }
818	 struct V1IncreaseSilo {
819	 uint256 beans;
820	 uint256 stalk;
821	 uint256 roots;
822	 }
823	 struct SeasonOfPlenty {
824	 uint256 weth;
825	 uint256 base;
826	 uint32 last;
827	 }
828	 struct Silo {
829	 uint256 stalk;
830	 uint256 seeds;
831	 uint256 roots;
832	 }
833	 struct Oracle {
834	 bool initialized;
835	 uint256 cumulative;
836	 uint256 pegCumulative;
837	 uint32 timestamp;
838	 uint32 pegTimestamp;
839	 }
840	 struct Rain {
841	 uint32 start;
842	 bool raining;
843	 uint256 pods;
844	 uint256 roots;
845	 }
846	 struct Season {
847	 uint32 current;
848	 uint32 sis;
849	 uint8 withdrawSeasons;
850	 uint256 start;
851	 uint256 period;
852	 uint256 timestamp;
853	 }
854	 struct Weather {
855	 uint256 startSoil;
856	 uint256 lastDSoil;
857	 uint96 lastSoilPercent;
858	 uint32 lastSowTime;
859	 uint32 nextSowTime;
860	 uint32 yield;
861	 bool didSowBelowMin;
862	 bool didSowFaster;
863	 }
864	 struct Fundraiser {
865	 address payee;
866	 address token;
867	 uint256 total;
868	 uint256 remaining;
869	 uint256 start;
870	 }
871	 struct SiloSettings {
872	 bytes4 selector;
873	 uint32 seeds;
874	 uint32 stalk;
875	 }
876	 }
877	 struct AppStorage {
878	 uint8 index;
879	 int8[32] cases;
880	 bool paused;
881	 uint128 pausedAt;
882	 Storage.Season season;
883	 Storage.Contracts c;
884	 Storage.Field f;
885	 Storage.Governance g;
886	 Storage.Oracle o;
887	 Storage.Rain r;
888	 Storage.Silo s;
889	 uint256 reentrantStatus;
890	 Storage.Weather w;
891	 Storage.AssetSilo bean;
892	 Storage.AssetSilo lp;
893	 Storage.IncreaseSilo si;
894	 Storage.SeasonOfPlenty sop;
895	 Storage.V1IncreaseSilo v1SI;
896	 uint256 unclaimedRoots;
897	 uint256 v2SIBeans;
898	 mapping (uint32 => uint256) sops;
899	 mapping (address => Account.State) a;
900	 uint32 bip0Start;
901	 uint32 hotFix3Start;
902	 mapping (uint32 => Storage.Fundraiser) fundraisers;
903	 uint32 fundraiserIndex;
904	 mapping (address => bool) isBudget;
905	 mapping(uint256 => bytes32) podListings;
906	 mapping(bytes32 => uint256) podOrders;
907	 mapping(address => Storage.AssetSilo) siloBalances;
908	 mapping(address => Storage.SiloSettings) ss;
909	 uint256 refundStatus;
910	 uint256 beanRefundAmount;
911	 uint256 ethRefundAmount;
912	 }
913	 pragma solidity =0.7.6;
914	 interface IDiamondCut {
915	 enum FacetCutAction {
916	 Add, Replace, Remove}
917	 struct FacetCut {
918	 address facetAddress;
919	 FacetCutAction action;
920	 bytes4[] functionSelectors;
921	 }
922	 function diamondCut( FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata ) external;
923	 event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);
924	 }
925	 pragma solidity =0.7.6;
926	 interface ISiloUpdate {
927	 function updateSilo(address account) external payable;
928	 }
929	 library LibInternal {
930	 bytes32 constant DIAMOND_STORAGE_POSITION = keccak256("diamond.standard.diamond.storage");
931	 struct FacetAddressAndPosition {
932	 address facetAddress;
933	 uint16 functionSelectorPosition;
934	 }
935	 struct FacetFunctionSelectors {
936	 bytes4[] functionSelectors;
937	 uint16 facetAddressPosition;
938	 }
939	 struct DiamondStorage {
940	 mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;
941	 mapping(address => FacetFunctionSelectors) facetFunctionSelectors;
942	 address[] facetAddresses;
943	 mapping(bytes4 => bool) supportedInterfaces;
944	 address contractOwner;
945	 }
946	 function diamondStorage() internal pure returns (DiamondStorage storage ds) {
947	 bytes32 position = DIAMOND_STORAGE_POSITION;
948	 assembly {
949	 ds.slot := position }
950	 }
951	 function updateSilo(address account) internal {
952	 DiamondStorage storage ds = diamondStorage();
953	 address facet = ds.selectorToFacetAndPosition[ISiloUpdate.updateSilo.selector].facetAddress;
954	 bytes memory myFunctionCall = abi.encodeWithSelector(ISiloUpdate.updateSilo.selector, account);
955	 (bool success,) = address(facet).delegatecall(myFunctionCall);
956	 require(success, "Silo: updateSilo failed.");
957	 }
958	 }
959	 pragma solidity =0.7.6;
960	 library LibMarket {
961	 event BeanAllocation(address indexed account, uint256 beans);
962	 struct DiamondStorage {
963	 address bean;
964	 address weth;
965	 address router;
966	 }
967	 struct AddLiquidity {
968	 uint256 beanAmount;
969	 uint256 minBeanAmount;
970	 uint256 minEthAmount;
971	 }
972	 using SafeMath for uint256;
973	 bytes32 private constant MARKET_STORAGE_POSITION = keccak256("diamond.standard.market.storage");
974	 function diamondStorage() internal pure returns (DiamondStorage storage ds) {
975	 bytes32 position = MARKET_STORAGE_POSITION;
976	 assembly {
977	 ds.slot := position }
978	 }
979	 function initMarket(address bean, address weth, address router) internal {
980	 DiamondStorage storage ds = diamondStorage();
981	 ds.bean = bean;
982	 ds.weth = weth;
983	 ds.router = router;
984	 }
985	 function buy(uint256 buyBeanAmount) internal returns (uint256 amount) {
986	 (, amount) = _buy(buyBeanAmount, msg.value, msg.sender);
987	 }
988	 function buyAndDeposit(uint256 buyBeanAmount) internal returns (uint256 amount) {
989	 (, amount) = _buy(buyBeanAmount, msg.value, address(this));
990	 }
991	 function buyExactTokensToWallet(uint256 buyBeanAmount, address to, bool toWallet) internal returns (uint256 amount) {
992	 AppStorage storage s = LibAppStorage.diamondStorage();
993	 if (toWallet) amount = buyExactTokens(buyBeanAmount, to);
994	 else {
995	 amount = buyExactTokens(buyBeanAmount, address(this));
996	 s.a[to].wrappedBeans = s.a[to].wrappedBeans.add(amount);
997	 }
998	 }
999	 function buyExactTokens(uint256 buyBeanAmount, address to) internal returns (uint256 amount) {
1000	 (uint256 ethAmount, uint256 beanAmount) = _buyExactTokens(buyBeanAmount, msg.value, to);
1001	 allocateEthRefund(msg.value, ethAmount, false);
1002	 return beanAmount;
1003	 }
1004	 function sellToWETH(uint256 sellBeanAmount, uint256 minBuyEthAmount) internal returns (uint256 amount) {
1005	 (,uint256 outAmount) = _sell(sellBeanAmount, minBuyEthAmount, address(this));
1006	 return outAmount;
1007	 }
1008	 function removeLiquidity(uint256 liqudity, uint256 minBeanAmount,uint256 minEthAmount) internal returns (uint256 beanAmount, uint256 ethAmount) {
1009	 DiamondStorage storage ds = diamondStorage();
1010	 return IUniswapV2Router02(ds.router).removeLiquidityETH( ds.bean, liqudity, minBeanAmount, minEthAmount, msg.sender, block.timestamp );
1011	 }
1012	 function removeLiquidityWithBeanAllocation(uint256 liqudity, uint256 minBeanAmount,uint256 minEthAmount) internal returns (uint256 beanAmount, uint256 ethAmount) {
1013	 DiamondStorage storage ds = diamondStorage();
1014	 (beanAmount, ethAmount) = IUniswapV2Router02(ds.router).removeLiquidity( ds.bean, ds.weth, liqudity, minBeanAmount, minEthAmount, address(this), block.timestamp );
1015	 allocateEthRefund(ethAmount, 0, true);
1016	 }
1017	 function addAndDepositLiquidity(AddLiquidity calldata al) internal returns (uint256) {
1018	 allocateBeans(al.beanAmount);
1019	 (, uint256 liquidity) = addLiquidity(al);
1020	 return liquidity;
1021	 }
1022	 function addLiquidity(AddLiquidity calldata al) internal returns (uint256, uint256) {
1023	 (uint256 beansDeposited, uint256 ethDeposited, uint256 liquidity) = _addLiquidity( msg.value, al.beanAmount, al.minEthAmount, al.minBeanAmount );
1024	 allocateEthRefund(msg.value, ethDeposited, false);
1025	 allocateBeanRefund(al.beanAmount, beansDeposited);
1026	 return (beansDeposited, liquidity);
1027	 }
1028	 function swapAndAddLiquidity( uint256 buyBeanAmount, uint256 buyEthAmount, LibMarket.AddLiquidity calldata al ) internal returns (uint256) {
1029	 uint256 boughtLP;
1030	 if (buyBeanAmount > 0) boughtLP = LibMarket.buyBeansAndAddLiquidity(buyBeanAmount, al);
1031	 else if (buyEthAmount > 0) boughtLP = LibMarket.buyEthAndAddLiquidity(buyEthAmount, al);
1032	 else boughtLP = LibMarket.addAndDepositLiquidity(al);
1033	 return boughtLP;
1034	 }
1035	 function buyBeansAndAddLiquidity(uint256 buyBeanAmount, AddLiquidity calldata al) internal returns (uint256 liquidity) {
1036	 DiamondStorage storage ds = diamondStorage();
1037	 IWETH(ds.weth).deposit{
1038	 value: msg.value}
1039	 ();
1040	 address[] memory path = new address[](2);
1041	 path[0] = ds.weth;
1042	 path[1] = ds.bean;
1043	 uint256[] memory amounts = IUniswapV2Router02(ds.router).getAmountsIn(buyBeanAmount, path);
1044	 (uint256 ethSold, uint256 beans) = _buyWithWETH(buyBeanAmount, amounts[0], address(this));
1045	 if (al.beanAmount > buyBeanAmount) {
1046	 uint256 newBeanAmount = al.beanAmount - buyBeanAmount;
1047	 allocateBeans(newBeanAmount);
1048	 beans = beans.add(newBeanAmount);
1049	 }
1050	 uint256 ethAdded;
1051	 (beans, ethAdded, liquidity) = _addLiquidityWETH( msg.value.sub(ethSold), beans, al.minEthAmount, al.minBeanAmount );
1052	 allocateBeanRefund(al.beanAmount, beans);
1053	 allocateEthRefund(msg.value, ethAdded.add(ethSold), true);
1054	 return liquidity;
1055	 }
1056	 function buyEthAndAddLiquidity(uint256 buyWethAmount, AddLiquidity calldata al) internal returns (uint256) {
1057	 DiamondStorage storage ds = diamondStorage();
1058	 uint256 sellBeans = _amountIn(buyWethAmount);
1059	 allocateBeans(al.beanAmount.add(sellBeans));
1060	 (uint256 beansSold, uint256 wethBought) = _sell(sellBeans, buyWethAmount, address(this));
1061	 if (msg.value > 0) IWETH(ds.weth).deposit{
1062	 value: msg.value}
1063	 ();
1064	 (uint256 beans, uint256 ethAdded, uint256 liquidity) = _addLiquidityWETH( msg.value.add(wethBought), al.beanAmount, al.minEthAmount, al.minBeanAmount );
1065	 allocateBeanRefund(al.beanAmount.add(sellBeans), beans.add(beansSold));
1066	 allocateEthRefund(msg.value.add(wethBought), ethAdded, true);
1067	 return liquidity;
1068	 }
1069	 function _sell(uint256 sellBeanAmount, uint256 minBuyEthAmount, address to) internal returns (uint256 inAmount, uint256 outAmount) {
1070	 DiamondStorage storage ds = diamondStorage();
1071	 address[] memory path = new address[](2);
1072	 path[0] = ds.bean;
1073	 path[1] = ds.weth;
1074	 uint[] memory amounts = IUniswapV2Router02(ds.router).swapExactTokensForTokens( sellBeanAmount, minBuyEthAmount, path, to, block.timestamp );
1075	 return (amounts[0], amounts[1]);
1076	 }
1077	 function _buy(uint256 beanAmount, uint256 ethAmount, address to) private returns (uint256 inAmount, uint256 outAmount) {
1078	 DiamondStorage storage ds = diamondStorage();
1079	 address[] memory path = new address[](2);
1080	 path[0] = ds.weth;
1081	 path[1] = ds.bean;
1082	 uint[] memory amounts = IUniswapV2Router02(ds.router).swapExactETHForTokens{
1083	 value: ethAmount}
1084	 ( beanAmount, path, to, block.timestamp );
1085	 return (amounts[0], amounts[1]);
1086	 }
1087	 function _buyExactTokens(uint256 beanAmount, uint256 ethAmount, address to) private returns (uint256 inAmount, uint256 outAmount) {
1088	 DiamondStorage storage ds = diamondStorage();
1089	 address[] memory path = new address[](2);
1090	 path[0] = ds.weth;
1091	 path[1] = ds.bean;
1092	 uint[] memory amounts = IUniswapV2Router02(ds.router).swapETHForExactTokens{
1093	 value: ethAmount}
1094	 ( beanAmount, path, to, block.timestamp );
1095	 return (amounts[0], amounts[1]);
1096	 }
1097	 function _buyWithWETH(uint256 beanAmount, uint256 ethAmount, address to) internal returns (uint256 inAmount, uint256 outAmount) {
1098	 DiamondStorage storage ds = diamondStorage();
1099	 address[] memory path = new address[](2);
1100	 path[0] = ds.weth;
1101	 path[1] = ds.bean;
1102	 uint[] memory amounts = IUniswapV2Router02(ds.router).swapExactTokensForTokens( ethAmount, beanAmount, path, to, block.timestamp );
1103	 return (amounts[0], amounts[1]);
1104	 }
1105	 function _addLiquidity(uint256 ethAmount, uint256 beanAmount, uint256 minEthAmount, uint256 minBeanAmount) private returns (uint256, uint256, uint256) {
1106	 DiamondStorage storage ds = diamondStorage();
1107	 return IUniswapV2Router02(ds.router).addLiquidityETH{
1108	 value: ethAmount}
1109	 ( ds.bean, beanAmount, minBeanAmount, minEthAmount, address(this), block.timestamp);
1110	 }
1111	 function _addLiquidityWETH(uint256 wethAmount, uint256 beanAmount, uint256 minWethAmount, uint256 minBeanAmount) internal returns (uint256, uint256, uint256) {
1112	 DiamondStorage storage ds = diamondStorage();
1113	 return IUniswapV2Router02(ds.router).addLiquidity( ds.bean, ds.weth, beanAmount, wethAmount, minBeanAmount, minWethAmount, address(this), block.timestamp);
1114	 }
1115	 function _amountIn(uint256 buyWethAmount) internal view returns (uint256) {
1116	 DiamondStorage storage ds = diamondStorage();
1117	 address[] memory path = new address[](2);
1118	 path[0] = ds.bean;
1119	 path[1] = ds.weth;
1120	 uint256[] memory amounts = IUniswapV2Router02(ds.router).getAmountsIn(buyWethAmount, path);
1121	 return amounts[0];
1122	 }
1123	 function allocateBeansToWallet(uint256 amount, address to, bool toWallet) internal {
1124	 AppStorage storage s = LibAppStorage.diamondStorage();
1125	 if (toWallet) LibMarket.allocateBeansTo(amount, to);
1126	 else {
1127	 LibMarket.allocateBeansTo(amount, address(this));
1128	 s.a[to].wrappedBeans = s.a[to].wrappedBeans.add(amount);
1129	 }
1130	 }
1131	 function transferBeans(address to, uint256 amount, bool toWallet) internal {
1132	 AppStorage storage s = LibAppStorage.diamondStorage();
1133	 if (toWallet) IBean(s.c.bean).transferFrom(msg.sender, to, amount);
1134	 else {
1135	 IBean(s.c.bean).transferFrom(msg.sender, address(this), amount);
1136	 s.a[to].wrappedBeans = s.a[to].wrappedBeans.add(amount);
1137	 }
1138	 }
1139	 function allocateBeans(uint256 amount) internal {
1140	 allocateBeansTo(amount, address(this));
1141	 }
1142	 function allocateBeansTo(uint256 amount, address to) internal {
1143	 AppStorage storage s = LibAppStorage.diamondStorage();
1144	 uint wrappedBeans = s.a[msg.sender].wrappedBeans;
1145	 uint remainingBeans = amount;
1146	 if (wrappedBeans > 0) {
1147	 if (remainingBeans > wrappedBeans) {
1148	 s.a[msg.sender].wrappedBeans = 0;
1149	 remainingBeans = remainingBeans - wrappedBeans;
1150	 }
1151	 else {
1152	 s.a[msg.sender].wrappedBeans = wrappedBeans - remainingBeans;
1153	 remainingBeans = 0;
1154	 }
1155	 uint fromWrappedBeans = amount - remainingBeans;
1156	 emit BeanAllocation(msg.sender, fromWrappedBeans);
1157	 if (to != address(this)) IBean(s.c.bean).transfer(to, fromWrappedBeans);
1158	 }
1159	 if (remainingBeans > 0) IBean(s.c.bean).transferFrom(msg.sender, to, remainingBeans);
1160	 }
1161	 function allocateBeanRefund(uint256 inputAmount, uint256 amount) internal {
1162	 if (inputAmount > amount) {
1163	 AppStorage storage s = LibAppStorage.diamondStorage();
1164	 if (s.refundStatus % 2 == 1) {
1165	 s.refundStatus += 1;
1166	 s.beanRefundAmount = inputAmount - amount;
1167	 }
1168	 else s.beanRefundAmount = s.beanRefundAmount.add(inputAmount - amount);
1169	 }
1170	 }
1171	 function allocateEthRefund(uint256 inputAmount, uint256 amount, bool weth) internal {
1172	 if (inputAmount > amount) {
1173	 AppStorage storage s = LibAppStorage.diamondStorage();
1174	 if (weth) IWETH(s.c.weth).withdraw(inputAmount - amount);
1175	 if (s.refundStatus < 3) {
1176	 s.refundStatus += 2;
1177	 s.ethRefundAmount = inputAmount - amount;
1178	 }
1179	 else s.ethRefundAmount = s.ethRefundAmount.add(inputAmount - amount);
1180	 }
1181	 }
1182	 function claimRefund(LibClaim.Claim calldata c) internal {
1183	 if (c.convertLP && !c.toWallet && c.lpWithdrawals.length > 0) refund();
1184	 }
1185	 function refund() internal {
1186	 AppStorage storage s = LibAppStorage.diamondStorage();
1187	 uint256 rs = s.refundStatus;
1188	 if(rs > 1) {
1189	 if (rs > 2) {
1190	 (bool success,) = msg.sender.call{
1191	 value: s.ethRefundAmount }
1192	 ("");
1193	 require(success, "Market: Refund failed.");
1194	 rs -= 2;
1195	 s.ethRefundAmount = 1;
1196	 }
1197	 if (rs == 2) {
1198	 IBean(s.c.bean).transfer(msg.sender, s.beanRefundAmount);
1199	 s.beanRefundAmount = 1;
1200	 }
1201	 s.refundStatus = 1;
1202	 }
1203	 }
1204	 }
1205	 pragma solidity =0.7.6;
1206	 interface IWETH is IERC20 {
1207	 function deposit() external payable;
1208	 function withdraw(uint) external;
1209	 }
1210	 pragma solidity >=0.6.2;
1211	 interface IUniswapV2Router02 is IUniswapV2Router01 {
1212	 function removeLiquidityETHSupportingFeeOnTransferTokens( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) external returns (uint amountETH);
1213	 function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s ) external returns (uint amountETH);
1214	 function swapExactTokensForTokensSupportingFeeOnTransferTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external;
1215	 function swapExactETHForTokensSupportingFeeOnTransferTokens( uint amountOutMin, address[] calldata path, address to, uint deadline ) external payable;
1216	 function swapExactTokensForETHSupportingFeeOnTransferTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external;
1217	 }
