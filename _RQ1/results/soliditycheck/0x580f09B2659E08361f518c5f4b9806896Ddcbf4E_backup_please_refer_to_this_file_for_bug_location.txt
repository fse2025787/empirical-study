row number 
1	  pragma experimental ABIEncoderV2;
2	 pragma solidity >=0.4.24 <0.8.0;
3	 abstract contract Initializable {
4	 bool private _initialized;
5	 bool private _initializing;
6	 modifier initializer() {
7	 require(_initializing || _isConstructor() || !_initialized, "Initializable: contract is already initialized");
8	 bool isTopLevelCall = !_initializing;
9	 if (isTopLevelCall) {
10	 _initializing = true;
11	 _initialized = true;
12	 }
13	 _;
14	 if (isTopLevelCall) {
15	 _initializing = false;
16	 }
17	 }
18	 function _isConstructor() private view returns (bool) {
19	 return !AddressUpgradeable.isContract(address(this));
20	 }
21	 }
22	 pragma solidity >=0.6.0 <0.8.0;
23	 abstract contract ContextUpgradeable is Initializable {
24	 function __Context_init() internal initializer {
25	 __Context_init_unchained();
26	 }
27	 function __Context_init_unchained() internal initializer {
28	 }
29	 function _msgSender() internal view virtual returns (address payable) {
30	 return msg.sender;
31	 }
32	 function _msgData() internal view virtual returns (bytes memory) {
33	 this;
34	 return msg.data;
35	 }
36	 uint256[50] private __gap;
37	 }
38	 pragma solidity >=0.6.0 <0.8.0;
39	 interface IERC20Upgradeable {
40	 function totalSupply() external view returns (uint256);
41	 function balanceOf(address account) external view returns (uint256);
42	 function transfer(address recipient, uint256 amount) external returns (bool);
43	 function allowance(address owner, address spender) external view returns (uint256);
44	 function approve(address spender, uint256 amount) external returns (bool);
45	 function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
46	 event Transfer(address indexed from, address indexed to, uint256 value);
47	 event Approval(address indexed owner, address indexed spender, uint256 value);
48	 }
49	 pragma solidity 0.6.12;
50	 contract SetGetAssembly {
51	 constructor() public {
52	 }
53	 function setAddress(bytes32 slot, address _address) internal {
54	 assembly {
55	 sstore(slot, _address) }
56	 }
57	 function setUint256(bytes32 slot, uint256 _value) internal {
58	 assembly {
59	 sstore(slot, _value) }
60	 }
61	 function setUint8(bytes32 slot, uint8 _value) internal {
62	 assembly {
63	 sstore(slot, _value) }
64	 }
65	 function setBool(bytes32 slot, bool _value) internal {
66	 setUint256(slot, _value ? 1 : 0);
67	 }
68	 function getBool(bytes32 slot) internal view returns (bool) {
69	 return (getUint256(slot) == 1);
70	 }
71	 function getAddress(bytes32 slot) internal view returns (address str) {
72	 assembly {
73	 str := sload(slot) }
74	 }
75	 function getUint256(bytes32 slot) internal view returns (uint256 str) {
76	 assembly {
77	 str := sload(slot) }
78	 }
79	 function getUint8(bytes32 slot) internal view returns (uint8 str) {
80	 assembly {
81	 str := sload(slot) }
82	 }
83	 }
84	 pragma solidity >=0.6.0 <0.8.0;
85	 contract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable {
86	 using SafeMathUpgradeable for uint256;
87	 mapping (address => uint256) private _balances;
88	 mapping (address => mapping (address => uint256)) private _allowances;
89	 uint256 private _totalSupply;
90	 string private _name;
91	 string private _symbol;
92	 uint8 private _decimals;
93	 function __ERC20_init(string memory name_, string memory symbol_) internal initializer {
94	 __Context_init_unchained();
95	 __ERC20_init_unchained(name_, symbol_);
96	 }
97	 function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {
98	 _name = name_;
99	 _symbol = symbol_;
100	 _decimals = 18;
101	 }
102	 function name() public view virtual returns (string memory) {
103	 return _name;
104	 }
105	 function symbol() public view virtual returns (string memory) {
106	 return _symbol;
107	 }
108	 function decimals() public view virtual returns (uint8) {
109	 return _decimals;
110	 }
111	 function totalSupply() public view virtual override returns (uint256) {
112	 return _totalSupply;
113	 }
114	 function balanceOf(address account) public view virtual override returns (uint256) {
115	 return _balances[account];
116	 }
117	 function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
118	 _transfer(_msgSender(), recipient, amount);
119	 return true;
120	 }
121	 function allowance(address owner, address spender) public view virtual override returns (uint256) {
122	 return _allowances[owner][spender];
123	 }
124	 function approve(address spender, uint256 amount) public virtual override returns (bool) {
125	 _approve(_msgSender(), spender, amount);
126	 return true;
127	 }
128	 function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
129	 _transfer(sender, recipient, amount);
130	 _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
131	 return true;
132	 }
133	 function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
134	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
135	 return true;
136	 }
137	 function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
138	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
139	 return true;
140	 }
141	 function _transfer(address sender, address recipient, uint256 amount) internal virtual {
142	 require(sender != address(0), "ERC20: transfer from the zero address");
143	 require(recipient != address(0), "ERC20: transfer to the zero address");
144	 _beforeTokenTransfer(sender, recipient, amount);
145	 _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
146	 _balances[recipient] = _balances[recipient].add(amount);
147	 emit Transfer(sender, recipient, amount);
148	 }
149	 function _mint(address account, uint256 amount) internal virtual {
150	 require(account != address(0), "ERC20: mint to the zero address");
151	 _beforeTokenTransfer(address(0), account, amount);
152	 _totalSupply = _totalSupply.add(amount);
153	 _balances[account] = _balances[account].add(amount);
154	 emit Transfer(address(0), account, amount);
155	 }
156	 function _burn(address account, uint256 amount) internal virtual {
157	 require(account != address(0), "ERC20: burn from the zero address");
158	 _beforeTokenTransfer(account, address(0), amount);
159	 _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
160	 _totalSupply = _totalSupply.sub(amount);
161	 emit Transfer(account, address(0), amount);
162	 }
163	 function _approve(address owner, address spender, uint256 amount) internal virtual {
164	 require(owner != address(0), "ERC20: approve from the zero address");
165	 require(spender != address(0), "ERC20: approve to the zero address");
166	 _allowances[owner][spender] = amount;
167	 emit Approval(owner, spender, amount);
168	 }
169	 function _setupDecimals(uint8 decimals_) internal virtual {
170	 _decimals = decimals_;
171	 }
172	 function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {
173	 }
174	 uint256[44] private __gap;
175	 }
176	 pragma solidity >=0.6.0 <0.8.0;
177	 abstract contract ReentrancyGuardUpgradeable is Initializable {
178	 uint256 private constant _NOT_ENTERED = 1;
179	 uint256 private constant _ENTERED = 2;
180	 uint256 private _status;
181	 function __ReentrancyGuard_init() internal initializer {
182	 __ReentrancyGuard_init_unchained();
183	 }
184	 function __ReentrancyGuard_init_unchained() internal initializer {
185	 _status = _NOT_ENTERED;
186	 }
187	 modifier nonReentrant() {
188	 require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
189	 _status = _ENTERED;
190	 _;
191	 _status = _NOT_ENTERED;
192	 }
193	 uint256[49] private __gap;
194	 }
195	 pragma solidity 0.6.12;
196	 interface IFund {
197	 function underlying() external view returns (address);
198	 function fundManager() external view returns (address);
199	 function relayer() external view returns (address);
200	 function deposit(uint256 amountWei) external;
201	 function depositFor(uint256 amountWei, address holder) external;
202	 function withdraw(uint256 numberOfShares) external;
203	 function getPricePerShare() external view returns (uint256);
204	 function totalValueLocked() external view returns (uint256);
205	 function underlyingBalanceWithInvestmentForHolder(address holder) external view returns (uint256);
206	 }
207	 pragma solidity 0.6.12;
208	 contract Governable is Initializable, SetGetAssembly {
209	 event GovernanceUpdated(address newGovernance, address oldGovernance);
210	 bytes32 internal constant _GOVERNANCE_SLOT = 0x597f9c7c685b907e823520bd45aeb3d58b505f86b2e41cd5b4cd5b6c72782950;
211	 bytes32 internal constant _PENDING_GOVERNANCE_SLOT = 0xcd77091f18f9504fccf6140ab99e20533c811d470bb9a5a983d0edc0720fbf8c;
212	 modifier onlyGovernance() {
213	 require(_governance() == msg.sender, "Not governance");
214	 _;
215	 }
216	 constructor() public {
217	 assert( _GOVERNANCE_SLOT == bytes32( uint256( keccak256("eip1967.mesh.finance.governable.governance") ) - 1 ) );
218	 assert( _PENDING_GOVERNANCE_SLOT == bytes32( uint256( keccak256( "eip1967.mesh.finance.governable.pendingGovernance" ) ) - 1 ) );
219	 }
220	 function initializeGovernance(address _governance) public initializer {
221	 _setGovernance(_governance);
222	 }
223	 function _setGovernance(address _governance) private {
224	 setAddress(_GOVERNANCE_SLOT, _governance);
225	 }
226	 function _setPendingGovernance(address _pendingGovernance) private {
227	 setAddress(_PENDING_GOVERNANCE_SLOT, _pendingGovernance);
228	 }
229	 function updateGovernance(address _newGovernance) public onlyGovernance {
230	 require( _newGovernance != address(0), "new governance shouldn't be empty" );
231	 _setPendingGovernance(_newGovernance);
232	 }
233	 function acceptGovernance() public {
234	 require(_pendingGovernance() == msg.sender, "Not pending governance");
235	 address oldGovernance = _governance();
236	 _setGovernance(msg.sender);
237	 emit GovernanceUpdated(msg.sender, oldGovernance);
238	 }
239	 function _governance() internal view returns (address str) {
240	 return getAddress(_GOVERNANCE_SLOT);
241	 }
242	 function _pendingGovernance() internal view returns (address str) {
243	 return getAddress(_PENDING_GOVERNANCE_SLOT);
244	 }
245	 function governance() public view returns (address) {
246	 return _governance();
247	 }
248	 }
249	 pragma solidity 0.6.12;
250	 contract FundStorage is Initializable, SetGetAssembly {
251	 bytes32 internal constant _UNDERLYING_SLOT = 0xe0dc1d429ff8628e5936b3d6a6546947e1cc9ea7415a59d46ce95b3cfa4442b9;
252	 bytes32 internal constant _UNDERLYING_UNIT_SLOT = 0x4840b03aa097a422092d99dc6875c2b69e8f48c9af2563a0447f3b4e4928d962;
253	 bytes32 internal constant _DECIMALS_SLOT = 0x15b9fa1072bc4b2cdb762a49a2c7917b8b3af02283e37ffd41d0fccd4eef0d48;
254	 bytes32 internal constant _FUND_MANAGER_SLOT = 0x670552e214026020a9e6caa820519c7f879b21bd75b5571387d6a9cf8f94bd18;
255	 bytes32 internal constant _RELAYER_SLOT = 0x84e8c6b8f2281d51d9f683d351409724c3caa7848051aeb9d92c106ab36cc24c;
256	 bytes32 internal constant _PLATFORM_REWARDS_SLOT = 0x92260bfe68dd0f8a9f5439b75466781ba1ce44523ed1a3026a73eada49072e65;
257	 bytes32 internal constant _CHANGE_DELAY_SLOT = 0x0391715d0dd26b729c4ba34639ad5bdb0a7feb89f59a1e38f38485ea7f5a1583;
258	 bytes32 internal constant _DEPOSIT_LIMIT_SLOT = 0xca2f8a3e9ea81335bcce793cde55fc0c38129b594f53052d2bb18099ffa72613;
259	 bytes32 internal constant _DEPOSIT_LIMIT_TX_MAX_SLOT = 0x769f312c3790719cf1ea5f75303393f080fd62be88d75fa86726a6be00bb5a24;
260	 bytes32 internal constant _DEPOSIT_LIMIT_TX_MIN_SLOT = 0x9027949576d185c74d79ad3b8a8dbff32126f3a3ee140b346f146beb18234c85;
261	 bytes32 internal constant _PERFORMANCE_FEE_FUND_SLOT = 0x5b8979500398f8fbeb42c36d18f31a76fd0ab30f4338d864e7d8734b340e9bb9;
262	 bytes32 internal constant _PLATFORM_FEE_SLOT = 0x2084059f3bff3cc3fd204df32325dcb05f47c2f590aba5d103ec584523738e7a;
263	 bytes32 internal constant _MAX_INVESTMENT_IN_STRATEGIES_SLOT = 0xe3b5969c9426551aa8f16dbc7b25042b9b9c9869b759c77a85f0b097ac363475;
264	 bytes32 internal constant _TOTAL_WEIGHT_IN_STRATEGIES_SLOT = 0x63177e03c47ab825f04f5f8f2334e312239890e7588db78cabe10d7aec327fd2;
265	 bytes32 internal constant _TOTAL_ACCOUNTED_SLOT = 0xa19f3b8a62465676ae47ab811ee15e3d2b68d88869cb38686d086a11d382f6bb;
266	 bytes32 internal constant _TOTAL_INVESTED_SLOT = 0x49c84685200b42972f845832b2c3da3d71def653c151340801aeae053ce104e9;
267	 bytes32 internal constant _DEPOSITS_PAUSED_SLOT = 0x3cefcfe9774096ac956c0d63992ea27a01fb3884a22b8765ad63c8366f90a9c8;
268	 bytes32 internal constant _SHOULD_REBALANCE_SLOT = 0x7f8e3dfb98485aa419c1d05b6ea089a8cddbafcfcf4491db33f5d0b5fe4f32c7;
269	 bytes32 internal constant _LAST_HARDWORK_TIMESTAMP_SLOT = 0x0260c2bf5555cd32cedf39c0fcb0eab8029c67b3d5137faeb3e24a500db80bc9;
270	 bytes32 internal constant _NEXT_IMPLEMENTATION_SLOT = 0xa7ae0fa763ec3009113ccc5eb9089e1f0028607f5b8198c52cd42366c1ddb17b;
271	 bytes32 internal constant _NEXT_IMPLEMENTATION_TIMESTAMP_SLOT = 0x5e1f7083e1d90c44893f97806d0ec517436a58b85860b28247fd6fd56f5dc897;
272	 constructor() public {
273	 assert( _UNDERLYING_SLOT == bytes32( uint256( keccak256("eip1967.mesh.finance.fundStorage.underlying") ) - 1 ) );
274	 assert( _UNDERLYING_UNIT_SLOT == bytes32( uint256( keccak256( "eip1967.mesh.finance.fundStorage.underlyingUnit" ) ) - 1 ) );
275	 assert( _DECIMALS_SLOT == bytes32( uint256( keccak256("eip1967.mesh.finance.fundStorage.decimals") ) - 1 ) );
276	 assert( _FUND_MANAGER_SLOT == bytes32( uint256( keccak256( "eip1967.mesh.finance.fundStorage.fundManager" ) ) - 1 ) );
277	 assert( _RELAYER_SLOT == bytes32( uint256( keccak256("eip1967.mesh.finance.fundStorage.relayer") ) - 1 ) );
278	 assert( _PLATFORM_REWARDS_SLOT == bytes32( uint256( keccak256( "eip1967.mesh.finance.fundStorage.platformRewards" ) ) - 1 ) );
279	 assert( _CHANGE_DELAY_SLOT == bytes32( uint256( keccak256( "eip1967.mesh.finance.fundStorage.changeDelay" ) ) - 1 ) );
280	 assert( _DEPOSIT_LIMIT_SLOT == bytes32( uint256( keccak256( "eip1967.mesh.finance.fundStorage.depositLimit" ) ) - 1 ) );
281	 assert( _DEPOSIT_LIMIT_TX_MAX_SLOT == bytes32( uint256( keccak256( "eip1967.mesh.finance.fundStorage.depositLimitTxMax" ) ) - 1 ) );
282	 assert( _DEPOSIT_LIMIT_TX_MIN_SLOT == bytes32( uint256( keccak256( "eip1967.mesh.finance.fundStorage.depositLimitTxMin" ) ) - 1 ) );
283	 assert( _PERFORMANCE_FEE_FUND_SLOT == bytes32( uint256( keccak256( "eip1967.mesh.finance.fundStorage.performanceFeeFund" ) ) - 1 ) );
284	 assert( _PLATFORM_FEE_SLOT == bytes32( uint256( keccak256( "eip1967.mesh.finance.fundStorage.platformFee" ) ) - 1 ) );
285	 assert( _MAX_INVESTMENT_IN_STRATEGIES_SLOT == bytes32( uint256( keccak256( "eip1967.mesh.finance.fundStorage.maxInvestmentInStrategies" ) ) - 1 ) );
286	 assert( _TOTAL_WEIGHT_IN_STRATEGIES_SLOT == bytes32( uint256( keccak256( "eip1967.mesh.finance.fundStorage.totalWeightInStrategies" ) ) - 1 ) );
287	 assert( _TOTAL_ACCOUNTED_SLOT == bytes32( uint256( keccak256( "eip1967.mesh.finance.fundStorage.totalAccounted" ) ) - 1 ) );
288	 assert( _TOTAL_INVESTED_SLOT == bytes32( uint256( keccak256( "eip1967.mesh.finance.fundStorage.totalInvested" ) ) - 1 ) );
289	 assert( _DEPOSITS_PAUSED_SLOT == bytes32( uint256( keccak256( "eip1967.mesh.finance.fundStorage.depositsPaused" ) ) - 1 ) );
290	 assert( _SHOULD_REBALANCE_SLOT == bytes32( uint256( keccak256( "eip1967.mesh.finance.fundStorage.shouldRebalance" ) ) - 1 ) );
291	 assert( _LAST_HARDWORK_TIMESTAMP_SLOT == bytes32( uint256( keccak256( "eip1967.mesh.finance.fundStorage.lastHardworkTimestamp" ) ) - 1 ) );
292	 assert( _NEXT_IMPLEMENTATION_SLOT == bytes32( uint256( keccak256( "eip1967.mesh.finance.fundStorage.nextImplementation" ) ) - 1 ) );
293	 assert( _NEXT_IMPLEMENTATION_TIMESTAMP_SLOT == bytes32( uint256( keccak256( "eip1967.mesh.finance.fundStorage.nextImplementationTimestamp" ) ) - 1 ) );
294	 }
295	 function initializeFundStorage( address _underlying, uint256 _underlyingUnit, uint8 _decimals, address _fundManager, address _relayer, address _platformRewards, uint256 _changeDelay ) public initializer {
296	 _setUnderlying(_underlying);
297	 _setUnderlyingUnit(_underlyingUnit);
298	 _setDecimals(_decimals);
299	 _setFundManager(_fundManager);
300	 _setRelayer(_relayer);
301	 _setPlatformRewards(_platformRewards);
302	 _setChangeDelay(_changeDelay);
303	 _setDepositLimit(0);
304	 _setDepositLimitTxMax(0);
305	 _setDepositLimitTxMin(0);
306	 _setPerformanceFeeFund(0);
307	 _setPlatformFee(0);
308	 _setMaxInvestmentInStrategies(9500);
309	 _setTotalWeightInStrategies(0);
310	 _setTotalAccounted(0);
311	 _setTotalInvested(0);
312	 _setDepositsPaused(false);
313	 _setShouldRebalance(false);
314	 _setLastHardworkTimestamp(0);
315	 _setNextImplementation(address(0));
316	 _setNextImplementationTimestamp(0);
317	 }
318	 function _setUnderlying(address _address) internal {
319	 setAddress(_UNDERLYING_SLOT, _address);
320	 }
321	 function _underlying() internal view returns (address) {
322	 return getAddress(_UNDERLYING_SLOT);
323	 }
324	 function _setUnderlyingUnit(uint256 _value) internal {
325	 setUint256(_UNDERLYING_UNIT_SLOT, _value);
326	 }
327	 function _underlyingUnit() internal view returns (uint256) {
328	 return getUint256(_UNDERLYING_UNIT_SLOT);
329	 }
330	 function _setDecimals(uint8 _value) internal {
331	 setUint8(_DECIMALS_SLOT, _value);
332	 }
333	 function _decimals() internal view returns (uint8) {
334	 return getUint8(_DECIMALS_SLOT);
335	 }
336	 function _setFundManager(address _fundManager) internal {
337	 setAddress(_FUND_MANAGER_SLOT, _fundManager);
338	 }
339	 function _fundManager() internal view returns (address) {
340	 return getAddress(_FUND_MANAGER_SLOT);
341	 }
342	 function _setRelayer(address _relayer) internal {
343	 setAddress(_RELAYER_SLOT, _relayer);
344	 }
345	 function _relayer() internal view returns (address) {
346	 return getAddress(_RELAYER_SLOT);
347	 }
348	 function _setPlatformRewards(address _rewards) internal {
349	 setAddress(_PLATFORM_REWARDS_SLOT, _rewards);
350	 }
351	 function _platformRewards() internal view returns (address) {
352	 return getAddress(_PLATFORM_REWARDS_SLOT);
353	 }
354	 function _setChangeDelay(uint256 _value) internal {
355	 setUint256(_CHANGE_DELAY_SLOT, _value);
356	 }
357	 function _changeDelay() internal view returns (uint256) {
358	 return getUint256(_CHANGE_DELAY_SLOT);
359	 }
360	 function _setDepositLimit(uint256 _value) internal {
361	 setUint256(_DEPOSIT_LIMIT_SLOT, _value);
362	 }
363	 function _depositLimit() internal view returns (uint256) {
364	 return getUint256(_DEPOSIT_LIMIT_SLOT);
365	 }
366	 function _setDepositLimitTxMax(uint256 _value) internal {
367	 setUint256(_DEPOSIT_LIMIT_TX_MAX_SLOT, _value);
368	 }
369	 function _depositLimitTxMax() internal view returns (uint256) {
370	 return getUint256(_DEPOSIT_LIMIT_TX_MAX_SLOT);
371	 }
372	 function _setDepositLimitTxMin(uint256 _value) internal {
373	 setUint256(_DEPOSIT_LIMIT_TX_MIN_SLOT, _value);
374	 }
375	 function _depositLimitTxMin() internal view returns (uint256) {
376	 return getUint256(_DEPOSIT_LIMIT_TX_MIN_SLOT);
377	 }
378	 function _setPerformanceFeeFund(uint256 _value) internal {
379	 setUint256(_PERFORMANCE_FEE_FUND_SLOT, _value);
380	 }
381	 function _performanceFeeFund() internal view returns (uint256) {
382	 return getUint256(_PERFORMANCE_FEE_FUND_SLOT);
383	 }
384	 function _setPlatformFee(uint256 _value) internal {
385	 setUint256(_PLATFORM_FEE_SLOT, _value);
386	 }
387	 function _platformFee() internal view returns (uint256) {
388	 return getUint256(_PLATFORM_FEE_SLOT);
389	 }
390	 function _setMaxInvestmentInStrategies(uint256 _value) internal {
391	 setUint256(_MAX_INVESTMENT_IN_STRATEGIES_SLOT, _value);
392	 }
393	 function _maxInvestmentInStrategies() internal view returns (uint256) {
394	 return getUint256(_MAX_INVESTMENT_IN_STRATEGIES_SLOT);
395	 }
396	 function _setTotalWeightInStrategies(uint256 _value) internal {
397	 setUint256(_TOTAL_WEIGHT_IN_STRATEGIES_SLOT, _value);
398	 }
399	 function _totalWeightInStrategies() internal view returns (uint256) {
400	 return getUint256(_TOTAL_WEIGHT_IN_STRATEGIES_SLOT);
401	 }
402	 function _setTotalAccounted(uint256 _value) internal {
403	 setUint256(_TOTAL_ACCOUNTED_SLOT, _value);
404	 }
405	 function _totalAccounted() internal view returns (uint256) {
406	 return getUint256(_TOTAL_ACCOUNTED_SLOT);
407	 }
408	 function _setTotalInvested(uint256 _value) internal {
409	 setUint256(_TOTAL_INVESTED_SLOT, _value);
410	 }
411	 function _totalInvested() internal view returns (uint256) {
412	 return getUint256(_TOTAL_INVESTED_SLOT);
413	 }
414	 function _setDepositsPaused(bool _value) internal {
415	 setBool(_DEPOSITS_PAUSED_SLOT, _value);
416	 }
417	 function _depositsPaused() internal view returns (bool) {
418	 return getBool(_DEPOSITS_PAUSED_SLOT);
419	 }
420	 function _setShouldRebalance(bool _value) internal {
421	 setBool(_SHOULD_REBALANCE_SLOT, _value);
422	 }
423	 function _shouldRebalance() internal view returns (bool) {
424	 return getBool(_SHOULD_REBALANCE_SLOT);
425	 }
426	 function _setLastHardworkTimestamp(uint256 _value) internal {
427	 setUint256(_LAST_HARDWORK_TIMESTAMP_SLOT, _value);
428	 }
429	 function _lastHardworkTimestamp() internal view returns (uint256) {
430	 return getUint256(_LAST_HARDWORK_TIMESTAMP_SLOT);
431	 }
432	 function _setNextImplementation(address _newImplementation) internal {
433	 setAddress(_NEXT_IMPLEMENTATION_SLOT, _newImplementation);
434	 }
435	 function _nextImplementation() internal view returns (address) {
436	 return getAddress(_NEXT_IMPLEMENTATION_SLOT);
437	 }
438	 function _setNextImplementationTimestamp(uint256 _value) internal {
439	 setUint256(_NEXT_IMPLEMENTATION_TIMESTAMP_SLOT, _value);
440	 }
441	 function _nextImplementationTimestamp() internal view returns (uint256) {
442	 return getUint256(_NEXT_IMPLEMENTATION_TIMESTAMP_SLOT);
443	 }
444	 uint256[50] private bigEmptySlot;
445	 }
446	 pragma solidity 0.6.12;
447	 contract Fund is ERC20Upgradeable, ReentrancyGuardUpgradeable, IFund, Governable, FundStorage {
448	 using SafeERC20 for IERC20;
449	 using AddressUpgradeable for address;
450	 using SafeMathUpgradeable for uint256;
451	 using SafeMathUpgradeable for uint8;
452	 event Withdraw(address indexed beneficiary, uint256 amount);
453	 event Deposit(address indexed beneficiary, uint256 amount);
454	 event InvestInStrategy(address indexed strategy, uint256 amount);
455	 event StrategyRewards( address indexed strategy, uint256 profit, uint256 strategyCreatorFee );
456	 event FundManagerRewards(uint256 profitTotal, uint256 fundManagerFee);
457	 event PlatformRewards( uint256 lastBalance, uint256 timeElapsed, uint256 platformFee );
458	 event HardWorkDone(uint256 totalValueLocked, uint256 pricePerShare);
459	 event StrategyAdded( address indexed strategy, uint256 weightage, uint256 performanceFeeStrategy );
460	 event StrategyWeightageUpdated( address indexed strategy, uint256 newWeightage );
461	 event StrategyPerformanceFeeUpdated( address indexed strategy, uint256 newPerformanceFeeStrategy );
462	 event StrategyRemoved(address indexed strategy);
463	 address internal constant ZERO_ADDRESS = address(0);
464	 uint256 internal constant MAX_BPS = 10000;
465	 uint256 internal constant SECS_PER_YEAR = 31556952;
466	 uint256 internal constant MAX_PLATFORM_FEE = 500;
467	 uint256 internal constant MAX_PERFORMANCE_FEE_FUND = 1000;
468	 uint256 internal constant MAX_PERFORMANCE_FEE_STRATEGY = 1000;
469	 uint256 internal constant MAX_ACTIVE_STRATEGIES = 10;
470	 struct StrategyParams {
471	 uint256 weightage;
472	 uint256 performanceFeeStrategy;
473	 uint256 activation;
474	 uint256 lastBalance;
475	 uint256 indexInList;
476	 }
477	 mapping(address => StrategyParams) public strategies;
478	 address[] public strategyList;
479	 constructor() public {
480	 }
481	 function initializeFund( address _governance, address _underlying, string memory _name, string memory _symbol ) external initializer {
482	 require(_governance != ZERO_ADDRESS, "governance must be defined");
483	 require(_underlying != ZERO_ADDRESS, "underlying must be defined");
484	 ERC20Upgradeable.__ERC20_init(_name, _symbol);
485	 __ReentrancyGuard_init();
486	 Governable.initializeGovernance(_governance);
487	 uint8 _decimals = ERC20Upgradeable(_underlying).decimals();
488	 uint256 _underlyingUnit = 10**uint256(_decimals);
489	 uint256 _changeDelay = 12 hours;
490	 FundStorage.initializeFundStorage( _underlying, _underlyingUnit, _decimals, _governance, _governance, _governance, _changeDelay );
491	 }
492	 modifier onlyFundManager {
493	 require(_fundManager() == msg.sender, "Not fund manager");
494	 _;
495	 }
496	 modifier onlyFundManagerOrGovernance() {
497	 require( (_governance() == msg.sender) || (_fundManager() == msg.sender), "Not governance or fund manager" );
498	 _;
499	 }
500	 modifier onlyFundManagerOrRelayer() {
501	 require( (_fundManager() == msg.sender) || (_relayer() == msg.sender), "Not fund manager or relayer" );
502	 _;
503	 }
504	 modifier whenDepositsNotPaused() {
505	 require(!_depositsPaused(), "Deposits are paused");
506	 _;
507	 }
508	 function fundManager() external view override returns (address) {
509	 return _fundManager();
510	 }
511	 function relayer() external view override returns (address) {
512	 return _relayer();
513	 }
514	 function underlying() external view override returns (address) {
515	 return _underlying();
516	 }
517	 function underlyingUnit() external view returns (uint256) {
518	 return _underlyingUnit();
519	 }
520	 function decimals() public view virtual override returns (uint8) {
521	 return _decimals();
522	 }
523	 function _getStrategyCount() internal view returns (uint256) {
524	 return strategyList.length;
525	 }
526	 modifier whenStrategyDefined() {
527	 require(_getStrategyCount() > 0, "Strategies must be defined");
528	 _;
529	 }
530	 function getStrategyList() public view returns (address[] memory) {
531	 return strategyList;
532	 }
533	 function getStrategy(address strategy) public view returns (StrategyParams memory) {
534	 return strategies[strategy];
535	 }
536	 function underlyingBalanceInFund() internal view returns (uint256) {
537	 return IERC20(_underlying()).balanceOf(address(this));
538	 }
539	 function underlyingBalanceWithInvestment() internal view returns (uint256) {
540	 uint256 underlyingBalance = underlyingBalanceInFund();
541	 for (uint256 i; i < _getStrategyCount(); i++) {
542	 underlyingBalance = underlyingBalance.add( IStrategy(strategyList[i]).investedUnderlyingBalance() );
543	 }
544	 return underlyingBalance;
545	 }
546	 function _getPricePerShare() internal view returns (uint256) {
547	 return totalSupply() == 0 ? _underlyingUnit() : _underlyingUnit().mul(underlyingBalanceWithInvestment()).div( totalSupply() );
548	 }
549	 function getPricePerShare() external view override returns (uint256) {
550	 return _getPricePerShare();
551	 }
552	 function totalValueLocked() external view override returns (uint256) {
553	 return underlyingBalanceWithInvestment();
554	 }
555	 function underlyingFromShares(uint256 _numShares) external view returns (uint256) {
556	 return _underlyingFromShares(_numShares);
557	 }
558	 function _underlyingFromShares(uint256 numShares) internal view returns (uint256) {
559	 return underlyingBalanceWithInvestment().mul(numShares).div(totalSupply());
560	 }
561	 function underlyingBalanceWithInvestmentForHolder(address holder) external view override returns (uint256) {
562	 if (totalSupply() == 0) {
563	 return 0;
564	 }
565	 return _underlyingFromShares(balanceOf(holder));
566	 }
567	 function isActiveStrategy(address strategy) internal view returns (bool) {
568	 return strategies[strategy].weightage > 0;
569	 }
570	 function addStrategy( address newStrategy, uint256 weightage, uint256 performanceFeeStrategy ) external onlyFundManager {
571	 require(newStrategy != ZERO_ADDRESS, "new newStrategy cannot be empty");
572	 require( IStrategy(newStrategy).fund() == address(this), "The strategy does not belong to this fund" );
573	 require( isActiveStrategy(newStrategy) == false, "This strategy is already active in this fund" );
574	 require( _getStrategyCount() + 1 <= MAX_ACTIVE_STRATEGIES, "Can not add more strategies" );
575	 require(weightage > 0, "The weightage should be greater than 0");
576	 uint256 totalWeightInStrategies = _totalWeightInStrategies().add(weightage);
577	 require( totalWeightInStrategies <= _maxInvestmentInStrategies(), "Total investment can't be above max allowed" );
578	 require( performanceFeeStrategy <= MAX_PERFORMANCE_FEE_STRATEGY, "Performance fee too high" );
579	 strategies[newStrategy].weightage = weightage;
580	 _setTotalWeightInStrategies(totalWeightInStrategies);
581	 strategies[newStrategy].activation = block.timestamp;
582	 strategies[newStrategy].indexInList = _getStrategyCount();
583	 strategies[newStrategy].performanceFeeStrategy = performanceFeeStrategy;
584	 strategyList.push(newStrategy);
585	 _setShouldRebalance(true);
586	 emit StrategyAdded(newStrategy, weightage, performanceFeeStrategy);
587	 }
588	 function removeStrategy(address activeStrategy) external onlyFundManagerOrGovernance {
589	 require( activeStrategy != ZERO_ADDRESS, "current strategy cannot be empty" );
590	 require( isActiveStrategy(activeStrategy), "This strategy is not active in this fund" );
591	 _setTotalWeightInStrategies( _totalWeightInStrategies().sub(strategies[activeStrategy].weightage) );
592	 uint256 totalStrategies = _getStrategyCount();
593	 if (totalStrategies > 1) {
594	 uint256 i = strategies[activeStrategy].indexInList;
595	 if (i != (totalStrategies - 1)) {
596	 strategyList[i] = strategyList[totalStrategies - 1];
597	 strategies[strategyList[i]].indexInList = i;
598	 }
599	 }
600	 strategyList.pop();
601	 delete strategies[activeStrategy];
602	 IStrategy(activeStrategy).withdrawAllToFund();
603	 _setShouldRebalance(true);
604	 emit StrategyRemoved(activeStrategy);
605	 }
606	 function updateStrategyWeightage( address activeStrategy, uint256 newWeightage ) external onlyFundManager {
607	 require( activeStrategy != ZERO_ADDRESS, "current strategy cannot be empty" );
608	 require( isActiveStrategy(activeStrategy), "This strategy is not active in this fund" );
609	 require(newWeightage > 0, "The weightage should be greater than 0");
610	 uint256 totalWeightInStrategies = _totalWeightInStrategies() .sub(strategies[activeStrategy].weightage) .add(newWeightage);
611	 require( totalWeightInStrategies <= _maxInvestmentInStrategies(), "Total investment can't be above max allowed" );
612	 _setTotalWeightInStrategies(totalWeightInStrategies);
613	 strategies[activeStrategy].weightage = newWeightage;
614	 _setShouldRebalance(true);
615	 emit StrategyWeightageUpdated(activeStrategy, newWeightage);
616	 }
617	 function updateStrategyPerformanceFee( address activeStrategy, uint256 newPerformanceFeeStrategy ) external onlyFundManager {
618	 require( activeStrategy != ZERO_ADDRESS, "current strategy cannot be empty" );
619	 require( isActiveStrategy(activeStrategy), "This strategy is not active in this fund" );
620	 require( newPerformanceFeeStrategy <= MAX_PERFORMANCE_FEE_STRATEGY, "Performance fee too high" );
621	 strategies[activeStrategy] .performanceFeeStrategy = newPerformanceFeeStrategy;
622	 emit StrategyPerformanceFeeUpdated( activeStrategy, newPerformanceFeeStrategy );
623	 }
624	 function processFees() internal {
625	 uint256 totalStrategies = _getStrategyCount();
626	 uint256[] memory strategyCreatorFees = new uint256[](totalStrategies);
627	 uint256[] memory strategyProfits = new uint256[](totalStrategies);
628	 uint256 profitToFund = 0;
629	 uint256 totalFee = 0;
630	 for (uint256 i; i < totalStrategies; i++) {
631	 address strategy = strategyList[i];
632	 uint256 profit = 0;
633	 uint256 strategyCreatorFee = 0;
634	 if ( IStrategy(strategy).investedUnderlyingBalance() > strategies[strategy].lastBalance ) {
635	 profit = IStrategy(strategy).investedUnderlyingBalance() - strategies[strategy].lastBalance;
636	 strategyCreatorFee = profit .mul(strategies[strategy].performanceFeeStrategy) .div(MAX_BPS);
637	 strategyProfits[i] = profit;
638	 strategyCreatorFees[i] = strategyCreatorFee;
639	 totalFee = totalFee.add(strategyCreatorFee);
640	 profitToFund = profitToFund.add(profit).sub(strategyCreatorFee);
641	 }
642	 strategies[strategy].lastBalance = IStrategy(strategy) .investedUnderlyingBalance();
643	 }
644	 uint256 fundManagerFee = profitToFund.mul(_performanceFeeFund()).div(MAX_BPS);
645	 totalFee = totalFee.add(fundManagerFee);
646	 uint256 timeSinceLastHardwork = block.timestamp.sub(_lastHardworkTimestamp());
647	 uint256 totalInvested = _totalInvested();
648	 uint256 platformFee = totalInvested.mul(timeSinceLastHardwork).mul(_platformFee()).div( MAX_BPS * SECS_PER_YEAR );
649	 totalFee = totalFee.add(platformFee);
650	 uint256 totalFeeInShares = (totalFee == 0 || totalSupply() == 0) ? totalFee : totalFee.mul(totalSupply()).div( underlyingBalanceWithInvestment() );
651	 if (totalFeeInShares > 0) {
652	 _mint(address(this), totalFeeInShares);
653	 }
654	 for (uint256 i; i < totalStrategies; i++) {
655	 if (strategyCreatorFees[i] > 0) {
656	 uint256 strategyCreatorFeeInShares = totalFeeInShares.mul(strategyCreatorFees[i]).div(totalFee);
657	 if (strategyCreatorFeeInShares > 0) {
658	 address strategy = strategyList[i];
659	 IERC20(address(this)).safeTransfer( IStrategy(strategy).creator(), strategyCreatorFeeInShares );
660	 emit StrategyRewards( strategy, strategyProfits[i], strategyCreatorFeeInShares );
661	 }
662	 }
663	 }
664	 if (fundManagerFee > 0) {
665	 uint256 fundManagerFeeInShares = totalFeeInShares.mul(fundManagerFee).div(totalFee);
666	 if (fundManagerFeeInShares > 0) {
667	 address fundManagerRewards = (_fundManager() == _governance()) ? _platformRewards() : _fundManager();
668	 IERC20(address(this)).safeTransfer( fundManagerRewards, fundManagerFeeInShares );
669	 emit FundManagerRewards(profitToFund, fundManagerFeeInShares);
670	 }
671	 }
672	 if (platformFee > 0) {
673	 uint256 platformFeeInShares = totalFeeInShares.mul(platformFee).div(totalFee);
674	 emit PlatformRewards( totalInvested, timeSinceLastHardwork, platformFeeInShares );
675	 }
676	 uint256 selfBalance = IERC20(address(this)).balanceOf(address(this));
677	 if (selfBalance > 0) {
678	 IERC20(address(this)).safeTransfer(_platformRewards(), selfBalance);
679	 }
680	 }
681	 function doHardWork() external nonReentrant whenStrategyDefined onlyFundManagerOrRelayer {
682	 if (_lastHardworkTimestamp() > 0) {
683	 processFees();
684	 }
685	 if (_shouldRebalance()) {
686	 _setShouldRebalance(false);
687	 doHardWorkWithRebalance();
688	 }
689	 else {
690	 doHardWorkWithoutRebalance();
691	 }
692	 _setLastHardworkTimestamp(block.timestamp);
693	 emit HardWorkDone( underlyingBalanceWithInvestment(), _getPricePerShare() );
694	 }
695	 function doHardWorkWithoutRebalance() internal {
696	 uint256 totalAccounted = _totalAccounted();
697	 uint256 totalInvested = _totalInvested();
698	 uint256 lastReserve = totalAccounted > 0 ? totalAccounted.sub(totalInvested) : 0;
699	 uint256 availableAmountToInvest = underlyingBalanceInFund() > lastReserve ? underlyingBalanceInFund().sub(lastReserve) : 0;
700	 _setTotalAccounted(totalAccounted.add(availableAmountToInvest));
701	 for (uint256 i; i < _getStrategyCount(); i++) {
702	 address strategy = strategyList[i];
703	 uint256 availableAmountForStrategy = availableAmountToInvest.mul(strategies[strategy].weightage).div( MAX_BPS );
704	 if (availableAmountForStrategy > 0) {
705	 IERC20(_underlying()).safeTransfer( strategy, availableAmountForStrategy );
706	 totalInvested = totalInvested.add(availableAmountForStrategy);
707	 emit InvestInStrategy(strategy, availableAmountForStrategy);
708	 }
709	 IStrategy(strategy).doHardWork();
710	 strategies[strategy].lastBalance = IStrategy(strategy) .investedUnderlyingBalance();
711	 }
712	 _setTotalInvested(totalInvested);
713	 }
714	 function doHardWorkWithRebalance() internal {
715	 uint256 totalUnderlyingWithInvestment = underlyingBalanceWithInvestment();
716	 _setTotalAccounted(totalUnderlyingWithInvestment);
717	 uint256 totalInvested = 0;
718	 uint256 totalStrategies = _getStrategyCount();
719	 uint256[] memory toDeposit = new uint256[](totalStrategies);
720	 for (uint256 i; i < totalStrategies; i++) {
721	 address strategy = strategyList[i];
722	 uint256 shouldBeInStrategy = totalUnderlyingWithInvestment .mul(strategies[strategy].weightage) .div(MAX_BPS);
723	 totalInvested = totalInvested.add(shouldBeInStrategy);
724	 uint256 currentlyInStrategy = IStrategy(strategy).investedUnderlyingBalance();
725	 if (currentlyInStrategy > shouldBeInStrategy) {
726	 IStrategy(strategy).withdrawToFund( currentlyInStrategy.sub(shouldBeInStrategy) );
727	 }
728	 else if (shouldBeInStrategy > currentlyInStrategy) {
729	 toDeposit[i] = shouldBeInStrategy.sub(currentlyInStrategy);
730	 }
731	 }
732	 _setTotalInvested(totalInvested);
733	 for (uint256 i; i < totalStrategies; i++) {
734	 address strategy = strategyList[i];
735	 if (toDeposit[i] > 0) {
736	 IERC20(_underlying()).safeTransfer(strategy, toDeposit[i]);
737	 emit InvestInStrategy(strategy, toDeposit[i]);
738	 }
739	 IStrategy(strategy).doHardWork();
740	 strategies[strategy].lastBalance = IStrategy(strategy) .investedUnderlyingBalance();
741	 }
742	 }
743	 function pauseDeposits(bool trigger) external onlyFundManagerOrGovernance {
744	 _setDepositsPaused(trigger);
745	 }
746	 function deposit(uint256 amount) external override nonReentrant whenDepositsNotPaused {
747	 _deposit(amount, msg.sender, msg.sender);
748	 }
749	 function depositFor(uint256 amount, address holder) external override nonReentrant whenDepositsNotPaused {
750	 require(holder != ZERO_ADDRESS, "holder must be defined");
751	 _deposit(amount, msg.sender, holder);
752	 }
753	 function _deposit( uint256 amount, address sender, address beneficiary ) internal {
754	 require(amount > 0, "Cannot deposit 0");
755	 if (_depositLimit() > 0) {
756	 require( underlyingBalanceWithInvestment().add(amount) <= _depositLimit(), "Total deposit limit hit" );
757	 }
758	 if (_depositLimitTxMax() > 0) {
759	 require( amount <= _depositLimitTxMax(), "Maximum transaction deposit limit hit" );
760	 }
761	 if (_depositLimitTxMin() > 0) {
762	 require( amount >= _depositLimitTxMin(), "Minimum transaction deposit limit hit" );
763	 }
764	 uint256 toMint = totalSupply() == 0 ? amount : amount.mul(totalSupply()).div( underlyingBalanceWithInvestment() );
765	 _mint(beneficiary, toMint);
766	 IERC20(_underlying()).safeTransferFrom(sender, address(this), amount);
767	 emit Deposit(beneficiary, amount);
768	 }
769	 function withdraw(uint256 numberOfShares) external override nonReentrant {
770	 require(totalSupply() > 0, "Fund has no shares");
771	 require(numberOfShares > 0, "numberOfShares must be greater than 0");
772	 uint256 underlyingAmountToWithdraw = _underlyingFromShares(numberOfShares);
773	 require(underlyingAmountToWithdraw > 0, "Can't withdraw 0");
774	 _burn(msg.sender, numberOfShares);
775	 if (underlyingAmountToWithdraw == underlyingBalanceInFund()) {
776	 _setShouldRebalance(true);
777	 }
778	 else if (underlyingAmountToWithdraw > underlyingBalanceInFund()) {
779	 uint256 missing = underlyingAmountToWithdraw.sub(underlyingBalanceInFund());
780	 uint256 missingCarryOver;
781	 for (uint256 i; i < _getStrategyCount(); i++) {
782	 if (isActiveStrategy(strategyList[i])) {
783	 uint256 balanceBefore = underlyingBalanceInFund();
784	 uint256 weightage = strategies[strategyList[i]].weightage;
785	 uint256 missingforStrategy = (missing.mul(weightage).div(_totalWeightInStrategies())) .add(missingCarryOver);
786	 IStrategy(strategyList[i]).withdrawToFund( missingforStrategy );
787	 missingCarryOver = missingforStrategy .add(balanceBefore) .sub(underlyingBalanceInFund());
788	 }
789	 }
790	 underlyingAmountToWithdraw = MathUpgradeable.min( underlyingAmountToWithdraw, underlyingBalanceInFund() );
791	 _setShouldRebalance(true);
792	 }
793	 IERC20(_underlying()).safeTransfer( msg.sender, underlyingAmountToWithdraw );
794	 emit Withdraw(msg.sender, underlyingAmountToWithdraw);
795	 }
796	 function scheduleUpgrade(address newImplementation) external onlyGovernance {
797	 require( newImplementation != ZERO_ADDRESS, "new implementation address can not be zero address" );
798	 require( newImplementation != IFundProxy(address(this)).implementation(), "new implementation address should not be same as current address" );
799	 _setNextImplementation(newImplementation);
800	 _setNextImplementationTimestamp(block.timestamp.add(_changeDelay()));
801	 }
802	 function shouldUpgrade() external view returns (bool, address) {
803	 return ( _nextImplementationTimestamp() != 0 && block.timestamp > _nextImplementationTimestamp() && _nextImplementation() != ZERO_ADDRESS, _nextImplementation() );
804	 }
805	 function finalizeUpgrade() external onlyGovernance {
806	 _setNextImplementation(ZERO_ADDRESS);
807	 _setNextImplementationTimestamp(0);
808	 }
809	 function setFundManager(address newFundManager) external onlyFundManagerOrGovernance {
810	 _setFundManager(newFundManager);
811	 }
812	 function setRelayer(address newRelayer) external onlyFundManager {
813	 _setRelayer(newRelayer);
814	 }
815	 function setPlatformRewards(address newRewards) external onlyGovernance {
816	 _setPlatformRewards(newRewards);
817	 }
818	 function setShouldRebalance(bool trigger) external onlyFundManager {
819	 _setShouldRebalance(trigger);
820	 }
821	 function setMaxInvestmentInStrategies(uint256 value) external onlyFundManager {
822	 require(value < MAX_BPS, "Value greater than 100%");
823	 _setMaxInvestmentInStrategies(value);
824	 }
825	 function setDepositLimit(uint256 limit) external onlyFundManager {
826	 _setDepositLimit(limit);
827	 }
828	 function depositLimit() external view returns (uint256) {
829	 return _depositLimit();
830	 }
831	 function setDepositLimitTxMax(uint256 limit) external onlyFundManager {
832	 require( _depositLimitTxMin() == 0 || limit > _depositLimitTxMin(), "Max limit greater than min limit" );
833	 _setDepositLimitTxMax(limit);
834	 }
835	 function depositLimitTxMax() external view returns (uint256) {
836	 return _depositLimitTxMax();
837	 }
838	 function setDepositLimitTxMin(uint256 limit) external onlyFundManager {
839	 require( _depositLimitTxMax() == 0 || limit < _depositLimitTxMax(), "Min limit greater than max limit" );
840	 _setDepositLimitTxMin(limit);
841	 }
842	 function depositLimitTxMin() external view returns (uint256) {
843	 return _depositLimitTxMin();
844	 }
845	 function setPerformanceFeeFund(uint256 fee) external onlyFundManager {
846	 require(fee <= MAX_PERFORMANCE_FEE_FUND, "Fee greater than max limit");
847	 _setPerformanceFeeFund(fee);
848	 }
849	 function performanceFeeFund() external view returns (uint256) {
850	 return _performanceFeeFund();
851	 }
852	 function setPlatformFee(uint256 fee) external onlyGovernance {
853	 require(fee <= MAX_PLATFORM_FEE, "Fee greater than max limit");
854	 _setPlatformFee(fee);
855	 }
856	 function platformFee() external view returns (uint256) {
857	 return _platformFee();
858	 }
859	 function sweep(address _token, address _sweepTo) external onlyGovernance {
860	 require(_token != address(_underlying()), "can not sweep underlying");
861	 require(_sweepTo != ZERO_ADDRESS, "can not sweep to zero");
862	 IERC20(_token).safeTransfer( _sweepTo, IERC20(_token).balanceOf(address(this)) );
863	 }
864	 }
865	 pragma solidity >=0.6.2 <0.8.0;
866	 library AddressUpgradeable {
867	 function isContract(address account) internal view returns (bool) {
868	 uint256 size;
869	 assembly {
870	 size := extcodesize(account) }
871	 return size > 0;
872	 }
873	 function sendValue(address payable recipient, uint256 amount) internal {
874	 require(address(this).balance >= amount, "Address: insufficient balance");
875	 (bool success, ) = recipient.call{
876	 value: amount }
877	 ("");
878	 require(success, "Address: unable to send value, recipient may have reverted");
879	 }
880	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
881	 return functionCall(target, data, "Address: low-level call failed");
882	 }
883	 function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
884	 return functionCallWithValue(target, data, 0, errorMessage);
885	 }
886	 function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
887	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
888	 }
889	 function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
890	 require(address(this).balance >= value, "Address: insufficient balance for call");
891	 require(isContract(target), "Address: call to non-contract");
892	 (bool success, bytes memory returndata) = target.call{
893	 value: value }
894	 (data);
895	 return _verifyCallResult(success, returndata, errorMessage);
896	 }
897	 function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
898	 return functionStaticCall(target, data, "Address: low-level static call failed");
899	 }
900	 function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
901	 require(isContract(target), "Address: static call to non-contract");
902	 (bool success, bytes memory returndata) = target.staticcall(data);
903	 return _verifyCallResult(success, returndata, errorMessage);
904	 }
905	 function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
906	 if (success) {
907	 return returndata;
908	 }
909	 else {
910	 if (returndata.length > 0) {
911	 assembly {
912	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
913	 }
914	 else {
915	 revert(errorMessage);
916	 }
917	 }
918	 }
919	 }
920	 pragma solidity >=0.6.0 <0.8.0;
921	 library MathUpgradeable {
922	 function max(uint256 a, uint256 b) internal pure returns (uint256) {
923	 return a >= b ? a : b;
924	 }
925	 function min(uint256 a, uint256 b) internal pure returns (uint256) {
926	 return a < b ? a : b;
927	 }
928	 function average(uint256 a, uint256 b) internal pure returns (uint256) {
929	 return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);
930	 }
931	 }
932	 pragma solidity >=0.6.0 <0.8.0;
933	 library SafeMathUpgradeable {
934	 function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
935	 uint256 c = a + b;
936	 if (c < a) return (false, 0);
937	 return (true, c);
938	 }
939	 function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
940	 if (b > a) return (false, 0);
941	 return (true, a - b);
942	 }
943	 function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
944	 if (a == 0) return (true, 0);
945	 uint256 c = a * b;
946	 if (c / a != b) return (false, 0);
947	 return (true, c);
948	 }
949	 function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
950	 if (b == 0) return (false, 0);
951	 return (true, a / b);
952	 }
953	 function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
954	 if (b == 0) return (false, 0);
955	 return (true, a % b);
956	 }
957	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
958	 uint256 c = a + b;
959	 require(c >= a, "SafeMath: addition overflow");
960	 return c;
961	 }
962	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
963	 require(b <= a, "SafeMath: subtraction overflow");
964	 return a - b;
965	 }
966	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
967	 if (a == 0) return 0;
968	 uint256 c = a * b;
969	 require(c / a == b, "SafeMath: multiplication overflow");
970	 return c;
971	 }
972	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
973	 require(b > 0, "SafeMath: division by zero");
974	 return a / b;
975	 }
976	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
977	 require(b > 0, "SafeMath: modulo by zero");
978	 return a % b;
979	 }
980	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
981	 require(b <= a, errorMessage);
982	 return a - b;
983	 }
984	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
985	 require(b > 0, errorMessage);
986	 return a / b;
987	 }
988	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
989	 require(b > 0, errorMessage);
990	 return a % b;
991	 }
992	 }
993	 pragma solidity >=0.6.0 <0.8.0;
994	 interface IERC20 {
995	 function totalSupply() external view returns (uint256);
996	 function balanceOf(address account) external view returns (uint256);
997	 function transfer(address recipient, uint256 amount) external returns (bool);
998	 function allowance(address owner, address spender) external view returns (uint256);
999	 function approve(address spender, uint256 amount) external returns (bool);
1000	 function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
1001	 event Transfer(address indexed from, address indexed to, uint256 value);
1002	 event Approval(address indexed owner, address indexed spender, uint256 value);
1003	 }
1004	 pragma solidity >=0.6.0 <0.8.0;
1005	 library SafeERC20 {
1006	 using SafeMath for uint256;
1007	 using Address for address;
1008	 function safeTransfer(IERC20 token, address to, uint256 value) internal {
1009	 _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
1010	 }
1011	 function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
1012	 _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
1013	 }
1014	 function safeApprove(IERC20 token, address spender, uint256 value) internal {
1015	 require((value == 0) || (token.allowance(address(this), spender) == 0), "SafeERC20: approve from non-zero to non-zero allowance" );
1016	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
1017	 }
1018	 function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
1019	 uint256 newAllowance = token.allowance(address(this), spender).add(value);
1020	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
1021	 }
1022	 function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
1023	 uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
1024	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
1025	 }
1026	 function _callOptionalReturn(IERC20 token, bytes memory data) private {
1027	 bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
1028	 if (returndata.length > 0) {
1029	 require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
1030	 }
1031	 }
1032	 }
1033	 pragma solidity >=0.6.0 <0.8.0;
1034	 library SafeMath {
1035	 function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
1036	 uint256 c = a + b;
1037	 if (c < a) return (false, 0);
1038	 return (true, c);
1039	 }
1040	 function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
1041	 if (b > a) return (false, 0);
1042	 return (true, a - b);
1043	 }
1044	 function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
1045	 if (a == 0) return (true, 0);
1046	 uint256 c = a * b;
1047	 if (c / a != b) return (false, 0);
1048	 return (true, c);
1049	 }
1050	 function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
1051	 if (b == 0) return (false, 0);
1052	 return (true, a / b);
1053	 }
1054	 function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
1055	 if (b == 0) return (false, 0);
1056	 return (true, a % b);
1057	 }
1058	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
1059	 uint256 c = a + b;
1060	 require(c >= a, "SafeMath: addition overflow");
1061	 return c;
1062	 }
1063	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
1064	 require(b <= a, "SafeMath: subtraction overflow");
1065	 return a - b;
1066	 }
1067	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
1068	 if (a == 0) return 0;
1069	 uint256 c = a * b;
1070	 require(c / a == b, "SafeMath: multiplication overflow");
1071	 return c;
1072	 }
1073	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
1074	 require(b > 0, "SafeMath: division by zero");
1075	 return a / b;
1076	 }
1077	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
1078	 require(b > 0, "SafeMath: modulo by zero");
1079	 return a % b;
1080	 }
1081	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
1082	 require(b <= a, errorMessage);
1083	 return a - b;
1084	 }
1085	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
1086	 require(b > 0, errorMessage);
1087	 return a / b;
1088	 }
1089	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
1090	 require(b > 0, errorMessage);
1091	 return a % b;
1092	 }
1093	 }
1094	 pragma solidity >=0.6.2 <0.8.0;
1095	 library Address {
1096	 function isContract(address account) internal view returns (bool) {
1097	 uint256 size;
1098	 assembly {
1099	 size := extcodesize(account) }
1100	 return size > 0;
1101	 }
1102	 function sendValue(address payable recipient, uint256 amount) internal {
1103	 require(address(this).balance >= amount, "Address: insufficient balance");
1104	 (bool success, ) = recipient.call{
1105	 value: amount }
1106	 ("");
1107	 require(success, "Address: unable to send value, recipient may have reverted");
1108	 }
1109	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
1110	 return functionCall(target, data, "Address: low-level call failed");
1111	 }
1112	 function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
1113	 return functionCallWithValue(target, data, 0, errorMessage);
1114	 }
1115	 function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
1116	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
1117	 }
1118	 function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
1119	 require(address(this).balance >= value, "Address: insufficient balance for call");
1120	 require(isContract(target), "Address: call to non-contract");
1121	 (bool success, bytes memory returndata) = target.call{
1122	 value: value }
1123	 (data);
1124	 return _verifyCallResult(success, returndata, errorMessage);
1125	 }
1126	 function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
1127	 return functionStaticCall(target, data, "Address: low-level static call failed");
1128	 }
1129	 function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
1130	 require(isContract(target), "Address: static call to non-contract");
1131	 (bool success, bytes memory returndata) = target.staticcall(data);
1132	 return _verifyCallResult(success, returndata, errorMessage);
1133	 }
1134	 function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
1135	 return functionDelegateCall(target, data, "Address: low-level delegate call failed");
1136	 }
1137	 function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
1138	 require(isContract(target), "Address: delegate call to non-contract");
1139	 (bool success, bytes memory returndata) = target.delegatecall(data);
1140	 return _verifyCallResult(success, returndata, errorMessage);
1141	 }
1142	 function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
1143	 if (success) {
1144	 return returndata;
1145	 }
1146	 else {
1147	 if (returndata.length > 0) {
1148	 assembly {
1149	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
1150	 }
1151	 else {
1152	 revert(errorMessage);
1153	 }
1154	 }
1155	 }
1156	 }
1157	 pragma solidity 0.6.12;
1158	 interface IFundProxy {
1159	 function implementation() external view returns (address);
1160	 }
1161	 pragma solidity 0.6.12;
1162	 interface IStrategy {
1163	 function name() external pure returns (string memory);
1164	 function version() external pure returns (string memory);
1165	 function underlying() external view returns (address);
1166	 function fund() external view returns (address);
1167	 function creator() external view returns (address);
1168	 function withdrawAllToFund() external;
1169	 function withdrawToFund(uint256 amount) external;
1170	 function investedUnderlyingBalance() external view returns (uint256);
1171	 function doHardWork() external;
1172	 }
