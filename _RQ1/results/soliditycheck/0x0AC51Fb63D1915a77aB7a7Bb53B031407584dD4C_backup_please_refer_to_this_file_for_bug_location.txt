row number 
1	  pragma abicoder v2;
2	 pragma solidity >=0.6.0 <0.8.0;
3	 abstract contract Context {
4	 function _msgSender() internal view virtual returns (address payable) {
5	 return msg.sender;
6	 }
7	 function _msgData() internal view virtual returns (bytes memory) {
8	 this;
9	 return msg.data;
10	 }
11	 }
12	 pragma solidity >=0.6.0 <0.8.0;
13	 interface IERC20 {
14	 function totalSupply() external view returns (uint256);
15	 function balanceOf(address account) external view returns (uint256);
16	 function transfer(address recipient, uint256 amount) external returns (bool);
17	 function allowance(address owner, address spender) external view returns (uint256);
18	 function approve(address spender, uint256 amount) external returns (bool);
19	 function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
20	 event Transfer(address indexed from, address indexed to, uint256 value);
21	 event Approval(address indexed owner, address indexed spender, uint256 value);
22	 }
23	 pragma solidity >=0.6.0 <0.8.0;
24	 abstract contract Ownable is Context {
25	 address private _owner;
26	 event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
27	 constructor () internal {
28	 address msgSender = _msgSender();
29	 _owner = msgSender;
30	 emit OwnershipTransferred(address(0), msgSender);
31	 }
32	 function owner() public view virtual returns (address) {
33	 return _owner;
34	 }
35	 modifier onlyOwner() {
36	 require(owner() == _msgSender(), "Ownable: caller is not the owner");
37	 _;
38	 }
39	 function renounceOwnership() public virtual onlyOwner {
40	 emit OwnershipTransferred(_owner, address(0));
41	 _owner = address(0);
42	 }
43	 function transferOwnership(address newOwner) public virtual onlyOwner {
44	 require(newOwner != address(0), "Ownable: new owner is the zero address");
45	 emit OwnershipTransferred(_owner, newOwner);
46	 _owner = newOwner;
47	 }
48	 }
49	 pragma solidity >=0.6.0 <0.8.0;
50	 contract ERC20 is Context, IERC20 {
51	 using SafeMath for uint256;
52	 mapping (address => uint256) private _balances;
53	 mapping (address => mapping (address => uint256)) private _allowances;
54	 uint256 private _totalSupply;
55	 string private _name;
56	 string private _symbol;
57	 uint8 private _decimals;
58	 constructor (string memory name_, string memory symbol_) public {
59	 _name = name_;
60	 _symbol = symbol_;
61	 _decimals = 18;
62	 }
63	 function name() public view virtual returns (string memory) {
64	 return _name;
65	 }
66	 function symbol() public view virtual returns (string memory) {
67	 return _symbol;
68	 }
69	 function decimals() public view virtual returns (uint8) {
70	 return _decimals;
71	 }
72	 function totalSupply() public view virtual override returns (uint256) {
73	 return _totalSupply;
74	 }
75	 function balanceOf(address account) public view virtual override returns (uint256) {
76	 return _balances[account];
77	 }
78	 function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
79	 _transfer(_msgSender(), recipient, amount);
80	 return true;
81	 }
82	 function allowance(address owner, address spender) public view virtual override returns (uint256) {
83	 return _allowances[owner][spender];
84	 }
85	 function approve(address spender, uint256 amount) public virtual override returns (bool) {
86	 _approve(_msgSender(), spender, amount);
87	 return true;
88	 }
89	 function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
90	 _transfer(sender, recipient, amount);
91	 _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
92	 return true;
93	 }
94	 function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
95	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
96	 return true;
97	 }
98	 function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
99	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
100	 return true;
101	 }
102	 function _transfer(address sender, address recipient, uint256 amount) internal virtual {
103	 require(sender != address(0), "ERC20: transfer from the zero address");
104	 require(recipient != address(0), "ERC20: transfer to the zero address");
105	 _beforeTokenTransfer(sender, recipient, amount);
106	 _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
107	 _balances[recipient] = _balances[recipient].add(amount);
108	 emit Transfer(sender, recipient, amount);
109	 }
110	 function _mint(address account, uint256 amount) internal virtual {
111	 require(account != address(0), "ERC20: mint to the zero address");
112	 _beforeTokenTransfer(address(0), account, amount);
113	 _totalSupply = _totalSupply.add(amount);
114	 _balances[account] = _balances[account].add(amount);
115	 emit Transfer(address(0), account, amount);
116	 }
117	 function _burn(address account, uint256 amount) internal virtual {
118	 require(account != address(0), "ERC20: burn from the zero address");
119	 _beforeTokenTransfer(account, address(0), amount);
120	 _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
121	 _totalSupply = _totalSupply.sub(amount);
122	 emit Transfer(account, address(0), amount);
123	 }
124	 function _approve(address owner, address spender, uint256 amount) internal virtual {
125	 require(owner != address(0), "ERC20: approve from the zero address");
126	 require(spender != address(0), "ERC20: approve to the zero address");
127	 _allowances[owner][spender] = amount;
128	 emit Approval(owner, spender, amount);
129	 }
130	 function _setupDecimals(uint8 decimals_) internal virtual {
131	 _decimals = decimals_;
132	 }
133	 function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {
134	 }
135	 }
136	 pragma solidity >=0.5.0;
137	 interface IUniswapV3MintCallback {
138	 function uniswapV3MintCallback( uint256 amount0Owed, uint256 amount1Owed, bytes calldata data ) external;
139	 }
140	 pragma solidity >=0.5.0;
141	 interface IUniswapV3SwapCallback {
142	 function uniswapV3SwapCallback( int256 amount0Delta, int256 amount1Delta, bytes calldata data ) external;
143	 }
144	 pragma solidity 0.7.6;
145	 interface IVault {
146	 function deposit( uint256, uint256, address ) external returns (uint256);
147	 function withdraw( uint256, address, address ) external returns (uint256, uint256);
148	 function rebalance( int24 _baseLower, int24 _baseUpper, int24 _limitLower, int24 _limitUpper, address feeRecipient, int256 swapQuantity ) external;
149	 function getTotalAmounts() external view returns (uint256, uint256);
150	 event Deposit( address indexed sender, address indexed to, uint256 shares, uint256 amount0, uint256 amount1 );
151	 event Withdraw( address indexed sender, address indexed to, uint256 shares, uint256 amount0, uint256 amount1 );
152	 event Rebalance( int24 tick, uint256 totalAmount0, uint256 totalAmount1, uint256 feeAmount0, uint256 feeAmount1, uint256 totalSupply );
153	 }
154	 pragma solidity >=0.5.0;
155	 interface IUniswapV3PoolImmutables {
156	 function factory() external view returns (address);
157	 function token0() external view returns (address);
158	 function token1() external view returns (address);
159	 function fee() external view returns (uint24);
160	 function tickSpacing() external view returns (int24);
161	 function maxLiquidityPerTick() external view returns (uint128);
162	 }
163	 pragma solidity >=0.5.0;
164	 interface IUniswapV3PoolState {
165	 function slot0() external view returns ( uint160 sqrtPriceX96, int24 tick, uint16 observationIndex, uint16 observationCardinality, uint16 observationCardinalityNext, uint8 feeProtocol, bool unlocked );
166	 function feeGrowthGlobal0X128() external view returns (uint256);
167	 function feeGrowthGlobal1X128() external view returns (uint256);
168	 function protocolFees() external view returns (uint128 token0, uint128 token1);
169	 function liquidity() external view returns (uint128);
170	 function ticks(int24 tick) external view returns ( uint128 liquidityGross, int128 liquidityNet, uint256 feeGrowthOutside0X128, uint256 feeGrowthOutside1X128, int56 tickCumulativeOutside, uint160 secondsPerLiquidityOutsideX128, uint32 secondsOutside, bool initialized );
171	 function tickBitmap(int16 wordPosition) external view returns (uint256);
172	 function positions(bytes32 key) external view returns ( uint128 _liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, uint128 tokensOwed0, uint128 tokensOwed1 );
173	 function observations(uint256 index) external view returns ( uint32 blockTimestamp, int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128, bool initialized );
174	 }
175	 pragma solidity >=0.5.0;
176	 interface IUniswapV3PoolDerivedState {
177	 function observe(uint32[] calldata secondsAgos) external view returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);
178	 function snapshotCumulativesInside(int24 tickLower, int24 tickUpper) external view returns ( int56 tickCumulativeInside, uint160 secondsPerLiquidityInsideX128, uint32 secondsInside );
179	 }
180	 pragma solidity >=0.5.0;
181	 interface IUniswapV3PoolActions {
182	 function initialize(uint160 sqrtPriceX96) external;
183	 function mint( address recipient, int24 tickLower, int24 tickUpper, uint128 amount, bytes calldata data ) external returns (uint256 amount0, uint256 amount1);
184	 function collect( address recipient, int24 tickLower, int24 tickUpper, uint128 amount0Requested, uint128 amount1Requested ) external returns (uint128 amount0, uint128 amount1);
185	 function burn( int24 tickLower, int24 tickUpper, uint128 amount ) external returns (uint256 amount0, uint256 amount1);
186	 function swap( address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes calldata data ) external returns (int256 amount0, int256 amount1);
187	 function flash( address recipient, uint256 amount0, uint256 amount1, bytes calldata data ) external;
188	 function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;
189	 }
190	 pragma solidity >=0.5.0;
191	 interface IUniswapV3PoolOwnerActions {
192	 function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;
193	 function collectProtocol( address recipient, uint128 amount0Requested, uint128 amount1Requested ) external returns (uint128 amount0, uint128 amount1);
194	 }
195	 pragma solidity >=0.5.0;
196	 interface IUniswapV3PoolEvents {
197	 event Initialize(uint160 sqrtPriceX96, int24 tick);
198	 event Mint( address sender, address indexed owner, int24 indexed tickLower, int24 indexed tickUpper, uint128 amount, uint256 amount0, uint256 amount1 );
199	 event Collect( address indexed owner, address recipient, int24 indexed tickLower, int24 indexed tickUpper, uint128 amount0, uint128 amount1 );
200	 event Burn( address indexed owner, int24 indexed tickLower, int24 indexed tickUpper, uint128 amount, uint256 amount0, uint256 amount1 );
201	 event Swap( address indexed sender, address indexed recipient, int256 amount0, int256 amount1, uint160 sqrtPriceX96, uint128 liquidity, int24 tick );
202	 event Flash( address indexed sender, address indexed recipient, uint256 amount0, uint256 amount1, uint256 paid0, uint256 paid1 );
203	 event IncreaseObservationCardinalityNext( uint16 observationCardinalityNextOld, uint16 observationCardinalityNextNew );
204	 event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);
205	 event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);
206	 }
207	 pragma solidity =0.7.6;
208	 contract HypervisorFactory is Ownable {
209	 IUniswapV3Factory public uniswapV3Factory;
210	 mapping(address => mapping(address => mapping(uint24 => address))) public getHypervisor;
211	 address[] public allHypervisors;
212	 event HypervisorCreated(address token0, address token1, uint24 fee, address hypervisor, uint256);
213	 constructor(address _uniswapV3Factory) {
214	 uniswapV3Factory = IUniswapV3Factory(_uniswapV3Factory);
215	 }
216	 function allHypervisorsLength() external view returns (uint256) {
217	 return allHypervisors.length;
218	 }
219	 function createHypervisor( address tokenA, address tokenB, uint24 fee, int24 _baseLower, int24 _baseUpper, int24 _limitLower, int24 _limitUpper ) external onlyOwner returns (address hypervisor) {
220	 require(tokenA != tokenB, 'SF: IDENTICAL_ADDRESSES');
221	 (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
222	 require(token0 != address(0), 'SF: ZERO_ADDRESS');
223	 require(getHypervisor[token0][token1][fee] == address(0), 'SF: HYPERVISOR_EXISTS');
224	 int24 tickSpacing = uniswapV3Factory.feeAmountTickSpacing(fee);
225	 require(tickSpacing != 0, 'SF: INCORRECT_FEE');
226	 address pool = uniswapV3Factory.getPool(token0, token1, fee);
227	 if (pool == address(0)) {
228	 pool = uniswapV3Factory.createPool(token0, token1, fee);
229	 }
230	 hypervisor = address( new Hypervisor{
231	 salt: keccak256(abi.encodePacked(token0, token1, fee, tickSpacing))}
232	 (pool, owner(), _baseLower, _baseUpper, _limitLower,_limitUpper) );
233	 getHypervisor[token0][token1][fee] = hypervisor;
234	 getHypervisor[token1][token0][fee] = hypervisor;
235	 allHypervisors.push(hypervisor);
236	 emit HypervisorCreated(token0, token1, fee, hypervisor, allHypervisors.length);
237	 }
238	 }
239	 pragma solidity >=0.5.0;
240	 interface IUniswapV3Factory {
241	 event OwnerChanged(address indexed oldOwner, address indexed newOwner);
242	 event PoolCreated( address indexed token0, address indexed token1, uint24 indexed fee, int24 tickSpacing, address pool );
243	 event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);
244	 function owner() external view returns (address);
245	 function feeAmountTickSpacing(uint24 fee) external view returns (int24);
246	 function getPool( address tokenA, address tokenB, uint24 fee ) external view returns (address pool);
247	 function createPool( address tokenA, address tokenB, uint24 fee ) external returns (address pool);
248	 function setOwner(address _owner) external;
249	 function enableFeeAmount(uint24 fee, int24 tickSpacing) external;
250	 }
251	 pragma solidity 0.7.6;
252	 contract Hypervisor is IVault, IUniswapV3MintCallback, IUniswapV3SwapCallback, ERC20 {
253	 using SafeERC20 for IERC20;
254	 using SafeMath for uint256;
255	 using SignedSafeMath for int256;
256	 IUniswapV3Pool public pool;
257	 IERC20 public token0;
258	 IERC20 public token1;
259	 uint24 public fee;
260	 int24 public tickSpacing;
261	 int24 public baseLower;
262	 int24 public baseUpper;
263	 int24 public limitLower;
264	 int24 public limitUpper;
265	 address public owner;
266	 uint256 public deposit0Max;
267	 uint256 public deposit1Max;
268	 uint256 public maxTotalSupply;
269	 mapping(address=>bool) public list;
270	 bool public whitelisted;
271	 uint256 constant public PRECISION = 1e36;
272	 constructor( address _pool, address _owner, int24 _baseLower, int24 _baseUpper, int24 _limitLower, int24 _limitUpper ) ERC20("Visor ETH-USDT Uni v3", "vETH-USDTV3-1") {
273	 pool = IUniswapV3Pool(_pool);
274	 token0 = IERC20(pool.token0());
275	 token1 = IERC20(pool.token1());
276	 fee = pool.fee();
277	 tickSpacing = pool.tickSpacing();
278	 owner = _owner;
279	 baseLower = _baseLower;
280	 baseUpper = _baseUpper;
281	 limitLower = _limitLower;
282	 limitUpper = _limitUpper;
283	 maxTotalSupply = 0;
284	 deposit0Max = uint256(-1);
285	 deposit1Max = uint256(-1);
286	 whitelisted = true;
287	 }
288	 function deposit( uint256 deposit0, uint256 deposit1, address to ) external override returns (uint256 shares) {
289	 require(deposit0 > 0 || deposit1 > 0, "deposits must be nonzero");
290	 require(deposit0 < deposit0Max && deposit1 < deposit1Max, "deposits must be less than maximum amounts");
291	 require(to != address(0) && to != address(this), "to");
292	 if(whitelisted) {
293	 require(list[to], "must be on the list");
294	 }
295	 (uint128 baseLiquidity,,) = _position(baseLower, baseUpper);
296	 if (baseLiquidity > 0) {
297	 pool.burn(baseLower, baseUpper, 0);
298	 }
299	 (uint128 limitLiquidity,,) = _position(limitLower, limitUpper);
300	 if (limitLiquidity > 0) {
301	 pool.burn(limitLower, limitUpper, 0);
302	 }
303	 uint160 sqrtPrice = TickMath.getSqrtRatioAtTick(currentTick());
304	 uint256 price = FullMath.mulDiv(uint256(sqrtPrice).mul(uint256(sqrtPrice)), PRECISION, 2**(96 * 2));
305	 (uint256 pool0, uint256 pool1) = getTotalAmounts();
306	 uint256 deposit0PricedInToken1 = deposit0.mul(price).div(PRECISION);
307	 shares = deposit1.add(deposit0PricedInToken1);
308	 if (deposit0 > 0) {
309	 token0.safeTransferFrom(msg.sender, address(this), deposit0);
310	 }
311	 if (deposit1 > 0) {
312	 token1.safeTransferFrom(msg.sender, address(this), deposit1);
313	 }
314	 if (totalSupply() != 0) {
315	 uint256 pool0PricedInToken1 = pool0.mul(price).div(PRECISION);
316	 shares = shares.mul(totalSupply()).div(pool0PricedInToken1.add(pool1));
317	 }
318	 _mint(to, shares);
319	 emit Deposit(msg.sender, to, shares, deposit0, deposit1);
320	 require(maxTotalSupply == 0 || totalSupply() <= maxTotalSupply, "maxTotalSupply");
321	 }
322	 function withdraw( uint256 shares, address to, address from ) external override returns (uint256 amount0, uint256 amount1) {
323	 require(shares > 0, "shares");
324	 require(to != address(0), "to");
325	 (uint256 base0, uint256 base1) = _burnLiquidity(baseLower, baseUpper, _liquidityForShares(baseLower, baseUpper, shares), to, false);
326	 (uint256 limit0, uint256 limit1) = _burnLiquidity(limitLower, limitUpper, _liquidityForShares(limitLower, limitUpper, shares), to, false);
327	 uint256 totalSupply = totalSupply();
328	 uint256 unusedAmount0 = token0.balanceOf(address(this)).mul(shares).div(totalSupply);
329	 uint256 unusedAmount1 = token1.balanceOf(address(this)).mul(shares).div(totalSupply);
330	 if (unusedAmount0 > 0) token0.safeTransfer(to, unusedAmount0);
331	 if (unusedAmount1 > 0) token1.safeTransfer(to, unusedAmount1);
332	 amount0 = base0.add(limit0).add(unusedAmount0);
333	 amount1 = base1.add(limit1).add(unusedAmount1);
334	 require(from == msg.sender || IUniversalVault(from).owner() == msg.sender, "Sender must own the tokens");
335	 _burn(from, shares);
336	 emit Withdraw(from, to, shares, amount0, amount1);
337	 }
338	 function rebalance( int24 _baseLower, int24 _baseUpper, int24 _limitLower, int24 _limitUpper, address feeRecipient, int256 swapQuantity ) external override onlyOwner {
339	 require(_baseLower < _baseUpper && _baseLower % tickSpacing == 0 && _baseUpper % tickSpacing == 0, "base position invalid");
340	 require(_limitLower < _limitUpper && _limitLower % tickSpacing == 0 && _limitUpper % tickSpacing == 0, "limit position invalid");
341	 (uint128 baseLiquidity,,) = _position(baseLower, baseUpper);
342	 if (baseLiquidity > 0) {
343	 pool.burn(baseLower, baseUpper, 0);
344	 }
345	 (uint128 limitLiquidity,,) = _position(limitLower, limitUpper);
346	 if (limitLiquidity > 0) {
347	 pool.burn(limitLower, limitUpper, 0);
348	 }
349	 (, uint256 feesLimit0, uint256 feesLimit1) = _position(baseLower, baseUpper);
350	 (, uint256 feesBase0, uint256 feesBase1) = _position(limitLower, limitUpper);
351	 uint256 fees0 = feesBase0.add(feesLimit0);
352	 uint256 fees1 = feesBase1.add(feesLimit1);
353	 _burnLiquidity(baseLower, baseUpper, baseLiquidity, address(this), true);
354	 _burnLiquidity(limitLower, limitUpper, limitLiquidity, address(this), true);
355	 if(fees0 > 0) token0.safeTransfer(feeRecipient, fees0.div(10));
356	 if(fees1 > 0) token1.safeTransfer(feeRecipient, fees1.div(10));
357	 emit Rebalance( currentTick(), token0.balanceOf(address(this)), token1.balanceOf(address(this)), fees0, fees1, totalSupply() );
358	 if (swapQuantity != 0) {
359	 pool.swap( address(this), swapQuantity > 0, swapQuantity > 0 ? swapQuantity : -swapQuantity, swapQuantity > 0 ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1, abi.encode(address(this)) );
360	 }
361	 baseLower = _baseLower;
362	 baseUpper = _baseUpper;
363	 baseLiquidity = _liquidityForAmounts( baseLower, baseUpper, token0.balanceOf(address(this)), token1.balanceOf(address(this)) );
364	 _mintLiquidity(baseLower, baseUpper, baseLiquidity, address(this));
365	 limitLower = _limitLower;
366	 limitUpper = _limitUpper;
367	 limitLiquidity = _liquidityForAmounts( limitLower, limitUpper, token0.balanceOf(address(this)), token1.balanceOf(address(this)) );
368	 _mintLiquidity(limitLower, limitUpper, limitLiquidity, address(this));
369	 }
370	 function _mintLiquidity( int24 tickLower, int24 tickUpper, uint128 liquidity, address payer ) internal returns (uint256 amount0, uint256 amount1) {
371	 if (liquidity > 0) {
372	 (amount0, amount1) = pool.mint( address(this), tickLower, tickUpper, liquidity, abi.encode(payer) );
373	 }
374	 }
375	 function _burnLiquidity( int24 tickLower, int24 tickUpper, uint128 liquidity, address to, bool collectAll ) internal returns (uint256 amount0, uint256 amount1) {
376	 if (liquidity > 0) {
377	 (uint256 owed0, uint256 owed1) = pool.burn(tickLower, tickUpper, liquidity);
378	 uint128 collect0 = collectAll ? type(uint128).max : _uint128Safe(owed0);
379	 uint128 collect1 = collectAll ? type(uint128).max : _uint128Safe(owed1);
380	 if (collect0 > 0 || collect1 > 0) {
381	 (amount0, amount1) = pool.collect(to, tickLower, tickUpper, collect0, collect1);
382	 }
383	 }
384	 }
385	 function _liquidityForShares( int24 tickLower, int24 tickUpper, uint256 shares ) internal view returns (uint128) {
386	 (uint128 position,,) = _position(tickLower, tickUpper);
387	 return _uint128Safe(uint256(position).mul(shares).div(totalSupply()));
388	 }
389	 function _position(int24 tickLower, int24 tickUpper) internal view returns (uint128 liquidity, uint128 tokensOwed0, uint128 tokensOwed1) {
390	 bytes32 positionKey = keccak256(abi.encodePacked(address(this), tickLower, tickUpper));
391	 (liquidity, , , tokensOwed0, tokensOwed1) = pool.positions(positionKey);
392	 }
393	 function uniswapV3MintCallback( uint256 amount0, uint256 amount1, bytes calldata data ) external override {
394	 require(msg.sender == address(pool));
395	 address payer = abi.decode(data, (address));
396	 if (payer == address(this)) {
397	 if (amount0 > 0) token0.safeTransfer(msg.sender, amount0);
398	 if (amount1 > 0) token1.safeTransfer(msg.sender, amount1);
399	 }
400	 else {
401	 if (amount0 > 0) token0.safeTransferFrom(payer, msg.sender, amount0);
402	 if (amount1 > 0) token1.safeTransferFrom(payer, msg.sender, amount1);
403	 }
404	 }
405	 function uniswapV3SwapCallback( int256 amount0Delta, int256 amount1Delta, bytes calldata data ) external override {
406	 require(msg.sender == address(pool));
407	 address payer = abi.decode(data, (address));
408	 if (amount0Delta > 0) {
409	 if (payer == address(this)) {
410	 token0.safeTransfer(msg.sender, uint256(amount0Delta));
411	 }
412	 else {
413	 token0.safeTransferFrom(payer, msg.sender, uint256(amount0Delta));
414	 }
415	 }
416	 else if (amount1Delta > 0) {
417	 if (payer == address(this)) {
418	 token1.safeTransfer(msg.sender, uint256(amount1Delta));
419	 }
420	 else {
421	 token1.safeTransferFrom(payer, msg.sender, uint256(amount1Delta));
422	 }
423	 }
424	 }
425	 function getTotalAmounts() public view override returns (uint256 total0, uint256 total1) {
426	 (, uint256 base0, uint256 base1) = getBasePosition();
427	 (, uint256 limit0, uint256 limit1) = getLimitPosition();
428	 total0 = token0.balanceOf(address(this)).add(base0).add(limit0);
429	 total1 = token1.balanceOf(address(this)).add(base1).add(limit1);
430	 }
431	 function getBasePosition() public view returns ( uint128 liquidity, uint256 amount0, uint256 amount1 ) {
432	 (uint128 positionLiquidity, uint128 tokensOwed0, uint128 tokensOwed1) = _position(baseLower, baseUpper);
433	 (amount0, amount1) = _amountsForLiquidity(baseLower, baseUpper, positionLiquidity);
434	 amount0 = amount0.add(uint256(tokensOwed0));
435	 amount1 = amount1.add(uint256(tokensOwed1));
436	 liquidity = positionLiquidity;
437	 }
438	 function getLimitPosition() public view returns ( uint128 liquidity, uint256 amount0, uint256 amount1 ) {
439	 (uint128 positionLiquidity, uint128 tokensOwed0, uint128 tokensOwed1) = _position(limitLower, limitUpper);
440	 (amount0, amount1) = _amountsForLiquidity(limitLower, limitUpper, positionLiquidity);
441	 amount0 = amount0.add(uint256(tokensOwed0));
442	 amount1 = amount1.add(uint256(tokensOwed1));
443	 liquidity = positionLiquidity;
444	 }
445	 function _amountsForLiquidity( int24 tickLower, int24 tickUpper, uint128 liquidity ) internal view returns (uint256, uint256) {
446	 (uint160 sqrtRatioX96, , , , , , ) = pool.slot0();
447	 return LiquidityAmounts.getAmountsForLiquidity( sqrtRatioX96, TickMath.getSqrtRatioAtTick(tickLower), TickMath.getSqrtRatioAtTick(tickUpper), liquidity );
448	 }
449	 function _liquidityForAmounts( int24 tickLower, int24 tickUpper, uint256 amount0, uint256 amount1 ) internal view returns (uint128) {
450	 (uint160 sqrtRatioX96, , , , , , ) = pool.slot0();
451	 return LiquidityAmounts.getLiquidityForAmounts( sqrtRatioX96, TickMath.getSqrtRatioAtTick(tickLower), TickMath.getSqrtRatioAtTick(tickUpper), amount0, amount1 );
452	 }
453	 function currentTick() public view returns (int24 tick) {
454	 (, tick, , , , , ) = pool.slot0();
455	 }
456	 function _uint128Safe(uint256 x) internal pure returns (uint128) {
457	 assert(x <= type(uint128).max);
458	 return uint128(x);
459	 }
460	 function setMaxTotalSupply(uint256 _maxTotalSupply) external onlyOwner {
461	 maxTotalSupply = _maxTotalSupply;
462	 }
463	 function setDepositMax(uint256 _deposit0Max, uint256 _deposit1Max) external onlyOwner {
464	 deposit0Max = _deposit0Max;
465	 deposit1Max = _deposit1Max;
466	 }
467	 function emergencyWithdraw(IERC20 token, uint256 amount) external onlyOwner {
468	 token.safeTransfer(msg.sender, amount);
469	 }
470	 function emergencyBurn( int24 tickLower, int24 tickUpper, uint128 liquidity ) external onlyOwner {
471	 pool.burn(tickLower, tickUpper, liquidity);
472	 pool.collect(msg.sender, tickLower, tickUpper, type(uint128).max, type(uint128).max);
473	 }
474	 function appendList(address[] memory listed) external onlyOwner {
475	 for (uint8 i; i < listed.length; i++) {
476	 list[listed[i]] = true;
477	 }
478	 }
479	 function toggleWhitelist() external onlyOwner {
480	 whitelisted = whitelisted ? false : true;
481	 }
482	 function transferOwnership(address newOwner) external onlyOwner {
483	 owner = newOwner;
484	 }
485	 modifier onlyOwner {
486	 require(msg.sender == owner, "only owner");
487	 _;
488	 }
489	 }
490	 pragma solidity >=0.6.0 <0.8.0;
491	 library SafeMath {
492	 function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
493	 uint256 c = a + b;
494	 if (c < a) return (false, 0);
495	 return (true, c);
496	 }
497	 function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
498	 if (b > a) return (false, 0);
499	 return (true, a - b);
500	 }
501	 function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
502	 if (a == 0) return (true, 0);
503	 uint256 c = a * b;
504	 if (c / a != b) return (false, 0);
505	 return (true, c);
506	 }
507	 function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
508	 if (b == 0) return (false, 0);
509	 return (true, a / b);
510	 }
511	 function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
512	 if (b == 0) return (false, 0);
513	 return (true, a % b);
514	 }
515	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
516	 uint256 c = a + b;
517	 require(c >= a, "SafeMath: addition overflow");
518	 return c;
519	 }
520	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
521	 require(b <= a, "SafeMath: subtraction overflow");
522	 return a - b;
523	 }
524	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
525	 if (a == 0) return 0;
526	 uint256 c = a * b;
527	 require(c / a == b, "SafeMath: multiplication overflow");
528	 return c;
529	 }
530	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
531	 require(b > 0, "SafeMath: division by zero");
532	 return a / b;
533	 }
534	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
535	 require(b > 0, "SafeMath: modulo by zero");
536	 return a % b;
537	 }
538	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
539	 require(b <= a, errorMessage);
540	 return a - b;
541	 }
542	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
543	 require(b > 0, errorMessage);
544	 return a / b;
545	 }
546	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
547	 require(b > 0, errorMessage);
548	 return a % b;
549	 }
550	 }
551	 pragma solidity >=0.6.0 <0.8.0;
552	 library SignedSafeMath {
553	 int256 constant private _INT256_MIN = -2**255;
554	 function mul(int256 a, int256 b) internal pure returns (int256) {
555	 if (a == 0) {
556	 return 0;
557	 }
558	 require(!(a == -1 && b == _INT256_MIN), "SignedSafeMath: multiplication overflow");
559	 int256 c = a * b;
560	 require(c / a == b, "SignedSafeMath: multiplication overflow");
561	 return c;
562	 }
563	 function div(int256 a, int256 b) internal pure returns (int256) {
564	 require(b != 0, "SignedSafeMath: division by zero");
565	 require(!(b == -1 && a == _INT256_MIN), "SignedSafeMath: division overflow");
566	 int256 c = a / b;
567	 return c;
568	 }
569	 function sub(int256 a, int256 b) internal pure returns (int256) {
570	 int256 c = a - b;
571	 require((b >= 0 && c <= a) || (b < 0 && c > a), "SignedSafeMath: subtraction overflow");
572	 return c;
573	 }
574	 function add(int256 a, int256 b) internal pure returns (int256) {
575	 int256 c = a + b;
576	 require((b >= 0 && c >= a) || (b < 0 && c < a), "SignedSafeMath: addition overflow");
577	 return c;
578	 }
579	 }
580	 pragma solidity >=0.6.0 <0.8.0;
581	 library SafeERC20 {
582	 using SafeMath for uint256;
583	 using Address for address;
584	 function safeTransfer(IERC20 token, address to, uint256 value) internal {
585	 _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
586	 }
587	 function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
588	 _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
589	 }
590	 function safeApprove(IERC20 token, address spender, uint256 value) internal {
591	 require((value == 0) || (token.allowance(address(this), spender) == 0), "SafeERC20: approve from non-zero to non-zero allowance" );
592	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
593	 }
594	 function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
595	 uint256 newAllowance = token.allowance(address(this), spender).add(value);
596	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
597	 }
598	 function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
599	 uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
600	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
601	 }
602	 function _callOptionalReturn(IERC20 token, bytes memory data) private {
603	 bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
604	 if (returndata.length > 0) {
605	 require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
606	 }
607	 }
608	 }
609	 pragma solidity >=0.5.0;
610	 interface IUniswapV3Pool is IUniswapV3PoolImmutables, IUniswapV3PoolState, IUniswapV3PoolDerivedState, IUniswapV3PoolActions, IUniswapV3PoolOwnerActions, IUniswapV3PoolEvents {
611	 }
612	 pragma solidity >=0.5.0;
613	 library TickMath {
614	 int24 internal constant MIN_TICK = -887272;
615	 int24 internal constant MAX_TICK = -MIN_TICK;
616	 uint160 internal constant MIN_SQRT_RATIO = 4295128739;
617	 uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;
618	 function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {
619	 uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));
620	 require(absTick <= uint256(MAX_TICK), 'T');
621	 uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;
622	 if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;
623	 if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;
624	 if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;
625	 if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;
626	 if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;
627	 if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;
628	 if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;
629	 if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;
630	 if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;
631	 if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;
632	 if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;
633	 if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;
634	 if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;
635	 if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;
636	 if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;
637	 if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;
638	 if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;
639	 if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;
640	 if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;
641	 if (tick > 0) ratio = type(uint256).max / ratio;
642	 sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));
643	 }
644	 function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {
645	 require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');
646	 uint256 ratio = uint256(sqrtPriceX96) << 32;
647	 uint256 r = ratio;
648	 uint256 msb = 0;
649	 assembly {
650	 let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) msb := or(msb, f) r := shr(f, r) }
651	 assembly {
652	 let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF)) msb := or(msb, f) r := shr(f, r) }
653	 assembly {
654	 let f := shl(5, gt(r, 0xFFFFFFFF)) msb := or(msb, f) r := shr(f, r) }
655	 assembly {
656	 let f := shl(4, gt(r, 0xFFFF)) msb := or(msb, f) r := shr(f, r) }
657	 assembly {
658	 let f := shl(3, gt(r, 0xFF)) msb := or(msb, f) r := shr(f, r) }
659	 assembly {
660	 let f := shl(2, gt(r, 0xF)) msb := or(msb, f) r := shr(f, r) }
661	 assembly {
662	 let f := shl(1, gt(r, 0x3)) msb := or(msb, f) r := shr(f, r) }
663	 assembly {
664	 let f := gt(r, 0x1) msb := or(msb, f) }
665	 if (msb >= 128) r = ratio >> (msb - 127);
666	 else r = ratio << (127 - msb);
667	 int256 log_2 = (int256(msb) - 128) << 64;
668	 assembly {
669	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(63, f)) r := shr(f, r) }
670	 assembly {
671	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(62, f)) r := shr(f, r) }
672	 assembly {
673	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(61, f)) r := shr(f, r) }
674	 assembly {
675	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(60, f)) r := shr(f, r) }
676	 assembly {
677	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(59, f)) r := shr(f, r) }
678	 assembly {
679	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(58, f)) r := shr(f, r) }
680	 assembly {
681	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(57, f)) r := shr(f, r) }
682	 assembly {
683	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(56, f)) r := shr(f, r) }
684	 assembly {
685	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(55, f)) r := shr(f, r) }
686	 assembly {
687	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(54, f)) r := shr(f, r) }
688	 assembly {
689	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(53, f)) r := shr(f, r) }
690	 assembly {
691	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(52, f)) r := shr(f, r) }
692	 assembly {
693	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(51, f)) r := shr(f, r) }
694	 assembly {
695	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(50, f)) }
696	 int256 log_sqrt10001 = log_2 * 255738958999603826347141;
697	 int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);
698	 int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);
699	 tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;
700	 }
701	 }
702	 pragma solidity >=0.4.0;
703	 library FullMath {
704	 function mulDiv( uint256 a, uint256 b, uint256 denominator ) internal pure returns (uint256 result) {
705	 uint256 prod0;
706	 uint256 prod1;
707	 assembly {
708	 let mm := mulmod(a, b, not(0)) prod0 := mul(a, b) prod1 := sub(sub(mm, prod0), lt(mm, prod0)) }
709	 if (prod1 == 0) {
710	 require(denominator > 0);
711	 assembly {
712	 result := div(prod0, denominator) }
713	 return result;
714	 }
715	 require(denominator > prod1);
716	 uint256 remainder;
717	 assembly {
718	 remainder := mulmod(a, b, denominator) }
719	 assembly {
720	 prod1 := sub(prod1, gt(remainder, prod0)) prod0 := sub(prod0, remainder) }
721	 uint256 twos = -denominator & denominator;
722	 assembly {
723	 denominator := div(denominator, twos) }
724	 assembly {
725	 prod0 := div(prod0, twos) }
726	 assembly {
727	 twos := add(div(sub(0, twos), twos), 1) }
728	 prod0 |= prod1 * twos;
729	 uint256 inv = (3 * denominator) ^ 2;
730	 inv *= 2 - denominator * inv;
731	 inv *= 2 - denominator * inv;
732	 inv *= 2 - denominator * inv;
733	 inv *= 2 - denominator * inv;
734	 inv *= 2 - denominator * inv;
735	 inv *= 2 - denominator * inv;
736	 result = prod0 * inv;
737	 return result;
738	 }
739	 function mulDivRoundingUp( uint256 a, uint256 b, uint256 denominator ) internal pure returns (uint256 result) {
740	 result = mulDiv(a, b, denominator);
741	 if (mulmod(a, b, denominator) > 0) {
742	 require(result < type(uint256).max);
743	 result++;
744	 }
745	 }
746	 }
747	 pragma solidity >=0.5.0;
748	 library LiquidityAmounts {
749	 function toUint128(uint256 x) private pure returns (uint128 y) {
750	 require((y = uint128(x)) == x);
751	 }
752	 function getLiquidityForAmount0( uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint256 amount0 ) internal pure returns (uint128 liquidity) {
753	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
754	 uint256 intermediate = FullMath.mulDiv(sqrtRatioAX96, sqrtRatioBX96, FixedPoint96.Q96);
755	 return toUint128(FullMath.mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));
756	 }
757	 function getLiquidityForAmount1( uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint256 amount1 ) internal pure returns (uint128 liquidity) {
758	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
759	 return toUint128(FullMath.mulDiv(amount1, FixedPoint96.Q96, sqrtRatioBX96 - sqrtRatioAX96));
760	 }
761	 function getLiquidityForAmounts( uint160 sqrtRatioX96, uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint256 amount0, uint256 amount1 ) internal pure returns (uint128 liquidity) {
762	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
763	 if (sqrtRatioX96 <= sqrtRatioAX96) {
764	 liquidity = getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);
765	 }
766	 else if (sqrtRatioX96 < sqrtRatioBX96) {
767	 uint128 liquidity0 = getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);
768	 uint128 liquidity1 = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);
769	 liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;
770	 }
771	 else {
772	 liquidity = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);
773	 }
774	 }
775	 function getAmount0ForLiquidity( uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity ) internal pure returns (uint256 amount0) {
776	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
777	 return FullMath.mulDiv( uint256(liquidity) << FixedPoint96.RESOLUTION, sqrtRatioBX96 - sqrtRatioAX96, sqrtRatioBX96 ) / sqrtRatioAX96;
778	 }
779	 function getAmount1ForLiquidity( uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity ) internal pure returns (uint256 amount1) {
780	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
781	 return FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);
782	 }
783	 function getAmountsForLiquidity( uint160 sqrtRatioX96, uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity ) internal pure returns (uint256 amount0, uint256 amount1) {
784	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
785	 if (sqrtRatioX96 <= sqrtRatioAX96) {
786	 amount0 = getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);
787	 }
788	 else if (sqrtRatioX96 < sqrtRatioBX96) {
789	 amount0 = getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);
790	 amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);
791	 }
792	 else {
793	 amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);
794	 }
795	 }
796	 }
797	 pragma solidity 0.7.6;
798	 interface IUniversalVault {
799	 event Locked(address delegate, address token, uint256 amount);
800	 event Unlocked(address delegate, address token, uint256 amount);
801	 event RageQuit(address delegate, address token, bool notified, string reason);
802	 struct LockData {
803	 address delegate;
804	 address token;
805	 uint256 balance;
806	 }
807	 function initialize() external;
808	 function lock( address token, uint256 amount, bytes calldata permission ) external;
809	 function unlock( address token, uint256 amount, bytes calldata permission ) external;
810	 function rageQuit(address delegate, address token) external returns (bool notified, string memory error);
811	 function transferERC20( address token, address to, uint256 amount ) external;
812	 function transferETH(address to, uint256 amount) external payable;
813	 function calculateLockID(address delegate, address token) external pure returns (bytes32 lockID);
814	 function getPermissionHash( bytes32 eip712TypeHash, address delegate, address token, uint256 amount, uint256 nonce ) external view returns (bytes32 permissionHash);
815	 function getNonce() external view returns (uint256 nonce);
816	 function owner() external view returns (address ownerAddress);
817	 function getLockSetCount() external view returns (uint256 count);
818	 function getLockAt(uint256 index) external view returns (LockData memory lockData);
819	 function getBalanceDelegated(address token, address delegate) external view returns (uint256 balance);
820	 function getBalanceLocked(address token) external view returns (uint256 balance);
821	 function checkBalances() external view returns (bool validity);
822	 }
823	 pragma solidity >=0.6.2 <0.8.0;
824	 library Address {
825	 function isContract(address account) internal view returns (bool) {
826	 uint256 size;
827	 assembly {
828	 size := extcodesize(account) }
829	 return size > 0;
830	 }
831	 function sendValue(address payable recipient, uint256 amount) internal {
832	 require(address(this).balance >= amount, "Address: insufficient balance");
833	 (bool success, ) = recipient.call{
834	 value: amount }
835	 ("");
836	 require(success, "Address: unable to send value, recipient may have reverted");
837	 }
838	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
839	 return functionCall(target, data, "Address: low-level call failed");
840	 }
841	 function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
842	 return functionCallWithValue(target, data, 0, errorMessage);
843	 }
844	 function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
845	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
846	 }
847	 function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
848	 require(address(this).balance >= value, "Address: insufficient balance for call");
849	 require(isContract(target), "Address: call to non-contract");
850	 (bool success, bytes memory returndata) = target.call{
851	 value: value }
852	 (data);
853	 return _verifyCallResult(success, returndata, errorMessage);
854	 }
855	 function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
856	 return functionStaticCall(target, data, "Address: low-level static call failed");
857	 }
858	 function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
859	 require(isContract(target), "Address: static call to non-contract");
860	 (bool success, bytes memory returndata) = target.staticcall(data);
861	 return _verifyCallResult(success, returndata, errorMessage);
862	 }
863	 function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
864	 return functionDelegateCall(target, data, "Address: low-level delegate call failed");
865	 }
866	 function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
867	 require(isContract(target), "Address: delegate call to non-contract");
868	 (bool success, bytes memory returndata) = target.delegatecall(data);
869	 return _verifyCallResult(success, returndata, errorMessage);
870	 }
871	 function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
872	 if (success) {
873	 return returndata;
874	 }
875	 else {
876	 if (returndata.length > 0) {
877	 assembly {
878	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
879	 }
880	 else {
881	 revert(errorMessage);
882	 }
883	 }
884	 }
885	 }
886	 pragma solidity >=0.4.0;
887	 library FixedPoint96 {
888	 uint8 internal constant RESOLUTION = 96;
889	 uint256 internal constant Q96 = 0x1000000000000000000000000;
890	 }
