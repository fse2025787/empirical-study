row number 
1	           pragma solidity 0.7.6;
2	 interface IStrategy {
3	 function rebalance() external;
4	 function shouldRebalance() external view returns (bool);
5	 }
6	 interface IVault {
7	 function deposit( uint256, uint256, uint256, uint256, address ) external returns ( uint256, uint256, uint256 );
8	 function withdraw( uint256, uint256, uint256, address ) external returns (uint256, uint256);
9	 function getTotalAmounts() external view returns (uint256, uint256);
10	 }
11	 library Address {
12	 function isContract(address account) internal view returns (bool) {
13	 uint256 size;
14	 assembly {
15	 size := extcodesize(account) }
16	 return size > 0;
17	 }
18	 function sendValue(address payable recipient, uint256 amount) internal {
19	 require(address(this).balance >= amount, "Address: insufficient balance");
20	 (bool success, ) = recipient.call{
21	 value: amount }
22	 ("");
23	 require(success, "Address: unable to send value, recipient may have reverted");
24	 }
25	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
26	 return functionCall(target, data, "Address: low-level call failed");
27	 }
28	 function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
29	 return functionCallWithValue(target, data, 0, errorMessage);
30	 }
31	 function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
32	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
33	 }
34	 function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
35	 require(address(this).balance >= value, "Address: insufficient balance for call");
36	 require(isContract(target), "Address: call to non-contract");
37	 (bool success, bytes memory returndata) = target.call{
38	 value: value }
39	 (data);
40	 return _verifyCallResult(success, returndata, errorMessage);
41	 }
42	 function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
43	 return functionStaticCall(target, data, "Address: low-level static call failed");
44	 }
45	 function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
46	 require(isContract(target), "Address: static call to non-contract");
47	 (bool success, bytes memory returndata) = target.staticcall(data);
48	 return _verifyCallResult(success, returndata, errorMessage);
49	 }
50	 function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
51	 return functionDelegateCall(target, data, "Address: low-level delegate call failed");
52	 }
53	 function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
54	 require(isContract(target), "Address: delegate call to non-contract");
55	 (bool success, bytes memory returndata) = target.delegatecall(data);
56	 return _verifyCallResult(success, returndata, errorMessage);
57	 }
58	 function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
59	 if (success) {
60	 return returndata;
61	 }
62	 else {
63	 if (returndata.length > 0) {
64	 assembly {
65	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
66	 }
67	 else {
68	 revert(errorMessage);
69	 }
70	 }
71	 }
72	 }
73	 abstract contract Context {
74	 function _msgSender() internal view virtual returns (address payable) {
75	 return msg.sender;
76	 }
77	 function _msgData() internal view virtual returns (bytes memory) {
78	 this;
79	 return msg.data;
80	 }
81	 }
82	 interface IERC20 {
83	 function totalSupply() external view returns (uint256);
84	 function balanceOf(address account) external view returns (uint256);
85	 function transfer(address recipient, uint256 amount) external returns (bool);
86	 function allowance(address owner, address spender) external view returns (uint256);
87	 function approve(address spender, uint256 amount) external returns (bool);
88	 function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
89	 event Transfer(address indexed from, address indexed to, uint256 value);
90	 event Approval(address indexed owner, address indexed spender, uint256 value);
91	 }
92	 library Math {
93	 function max(uint256 a, uint256 b) internal pure returns (uint256) {
94	 return a >= b ? a : b;
95	 }
96	 function min(uint256 a, uint256 b) internal pure returns (uint256) {
97	 return a < b ? a : b;
98	 }
99	 function average(uint256 a, uint256 b) internal pure returns (uint256) {
100	 return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);
101	 }
102	 }
103	 abstract contract ReentrancyGuard {
104	 uint256 private constant _NOT_ENTERED = 1;
105	 uint256 private constant _ENTERED = 2;
106	 uint256 private _status;
107	 constructor () internal {
108	 _status = _NOT_ENTERED;
109	 }
110	 modifier nonReentrant() {
111	 require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
112	 _status = _ENTERED;
113	 _;
114	 _status = _NOT_ENTERED;
115	 }
116	 }
117	 library SafeMath {
118	 function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
119	 uint256 c = a + b;
120	 if (c < a) return (false, 0);
121	 return (true, c);
122	 }
123	 function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
124	 if (b > a) return (false, 0);
125	 return (true, a - b);
126	 }
127	 function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
128	 if (a == 0) return (true, 0);
129	 uint256 c = a * b;
130	 if (c / a != b) return (false, 0);
131	 return (true, c);
132	 }
133	 function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
134	 if (b == 0) return (false, 0);
135	 return (true, a / b);
136	 }
137	 function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
138	 if (b == 0) return (false, 0);
139	 return (true, a % b);
140	 }
141	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
142	 uint256 c = a + b;
143	 require(c >= a, "SafeMath: addition overflow");
144	 return c;
145	 }
146	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
147	 require(b <= a, "SafeMath: subtraction overflow");
148	 return a - b;
149	 }
150	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
151	 if (a == 0) return 0;
152	 uint256 c = a * b;
153	 require(c / a == b, "SafeMath: multiplication overflow");
154	 return c;
155	 }
156	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
157	 require(b > 0, "SafeMath: division by zero");
158	 return a / b;
159	 }
160	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
161	 require(b > 0, "SafeMath: modulo by zero");
162	 return a % b;
163	 }
164	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
165	 require(b <= a, errorMessage);
166	 return a - b;
167	 }
168	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
169	 require(b > 0, errorMessage);
170	 return a / b;
171	 }
172	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
173	 require(b > 0, errorMessage);
174	 return a % b;
175	 }
176	 }
177	 library PositionKey {
178	 function compute( address owner, int24 tickLower, int24 tickUpper ) internal pure returns (bytes32) {
179	 return keccak256(abi.encodePacked(owner, tickLower, tickUpper));
180	 }
181	 }
182	 library FixedPoint96 {
183	 uint8 internal constant RESOLUTION = 96;
184	 uint256 internal constant Q96 = 0x1000000000000000000000000;
185	 }
186	 library FullMath {
187	 function mulDiv( uint256 a, uint256 b, uint256 denominator ) internal pure returns (uint256 result) {
188	 uint256 prod0;
189	 uint256 prod1;
190	 assembly {
191	 let mm := mulmod(a, b, not(0)) prod0 := mul(a, b) prod1 := sub(sub(mm, prod0), lt(mm, prod0)) }
192	 if (prod1 == 0) {
193	 require(denominator > 0);
194	 assembly {
195	 result := div(prod0, denominator) }
196	 return result;
197	 }
198	 require(denominator > prod1);
199	 uint256 remainder;
200	 assembly {
201	 remainder := mulmod(a, b, denominator) }
202	 assembly {
203	 prod1 := sub(prod1, gt(remainder, prod0)) prod0 := sub(prod0, remainder) }
204	 uint256 twos = -denominator & denominator;
205	 assembly {
206	 denominator := div(denominator, twos) }
207	 assembly {
208	 prod0 := div(prod0, twos) }
209	 assembly {
210	 twos := add(div(sub(0, twos), twos), 1) }
211	 prod0 |= prod1 * twos;
212	 uint256 inv = (3 * denominator) ^ 2;
213	 inv *= 2 - denominator * inv;
214	 inv *= 2 - denominator * inv;
215	 inv *= 2 - denominator * inv;
216	 inv *= 2 - denominator * inv;
217	 inv *= 2 - denominator * inv;
218	 inv *= 2 - denominator * inv;
219	 result = prod0 * inv;
220	 return result;
221	 }
222	 function mulDivRoundingUp( uint256 a, uint256 b, uint256 denominator ) internal pure returns (uint256 result) {
223	 result = mulDiv(a, b, denominator);
224	 if (mulmod(a, b, denominator) > 0) {
225	 require(result < type(uint256).max);
226	 result++;
227	 }
228	 }
229	 }
230	 interface IUniswapV3MintCallback {
231	 function uniswapV3MintCallback( uint256 amount0Owed, uint256 amount1Owed, bytes calldata data ) external;
232	 }
233	 interface IUniswapV3PoolActions {
234	 function initialize(uint160 sqrtPriceX96) external;
235	 function mint( address recipient, int24 tickLower, int24 tickUpper, uint128 amount, bytes calldata data ) external returns (uint256 amount0, uint256 amount1);
236	 function collect( address recipient, int24 tickLower, int24 tickUpper, uint128 amount0Requested, uint128 amount1Requested ) external returns (uint128 amount0, uint128 amount1);
237	 function burn( int24 tickLower, int24 tickUpper, uint128 amount ) external returns (uint256 amount0, uint256 amount1);
238	 function swap( address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes calldata data ) external returns (int256 amount0, int256 amount1);
239	 function flash( address recipient, uint256 amount0, uint256 amount1, bytes calldata data ) external;
240	 function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;
241	 }
242	 interface IUniswapV3PoolDerivedState {
243	 function observe(uint32[] calldata secondsAgos) external view returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);
244	 function snapshotCumulativesInside(int24 tickLower, int24 tickUpper) external view returns ( int56 tickCumulativeInside, uint160 secondsPerLiquidityInsideX128, uint32 secondsInside );
245	 }
246	 interface IUniswapV3PoolEvents {
247	 event Initialize(uint160 sqrtPriceX96, int24 tick);
248	 event Mint( address sender, address indexed owner, int24 indexed tickLower, int24 indexed tickUpper, uint128 amount, uint256 amount0, uint256 amount1 );
249	 event Collect( address indexed owner, address recipient, int24 indexed tickLower, int24 indexed tickUpper, uint128 amount0, uint128 amount1 );
250	 event Burn( address indexed owner, int24 indexed tickLower, int24 indexed tickUpper, uint128 amount, uint256 amount0, uint256 amount1 );
251	 event Swap( address indexed sender, address indexed recipient, int256 amount0, int256 amount1, uint160 sqrtPriceX96, uint128 liquidity, int24 tick );
252	 event Flash( address indexed sender, address indexed recipient, uint256 amount0, uint256 amount1, uint256 paid0, uint256 paid1 );
253	 event IncreaseObservationCardinalityNext( uint16 observationCardinalityNextOld, uint16 observationCardinalityNextNew );
254	 event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);
255	 event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);
256	 }
257	 interface IUniswapV3PoolImmutables {
258	 function factory() external view returns (address);
259	 function token0() external view returns (address);
260	 function token1() external view returns (address);
261	 function fee() external view returns (uint24);
262	 function tickSpacing() external view returns (int24);
263	 function maxLiquidityPerTick() external view returns (uint128);
264	 }
265	 interface IUniswapV3PoolOwnerActions {
266	 function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;
267	 function collectProtocol( address recipient, uint128 amount0Requested, uint128 amount1Requested ) external returns (uint128 amount0, uint128 amount1);
268	 }
269	 interface IUniswapV3PoolState {
270	 function slot0() external view returns ( uint160 sqrtPriceX96, int24 tick, uint16 observationIndex, uint16 observationCardinality, uint16 observationCardinalityNext, uint8 feeProtocol, bool unlocked );
271	 function feeGrowthGlobal0X128() external view returns (uint256);
272	 function feeGrowthGlobal1X128() external view returns (uint256);
273	 function protocolFees() external view returns (uint128 token0, uint128 token1);
274	 function liquidity() external view returns (uint128);
275	 function ticks(int24 tick) external view returns ( uint128 liquidityGross, int128 liquidityNet, uint256 feeGrowthOutside0X128, uint256 feeGrowthOutside1X128, int56 tickCumulativeOutside, uint160 secondsPerLiquidityOutsideX128, uint32 secondsOutside, bool initialized );
276	 function tickBitmap(int16 wordPosition) external view returns (uint256);
277	 function positions(bytes32 key) external view returns ( uint128 _liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, uint128 tokensOwed0, uint128 tokensOwed1 );
278	 function observations(uint256 index) external view returns ( uint32 blockTimestamp, int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128, bool initialized );
279	 }
280	 interface IUniswapV3SwapCallback {
281	 function uniswapV3SwapCallback( int256 amount0Delta, int256 amount1Delta, bytes calldata data ) external;
282	 }
283	 library TickMath {
284	 int24 internal constant MIN_TICK = -887272;
285	 int24 internal constant MAX_TICK = -MIN_TICK;
286	 uint160 internal constant MIN_SQRT_RATIO = 4295128739;
287	 uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;
288	 function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {
289	 uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));
290	 require(absTick <= uint256(MAX_TICK), 'T');
291	 uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;
292	 if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;
293	 if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;
294	 if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;
295	 if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;
296	 if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;
297	 if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;
298	 if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;
299	 if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;
300	 if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;
301	 if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;
302	 if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;
303	 if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;
304	 if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;
305	 if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;
306	 if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;
307	 if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;
308	 if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;
309	 if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;
310	 if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;
311	 if (tick > 0) ratio = type(uint256).max / ratio;
312	 sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));
313	 }
314	 function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {
315	 require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');
316	 uint256 ratio = uint256(sqrtPriceX96) << 32;
317	 uint256 r = ratio;
318	 uint256 msb = 0;
319	 assembly {
320	 let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) msb := or(msb, f) r := shr(f, r) }
321	 assembly {
322	 let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF)) msb := or(msb, f) r := shr(f, r) }
323	 assembly {
324	 let f := shl(5, gt(r, 0xFFFFFFFF)) msb := or(msb, f) r := shr(f, r) }
325	 assembly {
326	 let f := shl(4, gt(r, 0xFFFF)) msb := or(msb, f) r := shr(f, r) }
327	 assembly {
328	 let f := shl(3, gt(r, 0xFF)) msb := or(msb, f) r := shr(f, r) }
329	 assembly {
330	 let f := shl(2, gt(r, 0xF)) msb := or(msb, f) r := shr(f, r) }
331	 assembly {
332	 let f := shl(1, gt(r, 0x3)) msb := or(msb, f) r := shr(f, r) }
333	 assembly {
334	 let f := gt(r, 0x1) msb := or(msb, f) }
335	 if (msb >= 128) r = ratio >> (msb - 127);
336	 else r = ratio << (127 - msb);
337	 int256 log_2 = (int256(msb) - 128) << 64;
338	 assembly {
339	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(63, f)) r := shr(f, r) }
340	 assembly {
341	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(62, f)) r := shr(f, r) }
342	 assembly {
343	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(61, f)) r := shr(f, r) }
344	 assembly {
345	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(60, f)) r := shr(f, r) }
346	 assembly {
347	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(59, f)) r := shr(f, r) }
348	 assembly {
349	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(58, f)) r := shr(f, r) }
350	 assembly {
351	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(57, f)) r := shr(f, r) }
352	 assembly {
353	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(56, f)) r := shr(f, r) }
354	 assembly {
355	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(55, f)) r := shr(f, r) }
356	 assembly {
357	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(54, f)) r := shr(f, r) }
358	 assembly {
359	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(53, f)) r := shr(f, r) }
360	 assembly {
361	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(52, f)) r := shr(f, r) }
362	 assembly {
363	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(51, f)) r := shr(f, r) }
364	 assembly {
365	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(50, f)) }
366	 int256 log_sqrt10001 = log_2 * 255738958999603826347141;
367	 int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);
368	 int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);
369	 tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;
370	 }
371	 }
372	 library LiquidityAmounts {
373	 function toUint128(uint256 x) private pure returns (uint128 y) {
374	 require((y = uint128(x)) == x);
375	 }
376	 function getLiquidityForAmount0( uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint256 amount0 ) internal pure returns (uint128 liquidity) {
377	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
378	 uint256 intermediate = FullMath.mulDiv(sqrtRatioAX96, sqrtRatioBX96, FixedPoint96.Q96);
379	 return toUint128(FullMath.mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));
380	 }
381	 function getLiquidityForAmount1( uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint256 amount1 ) internal pure returns (uint128 liquidity) {
382	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
383	 return toUint128(FullMath.mulDiv(amount1, FixedPoint96.Q96, sqrtRatioBX96 - sqrtRatioAX96));
384	 }
385	 function getLiquidityForAmounts( uint160 sqrtRatioX96, uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint256 amount0, uint256 amount1 ) internal pure returns (uint128 liquidity) {
386	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
387	 if (sqrtRatioX96 <= sqrtRatioAX96) {
388	 liquidity = getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);
389	 }
390	 else if (sqrtRatioX96 < sqrtRatioBX96) {
391	 uint128 liquidity0 = getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);
392	 uint128 liquidity1 = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);
393	 liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;
394	 }
395	 else {
396	 liquidity = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);
397	 }
398	 }
399	 function getAmount0ForLiquidity( uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity ) internal pure returns (uint256 amount0) {
400	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
401	 return FullMath.mulDiv( uint256(liquidity) << FixedPoint96.RESOLUTION, sqrtRatioBX96 - sqrtRatioAX96, sqrtRatioBX96 ) / sqrtRatioAX96;
402	 }
403	 function getAmount1ForLiquidity( uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity ) internal pure returns (uint256 amount1) {
404	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
405	 return FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);
406	 }
407	 function getAmountsForLiquidity( uint160 sqrtRatioX96, uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity ) internal pure returns (uint256 amount0, uint256 amount1) {
408	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
409	 if (sqrtRatioX96 <= sqrtRatioAX96) {
410	 amount0 = getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);
411	 }
412	 else if (sqrtRatioX96 < sqrtRatioBX96) {
413	 amount0 = getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);
414	 amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);
415	 }
416	 else {
417	 amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);
418	 }
419	 }
420	 }
421	 contract ERC20 is Context, IERC20 {
422	 using SafeMath for uint256;
423	 mapping (address => uint256) private _balances;
424	 mapping (address => mapping (address => uint256)) private _allowances;
425	 uint256 private _totalSupply;
426	 string private _name;
427	 string private _symbol;
428	 uint8 private _decimals;
429	 constructor (string memory name_, string memory symbol_) public {
430	 _name = name_;
431	 _symbol = symbol_;
432	 _decimals = 18;
433	 }
434	 function name() public view virtual returns (string memory) {
435	 return _name;
436	 }
437	 function symbol() public view virtual returns (string memory) {
438	 return _symbol;
439	 }
440	 function decimals() public view virtual returns (uint8) {
441	 return _decimals;
442	 }
443	 function totalSupply() public view virtual override returns (uint256) {
444	 return _totalSupply;
445	 }
446	 function balanceOf(address account) public view virtual override returns (uint256) {
447	 return _balances[account];
448	 }
449	 function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
450	 _transfer(_msgSender(), recipient, amount);
451	 return true;
452	 }
453	 function allowance(address owner, address spender) public view virtual override returns (uint256) {
454	 return _allowances[owner][spender];
455	 }
456	 function approve(address spender, uint256 amount) public virtual override returns (bool) {
457	 _approve(_msgSender(), spender, amount);
458	 return true;
459	 }
460	 function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
461	 _transfer(sender, recipient, amount);
462	 _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
463	 return true;
464	 }
465	 function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
466	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
467	 return true;
468	 }
469	 function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
470	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
471	 return true;
472	 }
473	 function _transfer(address sender, address recipient, uint256 amount) internal virtual {
474	 require(sender != address(0), "ERC20: transfer from the zero address");
475	 require(recipient != address(0), "ERC20: transfer to the zero address");
476	 _beforeTokenTransfer(sender, recipient, amount);
477	 _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
478	 _balances[recipient] = _balances[recipient].add(amount);
479	 emit Transfer(sender, recipient, amount);
480	 }
481	 function _mint(address account, uint256 amount) internal virtual {
482	 require(account != address(0), "ERC20: mint to the zero address");
483	 _beforeTokenTransfer(address(0), account, amount);
484	 _totalSupply = _totalSupply.add(amount);
485	 _balances[account] = _balances[account].add(amount);
486	 emit Transfer(address(0), account, amount);
487	 }
488	 function _burn(address account, uint256 amount) internal virtual {
489	 require(account != address(0), "ERC20: burn from the zero address");
490	 _beforeTokenTransfer(account, address(0), amount);
491	 _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
492	 _totalSupply = _totalSupply.sub(amount);
493	 emit Transfer(account, address(0), amount);
494	 }
495	 function _approve(address owner, address spender, uint256 amount) internal virtual {
496	 require(owner != address(0), "ERC20: approve from the zero address");
497	 require(spender != address(0), "ERC20: approve to the zero address");
498	 _allowances[owner][spender] = amount;
499	 emit Approval(owner, spender, amount);
500	 }
501	 function _setupDecimals(uint8 decimals_) internal virtual {
502	 _decimals = decimals_;
503	 }
504	 function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {
505	 }
506	 }
507	 library SafeERC20 {
508	 using SafeMath for uint256;
509	 using Address for address;
510	 function safeTransfer(IERC20 token, address to, uint256 value) internal {
511	 _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
512	 }
513	 function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
514	 _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
515	 }
516	 function safeApprove(IERC20 token, address spender, uint256 value) internal {
517	 require((value == 0) || (token.allowance(address(this), spender) == 0), "SafeERC20: approve from non-zero to non-zero allowance" );
518	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
519	 }
520	 function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
521	 uint256 newAllowance = token.allowance(address(this), spender).add(value);
522	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
523	 }
524	 function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
525	 uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
526	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
527	 }
528	 function _callOptionalReturn(IERC20 token, bytes memory data) private {
529	 bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
530	 if (returndata.length > 0) {
531	 require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
532	 }
533	 }
534	 }
535	 interface IUniswapV3Pool is IUniswapV3PoolImmutables, IUniswapV3PoolState, IUniswapV3PoolDerivedState, IUniswapV3PoolActions, IUniswapV3PoolOwnerActions, IUniswapV3PoolEvents {
536	 }
537	 contract AlphaVault is IVault, IUniswapV3MintCallback, IUniswapV3SwapCallback, ERC20, ReentrancyGuard {
538	 using SafeERC20 for IERC20;
539	 using SafeMath for uint256;
540	 event Deposit( address indexed sender, address indexed to, uint256 shares, uint256 amount0, uint256 amount1 );
541	 event Withdraw( address indexed sender, address indexed to, uint256 shares, uint256 amount0, uint256 amount1 );
542	 event CollectFees( uint256 feesToVault0, uint256 feesToVault1, uint256 feesToProtocol0, uint256 feesToProtocol1 );
543	 event Snapshot(int24 tick, uint256 totalAmount0, uint256 totalAmount1, uint256 totalSupply);
544	 IUniswapV3Pool public immutable pool;
545	 IERC20 public immutable token0;
546	 IERC20 public immutable token1;
547	 int24 public immutable tickSpacing;
548	 uint256 public protocolFee;
549	 uint256 public maxTotalSupply;
550	 address public strategy;
551	 address public governance;
552	 address public pendingGovernance;
553	 int24 public baseLower;
554	 int24 public baseUpper;
555	 int24 public limitLower;
556	 int24 public limitUpper;
557	 uint256 public accruedProtocolFees0;
558	 uint256 public accruedProtocolFees1;
559	 constructor( address _pool, uint256 _protocolFee, uint256 _maxTotalSupply ) ERC20("Alpha Vault", "AV") {
560	 pool = IUniswapV3Pool(_pool);
561	 token0 = IERC20(IUniswapV3Pool(_pool).token0());
562	 token1 = IERC20(IUniswapV3Pool(_pool).token1());
563	 tickSpacing = IUniswapV3Pool(_pool).tickSpacing();
564	 protocolFee = _protocolFee;
565	 maxTotalSupply = _maxTotalSupply;
566	 governance = msg.sender;
567	 require(_protocolFee < 1e6, "protocolFee");
568	 }
569	 function deposit( uint256 amount0Desired, uint256 amount1Desired, uint256 amount0Min, uint256 amount1Min, address to ) external override nonReentrant returns ( uint256 shares, uint256 amount0, uint256 amount1 ) {
570	 require(amount0Desired > 0 || amount1Desired > 0, "amount0Desired or amount1Desired");
571	 require(to != address(0) && to != address(this), "to");
572	 _poke(baseLower, baseUpper);
573	 _poke(limitLower, limitUpper);
574	 (shares, amount0, amount1) = _calcSharesAndAmounts(amount0Desired, amount1Desired);
575	 require(shares > 0, "shares");
576	 require(amount0 >= amount0Min, "amount0Min");
577	 require(amount1 >= amount1Min, "amount1Min");
578	 if (amount0 > 0) token0.safeTransferFrom(msg.sender, address(this), amount0);
579	 if (amount1 > 0) token1.safeTransferFrom(msg.sender, address(this), amount1);
580	 _mint(to, shares);
581	 emit Deposit(msg.sender, to, shares, amount0, amount1);
582	 require(totalSupply() <= maxTotalSupply, "maxTotalSupply");
583	 }
584	 function _poke(int24 tickLower, int24 tickUpper) internal {
585	 (uint128 liquidity, , , , ) = _position(tickLower, tickUpper);
586	 if (liquidity > 0) {
587	 pool.burn(tickLower, tickUpper, 0);
588	 }
589	 }
590	 function _calcSharesAndAmounts(uint256 amount0Desired, uint256 amount1Desired) internal view returns ( uint256 shares, uint256 amount0, uint256 amount1 ) {
591	 uint256 totalSupply = totalSupply();
592	 (uint256 total0, uint256 total1) = getTotalAmounts();
593	 assert(totalSupply == 0 || total0 > 0 || total1 > 0);
594	 if (totalSupply == 0) {
595	 amount0 = amount0Desired;
596	 amount1 = amount1Desired;
597	 shares = Math.max(amount0, amount1);
598	 }
599	 else if (total0 == 0) {
600	 amount1 = amount1Desired;
601	 shares = amount1.mul(totalSupply).div(total1);
602	 }
603	 else if (total1 == 0) {
604	 amount0 = amount0Desired;
605	 shares = amount0.mul(totalSupply).div(total0);
606	 }
607	 else {
608	 uint256 cross = Math.min(amount0Desired.mul(total1), amount1Desired.mul(total0));
609	 require(cross > 0, "cross");
610	 amount0 = cross.sub(1).div(total1).add(1);
611	 amount1 = cross.sub(1).div(total0).add(1);
612	 shares = cross.mul(totalSupply).div(total0).div(total1);
613	 }
614	 }
615	 function withdraw( uint256 shares, uint256 amount0Min, uint256 amount1Min, address to ) external override nonReentrant returns (uint256 amount0, uint256 amount1) {
616	 require(shares > 0, "shares");
617	 require(to != address(0) && to != address(this), "to");
618	 uint256 totalSupply = totalSupply();
619	 _burn(msg.sender, shares);
620	 uint256 unusedAmount0 = getBalance0().mul(shares).div(totalSupply);
621	 uint256 unusedAmount1 = getBalance1().mul(shares).div(totalSupply);
622	 (uint256 baseAmount0, uint256 baseAmount1) = _burnLiquidityShare(baseLower, baseUpper, shares, totalSupply);
623	 (uint256 limitAmount0, uint256 limitAmount1) = _burnLiquidityShare(limitLower, limitUpper, shares, totalSupply);
624	 amount0 = unusedAmount0.add(baseAmount0).add(limitAmount0);
625	 amount1 = unusedAmount1.add(baseAmount1).add(limitAmount1);
626	 require(amount0 >= amount0Min, "amount0Min");
627	 require(amount1 >= amount1Min, "amount1Min");
628	 if (amount0 > 0) token0.safeTransfer(to, amount0);
629	 if (amount1 > 0) token1.safeTransfer(to, amount1);
630	 emit Withdraw(msg.sender, to, shares, amount0, amount1);
631	 }
632	 function _burnLiquidityShare( int24 tickLower, int24 tickUpper, uint256 shares, uint256 totalSupply ) internal returns (uint256 amount0, uint256 amount1) {
633	 (uint128 totalLiquidity, , , , ) = _position(tickLower, tickUpper);
634	 uint256 liquidity = uint256(totalLiquidity).mul(shares).div(totalSupply);
635	 if (liquidity > 0) {
636	 (uint256 burned0, uint256 burned1, uint256 fees0, uint256 fees1) = _burnAndCollect(tickLower, tickUpper, _toUint128(liquidity));
637	 amount0 = burned0.add(fees0.mul(shares).div(totalSupply));
638	 amount1 = burned1.add(fees1.mul(shares).div(totalSupply));
639	 }
640	 }
641	 function rebalance( int256 swapAmount, uint160 sqrtPriceLimitX96, int24 _baseLower, int24 _baseUpper, int24 _bidLower, int24 _bidUpper, int24 _askLower, int24 _askUpper ) external nonReentrant {
642	 require(msg.sender == strategy, "strategy");
643	 _checkRange(_baseLower, _baseUpper);
644	 _checkRange(_bidLower, _bidUpper);
645	 _checkRange(_askLower, _askUpper);
646	 (, int24 tick, , , , , ) = pool.slot0();
647	 require(_bidUpper <= tick, "bidUpper");
648	 require(_askLower > tick, "askLower");
649	 {
650	 (uint128 baseLiquidity, , , , ) = _position(baseLower, baseUpper);
651	 (uint128 limitLiquidity, , , , ) = _position(limitLower, limitUpper);
652	 _burnAndCollect(baseLower, baseUpper, baseLiquidity);
653	 _burnAndCollect(limitLower, limitUpper, limitLiquidity);
654	 }
655	 uint256 balance0 = getBalance0();
656	 uint256 balance1 = getBalance1();
657	 emit Snapshot(tick, balance0, balance1, totalSupply());
658	 if (swapAmount != 0) {
659	 pool.swap( address(this), swapAmount > 0, swapAmount > 0 ? swapAmount : -swapAmount, sqrtPriceLimitX96, "" );
660	 balance0 = getBalance0();
661	 balance1 = getBalance1();
662	 }
663	 uint128 liquidity = _liquidityForAmounts(_baseLower, _baseUpper, balance0, balance1);
664	 _mintLiquidity(_baseLower, _baseUpper, liquidity);
665	 (baseLower, baseUpper) = (_baseLower, _baseUpper);
666	 balance0 = getBalance0();
667	 balance1 = getBalance1();
668	 uint128 bidLiquidity = _liquidityForAmounts(_bidLower, _bidUpper, balance0, balance1);
669	 uint128 askLiquidity = _liquidityForAmounts(_askLower, _askUpper, balance0, balance1);
670	 if (bidLiquidity > askLiquidity) {
671	 _mintLiquidity(_bidLower, _bidUpper, bidLiquidity);
672	 (limitLower, limitUpper) = (_bidLower, _bidUpper);
673	 }
674	 else {
675	 _mintLiquidity(_askLower, _askUpper, askLiquidity);
676	 (limitLower, limitUpper) = (_askLower, _askUpper);
677	 }
678	 }
679	 function _checkRange(int24 tickLower, int24 tickUpper) internal view {
680	 int24 _tickSpacing = tickSpacing;
681	 require(tickLower < tickUpper, "tickLower < tickUpper");
682	 require(tickLower >= TickMath.MIN_TICK, "tickLower too low");
683	 require(tickUpper <= TickMath.MAX_TICK, "tickUpper too high");
684	 require(tickLower % _tickSpacing == 0, "tickLower % tickSpacing");
685	 require(tickUpper % _tickSpacing == 0, "tickUpper % tickSpacing");
686	 }
687	 function _burnAndCollect( int24 tickLower, int24 tickUpper, uint128 liquidity ) internal returns ( uint256 burned0, uint256 burned1, uint256 feesToVault0, uint256 feesToVault1 ) {
688	 if (liquidity > 0) {
689	 (burned0, burned1) = pool.burn(tickLower, tickUpper, liquidity);
690	 }
691	 (uint256 collect0, uint256 collect1) = pool.collect( address(this), tickLower, tickUpper, type(uint128).max, type(uint128).max );
692	 feesToVault0 = collect0.sub(burned0);
693	 feesToVault1 = collect1.sub(burned1);
694	 uint256 feesToProtocol0;
695	 uint256 feesToProtocol1;
696	 uint256 _protocolFee = protocolFee;
697	 if (_protocolFee > 0) {
698	 feesToProtocol0 = feesToVault0.mul(_protocolFee).div(1e6);
699	 feesToProtocol1 = feesToVault1.mul(_protocolFee).div(1e6);
700	 feesToVault0 = feesToVault0.sub(feesToProtocol0);
701	 feesToVault1 = feesToVault1.sub(feesToProtocol1);
702	 accruedProtocolFees0 = accruedProtocolFees0.add(feesToProtocol0);
703	 accruedProtocolFees1 = accruedProtocolFees1.add(feesToProtocol1);
704	 }
705	 emit CollectFees(feesToVault0, feesToVault1, feesToProtocol0, feesToProtocol1);
706	 }
707	 function _mintLiquidity( int24 tickLower, int24 tickUpper, uint128 liquidity ) internal {
708	 if (liquidity > 0) {
709	 pool.mint(address(this), tickLower, tickUpper, liquidity, "");
710	 }
711	 }
712	 function getTotalAmounts() public view override returns (uint256 total0, uint256 total1) {
713	 (uint256 baseAmount0, uint256 baseAmount1) = getPositionAmounts(baseLower, baseUpper);
714	 (uint256 limitAmount0, uint256 limitAmount1) = getPositionAmounts(limitLower, limitUpper);
715	 total0 = getBalance0().add(baseAmount0).add(limitAmount0);
716	 total1 = getBalance1().add(baseAmount1).add(limitAmount1);
717	 }
718	 function getPositionAmounts(int24 tickLower, int24 tickUpper) public view returns (uint256 amount0, uint256 amount1) {
719	 (uint128 liquidity, , , uint128 tokensOwed0, uint128 tokensOwed1) = _position(tickLower, tickUpper);
720	 (amount0, amount1) = _amountsForLiquidity(tickLower, tickUpper, liquidity);
721	 uint256 oneMinusFee = uint256(1e6).sub(protocolFee);
722	 amount0 = amount0.add(uint256(tokensOwed0).mul(oneMinusFee).div(1e6));
723	 amount1 = amount1.add(uint256(tokensOwed1).mul(oneMinusFee).div(1e6));
724	 }
725	 function getBalance0() public view returns (uint256) {
726	 return token0.balanceOf(address(this)).sub(accruedProtocolFees0);
727	 }
728	 function getBalance1() public view returns (uint256) {
729	 return token1.balanceOf(address(this)).sub(accruedProtocolFees1);
730	 }
731	 function _position(int24 tickLower, int24 tickUpper) internal view returns ( uint128, uint256, uint256, uint128, uint128 ) {
732	 bytes32 positionKey = PositionKey.compute(address(this), tickLower, tickUpper);
733	 return pool.positions(positionKey);
734	 }
735	 function _amountsForLiquidity( int24 tickLower, int24 tickUpper, uint128 liquidity ) internal view returns (uint256, uint256) {
736	 (uint160 sqrtRatioX96, , , , , , ) = pool.slot0();
737	 return LiquidityAmounts.getAmountsForLiquidity( sqrtRatioX96, TickMath.getSqrtRatioAtTick(tickLower), TickMath.getSqrtRatioAtTick(tickUpper), liquidity );
738	 }
739	 function _liquidityForAmounts( int24 tickLower, int24 tickUpper, uint256 amount0, uint256 amount1 ) internal view returns (uint128) {
740	 (uint160 sqrtRatioX96, , , , , , ) = pool.slot0();
741	 return LiquidityAmounts.getLiquidityForAmounts( sqrtRatioX96, TickMath.getSqrtRatioAtTick(tickLower), TickMath.getSqrtRatioAtTick(tickUpper), amount0, amount1 );
742	 }
743	 function _toUint128(uint256 x) internal pure returns (uint128) {
744	 assert(x <= type(uint128).max);
745	 return uint128(x);
746	 }
747	 function uniswapV3MintCallback( uint256 amount0, uint256 amount1, bytes calldata data ) external override {
748	 require(msg.sender == address(pool));
749	 if (amount0 > 0) token0.safeTransfer(msg.sender, amount0);
750	 if (amount1 > 0) token1.safeTransfer(msg.sender, amount1);
751	 }
752	 function uniswapV3SwapCallback( int256 amount0Delta, int256 amount1Delta, bytes calldata data ) external override {
753	 require(msg.sender == address(pool));
754	 if (amount0Delta > 0) token0.safeTransfer(msg.sender, uint256(amount0Delta));
755	 if (amount1Delta > 0) token1.safeTransfer(msg.sender, uint256(amount1Delta));
756	 }
757	 function collectProtocol( uint256 amount0, uint256 amount1, address to ) external onlyGovernance {
758	 accruedProtocolFees0 = accruedProtocolFees0.sub(amount0);
759	 accruedProtocolFees1 = accruedProtocolFees1.sub(amount1);
760	 if (amount0 > 0) token0.safeTransfer(to, amount0);
761	 if (amount1 > 0) token1.safeTransfer(to, amount1);
762	 }
763	 function sweep( IERC20 token, uint256 amount, address to ) external onlyGovernance {
764	 require(token != token0 && token != token1, "token");
765	 token.safeTransfer(to, amount);
766	 }
767	 function setStrategy(address _strategy) external onlyGovernance {
768	 strategy = _strategy;
769	 }
770	 function setProtocolFee(uint256 _protocolFee) external onlyGovernance {
771	 require(_protocolFee < 1e6, "protocolFee");
772	 protocolFee = _protocolFee;
773	 }
774	 function setMaxTotalSupply(uint256 _maxTotalSupply) external onlyGovernance {
775	 maxTotalSupply = _maxTotalSupply;
776	 }
777	 function emergencyBurn( int24 tickLower, int24 tickUpper, uint128 liquidity ) external onlyGovernance {
778	 pool.burn(tickLower, tickUpper, liquidity);
779	 pool.collect(address(this), tickLower, tickUpper, type(uint128).max, type(uint128).max);
780	 }
781	 function setGovernance(address _governance) external onlyGovernance {
782	 pendingGovernance = _governance;
783	 }
784	 function acceptGovernance() external {
785	 require(msg.sender == pendingGovernance, "pendingGovernance");
786	 governance = msg.sender;
787	 }
788	 modifier onlyGovernance {
789	 require(msg.sender == governance, "governance");
790	 _;
791	 }
792	 }
793	 contract PassiveStrategy is IStrategy {
794	 using SafeMath for uint256;
795	 AlphaVault public immutable vault;
796	 IUniswapV3Pool public immutable pool;
797	 int24 public immutable tickSpacing;
798	 int24 public baseThreshold;
799	 int24 public limitThreshold;
800	 uint256 public period;
801	 int24 public minTickMove;
802	 int24 public maxTwapDeviation;
803	 uint32 public twapDuration;
804	 address public keeper;
805	 uint256 public lastTimestamp;
806	 int24 public lastTick;
807	 constructor( address _vault, int24 _baseThreshold, int24 _limitThreshold, uint256 _period, int24 _minTickMove, int24 _maxTwapDeviation, uint32 _twapDuration, address _keeper ) {
808	 IUniswapV3Pool _pool = AlphaVault(_vault).pool();
809	 int24 _tickSpacing = _pool.tickSpacing();
810	 vault = AlphaVault(_vault);
811	 pool = _pool;
812	 tickSpacing = _tickSpacing;
813	 baseThreshold = _baseThreshold;
814	 limitThreshold = _limitThreshold;
815	 period = _period;
816	 minTickMove = _minTickMove;
817	 maxTwapDeviation = _maxTwapDeviation;
818	 twapDuration = _twapDuration;
819	 keeper = _keeper;
820	 _checkThreshold(_baseThreshold, _tickSpacing);
821	 _checkThreshold(_limitThreshold, _tickSpacing);
822	 require(_minTickMove >= 0, "minTickMove must be >= 0");
823	 require(_maxTwapDeviation >= 0, "maxTwapDeviation must be >= 0");
824	 require(_twapDuration > 0, "twapDuration must be > 0");
825	 (, lastTick, , , , , ) = _pool.slot0();
826	 }
827	 function rebalance() external override {
828	 require(shouldRebalance(), "cannot rebalance");
829	 (, int24 tick, , , , , ) = pool.slot0();
830	 int24 tickFloor = _floor(tick);
831	 int24 tickCeil = tickFloor + tickSpacing;
832	 vault.rebalance( 0, 0, tickFloor - baseThreshold, tickCeil + baseThreshold, tickFloor - limitThreshold, tickFloor, tickCeil, tickCeil + limitThreshold );
833	 lastTimestamp = block.timestamp;
834	 lastTick = tick;
835	 }
836	 function shouldRebalance() public view override returns (bool) {
837	 if (msg.sender != keeper) {
838	 return false;
839	 }
840	 if (block.timestamp < lastTimestamp.add(period)) {
841	 return false;
842	 }
843	 (, int24 tick, , , , , ) = pool.slot0();
844	 int24 tickMove = tick > lastTick ? tick - lastTick : lastTick - tick;
845	 if (tickMove < minTickMove) {
846	 return false;
847	 }
848	 int24 twap = getTwap();
849	 int24 twapDeviation = tick > twap ? tick - twap : twap - tick;
850	 if (twapDeviation > maxTwapDeviation) {
851	 return false;
852	 }
853	 int24 maxThreshold = baseThreshold > limitThreshold ? baseThreshold : limitThreshold;
854	 if ( tick < TickMath.MIN_TICK + maxThreshold + tickSpacing || tick > TickMath.MAX_TICK - maxThreshold - tickSpacing ) {
855	 return false;
856	 }
857	 return true;
858	 }
859	 function getTwap() public view returns (int24) {
860	 uint32 _twapDuration = twapDuration;
861	 uint32[] memory secondsAgo = new uint32[](2);
862	 secondsAgo[0] = _twapDuration;
863	 secondsAgo[1] = 0;
864	 (int56[] memory tickCumulatives, ) = pool.observe(secondsAgo);
865	 return int24((tickCumulatives[1] - tickCumulatives[0]) / _twapDuration);
866	 }
867	 function _floor(int24 tick) internal view returns (int24) {
868	 int24 compressed = tick / tickSpacing;
869	 if (tick < 0 && tick % tickSpacing != 0) compressed--;
870	 return compressed * tickSpacing;
871	 }
872	 function _checkThreshold(int24 threshold, int24 _tickSpacing) internal pure {
873	 require(threshold > 0, "threshold must be > 0");
874	 require(threshold <= TickMath.MAX_TICK, "threshold too high");
875	 require(threshold % _tickSpacing == 0, "threshold must be multiple of tickSpacing");
876	 }
877	 function setKeeper(address _keeper) external onlyGovernance {
878	 keeper = _keeper;
879	 }
880	 function setBaseThreshold(int24 _baseThreshold) external onlyGovernance {
881	 _checkThreshold(_baseThreshold, tickSpacing);
882	 baseThreshold = _baseThreshold;
883	 }
884	 function setLimitThreshold(int24 _limitThreshold) external onlyGovernance {
885	 _checkThreshold(_limitThreshold, tickSpacing);
886	 limitThreshold = _limitThreshold;
887	 }
888	 function setPeriod(uint256 _period) external onlyGovernance {
889	 period = _period;
890	 }
891	 function setMinTickMove(int24 _minTickMove) external onlyGovernance {
892	 require(_minTickMove >= 0, "minTickMove must be >= 0");
893	 minTickMove = _minTickMove;
894	 }
895	 function setMaxTwapDeviation(int24 _maxTwapDeviation) external onlyGovernance {
896	 require(_maxTwapDeviation >= 0, "maxTwapDeviation must be >= 0");
897	 maxTwapDeviation = _maxTwapDeviation;
898	 }
899	 function setTwapDuration(uint32 _twapDuration) external onlyGovernance {
900	 require(_twapDuration > 0, "twapDuration must be > 0");
901	 twapDuration = _twapDuration;
902	 }
903	 modifier onlyGovernance {
904	 require(msg.sender == vault.governance(), "governance");
905	 _;
906	 }
907	 }
