row number 
1	  pragma experimental ABIEncoderV2;
2	 pragma solidity ^0.6.12;
3	 interface IPowerPoke {
4	 function authorizeReporter(uint256 userId_, address pokerKey_) external view;
5	 function authorizeNonReporter(uint256 userId_, address pokerKey_) external view;
6	 function authorizeNonReporterWithDeposit( uint256 userId_, address pokerKey_, uint256 overrideMinDeposit_ ) external view;
7	 function authorizePoker(uint256 userId_, address pokerKey_) external view;
8	 function authorizePokerWithDeposit( uint256 userId_, address pokerKey_, uint256 overrideMinStake_ ) external view;
9	 function slashReporter(uint256 slasherId_, uint256 times_) external;
10	 function reward( uint256 userId_, uint256 gasUsed_, uint256 compensationPlan_, bytes calldata pokeOptions_ ) external;
11	 function transferClientOwnership(address client_, address to_) external;
12	 function addCredit(address client_, uint256 amount_) external;
13	 function withdrawCredit( address client_, address to_, uint256 amount_ ) external;
14	 function setReportIntervals( address client_, uint256 minReportInterval_, uint256 maxReportInterval_ ) external;
15	 function setSlasherHeartbeat(address client_, uint256 slasherHeartbeat_) external;
16	 function setGasPriceLimit(address client_, uint256 gasPriceLimit_) external;
17	 function setFixedCompensations( address client_, uint256 eth_, uint256 cvp_ ) external;
18	 function setBonusPlan( address client_, uint256 planId_, bool active_, uint64 bonusNominator_, uint64 bonusDenominator_, uint64 perGas_ ) external;
19	 function setMinimalDeposit(address client_, uint256 defaultMinDeposit_) external;
20	 function withdrawRewards(uint256 userId_, address to_) external;
21	 function setPokerKeyRewardWithdrawAllowance(uint256 userId_, bool allow_) external;
22	 function addClient( address client_, address owner_, bool canSlash_, uint256 gasPriceLimit_, uint256 minReportInterval_, uint256 maxReportInterval_ ) external;
23	 function setClientActiveFlag(address client_, bool active_) external;
24	 function setCanSlashFlag(address client_, bool canSlash) external;
25	 function setOracle(address oracle_) external;
26	 function pause() external;
27	 function unpause() external;
28	 function creditOf(address client_) external view returns (uint256);
29	 function ownerOf(address client_) external view returns (address);
30	 function getMinMaxReportIntervals(address client_) external view returns (uint256 min, uint256 max);
31	 function getSlasherHeartbeat(address client_) external view returns (uint256);
32	 function getGasPriceLimit(address client_) external view returns (uint256);
33	 function getPokerBonus( address client_, uint256 bonusPlanId_, uint256 gasUsed_, uint256 userDeposit_ ) external view returns (uint256);
34	 function getGasPriceFor(address client_) external view returns (uint256);
35	 }
36	 pragma solidity >=0.6.0 <0.8.0;
37	 interface IERC20 {
38	 function totalSupply() external view returns (uint256);
39	 function balanceOf(address account) external view returns (uint256);
40	 function transfer(address recipient, uint256 amount) external returns (bool);
41	 function allowance(address owner, address spender) external view returns (uint256);
42	 function approve(address spender, uint256 amount) external returns (bool);
43	 function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
44	 event Transfer(address indexed from, address indexed to, uint256 value);
45	 event Approval(address indexed owner, address indexed spender, uint256 value);
46	 }
47	 pragma solidity >=0.6.0 <0.8.0;
48	 library SafeMath {
49	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
50	 uint256 c = a + b;
51	 require(c >= a, "SafeMath: addition overflow");
52	 return c;
53	 }
54	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
55	 return sub(a, b, "SafeMath: subtraction overflow");
56	 }
57	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
58	 require(b <= a, errorMessage);
59	 uint256 c = a - b;
60	 return c;
61	 }
62	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
63	 if (a == 0) {
64	 return 0;
65	 }
66	 uint256 c = a * b;
67	 require(c / a == b, "SafeMath: multiplication overflow");
68	 return c;
69	 }
70	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
71	 return div(a, b, "SafeMath: division by zero");
72	 }
73	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
74	 require(b > 0, errorMessage);
75	 uint256 c = a / b;
76	 return c;
77	 }
78	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
79	 return mod(a, b, "SafeMath: modulo by zero");
80	 }
81	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
82	 require(b != 0, errorMessage);
83	 return a % b;
84	 }
85	 }
86	 pragma solidity >=0.6.2 <0.8.0;
87	 library Address {
88	 function isContract(address account) internal view returns (bool) {
89	 uint256 size;
90	 assembly {
91	 size := extcodesize(account) }
92	 return size > 0;
93	 }
94	 function sendValue(address payable recipient, uint256 amount) internal {
95	 require(address(this).balance >= amount, "Address: insufficient balance");
96	 (bool success, ) = recipient.call{
97	 value: amount }
98	 ("");
99	 require(success, "Address: unable to send value, recipient may have reverted");
100	 }
101	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
102	 return functionCall(target, data, "Address: low-level call failed");
103	 }
104	 function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
105	 return functionCallWithValue(target, data, 0, errorMessage);
106	 }
107	 function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
108	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
109	 }
110	 function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
111	 require(address(this).balance >= value, "Address: insufficient balance for call");
112	 require(isContract(target), "Address: call to non-contract");
113	 (bool success, bytes memory returndata) = target.call{
114	 value: value }
115	 (data);
116	 return _verifyCallResult(success, returndata, errorMessage);
117	 }
118	 function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
119	 return functionStaticCall(target, data, "Address: low-level static call failed");
120	 }
121	 function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
122	 require(isContract(target), "Address: static call to non-contract");
123	 (bool success, bytes memory returndata) = target.staticcall(data);
124	 return _verifyCallResult(success, returndata, errorMessage);
125	 }
126	 function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
127	 if (success) {
128	 return returndata;
129	 }
130	 else {
131	 if (returndata.length > 0) {
132	 assembly {
133	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
134	 }
135	 else {
136	 revert(errorMessage);
137	 }
138	 }
139	 }
140	 }
141	 pragma solidity >=0.6.0 <0.8.0;
142	 library SafeERC20 {
143	 using SafeMath for uint256;
144	 using Address for address;
145	 function safeTransfer(IERC20 token, address to, uint256 value) internal {
146	 _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
147	 }
148	 function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
149	 _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
150	 }
151	 function safeApprove(IERC20 token, address spender, uint256 value) internal {
152	 require((value == 0) || (token.allowance(address(this), spender) == 0), "SafeERC20: approve from non-zero to non-zero allowance" );
153	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
154	 }
155	 function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
156	 uint256 newAllowance = token.allowance(address(this), spender).add(value);
157	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
158	 }
159	 function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
160	 uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
161	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
162	 }
163	 function _callOptionalReturn(IERC20 token, bytes memory data) private {
164	 bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
165	 if (returndata.length > 0) {
166	 require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
167	 }
168	 }
169	 }
170	 pragma solidity ^0.6.0;
171	 interface IYearnVaultV2 {
172	 function token() external view returns (address);
173	 function totalAssets() external view returns (uint256);
174	 function pricePerShare() external view returns (uint256);
175	 function deposit(uint256 amount) external;
176	 function deposit(uint256 amount, address recipient) external;
177	 function withdraw(uint256 maxShares) external;
178	 function withdraw(uint256 maxShares, address recipient) external;
179	 function withdraw( uint256 maxShares, address recipient, uint256 maxLoss ) external;
180	 function report( uint256 gain, uint256 loss, uint256 debtPayment ) external returns (uint256);
181	 }
182	 pragma solidity 0.6.12;
183	 interface PowerIndexPoolControllerInterface {
184	 function rebindByStrategyAdd( address token, uint256 balance, uint256 denorm, uint256 deposit ) external;
185	 function rebindByStrategyRemove( address token, uint256 balance, uint256 denorm ) external;
186	 function bindByStrategy( address token, uint256 balance, uint256 denorm ) external;
187	 function unbindByStrategy(address token) external;
188	 }
189	 pragma solidity 0.6.12;
190	 interface ICurveDepositor {
191	 function calc_withdraw_one_coin(uint256 _tokenAmount, int128 _index) external view returns (uint256);
192	 function remove_liquidity_one_coin( uint256 _token_amount, int128 _i, uint256 _min_amount ) external;
193	 }
194	 pragma solidity 0.6.12;
195	 interface ICurveDepositor2 {
196	 function add_liquidity(uint256[2] memory _amounts, uint256 _min_mint_amount) external;
197	 function calc_token_amount(uint256[2] memory _amounts, bool _deposit) external view returns (uint256);
198	 }
199	 pragma solidity 0.6.12;
200	 interface ICurveDepositor3 {
201	 function add_liquidity(uint256[3] memory _amounts, uint256 _min_mint_amount) external;
202	 function calc_token_amount(uint256[3] memory _amounts, bool _deposit) external view returns (uint256);
203	 }
204	 pragma solidity 0.6.12;
205	 interface ICurveDepositor4 {
206	 function add_liquidity(uint256[4] memory _amounts, uint256 _min_mint_amount) external;
207	 function calc_token_amount(uint256[4] memory _amounts, bool _deposit) external view returns (uint256);
208	 }
209	 pragma solidity 0.6.12;
210	 interface ICurveZapDepositor {
211	 function calc_withdraw_one_coin( address _pool, uint256 _tokenAmount, int128 _index ) external view returns (uint256);
212	 function remove_liquidity_one_coin( address _pool, uint256 _token_amount, int128 _i, uint256 _min_amount ) external;
213	 }
214	 pragma solidity 0.6.12;
215	 interface ICurveZapDepositor2 {
216	 function add_liquidity( address _pool, uint256[2] memory _amounts, uint256 _min_mint_amount ) external;
217	 function calc_token_amount( address _pool, uint256[2] memory _amounts, bool _deposit ) external view returns (uint256);
218	 }
219	 pragma solidity 0.6.12;
220	 interface ICurveZapDepositor3 {
221	 function add_liquidity( address _pool, uint256[3] memory _amounts, uint256 _min_mint_amount ) external;
222	 function calc_token_amount( address _pool, uint256[3] memory _amounts, bool _deposit ) external view returns (uint256);
223	 }
224	 pragma solidity 0.6.12;
225	 interface ICurveZapDepositor4 {
226	 function add_liquidity( address _pool, uint256[4] memory _amounts, uint256 _min_mint_amount ) external;
227	 function calc_token_amount( address _pool, uint256[4] memory _amounts, bool _deposit ) external view returns (uint256);
228	 }
229	 pragma solidity 0.6.12;
230	 interface ICurvePoolRegistry {
231	 function get_virtual_price_from_lp_token(address _token) external view returns (uint256);
232	 }
233	 pragma solidity >=0.4.24 <0.7.0;
234	 contract Initializable {
235	 bool private initialized;
236	 bool private initializing;
237	 modifier initializer() {
238	 require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");
239	 bool isTopLevelCall = !initializing;
240	 if (isTopLevelCall) {
241	 initializing = true;
242	 initialized = true;
243	 }
244	 _;
245	 if (isTopLevelCall) {
246	 initializing = false;
247	 }
248	 }
249	 function isConstructor() private view returns (bool) {
250	 address self = address(this);
251	 uint256 cs;
252	 assembly {
253	 cs := extcodesize(self) }
254	 return cs == 0;
255	 }
256	 uint256[50] private ______gap;
257	 }
258	 pragma solidity ^0.6.0;
259	 contract ContextUpgradeSafe is Initializable {
260	 function __Context_init() internal initializer {
261	 __Context_init_unchained();
262	 }
263	 function __Context_init_unchained() internal initializer {
264	 }
265	 function _msgSender() internal view virtual returns (address payable) {
266	 return msg.sender;
267	 }
268	 function _msgData() internal view virtual returns (bytes memory) {
269	 this;
270	 return msg.data;
271	 }
272	 uint256[50] private __gap;
273	 }
274	 pragma solidity ^0.6.0;
275	 contract OwnableUpgradeSafe is Initializable, ContextUpgradeSafe {
276	 address private _owner;
277	 event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
278	 function __Ownable_init() internal initializer {
279	 __Context_init_unchained();
280	 __Ownable_init_unchained();
281	 }
282	 function __Ownable_init_unchained() internal initializer {
283	 address msgSender = _msgSender();
284	 _owner = msgSender;
285	 emit OwnershipTransferred(address(0), msgSender);
286	 }
287	 function owner() public view returns (address) {
288	 return _owner;
289	 }
290	 modifier onlyOwner() {
291	 require(_owner == _msgSender(), "Ownable: caller is not the owner");
292	 _;
293	 }
294	 function renounceOwnership() public virtual onlyOwner {
295	 emit OwnershipTransferred(_owner, address(0));
296	 _owner = address(0);
297	 }
298	 function transferOwnership(address newOwner) public virtual onlyOwner {
299	 require(newOwner != address(0), "Ownable: new owner is the zero address");
300	 emit OwnershipTransferred(_owner, newOwner);
301	 _owner = newOwner;
302	 }
303	 uint256[49] private __gap;
304	 }
305	 pragma solidity 0.6.12;
306	 abstract contract SinglePoolManagement is OwnableUpgradeSafe {
307	 address public immutable pool;
308	 address public poolController;
309	 constructor(address _pool) public {
310	 pool = _pool;
311	 }
312	 function __SinglePoolManagement_init(address _poolController) internal {
313	 poolController = _poolController;
314	 }
315	 }
316	 pragma solidity 0.6.12;
317	 contract BConst {
318	 uint public constant BONE = 10**18;
319	 uint public constant MIN_BOUND_TOKENS = 2;
320	 uint public constant MAX_BOUND_TOKENS = 21;
321	 uint public constant MIN_FEE = BONE / 10**6;
322	 uint public constant MAX_FEE = BONE / 10;
323	 uint public constant MIN_WEIGHT = 1000000000;
324	 uint public constant MAX_WEIGHT = BONE * 50;
325	 uint public constant MAX_TOTAL_WEIGHT = BONE * 50;
326	 uint public constant MIN_BALANCE = BONE / 10**12;
327	 uint public constant INIT_POOL_SUPPLY = BONE * 100;
328	 uint public constant MIN_BPOW_BASE = 1 wei;
329	 uint public constant MAX_BPOW_BASE = (2 * BONE) - 1 wei;
330	 uint public constant BPOW_PRECISION = BONE / 10**10;
331	 uint public constant MAX_IN_RATIO = BONE / 2;
332	 uint public constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;
333	 }
334	 pragma solidity 0.6.12;
335	 contract BNum is BConst {
336	 function btoi(uint a) internal pure returns (uint) {
337	 return a / BONE;
338	 }
339	 function bfloor(uint a) internal pure returns (uint) {
340	 return btoi(a) * BONE;
341	 }
342	 function badd(uint a, uint b) internal pure returns (uint) {
343	 uint c = a + b;
344	 require(c >= a, "ERR_ADD_OVERFLOW");
345	 return c;
346	 }
347	 function bsub(uint a, uint b) internal pure returns (uint) {
348	 (uint c, bool flag) = bsubSign(a, b);
349	 require(!flag, "ERR_SUB_UNDERFLOW");
350	 return c;
351	 }
352	 function bsubSign(uint a, uint b) internal pure returns (uint, bool) {
353	 if (a >= b) {
354	 return (a - b, false);
355	 }
356	 else {
357	 return (b - a, true);
358	 }
359	 }
360	 function bmul(uint a, uint b) internal pure returns (uint) {
361	 uint c0 = a * b;
362	 require(a == 0 || c0 / a == b, "ERR_MUL_OVERFLOW");
363	 uint c1 = c0 + (BONE / 2);
364	 require(c1 >= c0, "ERR_MUL_OVERFLOW");
365	 uint c2 = c1 / BONE;
366	 return c2;
367	 }
368	 function bdiv(uint a, uint b) internal pure returns (uint) {
369	 require(b != 0, "ERR_DIV_ZERO");
370	 uint c0 = a * BONE;
371	 require(a == 0 || c0 / a == BONE, "ERR_DIV_INTERNAL");
372	 uint c1 = c0 + (b / 2);
373	 require(c1 >= c0, "ERR_DIV_INTERNAL");
374	 uint c2 = c1 / b;
375	 return c2;
376	 }
377	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
378	 require(b > 0, "ERR_DIV_ZERO");
379	 return a / b;
380	 }
381	 function bpowi(uint a, uint n) internal pure returns (uint) {
382	 uint z = n % 2 != 0 ? a : BONE;
383	 for (n /= 2; n != 0; n /= 2) {
384	 a = bmul(a, a);
385	 if (n % 2 != 0) {
386	 z = bmul(z, a);
387	 }
388	 }
389	 return z;
390	 }
391	 function bpow(uint base, uint exp) internal pure returns (uint) {
392	 require(base >= MIN_BPOW_BASE, "ERR_BPOW_BASE_TOO_LOW");
393	 require(base <= MAX_BPOW_BASE, "ERR_BPOW_BASE_TOO_HIGH");
394	 uint whole = bfloor(exp);
395	 uint remain = bsub(exp, whole);
396	 uint wholePow = bpowi(base, btoi(whole));
397	 if (remain == 0) {
398	 return wholePow;
399	 }
400	 uint partialResult = bpowApprox(base, remain, BPOW_PRECISION);
401	 return bmul(wholePow, partialResult);
402	 }
403	 function bpowApprox(uint base, uint exp, uint precision) internal pure returns (uint) {
404	 uint a = exp;
405	 (uint x, bool xneg) = bsubSign(base, BONE);
406	 uint term = BONE;
407	 uint sum = term;
408	 bool negative = false;
409	 for (uint i = 1; term >= precision; i++) {
410	 uint bigK = i * BONE;
411	 (uint c, bool cneg) = bsubSign(a, bsub(bigK, BONE));
412	 term = bmul(term, bmul(c, x));
413	 term = bdiv(term, bigK);
414	 if (term == 0) break;
415	 if (xneg) negative = !negative;
416	 if (cneg) negative = !negative;
417	 if (negative) {
418	 sum = bsub(sum, term);
419	 }
420	 else {
421	 sum = badd(sum, term);
422	 }
423	 }
424	 return sum;
425	 }
426	 }
427	 pragma solidity 0.6.12;
428	 interface BMathInterface {
429	 function calcInGivenOut( uint256 tokenBalanceIn, uint256 tokenWeightIn, uint256 tokenBalanceOut, uint256 tokenWeightOut, uint256 tokenAmountOut, uint256 swapFee ) external pure returns (uint256 tokenAmountIn);
430	 function calcSingleInGivenPoolOut( uint256 tokenBalanceIn, uint256 tokenWeightIn, uint256 poolSupply, uint256 totalWeight, uint256 poolAmountOut, uint256 swapFee ) external pure returns (uint256 tokenAmountIn);
431	 }
432	 pragma solidity 0.6.12;
433	 interface BPoolInterface is IERC20, BMathInterface {
434	 function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn) external;
435	 function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut) external;
436	 function swapExactAmountIn( address, uint256, address, uint256, uint256 ) external returns (uint256, uint256);
437	 function swapExactAmountOut( address, uint256, address, uint256, uint256 ) external returns (uint256, uint256);
438	 function joinswapExternAmountIn( address, uint256, uint256 ) external returns (uint256);
439	 function joinswapPoolAmountOut( address, uint256, uint256 ) external returns (uint256);
440	 function exitswapPoolAmountIn( address, uint256, uint256 ) external returns (uint256);
441	 function exitswapExternAmountOut( address, uint256, uint256 ) external returns (uint256);
442	 function getDenormalizedWeight(address) external view returns (uint256);
443	 function getBalance(address) external view returns (uint256);
444	 function getSwapFee() external view returns (uint256);
445	 function getTotalDenormalizedWeight() external view returns (uint256);
446	 function getCommunityFee() external view returns ( uint256, uint256, uint256, address );
447	 function calcAmountWithCommunityFee( uint256, uint256, address ) external view returns (uint256, uint256);
448	 function getRestrictions() external view returns (address);
449	 function isSwapsDisabled() external view returns (bool);
450	 function isFinalized() external view returns (bool);
451	 function isBound(address t) external view returns (bool);
452	 function getCurrentTokens() external view returns (address[] memory tokens);
453	 function getFinalTokens() external view returns (address[] memory tokens);
454	 function setSwapFee(uint256) external;
455	 function setCommunityFeeAndReceiver( uint256, uint256, uint256, address ) external;
456	 function setController(address) external;
457	 function setSwapsDisabled(bool) external;
458	 function finalize() external;
459	 function bind( address, uint256, uint256 ) external;
460	 function rebind( address, uint256, uint256 ) external;
461	 function unbind(address) external;
462	 function gulp(address) external;
463	 function callVoting( address voting, bytes4 signature, bytes calldata args, uint256 value ) external;
464	 function getMinWeight() external view returns (uint256);
465	 function getMaxBoundTokens() external view returns (uint256);
466	 }
467	 pragma solidity 0.6.12;
468	 interface PowerIndexPoolInterface is BPoolInterface {
469	 function initialize( string calldata name, string calldata symbol, uint256 minWeightPerSecond, uint256 maxWeightPerSecond ) external;
470	 function bind( address, uint256, uint256, uint256, uint256 ) external;
471	 function setDynamicWeight( address token, uint256 targetDenorm, uint256 fromTimestamp, uint256 targetTimestamp ) external;
472	 function getDynamicWeightSettings(address token) external view returns ( uint256 fromTimestamp, uint256 targetTimestamp, uint256 fromDenorm, uint256 targetDenorm );
473	 function getMinWeight() external view override returns (uint256);
474	 function getWeightPerSecondBounds() external view returns (uint256, uint256);
475	 function setWeightPerSecondBounds(uint256, uint256) external;
476	 function setWrapper(address, bool) external;
477	 function getWrapperMode() external view returns (bool);
478	 }
479	 pragma solidity 0.6.12;
480	 interface IPowerOracle {
481	 function assetPrices(address _token) external view returns (uint256);
482	 }
483	 pragma solidity 0.6.12;
484	 abstract contract WeightValueAbstract is BNum, OwnableUpgradeSafe {
485	 event UpdatePoolWeights( address indexed pool, uint256 indexed timestamp, address[] tokens, uint256[3][] weightsChange, uint256[] newTokenValues );
486	 event SetTotalWeight(uint256 totalWeight);
487	 struct TokenConfigItem {
488	 address token;
489	 address[] excludeTokenBalances;
490	 }
491	 IPowerOracle public oracle;
492	 uint256 public totalWeight;
493	 function getTokenValue(PowerIndexPoolInterface _pool, address _token) public view virtual returns (uint256) {
494	 return getTVL(_pool, _token);
495	 }
496	 function getTVL(PowerIndexPoolInterface _pool, address _token) public view returns (uint256) {
497	 uint256 balance = _pool.getBalance(_token);
498	 return bdiv(bmul(balance, oracle.assetPrices(_token)), 1 ether);
499	 }
500	 function setTotalWeight(uint256 _totalWeight) external onlyOwner {
501	 totalWeight = _totalWeight;
502	 emit SetTotalWeight(_totalWeight);
503	 }
504	 function _computeWeightsChangeWithEvent( PowerIndexPoolInterface _pool, address[] memory _tokens, address[] memory _piTokens, uint256 _minWPS, uint256 fromTimestamp, uint256 toTimestamp ) internal returns ( uint256[3][] memory weightsChange, uint256 lenToPush, uint256[] memory newTokensValues ) {
505	 (weightsChange, lenToPush, newTokensValues, ) = computeWeightsChange( _pool, _tokens, _piTokens, _minWPS, fromTimestamp, toTimestamp );
506	 emit UpdatePoolWeights(address(_pool), block.timestamp, _tokens, weightsChange, newTokensValues);
507	 }
508	 function computeWeightsChange( PowerIndexPoolInterface _pool, address[] memory _tokens, address[] memory _piTokens, uint256 _minWPS, uint256 fromTimestamp, uint256 toTimestamp ) public view returns ( uint256[3][] memory weightsChange, uint256 lenToPush, uint256[] memory newTokenValues, uint256 newTokenValueSum ) {
509	 uint256 len = _tokens.length;
510	 newTokenValues = new uint256[](len);
511	 for (uint256 i = 0; i < len; i++) {
512	 uint256 value = getTokenValue(_pool, _tokens[i]);
513	 newTokenValues[i] = value;
514	 newTokenValueSum = badd(newTokenValueSum, value);
515	 }
516	 weightsChange = new uint256[3][](len);
517	 for (uint256 i = 0; i < len; i++) {
518	 uint256 oldWeight;
519	 if (_piTokens.length == _tokens.length) {
520	 try _pool.getDenormalizedWeight(_piTokens[i]) returns (uint256 _weight) {
521	 oldWeight = _weight;
522	 }
523	 catch {
524	 oldWeight = 0;
525	 }
526	 }
527	 else {
528	 try _pool.getDenormalizedWeight(_tokens[i]) returns (uint256 _weight) {
529	 oldWeight = _weight;
530	 }
531	 catch {
532	 oldWeight = 0;
533	 }
534	 }
535	 uint256 newWeight = bmul(bdiv(newTokenValues[i], newTokenValueSum), totalWeight);
536	 weightsChange[i] = [i, oldWeight, newWeight];
537	 }
538	 for (uint256 i = 0; i < len; i++) {
539	 uint256 wps = getWeightPerSecond(weightsChange[i][1], weightsChange[i][2], fromTimestamp, toTimestamp);
540	 if (wps >= _minWPS) {
541	 lenToPush++;
542	 }
543	 }
544	 if (lenToPush > 1) {
545	 _sort(weightsChange);
546	 }
547	 }
548	 function getWeightPerSecond( uint256 fromDenorm, uint256 targetDenorm, uint256 fromTimestamp, uint256 targetTimestamp ) public pure returns (uint256) {
549	 uint256 delta = targetDenorm > fromDenorm ? bsub(targetDenorm, fromDenorm) : bsub(fromDenorm, targetDenorm);
550	 return div(delta, bsub(targetTimestamp, fromTimestamp));
551	 }
552	 function _quickSort( uint256[3][] memory wightsChange, int256 left, int256 right ) internal pure {
553	 int256 i = left;
554	 int256 j = right;
555	 if (i == j) return;
556	 uint256[3] memory pivot = wightsChange[uint256(left + (right - left) / 2)];
557	 int256 pDiff = int256(pivot[2]) - int256(pivot[1]);
558	 while (i <= j) {
559	 while (int256(wightsChange[uint256(i)][2]) - int256(wightsChange[uint256(i)][1]) < pDiff) i++;
560	 while (pDiff < int256(wightsChange[uint256(j)][2]) - int256(wightsChange[uint256(j)][1])) j--;
561	 if (i <= j) {
562	 (wightsChange[uint256(i)], wightsChange[uint256(j)]) = (wightsChange[uint256(j)], wightsChange[uint256(i)]);
563	 i++;
564	 j--;
565	 }
566	 }
567	 if (left < j) _quickSort(wightsChange, left, j);
568	 if (i < right) _quickSort(wightsChange, i, right);
569	 }
570	 function _sort(uint256[3][] memory weightsChange) internal pure {
571	 _quickSort(weightsChange, int256(0), int256(weightsChange.length - 1));
572	 }
573	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
574	 if (a == 0) {
575	 return 0;
576	 }
577	 uint256 c = a * b;
578	 require(c / a == b, "SafeMath: multiplication overflow");
579	 return c;
580	 }
581	 }
582	 pragma solidity 0.6.12;
583	 abstract contract WeightValueChangeRateAbstract is WeightValueAbstract {
584	 mapping(address => uint256) public lastValue;
585	 mapping(address => uint256) public valueChangeRate;
586	 bool public rateChangeDisabled;
587	 event UpdatePoolTokenValue( address indexed token, uint256 oldTokenValue, uint256 newTokenValue, uint256 lastChangeRate, uint256 newChangeRate );
588	 event SetValueChangeRate(address indexed token, uint256 oldRate, uint256 newRate);
589	 event SetRateChangeDisabled(bool rateChangeDisabled);
590	 constructor() public WeightValueAbstract() {
591	 }
592	 function _updatePoolByPoke( address _pool, address[] memory _tokens, uint256[] memory _newTokenValues ) internal {
593	 uint256 len = _tokens.length;
594	 for (uint256 i = 0; i < len; i++) {
595	 uint256 oldValue = lastValue[_tokens[i]];
596	 lastValue[_tokens[i]] = _newTokenValues[i];
597	 uint256 lastChangeRate;
598	 (lastChangeRate, valueChangeRate[_tokens[i]]) = getValueChangeRate(_tokens[i], oldValue, _newTokenValues[i]);
599	 emit UpdatePoolTokenValue(_tokens[i], oldValue, _newTokenValues[i], lastChangeRate, valueChangeRate[_tokens[i]]);
600	 }
601	 }
602	 function getValueChangeRate( address _token, uint256 oldTokenValue, uint256 newTokenValue ) public view returns (uint256 lastChangeRate, uint256 newChangeRate) {
603	 lastChangeRate = valueChangeRate[_token] == 0 ? 1 ether : valueChangeRate[_token];
604	 if (oldTokenValue == 0) {
605	 newChangeRate = lastChangeRate;
606	 return (lastChangeRate, newChangeRate);
607	 }
608	 newChangeRate = rateChangeDisabled ? lastChangeRate : bmul(bdiv(newTokenValue, oldTokenValue), lastChangeRate);
609	 }
610	 function getTokenValue(PowerIndexPoolInterface _pool, address _token) public view virtual override returns (uint256 value) {
611	 value = getTVL(_pool, _token);
612	 if (valueChangeRate[_token] != 0) {
613	 value = bmul(value, valueChangeRate[_token]);
614	 }
615	 }
616	 function setValueChangeRates(address[] memory _tokens, uint256[] memory _newTokenRates) public onlyOwner {
617	 uint256 len = _tokens.length;
618	 require(len == _newTokenRates.length, "LENGTHS_MISMATCH");
619	 for (uint256 i = 0; i < len; i++) {
620	 emit SetValueChangeRate(_tokens[i], valueChangeRate[_tokens[i]], _newTokenRates[i]);
621	 valueChangeRate[_tokens[i]] = _newTokenRates[i];
622	 }
623	 }
624	 function setRateUpdateDisabled(bool _disabled) public onlyOwner {
625	 rateChangeDisabled = _disabled;
626	 emit SetRateChangeDisabled(rateChangeDisabled);
627	 }
628	 }
629	 pragma solidity 0.6.12;
630	 contract YearnVaultInstantRebindStrategy is SinglePoolManagement, WeightValueChangeRateAbstract {
631	 using SafeMath for uint256;
632	 using SafeERC20 for IERC20;
633	 uint256 internal constant COMPENSATION_PLAN_1_ID = 1;
634	 event ChangePoolTokens(address[] poolTokensBefore, address[] poolTokensAfter);
635	 event InstantRebind(uint256 poolCurrentTokensCount, uint256 usdcPulled, uint256 usdcRemainder);
636	 event UpdatePool(address[] poolTokensBefore, address[] poolTokensAfter);
637	 event VaultWithdrawFee(address indexed vaultToken, uint256 crvAmount);
638	 event SeizeERC20(address indexed token, address indexed to, uint256 amount);
639	 event SetMaxWithdrawalLoss(uint256 maxWithdrawalLoss);
640	 event PullLiquidity( address indexed vaultToken, address crvToken, uint256 vaultAmount, uint256 crvAmountExpected, uint256 crvAmountActual, uint256 usdcAmount, uint256 vaultReserve );
641	 event PushLiquidity( address indexed vaultToken, address crvToken, uint256 vaultAmount, uint256 crvAmount, uint256 usdcAmount );
642	 event SetPoolController(address indexed poolController);
643	 event SetCurvePoolRegistry(address curvePoolRegistry);
644	 event SetVaultConfig( address indexed vault, address indexed depositor, uint8 depositorType, uint8 depositorTokenLength, int8 usdcIndex );
645	 event SetStrategyConstraints(uint256 minUSDCRemainder, bool useVirtualPriceEstimation);
646	 struct RebindConfig {
647	 address token;
648	 uint256 newWeight;
649	 uint256 oldBalance;
650	 uint256 newBalance;
651	 }
652	 struct VaultConfig {
653	 address depositor;
654	 uint8 depositorType;
655	 uint8 depositorTokenLength;
656	 int8 usdcIndex;
657	 }
658	 struct StrategyConstraints {
659	 uint256 minUSDCRemainder;
660	 bool useVirtualPriceEstimation;
661	 }
662	 struct PullDataHelper {
663	 address crvToken;
664	 uint256 yDiff;
665	 uint256 ycrvBalance;
666	 uint256 crvExpected;
667	 uint256 crvActual;
668	 uint256 usdcBefore;
669	 uint256 vaultReserve;
670	 }
671	 IERC20 public immutable USDC;
672	 IPowerPoke public powerPoke;
673	 ICurvePoolRegistry public curvePoolRegistry;
674	 uint256 public lastUpdate;
675	 uint256 public maxWithdrawalLoss;
676	 StrategyConstraints public constraints;
677	 address[] internal poolTokens;
678	 mapping(address => VaultConfig) public vaultConfig;
679	 modifier onlyEOA() {
680	 require(msg.sender == tx.origin, "ONLY_EOA");
681	 _;
682	 }
683	 modifier onlyReporter(uint256 _reporterId, bytes calldata _rewardOpts) {
684	 uint256 gasStart = gasleft();
685	 powerPoke.authorizeReporter(_reporterId, msg.sender);
686	 _;
687	 _reward(_reporterId, gasStart, COMPENSATION_PLAN_1_ID, _rewardOpts);
688	 }
689	 modifier onlyNonReporter(uint256 _reporterId, bytes calldata _rewardOpts) {
690	 uint256 gasStart = gasleft();
691	 powerPoke.authorizeNonReporter(_reporterId, msg.sender);
692	 _;
693	 _reward(_reporterId, gasStart, COMPENSATION_PLAN_1_ID, _rewardOpts);
694	 }
695	 constructor(address _pool, address _usdc) public SinglePoolManagement(_pool) OwnableUpgradeSafe() {
696	 USDC = IERC20(_usdc);
697	 }
698	 function initialize( address _powerPoke, address _curvePoolRegistry, address _poolController, uint256 _maxWithdrawalLoss, StrategyConstraints memory _constraints ) external initializer {
699	 __Ownable_init();
700	 __SinglePoolManagement_init(_poolController);
701	 maxWithdrawalLoss = _maxWithdrawalLoss;
702	 powerPoke = IPowerPoke(_powerPoke);
703	 curvePoolRegistry = ICurvePoolRegistry(_curvePoolRegistry);
704	 constraints = _constraints;
705	 totalWeight = 25 * BONE;
706	 }
707	 function getTokenValue(PowerIndexPoolInterface, address _token) public view override returns (uint256 value) {
708	 value = getVaultVirtualPriceEstimation(_token, IYearnVaultV2(_token).totalAssets());
709	 (, uint256 newValueChangeRate) = getValueChangeRate(_token, lastValue[_token], value);
710	 if (newValueChangeRate != 0) {
711	 value = bmul(value, newValueChangeRate);
712	 }
713	 }
714	 function getVaultVirtualPriceEstimation(address _token, uint256 _amount) public view returns (uint256) {
715	 return ICurvePoolRegistry(curvePoolRegistry).get_virtual_price_from_lp_token(IYearnVaultV2(_token).token()).mul( _amount ) / 1e18;
716	 }
717	 function getVaultUsdcEstimation( address _token, address _crvToken, uint256 _amount ) public returns (uint256) {
718	 VaultConfig memory vc = vaultConfig[_token];
719	 if (vc.depositorType == 2) {
720	 return ICurveZapDepositor(vc.depositor).calc_withdraw_one_coin(_crvToken, _amount, int128(vc.usdcIndex));
721	 }
722	 else {
723	 return ICurveDepositor(vc.depositor).calc_withdraw_one_coin(_amount, int128(vc.usdcIndex));
724	 }
725	 }
726	 function getPoolTokens() public view returns (address[] memory) {
727	 return poolTokens;
728	 }
729	 function setCurvePoolRegistry(address _curvePoolRegistry) external onlyOwner {
730	 curvePoolRegistry = ICurvePoolRegistry(_curvePoolRegistry);
731	 emit SetCurvePoolRegistry(_curvePoolRegistry);
732	 }
733	 function setVaultConfig( address _vault, address _depositor, uint8 _depositorType, uint8 _depositorTokenLength, int8 _usdcIndex ) external onlyOwner {
734	 vaultConfig[_vault] = VaultConfig(_depositor, _depositorType, _depositorTokenLength, _usdcIndex);
735	 IERC20 crvToken = IERC20(IYearnVaultV2(_vault).token());
736	 _checkApprove(USDC.approve(_depositor, uint256(-1)));
737	 _checkApprove(crvToken.approve(_vault, uint256(-1)));
738	 _checkApprove(crvToken.approve(_depositor, uint256(-1)));
739	 emit SetVaultConfig(_vault, _depositor, _depositorType, _depositorTokenLength, _usdcIndex);
740	 }
741	 function setPoolController(address _poolController) public onlyOwner {
742	 poolController = _poolController;
743	 _updatePool(poolController, _poolController);
744	 emit SetPoolController(_poolController);
745	 }
746	 function syncPoolTokens() external onlyOwner {
747	 address controller = poolController;
748	 _updatePool(controller, controller);
749	 }
750	 function setMaxWithdrawalLoss(uint256 _maxWithdrawalLoss) external onlyOwner {
751	 maxWithdrawalLoss = _maxWithdrawalLoss;
752	 emit SetMaxWithdrawalLoss(_maxWithdrawalLoss);
753	 }
754	 function removeApprovals(IERC20[] calldata _tokens, address[] calldata _tos) external onlyOwner {
755	 uint256 len = _tokens.length;
756	 for (uint256 i = 0; i < len; i++) {
757	 _checkApprove(_tokens[i].approve(_tos[i], uint256(0)));
758	 }
759	 }
760	 function seizeERC20( address[] calldata _tokens, address[] calldata _tos, uint256[] calldata _amounts ) external onlyOwner {
761	 uint256 len = _tokens.length;
762	 require(len == _tos.length && len == _amounts.length, "LENGTHS");
763	 for (uint256 i = 0; i < len; i++) {
764	 IERC20(_tokens[i]).safeTransfer(_tos[i], _amounts[i]);
765	 emit SeizeERC20(_tokens[i], _tos[i], _amounts[i]);
766	 }
767	 }
768	 function setStrategyConstraints(StrategyConstraints memory _constraints) external onlyOwner {
769	 constraints = _constraints;
770	 emit SetStrategyConstraints(_constraints.minUSDCRemainder, _constraints.useVirtualPriceEstimation);
771	 }
772	 function _checkApprove(bool _result) internal {
773	 require(_result, "APPROVE_FAILED");
774	 }
775	 function _updatePool(address _oldController, address _newController) internal {
776	 address[] memory poolTokensBefore = poolTokens;
777	 uint256 len = poolTokensBefore.length;
778	 if (_oldController != address(0)) {
779	 for (uint256 i = 0; i < len; i++) {
780	 _removeApprovalVault(poolTokensBefore[i], address(_oldController));
781	 }
782	 }
783	 address[] memory poolTokensAfter = PowerIndexPoolInterface(pool).getCurrentTokens();
784	 poolTokens = poolTokensAfter;
785	 len = poolTokensAfter.length;
786	 for (uint256 i = 0; i < len; i++) {
787	 _approveVault(poolTokensAfter[i], address(_newController));
788	 }
789	 emit UpdatePool(poolTokensBefore, poolTokensAfter);
790	 }
791	 function _approveVault(address _vaultToken, address _controller) internal {
792	 IERC20 vaultToken = IERC20(_vaultToken);
793	 _checkApprove(vaultToken.approve(pool, uint256(-1)));
794	 _checkApprove(vaultToken.approve(_controller, uint256(-1)));
795	 }
796	 function _removeApprovalVault(address _vaultToken, address _controller) internal {
797	 IERC20 vaultToken = IERC20(_vaultToken);
798	 _checkApprove(vaultToken.approve(pool, uint256(0)));
799	 _checkApprove(vaultToken.approve(_controller, uint256(0)));
800	 }
801	 function changePoolTokens(address[] memory _newTokens) external onlyOwner {
802	 address[] memory _currentTokens = BPoolInterface(pool).getCurrentTokens();
803	 uint256 cLen = _currentTokens.length;
804	 uint256 nLen = _newTokens.length;
805	 for (uint256 i = 0; i < cLen; i++) {
806	 bool existsInNewTokens = false;
807	 for (uint256 j = 0; j < nLen; j++) {
808	 if (_currentTokens[i] == _newTokens[j]) {
809	 existsInNewTokens = true;
810	 }
811	 }
812	 if (!existsInNewTokens) {
813	 PowerIndexPoolControllerInterface(poolController).unbindByStrategy(_currentTokens[i]);
814	 _vaultToUsdc(_currentTokens[i], IYearnVaultV2(_currentTokens[i]).token(), vaultConfig[_currentTokens[i]]);
815	 _removeApprovalVault(_currentTokens[i], address(poolController));
816	 }
817	 }
818	 for (uint256 j = 0; j < nLen; j++) {
819	 if (!BPoolInterface(pool).isBound(_newTokens[j])) {
820	 _approveVault(_newTokens[j], address(poolController));
821	 }
822	 }
823	 _instantRebind(_newTokens, true);
824	 emit ChangePoolTokens(_currentTokens, _newTokens);
825	 }
826	 function pokeFromReporter(uint256 _reporterId, bytes calldata _rewardOpts) external onlyReporter(_reporterId, _rewardOpts) onlyEOA {
827	 _poke(false);
828	 }
829	 function pokeFromSlasher(uint256 _reporterId, bytes calldata _rewardOpts) external onlyNonReporter(_reporterId, _rewardOpts) onlyEOA {
830	 _poke(true);
831	 }
832	 function _poke(bool _bySlasher) internal {
833	 (uint256 minInterval, uint256 maxInterval) = _getMinMaxReportInterval();
834	 require(lastUpdate + minInterval < block.timestamp, "MIN_INTERVAL_NOT_REACHED");
835	 if (_bySlasher) {
836	 require(lastUpdate + maxInterval < block.timestamp, "MAX_INTERVAL_NOT_REACHED");
837	 }
838	 lastUpdate = block.timestamp;
839	 _instantRebind(BPoolInterface(pool).getCurrentTokens(), false);
840	 }
841	 function _vaultToUsdc( address _token, address _crvToken, VaultConfig memory _vc ) internal returns ( uint256 crvBalance, uint256 crvReceived, uint256 usdcBefore ) {
842	 crvBalance = IERC20(_token).balanceOf(address(this));
843	 uint256 crvBefore = IERC20(_crvToken).balanceOf(address(this));
844	 IYearnVaultV2(_token).withdraw(crvBalance, address(this), maxWithdrawalLoss);
845	 crvReceived = IERC20(_crvToken).balanceOf(address(this)).sub(crvBefore);
846	 usdcBefore = USDC.balanceOf(address(this));
847	 if (_vc.depositorType == 2) {
848	 ICurveZapDepositor(_vc.depositor).remove_liquidity_one_coin(_crvToken, crvReceived, _vc.usdcIndex, 0);
849	 }
850	 else {
851	 ICurveDepositor(_vc.depositor).remove_liquidity_one_coin(crvReceived, _vc.usdcIndex, 0);
852	 }
853	 }
854	 function _usdcToVault( address _token, VaultConfig memory _vc, uint256 _usdcAmount ) internal returns ( uint256 crvBalance, uint256 vaultBalance, address crvToken ) {
855	 crvToken = IYearnVaultV2(_token).token();
856	 _addUSDC2CurvePool(crvToken, _vc, _usdcAmount);
857	 crvBalance = IERC20(crvToken).balanceOf(address(this));
858	 IYearnVaultV2(_token).deposit(crvBalance);
859	 vaultBalance = IERC20(_token).balanceOf(address(this));
860	 }
861	 function _instantRebind(address[] memory _tokens, bool _allowNotBound) internal {
862	 address poolController_ = poolController;
863	 require(poolController_ != address(0), "CFG_NOT_SET");
864	 RebindConfig[] memory configs = fetchRebindConfigs(PowerIndexPoolInterface(pool), _tokens, _allowNotBound);
865	 uint256 toPushUSDCTotal;
866	 uint256 len = configs.length;
867	 uint256[] memory toPushUSDC = new uint256[](len);
868	 VaultConfig[] memory vaultConfigs = new VaultConfig[](len);
869	 for (uint256 si = 0; si < len; si++) {
870	 RebindConfig memory cfg = configs[si];
871	 VaultConfig memory vc = vaultConfig[cfg.token];
872	 vaultConfigs[si] = vc;
873	 require(vc.depositor != address(0), "DEPOSIT_CONTRACT_NOT_SET");
874	 if (cfg.newBalance <= cfg.oldBalance) {
875	 PullDataHelper memory mem;
876	 mem.crvToken = IYearnVaultV2(cfg.token).token();
877	 mem.vaultReserve = IERC20(mem.crvToken).balanceOf(cfg.token);
878	 mem.yDiff = (cfg.oldBalance - cfg.newBalance);
879	 PowerIndexPoolControllerInterface(poolController_).rebindByStrategyRemove( cfg.token, cfg.newBalance, cfg.newWeight );
880	 (mem.ycrvBalance, mem.crvActual, mem.usdcBefore) = _vaultToUsdc(cfg.token, mem.crvToken, vc);
881	 mem.crvExpected = (mem.ycrvBalance * IYearnVaultV2(cfg.token).pricePerShare()) / 1e18;
882	 emit PullLiquidity( cfg.token, mem.crvToken, mem.yDiff, mem.crvExpected, mem.crvActual, USDC.balanceOf(address(this)) - mem.usdcBefore, mem.vaultReserve );
883	 }
884	 else {
885	 uint256 yDiff = cfg.newBalance - cfg.oldBalance;
886	 uint256 crvAmount = IYearnVaultV2(cfg.token).pricePerShare().mul(yDiff) / 1e18;
887	 uint256 usdcIn;
888	 address crvToken = IYearnVaultV2(cfg.token).token();
889	 if (constraints.useVirtualPriceEstimation) {
890	 uint256 virtualPrice = ICurvePoolRegistry(curvePoolRegistry).get_virtual_price_from_lp_token(crvToken);
891	 usdcIn = bmul(virtualPrice, crvAmount);
892	 }
893	 else {
894	 usdcIn = getVaultUsdcEstimation(cfg.token, crvToken, crvAmount);
895	 }
896	 toPushUSDCTotal = toPushUSDCTotal.add(usdcIn);
897	 toPushUSDC[si] = usdcIn;
898	 }
899	 }
900	 uint256 usdcPulled = USDC.balanceOf(address(this));
901	 require(usdcPulled > 0, "USDC_PULLED_NULL");
902	 for (uint256 si = 0; si < len; si++) {
903	 if (toPushUSDC[si] > 0) {
904	 RebindConfig memory cfg = configs[si];
905	 uint256 usdcAmount = (usdcPulled.mul(toPushUSDC[si])) / toPushUSDCTotal;
906	 (uint256 crvBalance, uint256 vaultBalance, address crvToken) = _usdcToVault(cfg.token, vaultConfigs[si], usdcAmount);
907	 uint256 newBalance;
908	 try BPoolInterface(pool).getBalance(cfg.token) returns (uint256 _poolBalance) {
909	 newBalance = IERC20(cfg.token).balanceOf(address(this)).add(_poolBalance);
910	 }
911	 catch {
912	 newBalance = IERC20(cfg.token).balanceOf(address(this));
913	 }
914	 if (cfg.oldBalance == 0) {
915	 require(_allowNotBound, "BIND_NOT_ALLOW");
916	 PowerIndexPoolControllerInterface(poolController_).bindByStrategy(cfg.token, newBalance, cfg.newWeight);
917	 }
918	 else {
919	 PowerIndexPoolControllerInterface(poolController_).rebindByStrategyAdd( cfg.token, newBalance, cfg.newWeight, vaultBalance );
920	 }
921	 emit PushLiquidity(cfg.token, crvToken, vaultBalance, crvBalance, usdcAmount);
922	 }
923	 }
924	 uint256 usdcRemainder = USDC.balanceOf(address(this));
925	 require(usdcRemainder <= constraints.minUSDCRemainder, "USDC_REMAINDER");
926	 emit InstantRebind(len, usdcPulled, usdcRemainder);
927	 }
928	 function fetchRebindConfigs( PowerIndexPoolInterface _pool, address[] memory _tokens, bool _allowNotBound ) internal returns (RebindConfig[] memory configs) {
929	 uint256 len = _tokens.length;
930	 (uint256[] memory oldBalances, uint256[] memory poolUSDCBalances, uint256 totalUSDCPool) = getRebindConfigBalances(_pool, _tokens);
931	 (uint256[3][] memory weightsChange, , uint256[] memory newTokenValuesUSDC, uint256 totalValueUSDC) = computeWeightsChange(_pool, _tokens, new address[](0), 0, block.timestamp, block.timestamp + 1);
932	 configs = new RebindConfig[](len);
933	 for (uint256 si = 0; si < len; si++) {
934	 uint256[3] memory wc = weightsChange[si];
935	 require(wc[1] != 0 || _allowNotBound, "TOKEN_NOT_BOUND");
936	 configs[si] = RebindConfig( _tokens[wc[0]], wc[2], oldBalances[wc[0]], getNewTokenBalance(_tokens, wc, poolUSDCBalances, newTokenValuesUSDC, totalUSDCPool, totalValueUSDC) );
937	 }
938	 _updatePoolByPoke(pool, _tokens, newTokenValuesUSDC);
939	 }
940	 function getNewTokenBalance( address[] memory _tokens, uint256[3] memory wc, uint256[] memory poolUSDCBalances, uint256[] memory newTokenValuesUSDC, uint256 totalUSDCPool, uint256 totalValueUSDC ) internal view returns (uint256) {
941	 return bdiv( bdiv(bmul(wc[2], totalUSDCPool), totalWeight), bdiv(poolUSDCBalances[wc[0]], IERC20(_tokens[wc[0]]).totalSupply()) ) * 1e12;
942	 }
943	 function getRebindConfigBalances(PowerIndexPoolInterface _pool, address[] memory _tokens) internal returns ( uint256[] memory oldBalances, uint256[] memory poolUSDCBalances, uint256 totalUSDCPool ) {
944	 uint256 len = _tokens.length;
945	 oldBalances = new uint256[](len);
946	 poolUSDCBalances = new uint256[](len);
947	 totalUSDCPool = USDC.balanceOf(address(this));
948	 for (uint256 oi = 0; oi < len; oi++) {
949	 try PowerIndexPoolInterface(address(_pool)).getBalance(_tokens[oi]) returns (uint256 _balance) {
950	 oldBalances[oi] = _balance;
951	 totalUSDCPool = totalUSDCPool.add( getVaultUsdcEstimation(_tokens[oi], IYearnVaultV2(_tokens[oi]).token(), oldBalances[oi]) );
952	 }
953	 catch {
954	 oldBalances[oi] = 0;
955	 }
956	 uint256 poolUSDCBalance = getVaultVirtualPriceEstimation(_tokens[oi], IYearnVaultV2(_tokens[oi]).totalAssets());
957	 poolUSDCBalances[oi] = poolUSDCBalance;
958	 }
959	 }
960	 function _addUSDC2CurvePool( address _crvToken, VaultConfig memory _vc, uint256 _usdcAmount ) internal {
961	 if (_vc.depositorTokenLength == 2) {
962	 uint256[2] memory amounts;
963	 amounts[uint256(_vc.usdcIndex)] = _usdcAmount;
964	 if (_vc.depositorType == 2) {
965	 ICurveZapDepositor2(_vc.depositor).add_liquidity(_crvToken, amounts, 1);
966	 }
967	 else {
968	 ICurveDepositor2(_vc.depositor).add_liquidity(amounts, 1);
969	 }
970	 }
971	 if (_vc.depositorTokenLength == 3) {
972	 uint256[3] memory amounts;
973	 amounts[uint256(_vc.usdcIndex)] = _usdcAmount;
974	 if (_vc.depositorType == 2) {
975	 ICurveZapDepositor3(_vc.depositor).add_liquidity(_crvToken, amounts, 1);
976	 }
977	 else {
978	 ICurveDepositor3(_vc.depositor).add_liquidity(amounts, 1);
979	 }
980	 }
981	 if (_vc.depositorTokenLength == 4) {
982	 uint256[4] memory amounts;
983	 amounts[uint256(_vc.usdcIndex)] = _usdcAmount;
984	 if (_vc.depositorType == 2) {
985	 ICurveZapDepositor4(_vc.depositor).add_liquidity(_crvToken, amounts, 1);
986	 }
987	 else {
988	 ICurveDepositor4(_vc.depositor).add_liquidity(amounts, 1);
989	 }
990	 }
991	 }
992	 function _reward( uint256 _reporterId, uint256 _gasStart, uint256 _compensationPlan, bytes calldata _rewardOpts ) internal {
993	 powerPoke.reward(_reporterId, bsub(_gasStart, gasleft()), _compensationPlan, _rewardOpts);
994	 }
995	 function _getMinMaxReportInterval() internal view returns (uint256 min, uint256 max) {
996	 (uint256 minInterval, uint256 maxInterval) = powerPoke.getMinMaxReportIntervals(address(this));
997	 require(minInterval > 0 && maxInterval > 0, "INTERVALS_ARE_0");
998	 return (minInterval, maxInterval);
999	 }
1000	 }
