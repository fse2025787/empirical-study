row number 
1	         pragma solidity ^0.8.4;
2	 interface ICedarDeployerEventsV0 {
3	 event CedarInterfaceDeployed( address indexed contractAddress, uint256 indexed majorVersion, uint256 indexed minorVersion, uint256 patchVersion, string interfaceName );
4	 event CedarImplementationDeployed( address indexed implementationAddress, uint256 indexed majorVersion, uint256 indexed minorVersion, uint256 patchVersion, string contractName );
5	 event CedarERC721PremintV0Deployment( address indexed contractAddress, uint256 indexed majorVersion, uint256 indexed minorVersion, uint256 patchVersion, address adminAddress, string name, string symbol, uint256 maxLimit, string userAgreement, string baseURI );
6	 event CedarERC721DropV0Deployment( address indexed contractAddress, uint256 indexed majorVersion, uint256 indexed minorVersion, uint256 patchVersion, address defaultAdmin, string name, string symbol, string contractURI, address[] trustedForwarders, address saleRecipient, address royaltyRecipient, uint128 royaltyBps, string userAgreement, address signatureVerifier, address greenlistManager );
7	 }
8	 interface ICedarDeployerEventsV1 is ICedarDeployerEventsV0 {
9	 event CedarERC1155DropV0Deployment( address indexed contractAddress, uint256 indexed majorVersion, uint256 indexed minorVersion, uint256 patchVersion, address defaultAdmin, string name, string symbol, string contractURI, address[] trustedForwarders, address saleRecipient, address royaltyRecipient, uint128 royaltyBps, uint128 platformFeeBps, address platformFeeRecipient );
10	 }
11	 pragma solidity ^0.8.0;
12	 interface IERC165Upgradeable {
13	 function supportsInterface(bytes4 interfaceId) external view returns (bool);
14	 }
15	 pragma solidity ^0.8.0;
16	 abstract contract Initializable {
17	 bool private _initialized;
18	 bool private _initializing;
19	 modifier initializer() {
20	 require(_initializing ? _isConstructor() : !_initialized, "Initializable: contract is already initialized");
21	 bool isTopLevelCall = !_initializing;
22	 if (isTopLevelCall) {
23	 _initializing = true;
24	 _initialized = true;
25	 }
26	 _;
27	 if (isTopLevelCall) {
28	 _initializing = false;
29	 }
30	 }
31	 modifier onlyInitializing() {
32	 require(_initializing, "Initializable: contract is not initializing");
33	 _;
34	 }
35	 function _isConstructor() private view returns (bool) {
36	 return !AddressUpgradeable.isContract(address(this));
37	 }
38	 }
39	 pragma solidity ^0.8.0;
40	 interface IDropClaimConditionV0 {
41	 struct ClaimCondition {
42	 uint256 startTimestamp;
43	 uint256 maxClaimableSupply;
44	 uint256 supplyClaimed;
45	 uint256 quantityLimitPerTransaction;
46	 uint256 waitTimeInSecondsBetweenClaims;
47	 bytes32 merkleRoot;
48	 uint256 pricePerToken;
49	 address currency;
50	 }
51	 struct ClaimConditionList {
52	 uint256 currentStartId;
53	 uint256 count;
54	 mapping(uint256 => ClaimCondition) phases;
55	 mapping(uint256 => mapping(address => uint256)) limitLastClaimTimestamp;
56	 mapping(uint256 => BitMapsUpgradeable.BitMap) limitMerkleProofClaim;
57	 }
58	 }
59	 interface ICedarDeployerEventsV2 is ICedarDeployerEventsV1 {
60	 event CedarERC721PremintV1Deployment( address indexed contractAddress, uint256 indexed majorVersion, uint256 indexed minorVersion, uint256 patchVersion, address adminAddress, string name, string symbol, uint256 maxLimit, string userAgreement, string baseURI );
61	 }
62	 pragma solidity ^0.8.0;
63	 interface IERC721Upgradeable is IERC165Upgradeable {
64	 event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
65	 event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
66	 event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
67	 function balanceOf(address owner) external view returns (uint256 balance);
68	 function ownerOf(uint256 tokenId) external view returns (address owner);
69	 function safeTransferFrom( address from, address to, uint256 tokenId ) external;
70	 function transferFrom( address from, address to, uint256 tokenId ) external;
71	 function approve(address to, uint256 tokenId) external;
72	 function getApproved(uint256 tokenId) external view returns (address operator);
73	 function setApprovalForAll(address operator, bool _approved) external;
74	 function isApprovedForAll(address owner, address operator) external view returns (bool);
75	 function safeTransferFrom( address from, address to, uint256 tokenId, bytes calldata data ) external;
76	 }
77	 interface ICedarImplementationVersionedV0 {
78	 function implementationVersion() external view returns ( uint256 major, uint256 minor, uint256 patch );
79	 }
80	 pragma solidity ^0.8.4;
81	 interface ICedarNFTIssuanceV0 is IDropClaimConditionV0 {
82	 event TokensClaimed( uint256 indexed claimConditionIndex, address indexed claimer, address indexed receiver, uint256 startTokenId, uint256 quantityClaimed );
83	 event ClaimConditionsUpdated(ClaimCondition[] claimConditions);
84	 function setClaimConditions(ClaimCondition[] calldata phases, bool resetClaimEligibility) external;
85	 function claim( address receiver, uint256 quantity, address currency, uint256 pricePerToken, bytes32[] calldata proofs, uint256 proofMaxQuantityPerTransaction ) external payable;
86	 }
87	 pragma solidity ^0.8.0;
88	 abstract contract ContextUpgradeable is Initializable {
89	 function __Context_init() internal onlyInitializing {
90	 }
91	 function __Context_init_unchained() internal onlyInitializing {
92	 }
93	 function _msgSender() internal view virtual returns (address) {
94	 return msg.sender;
95	 }
96	 function _msgData() internal view virtual returns (bytes calldata) {
97	 return msg.data;
98	 }
99	 uint256[50] private __gap;
100	 }
101	 pragma solidity ^0.8.4;
102	 interface ICedarMinorVersionedV0 {
103	 function minorVersion() external view returns (uint256 minor, uint256 patch);
104	 }
105	 pragma solidity ^0.8.4;
106	 interface ICedarAgreementV0 {
107	 function acceptTerms() external;
108	 function userAgreement() external view returns (string memory);
109	 function termsActivated() external view returns (bool);
110	 function setTermsStatus(bool _status) external;
111	 function getAgreementStatus(address _address) external view returns (bool sig);
112	 function storeTermsAccepted(address _acceptor, bytes calldata _signature) external;
113	 }
114	 interface ICedarDeployerEventsV3 is ICedarDeployerEventsV2 {
115	 event CedarPaymentSplitterDeployment( address indexed contractAddress, uint256 indexed majorVersion, uint256 indexed minorVersion, uint256 patchVersion, address[] payees, uint256[] shares );
116	 }
117	 pragma solidity ^0.8.0;
118	 interface ICedarFeaturesV0 is IERC165Upgradeable {
119	 function isICedarFeaturesV0() external pure returns (bool);
120	 function supportedFeatures() external pure returns (string[] memory features);
121	 }
122	 pragma solidity ^0.8.4;
123	 interface IMulticallableV0 {
124	 function multicall(bytes[] calldata data) external returns (bytes[] memory results);
125	 }
126	 interface ICedarVersionedV0 is ICedarImplementationVersionedV0, ICedarMinorVersionedV0, IERC165Upgradeable {
127	 }
128	 interface ICedarNFTIssuanceV1 is ICedarNFTIssuanceV0 {
129	 function getActiveClaimConditions() external view returns (ClaimCondition memory condition, uint256 conditionId, uint256 walletMaxClaimCount, uint256 remainingSupply);
130	 function getUserClaimConditions(address _claimer) external view returns (uint256 conditionId, uint256 walletClaimedCount, uint256 lastClaimTimestamp, uint256 nextValidClaimTimestamp);
131	 function verifyClaim( uint256 _conditionId, address _claimer, uint256 _quantity, address _currency, uint256 _pricePerToken, bool verifyMaxQuantityPerTransaction ) external view;
132	 }
133	 interface ICedarNFTLazyMintV1 {
134	 event TokensLazyMinted(uint256 startTokenId, uint256 endTokenId, string baseURI);
135	 function lazyMint( uint256 amount, string calldata baseURIForTokens ) external;
136	 }
137	 pragma solidity ^0.8.4;
138	 interface IERC721V0 is IERC721Upgradeable {
139	 }
140	 pragma solidity ^0.8.0;
141	 interface IRoyaltyV0 {
142	 struct RoyaltyInfo {
143	 address recipient;
144	 uint256 bps;
145	 }
146	 function getDefaultRoyaltyInfo() external view returns (address, uint16);
147	 function setDefaultRoyaltyInfo(address _royaltyRecipient, uint256 _royaltyBps) external;
148	 function setRoyaltyInfoForToken( uint256 tokenId, address recipient, uint256 bps ) external;
149	 function getRoyaltyInfoForToken(uint256 tokenId) external view returns (address, uint16);
150	 function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address receiver, uint256 royaltyAmount);
151	 event DefaultRoyalty(address newRoyaltyRecipient, uint256 newRoyaltyBps);
152	 event RoyaltyForToken(uint256 indexed tokenId, address royaltyRecipient, uint256 royaltyBps);
153	 }
154	 pragma solidity ^0.8.4;
155	 interface ICedarUpdateBaseURIV0 {
156	 event BaseURIUpdated(uint256 baseURIIndex, string baseURI);
157	 function updateBaseURI( uint256 baseURIIndex, string calldata _baseURIForTokens ) external;
158	 function getBaseURIIndices() external view returns(uint256[] memory);
159	 }
160	 pragma solidity ^0.8.0;
161	 interface ICedarMetadataV0 {
162	 function contractURI() external view returns (string memory);
163	 function setContractURI(string calldata _uri) external;
164	 }
165	 pragma solidity ^0.8.0;
166	 interface IERC721MetadataUpgradeable is IERC721Upgradeable {
167	 function name() external view returns (string memory);
168	 function symbol() external view returns (string memory);
169	 function tokenURI(uint256 tokenId) external view returns (string memory);
170	 }
171	 pragma solidity ^0.8.0;
172	 abstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {
173	 function __ERC165_init() internal onlyInitializing {
174	 }
175	 function __ERC165_init_unchained() internal onlyInitializing {
176	 }
177	 function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
178	 return interfaceId == type(IERC165Upgradeable).interfaceId;
179	 }
180	 uint256[50] private __gap;
181	 }
182	 pragma solidity ^0.8.0;
183	 interface IAccessControlUpgradeable {
184	 event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
185	 event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
186	 event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
187	 function hasRole(bytes32 role, address account) external view returns (bool);
188	 function getRoleAdmin(bytes32 role) external view returns (bytes32);
189	 function grantRole(bytes32 role, address account) external;
190	 function revokeRole(bytes32 role, address account) external;
191	 function renounceRole(bytes32 role, address account) external;
192	 }
193	 interface ICedarNFTMetadataV1 {
194	 function tokenURI(uint256 _tokenId) view external returns (string memory);
195	 }
196	 pragma solidity ^0.8.4;
197	 interface ICedarSFTIssuanceV0 is IDropClaimConditionV0 {
198	 event TokensClaimed( uint256 indexed claimConditionIndex, uint256 indexed tokenId, address indexed claimer, address receiver, uint256 quantityClaimed );
199	 event TokensIssued( uint256 indexed tokenId, address indexed claimer, address receiver, uint256 quantityClaimed );
200	 event ClaimConditionsUpdated(uint256 indexed tokenId, ClaimCondition[] claimConditions);
201	 function setClaimConditions( uint256 tokenId, ClaimCondition[] calldata phases, bool resetClaimEligibility ) external;
202	 function claim( address receiver, uint256 tokenId, uint256 quantity, address currency, uint256 pricePerToken, bytes32[] calldata proofs, uint256 proofMaxQuantityPerTransaction ) external payable;
203	 function issue( address receiver, uint256 tokenId, uint256 quantity ) external;
204	 }
205	 interface ICedarDeployerEventsV4 is ICedarDeployerEventsV3 {
206	 event CedarERC721DropV1Deployment( address indexed contractAddress, uint256 indexed majorVersion, uint256 indexed minorVersion, uint256 patchVersion, address defaultAdmin, string name, string symbol, string contractURI, address[] trustedForwarders, address saleRecipient, address royaltyRecipient, uint128 royaltyBps, string userAgreement, address signatureVerifier, address greenlistManager );
207	 event CedarERC1155DropV1Deployment( address indexed contractAddress, uint256 indexed majorVersion, uint256 indexed minorVersion, uint256 patchVersion, address defaultAdmin, string name, string symbol, string contractURI, address[] trustedForwarders, address saleRecipient, address royaltyRecipient, uint128 royaltyBps, uint128 platformFeeBps, address platformFeeRecipient );
208	 }
209	 pragma solidity ^0.8.0;
210	 abstract contract Context {
211	 function _msgSender() internal view virtual returns (address) {
212	 return msg.sender;
213	 }
214	 function _msgData() internal view virtual returns (bytes calldata) {
215	 return msg.data;
216	 }
217	 }
218	 pragma solidity ^0.8.0;
219	 contract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable {
220	 using AddressUpgradeable for address;
221	 using StringsUpgradeable for uint256;
222	 string private _name;
223	 string private _symbol;
224	 mapping(uint256 => address) private _owners;
225	 mapping(address => uint256) private _balances;
226	 mapping(uint256 => address) private _tokenApprovals;
227	 mapping(address => mapping(address => bool)) private _operatorApprovals;
228	 function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {
229	 __ERC721_init_unchained(name_, symbol_);
230	 }
231	 function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {
232	 _name = name_;
233	 _symbol = symbol_;
234	 }
235	 function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {
236	 return interfaceId == type(IERC721Upgradeable).interfaceId || interfaceId == type(IERC721MetadataUpgradeable).interfaceId || super.supportsInterface(interfaceId);
237	 }
238	 function balanceOf(address owner) public view virtual override returns (uint256) {
239	 require(owner != address(0), "ERC721: balance query for the zero address");
240	 return _balances[owner];
241	 }
242	 function ownerOf(uint256 tokenId) public view virtual override returns (address) {
243	 address owner = _owners[tokenId];
244	 require(owner != address(0), "ERC721: owner query for nonexistent token");
245	 return owner;
246	 }
247	 function name() public view virtual override returns (string memory) {
248	 return _name;
249	 }
250	 function symbol() public view virtual override returns (string memory) {
251	 return _symbol;
252	 }
253	 function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
254	 require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
255	 string memory baseURI = _baseURI();
256	 return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";
257	 }
258	 function _baseURI() internal view virtual returns (string memory) {
259	 return "";
260	 }
261	 function approve(address to, uint256 tokenId) public virtual override {
262	 address owner = ERC721Upgradeable.ownerOf(tokenId);
263	 require(to != owner, "ERC721: approval to current owner");
264	 require( _msgSender() == owner || isApprovedForAll(owner, _msgSender()), "ERC721: approve caller is not owner nor approved for all" );
265	 _approve(to, tokenId);
266	 }
267	 function getApproved(uint256 tokenId) public view virtual override returns (address) {
268	 require(_exists(tokenId), "ERC721: approved query for nonexistent token");
269	 return _tokenApprovals[tokenId];
270	 }
271	 function setApprovalForAll(address operator, bool approved) public virtual override {
272	 _setApprovalForAll(_msgSender(), operator, approved);
273	 }
274	 function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
275	 return _operatorApprovals[owner][operator];
276	 }
277	 function transferFrom( address from, address to, uint256 tokenId ) public virtual override {
278	 require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");
279	 _transfer(from, to, tokenId);
280	 }
281	 function safeTransferFrom( address from, address to, uint256 tokenId ) public virtual override {
282	 safeTransferFrom(from, to, tokenId, "");
283	 }
284	 function safeTransferFrom( address from, address to, uint256 tokenId, bytes memory _data ) public virtual override {
285	 require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");
286	 _safeTransfer(from, to, tokenId, _data);
287	 }
288	 function _safeTransfer( address from, address to, uint256 tokenId, bytes memory _data ) internal virtual {
289	 _transfer(from, to, tokenId);
290	 require(_checkOnERC721Received(from, to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");
291	 }
292	 function _exists(uint256 tokenId) internal view virtual returns (bool) {
293	 return _owners[tokenId] != address(0);
294	 }
295	 function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {
296	 require(_exists(tokenId), "ERC721: operator query for nonexistent token");
297	 address owner = ERC721Upgradeable.ownerOf(tokenId);
298	 return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
299	 }
300	 function _safeMint(address to, uint256 tokenId) internal virtual {
301	 _safeMint(to, tokenId, "");
302	 }
303	 function _safeMint( address to, uint256 tokenId, bytes memory _data ) internal virtual {
304	 _mint(to, tokenId);
305	 require( _checkOnERC721Received(address(0), to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer" );
306	 }
307	 function _mint(address to, uint256 tokenId) internal virtual {
308	 require(to != address(0), "ERC721: mint to the zero address");
309	 require(!_exists(tokenId), "ERC721: token already minted");
310	 _beforeTokenTransfer(address(0), to, tokenId);
311	 _balances[to] += 1;
312	 _owners[tokenId] = to;
313	 emit Transfer(address(0), to, tokenId);
314	 _afterTokenTransfer(address(0), to, tokenId);
315	 }
316	 function _burn(uint256 tokenId) internal virtual {
317	 address owner = ERC721Upgradeable.ownerOf(tokenId);
318	 _beforeTokenTransfer(owner, address(0), tokenId);
319	 _approve(address(0), tokenId);
320	 _balances[owner] -= 1;
321	 delete _owners[tokenId];
322	 emit Transfer(owner, address(0), tokenId);
323	 _afterTokenTransfer(owner, address(0), tokenId);
324	 }
325	 function _transfer( address from, address to, uint256 tokenId ) internal virtual {
326	 require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");
327	 require(to != address(0), "ERC721: transfer to the zero address");
328	 _beforeTokenTransfer(from, to, tokenId);
329	 _approve(address(0), tokenId);
330	 _balances[from] -= 1;
331	 _balances[to] += 1;
332	 _owners[tokenId] = to;
333	 emit Transfer(from, to, tokenId);
334	 _afterTokenTransfer(from, to, tokenId);
335	 }
336	 function _approve(address to, uint256 tokenId) internal virtual {
337	 _tokenApprovals[tokenId] = to;
338	 emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);
339	 }
340	 function _setApprovalForAll( address owner, address operator, bool approved ) internal virtual {
341	 require(owner != operator, "ERC721: approve to caller");
342	 _operatorApprovals[owner][operator] = approved;
343	 emit ApprovalForAll(owner, operator, approved);
344	 }
345	 function _checkOnERC721Received( address from, address to, uint256 tokenId, bytes memory _data ) private returns (bool) {
346	 if (to.isContract()) {
347	 try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {
348	 return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;
349	 }
350	 catch (bytes memory reason) {
351	 if (reason.length == 0) {
352	 revert("ERC721: transfer to non ERC721Receiver implementer");
353	 }
354	 else {
355	 assembly {
356	 revert(add(32, reason), mload(reason)) }
357	 }
358	 }
359	 }
360	 else {
361	 return true;
362	 }
363	 }
364	 function _beforeTokenTransfer( address from, address to, uint256 tokenId ) internal virtual {
365	 }
366	 function _afterTokenTransfer( address from, address to, uint256 tokenId ) internal virtual {
367	 }
368	 uint256[44] private __gap;
369	 }
370	 pragma solidity ^0.8.0;
371	 interface IERC721EnumerableUpgradeable is IERC721Upgradeable {
372	 function totalSupply() external view returns (uint256);
373	 function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);
374	 function tokenByIndex(uint256 index) external view returns (uint256);
375	 }
376	 pragma solidity ^0.8.0;
377	 pragma solidity ^0.8.0;
378	 interface IAccessControlEnumerableUpgradeable is IAccessControlUpgradeable {
379	 function getRoleMember(bytes32 role, uint256 index) external view returns (address);
380	 function getRoleMemberCount(bytes32 role) external view returns (uint256);
381	 }
382	 pragma solidity ^0.8.0;
383	 abstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {
384	 function __AccessControl_init() internal onlyInitializing {
385	 }
386	 function __AccessControl_init_unchained() internal onlyInitializing {
387	 }
388	 struct RoleData {
389	 mapping(address => bool) members;
390	 bytes32 adminRole;
391	 }
392	 mapping(bytes32 => RoleData) private _roles;
393	 bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;
394	 modifier onlyRole(bytes32 role) {
395	 _checkRole(role, _msgSender());
396	 _;
397	 }
398	 function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
399	 return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);
400	 }
401	 function hasRole(bytes32 role, address account) public view virtual override returns (bool) {
402	 return _roles[role].members[account];
403	 }
404	 function _checkRole(bytes32 role, address account) internal view virtual {
405	 if (!hasRole(role, account)) {
406	 revert( string( abi.encodePacked( "AccessControl: account ", StringsUpgradeable.toHexString(uint160(account), 20), " is missing role ", StringsUpgradeable.toHexString(uint256(role), 32) ) ) );
407	 }
408	 }
409	 function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {
410	 return _roles[role].adminRole;
411	 }
412	 function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {
413	 _grantRole(role, account);
414	 }
415	 function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {
416	 _revokeRole(role, account);
417	 }
418	 function renounceRole(bytes32 role, address account) public virtual override {
419	 require(account == _msgSender(), "AccessControl: can only renounce roles for self");
420	 _revokeRole(role, account);
421	 }
422	 function _setupRole(bytes32 role, address account) internal virtual {
423	 _grantRole(role, account);
424	 }
425	 function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
426	 bytes32 previousAdminRole = getRoleAdmin(role);
427	 _roles[role].adminRole = adminRole;
428	 emit RoleAdminChanged(role, previousAdminRole, adminRole);
429	 }
430	 function _grantRole(bytes32 role, address account) internal virtual {
431	 if (!hasRole(role, account)) {
432	 _roles[role].members[account] = true;
433	 emit RoleGranted(role, account, _msgSender());
434	 }
435	 }
436	 function _revokeRole(bytes32 role, address account) internal virtual {
437	 if (hasRole(role, account)) {
438	 _roles[role].members[account] = false;
439	 emit RoleRevoked(role, account, _msgSender());
440	 }
441	 }
442	 uint256[49] private __gap;
443	 }
444	 interface ICedarERC721DropV3 is ICedarFeaturesV0, ICedarVersionedV0, IMulticallableV0, ICedarAgreementV0, ICedarNFTIssuanceV1, ICedarNFTLazyMintV1, IERC721V0, IRoyaltyV0, ICedarUpdateBaseURIV0, ICedarNFTMetadataV1, ICedarMetadataV0 {
445	 }
446	 pragma solidity ^0.8.0;
447	 interface IERC1822ProxiableUpgradeable {
448	 function proxiableUUID() external view returns (bytes32);
449	 }
450	 pragma solidity ^0.8.2;
451	 abstract contract ERC1967UpgradeUpgradeable is Initializable {
452	 function __ERC1967Upgrade_init() internal onlyInitializing {
453	 }
454	 function __ERC1967Upgrade_init_unchained() internal onlyInitializing {
455	 }
456	 bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;
457	 bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
458	 event Upgraded(address indexed implementation);
459	 function _getImplementation() internal view returns (address) {
460	 return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;
461	 }
462	 function _setImplementation(address newImplementation) private {
463	 require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");
464	 StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;
465	 }
466	 function _upgradeTo(address newImplementation) internal {
467	 _setImplementation(newImplementation);
468	 emit Upgraded(newImplementation);
469	 }
470	 function _upgradeToAndCall( address newImplementation, bytes memory data, bool forceCall ) internal {
471	 _upgradeTo(newImplementation);
472	 if (data.length > 0 || forceCall) {
473	 _functionDelegateCall(newImplementation, data);
474	 }
475	 }
476	 function _upgradeToAndCallUUPS( address newImplementation, bytes memory data, bool forceCall ) internal {
477	 if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {
478	 _setImplementation(newImplementation);
479	 }
480	 else {
481	 try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {
482	 require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");
483	 }
484	 catch {
485	 revert("ERC1967Upgrade: new implementation is not UUPS");
486	 }
487	 _upgradeToAndCall(newImplementation, data, forceCall);
488	 }
489	 }
490	 bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;
491	 event AdminChanged(address previousAdmin, address newAdmin);
492	 function _getAdmin() internal view returns (address) {
493	 return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;
494	 }
495	 function _setAdmin(address newAdmin) private {
496	 require(newAdmin != address(0), "ERC1967: new admin is the zero address");
497	 StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;
498	 }
499	 function _changeAdmin(address newAdmin) internal {
500	 emit AdminChanged(_getAdmin(), newAdmin);
501	 _setAdmin(newAdmin);
502	 }
503	 bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;
504	 event BeaconUpgraded(address indexed beacon);
505	 function _getBeacon() internal view returns (address) {
506	 return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;
507	 }
508	 function _setBeacon(address newBeacon) private {
509	 require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");
510	 require( AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()), "ERC1967: beacon implementation is not a contract" );
511	 StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;
512	 }
513	 function _upgradeBeaconToAndCall( address newBeacon, bytes memory data, bool forceCall ) internal {
514	 _setBeacon(newBeacon);
515	 emit BeaconUpgraded(newBeacon);
516	 if (data.length > 0 || forceCall) {
517	 _functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);
518	 }
519	 }
520	 function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {
521	 require(AddressUpgradeable.isContract(target), "Address: delegate call to non-contract");
522	 (bool success, bytes memory returndata) = target.delegatecall(data);
523	 return AddressUpgradeable.verifyCallResult(success, returndata, "Address: low-level delegate call failed");
524	 }
525	 uint256[50] private __gap;
526	 }
527	 pragma solidity ^0.8.0;
528	 interface IERC1155Upgradeable is IERC165Upgradeable {
529	 event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);
530	 event TransferBatch( address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values );
531	 event ApprovalForAll(address indexed account, address indexed operator, bool approved);
532	 event URI(string value, uint256 indexed id);
533	 function balanceOf(address account, uint256 id) external view returns (uint256);
534	 function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);
535	 function setApprovalForAll(address operator, bool approved) external;
536	 function isApprovedForAll(address account, address operator) external view returns (bool);
537	 function safeTransferFrom( address from, address to, uint256 id, uint256 amount, bytes calldata data ) external;
538	 function safeBatchTransferFrom( address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data ) external;
539	 }
540	 pragma solidity ^0.8.0;
541	 abstract contract Ownable is Context {
542	 address private _owner;
543	 event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
544	 constructor() {
545	 _transferOwnership(_msgSender());
546	 }
547	 function owner() public view virtual returns (address) {
548	 return _owner;
549	 }
550	 modifier onlyOwner() {
551	 require(owner() == _msgSender(), "Ownable: caller is not the owner");
552	 _;
553	 }
554	 function renounceOwnership() public virtual onlyOwner {
555	 _transferOwnership(address(0));
556	 }
557	 function transferOwnership(address newOwner) public virtual onlyOwner {
558	 require(newOwner != address(0), "Ownable: new owner is the zero address");
559	 _transferOwnership(newOwner);
560	 }
561	 function _transferOwnership(address newOwner) internal virtual {
562	 address oldOwner = _owner;
563	 _owner = newOwner;
564	 emit OwnershipTransferred(oldOwner, newOwner);
565	 }
566	 }
567	 interface ICedarDeployerEventsV5 is ICedarDeployerEventsV4 {
568	 event CedarERC721DropV2Deployment( address indexed contractAddress, uint256 indexed majorVersion, uint256 indexed minorVersion, uint256 patchVersion );
569	 }
570	 interface ICedarDeployerV0 is ICedarVersionedV0, ICedarDeployerEventsV0 {
571	 function deployCedarERC721PremintV0( address adminAddress, string memory _name, string memory _symbol, uint256 _maxLimit, string memory _userAgreement, string memory baseURI_ ) external returns (ICedarERC721PremintV0);
572	 function deployCedarERC721DropV0( address _defaultAdmin, string memory _name, string memory _symbol, string memory _contractURI, address[] memory _trustedForwarders, address _saleRecipient, address _royaltyRecipient, uint128 _royaltyBps, string memory _userAgreement ) external returns (ICedarERC721DropV0);
573	 function cedarERC721PremintVersion() external view returns ( uint256 major, uint256 minor, uint256 patch );
574	 function cedarERC721DropVersion() external view returns ( uint256 major, uint256 minor, uint256 patch );
575	 }
576	 interface ICedarDeployerAddedV1 {
577	 function deployCedarERC1155DropV0( address _defaultAdmin, string memory _name, string memory _symbol, string memory _contractURI, address[] memory _trustedForwarders, address _saleRecipient, address _royaltyRecipient, uint128 _royaltyBps, uint128 _platformFeeBps, address _platformFeeRecipient ) external returns (ICedarERC1155DropV0);
578	 function cedarERC1155DropVersion() external view returns ( uint256 major, uint256 minor, uint256 patch );
579	 function cedarERC721PremintFeatures() external view returns (string[] memory features);
580	 function cedarERC721DropFeatures() external view returns (string[] memory features);
581	 function cedarERC1155DropFeatures() external view returns (string[] memory features);
582	 }
583	 interface ICedarDeployerAddedV2 {
584	 function deployCedarERC721PremintV1( address adminAddress, string memory _name, string memory _symbol, uint256 _maxLimit, string memory _userAgreement, string memory baseURI_ ) external returns (ICedarERC721PremintV1);
585	 }
586	 interface ICedarDeployerAddedV3 {
587	 function deployCedarPaymentSplitterV0(address[] memory payees, uint256[] memory shares_) external returns (ICedarPaymentSplitterV0);
588	 function cedarPaymentSplitterVersion() external view returns ( uint256 major, uint256 minor, uint256 patch );
589	 function cedarPaymentSplitterFeatures() external view returns (string[] memory features);
590	 }
591	 interface ICedarDeployerIntrospectionV0 is ICedarVersionedV0 {
592	 function cedarERC721PremintVersion() external view returns ( uint256 major, uint256 minor, uint256 patch );
593	 function cedarERC721DropVersion() external view returns ( uint256 major, uint256 minor, uint256 patch );
594	 function cedarERC1155DropVersion() external view returns ( uint256 major, uint256 minor, uint256 patch );
595	 function cedarERC721PremintFeatures() external view returns (string[] memory features);
596	 function cedarERC721DropFeatures() external view returns (string[] memory features);
597	 function cedarERC1155DropFeatures() external view returns (string[] memory features);
598	 }
599	 interface ICedarDeployerAddedV4 {
600	 function deployCedarERC1155DropV1( address _defaultAdmin, string memory _name, string memory _symbol, string memory _contractURI, address[] memory _trustedForwarders, address _saleRecipient, address _royaltyRecipient, uint128 _royaltyBps, uint128 _platformFeeBps, address _platformFeeRecipient ) external returns (ICedarERC1155DropV1);
601	 function deployCedarERC721DropV1( address _defaultAdmin, string memory _name, string memory _symbol, string memory _contractURI, address[] memory _trustedForwarders, address _saleRecipient, address _royaltyRecipient, uint128 _royaltyBps, string memory _userAgreement ) external returns (ICedarERC721DropV1);
602	 }
603	 interface ICedarDeployerAddedV5 {
604	 function deployCedarERC1155DropV1( address _defaultAdmin, string memory _name, string memory _symbol, string memory _contractURI, address[] memory _trustedForwarders, address _saleRecipient, address _royaltyRecipient, uint128 _royaltyBps, uint128 _platformFeeBps, address _platformFeeRecipient ) external returns (ICedarERC1155DropV1);
605	 function deployCedarERC721DropV2( address _defaultAdmin, string memory _name, string memory _symbol, string memory _contractURI, address[] memory _trustedForwarders, address _saleRecipient, address _royaltyRecipient, uint128 _royaltyBps, string memory _userAgreement ) external returns (ICedarERC721DropV2);
606	 }
607	 interface ICedarDeployerAddedV7 {
608	 function deployCedarERC1155DropV1( address _defaultAdmin, string memory _name, string memory _symbol, string memory _contractURI, address[] memory _trustedForwarders, address _saleRecipient, address _royaltyRecipient, uint128 _royaltyBps, uint128 _platformFeeBps, address _platformFeeRecipient ) external returns (ICedarERC1155DropV1);
609	 function deployCedarERC721DropV3( address _defaultAdmin, string memory _name, string memory _symbol, string memory _contractURI, address[] memory _trustedForwarders, address _saleRecipient, address _royaltyRecipient, uint128 _royaltyBps, string memory _userAgreement, uint128 _platformFeeBps, address _platformFeeRecipient ) external returns (ICedarERC721DropV3);
610	 }
611	 pragma solidity ^0.8.0;
612	 abstract contract ERC721EnumerableUpgradeable is Initializable, ERC721Upgradeable, IERC721EnumerableUpgradeable {
613	 function __ERC721Enumerable_init() internal onlyInitializing {
614	 }
615	 function __ERC721Enumerable_init_unchained() internal onlyInitializing {
616	 }
617	 mapping(address => mapping(uint256 => uint256)) private _ownedTokens;
618	 mapping(uint256 => uint256) private _ownedTokensIndex;
619	 uint256[] private _allTokens;
620	 mapping(uint256 => uint256) private _allTokensIndex;
621	 function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165Upgradeable, ERC721Upgradeable) returns (bool) {
622	 return interfaceId == type(IERC721EnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);
623	 }
624	 function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {
625	 require(index < ERC721Upgradeable.balanceOf(owner), "ERC721Enumerable: owner index out of bounds");
626	 return _ownedTokens[owner][index];
627	 }
628	 function totalSupply() public view virtual override returns (uint256) {
629	 return _allTokens.length;
630	 }
631	 function tokenByIndex(uint256 index) public view virtual override returns (uint256) {
632	 require(index < ERC721EnumerableUpgradeable.totalSupply(), "ERC721Enumerable: global index out of bounds");
633	 return _allTokens[index];
634	 }
635	 function _beforeTokenTransfer( address from, address to, uint256 tokenId ) internal virtual override {
636	 super._beforeTokenTransfer(from, to, tokenId);
637	 if (from == address(0)) {
638	 _addTokenToAllTokensEnumeration(tokenId);
639	 }
640	 else if (from != to) {
641	 _removeTokenFromOwnerEnumeration(from, tokenId);
642	 }
643	 if (to == address(0)) {
644	 _removeTokenFromAllTokensEnumeration(tokenId);
645	 }
646	 else if (to != from) {
647	 _addTokenToOwnerEnumeration(to, tokenId);
648	 }
649	 }
650	 function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {
651	 uint256 length = ERC721Upgradeable.balanceOf(to);
652	 _ownedTokens[to][length] = tokenId;
653	 _ownedTokensIndex[tokenId] = length;
654	 }
655	 function _addTokenToAllTokensEnumeration(uint256 tokenId) private {
656	 _allTokensIndex[tokenId] = _allTokens.length;
657	 _allTokens.push(tokenId);
658	 }
659	 function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {
660	 uint256 lastTokenIndex = ERC721Upgradeable.balanceOf(from) - 1;
661	 uint256 tokenIndex = _ownedTokensIndex[tokenId];
662	 if (tokenIndex != lastTokenIndex) {
663	 uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];
664	 _ownedTokens[from][tokenIndex] = lastTokenId;
665	 _ownedTokensIndex[lastTokenId] = tokenIndex;
666	 }
667	 delete _ownedTokensIndex[tokenId];
668	 delete _ownedTokens[from][lastTokenIndex];
669	 }
670	 function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {
671	 uint256 lastTokenIndex = _allTokens.length - 1;
672	 uint256 tokenIndex = _allTokensIndex[tokenId];
673	 uint256 lastTokenId = _allTokens[lastTokenIndex];
674	 _allTokens[tokenIndex] = lastTokenId;
675	 _allTokensIndex[lastTokenId] = tokenIndex;
676	 delete _allTokensIndex[tokenId];
677	 _allTokens.pop();
678	 }
679	 uint256[46] private __gap;
680	 }
681	 pragma solidity ^0.8.0;
682	 abstract contract AccessControlEnumerableUpgradeable is Initializable, IAccessControlEnumerableUpgradeable, AccessControlUpgradeable {
683	 function __AccessControlEnumerable_init() internal onlyInitializing {
684	 }
685	 function __AccessControlEnumerable_init_unchained() internal onlyInitializing {
686	 }
687	 using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;
688	 mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _roleMembers;
689	 function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
690	 return interfaceId == type(IAccessControlEnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);
691	 }
692	 function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {
693	 return _roleMembers[role].at(index);
694	 }
695	 function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {
696	 return _roleMembers[role].length();
697	 }
698	 function _grantRole(bytes32 role, address account) internal virtual override {
699	 super._grantRole(role, account);
700	 _roleMembers[role].add(account);
701	 }
702	 function _revokeRole(bytes32 role, address account) internal virtual override {
703	 super._revokeRole(role, account);
704	 _roleMembers[role].remove(account);
705	 }
706	 uint256[49] private __gap;
707	 }
708	 pragma solidity ^0.8.0;
709	 abstract contract ReentrancyGuardUpgradeable is Initializable {
710	 uint256 private constant _NOT_ENTERED = 1;
711	 uint256 private constant _ENTERED = 2;
712	 uint256 private _status;
713	 function __ReentrancyGuard_init() internal onlyInitializing {
714	 __ReentrancyGuard_init_unchained();
715	 }
716	 function __ReentrancyGuard_init_unchained() internal onlyInitializing {
717	 _status = _NOT_ENTERED;
718	 }
719	 modifier nonReentrant() {
720	 require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
721	 _status = _ENTERED;
722	 _;
723	 _status = _NOT_ENTERED;
724	 }
725	 uint256[49] private __gap;
726	 }
727	 pragma solidity ^0.8.0;
728	 abstract contract MulticallUpgradeable is Initializable {
729	 function __Multicall_init() internal onlyInitializing {
730	 }
731	 function __Multicall_init_unchained() internal onlyInitializing {
732	 }
733	 function multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) {
734	 results = new bytes[](data.length);
735	 for (uint256 i = 0; i < data.length; i++) {
736	 results[i] = _functionDelegateCall(address(this), data[i]);
737	 }
738	 return results;
739	 }
740	 function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {
741	 require(AddressUpgradeable.isContract(target), "Address: delegate call to non-contract");
742	 (bool success, bytes memory returndata) = target.delegatecall(data);
743	 return AddressUpgradeable.verifyCallResult(success, returndata, "Address: low-level delegate call failed");
744	 }
745	 uint256[50] private __gap;
746	 }
747	 pragma solidity ^0.8.4;
748	 interface IThirdwebContract {
749	 function contractType() external pure returns (bytes32);
750	 function contractVersion() external pure returns (uint8);
751	 function contractURI() external view returns (string memory);
752	 function setContractURI(string calldata _uri) external;
753	 }
754	 pragma solidity ^0.8.0;
755	 interface IPlatformFee {
756	 function getPlatformFeeInfo() external view returns (address, uint16);
757	 function setPlatformFeeInfo(address _platformFeeRecipient, uint256 _platformFeeBps) external;
758	 event PlatformFeeInfoUpdated(address platformFeeRecipient, uint256 platformFeeBps);
759	 }
760	 pragma solidity ^0.8.0;
761	 interface IPrimarySale {
762	 function primarySaleRecipient() external view returns (address);
763	 function setPrimarySaleRecipient(address _saleRecipient) external;
764	 event PrimarySaleRecipientUpdated(address indexed recipient);
765	 }
766	 pragma solidity ^0.8.0;
767	 interface IOwnable {
768	 function owner() external view returns (address);
769	 function setOwner(address _newOwner) external;
770	 event OwnerUpdated(address prevOwner, address newOwner);
771	 }
772	 pragma solidity ^0.8.4;
773	 abstract contract ERC2771ContextUpgradeable is Initializable, ContextUpgradeable {
774	 mapping(address => bool) private _trustedForwarder;
775	 function __ERC2771Context_init(address[] memory trustedForwarder) internal onlyInitializing {
776	 __Context_init_unchained();
777	 __ERC2771Context_init_unchained(trustedForwarder);
778	 }
779	 function __ERC2771Context_init_unchained(address[] memory trustedForwarder) internal onlyInitializing {
780	 for (uint256 i = 0; i < trustedForwarder.length; i++) {
781	 _trustedForwarder[trustedForwarder[i]] = true;
782	 }
783	 }
784	 function isTrustedForwarder(address forwarder) public view virtual returns (bool) {
785	 return _trustedForwarder[forwarder];
786	 }
787	 function _msgSender() internal view virtual override returns (address sender) {
788	 if (isTrustedForwarder(msg.sender)) {
789	 assembly {
790	 sender := shr(96, calldataload(sub(calldatasize(), 20))) }
791	 }
792	 else {
793	 return super._msgSender();
794	 }
795	 }
796	 function _msgData() internal view virtual override returns (bytes calldata) {
797	 if (isTrustedForwarder(msg.sender)) {
798	 return msg.data[:msg.data.length - 20];
799	 }
800	 else {
801	 return super._msgData();
802	 }
803	 }
804	 uint256[49] private __gap;
805	 }
806	 pragma solidity ^0.8.4;
807	 abstract contract BaseCedarERC721DropV3 is ICedarERC721DropV3 {
808	 function supportedFeatures() override public pure returns (string[] memory features) {
809	 features = new string[](11);
810	 features[0] = "ICedarFeatures.sol:ICedarFeaturesV0";
811	 features[1] = "ICedarVersioned.sol:ICedarVersionedV0";
812	 features[2] = "IMulticallable.sol:IMulticallableV0";
813	 features[3] = "agreement/ICedarAgreement.sol:ICedarAgreementV0";
814	 features[4] = "issuance/ICedarNFTIssuance.sol:ICedarNFTIssuanceV1";
815	 features[5] = "lazymint/ICedarNFTLazyMint.sol:ICedarNFTLazyMintV1";
816	 features[6] = "standard/IERC721.sol:IERC721V0";
817	 features[7] = "royalties/IRoyalty.sol:IRoyaltyV0";
818	 features[8] = "baseURI/ICedarUpdateBaseURI.sol:ICedarUpdateBaseURIV0";
819	 features[9] = "metadata/ICedarNFTMetadata.sol:ICedarNFTMetadataV1";
820	 features[10] = "metadata/IContractMetadata.sol:ICedarMetadataV0";
821	 }
822	 function minorVersion() virtual override public pure returns (uint256 minor, uint256 patch);
823	 function implementationVersion() override public pure returns (uint256 major, uint256 minor, uint256 patch) {
824	 (minor, patch) = minorVersion();
825	 major = 3;
826	 }
827	 function supportsInterface(bytes4 interfaceID) virtual override public view returns (bool) {
828	 return (interfaceID == type(IERC165Upgradeable).interfaceId) || ((interfaceID == type(ICedarFeaturesV0).interfaceId) || ((interfaceID == type(ICedarVersionedV0).interfaceId) || ((interfaceID == type(IMulticallableV0).interfaceId) || ((interfaceID == type(ICedarAgreementV0).interfaceId) || ((interfaceID == type(ICedarNFTIssuanceV1).interfaceId) || ((interfaceID == type(ICedarNFTLazyMintV1).interfaceId) || ((interfaceID == type(IERC721V0).interfaceId) || ((interfaceID == type(IRoyaltyV0).interfaceId) || ((interfaceID == type(ICedarUpdateBaseURIV0).interfaceId) || ((interfaceID == type(ICedarNFTMetadataV1).interfaceId) || (interfaceID == type(ICedarMetadataV0).interfaceId)))))))))));
829	 }
830	 function isICedarFeaturesV0() override public pure returns (bool) {
831	 return true;
832	 }
833	 }
834	 pragma solidity ^0.8.7;
835	 abstract contract Agreement is Initializable, ICedarAgreementV0 {
836	 string public override userAgreement;
837	 mapping(address => bool) termsAccepted;
838	 bool public override termsActivated;
839	 SignatureVerifier public verifier;
840	 string public ownerDomain;
841	 event TermsActive(bool status);
842	 event AcceptTerms(string userAgreement, address user);
843	 function __Agreement_init(string memory _userAgreement, address _signatureVerifier) internal onlyInitializing {
844	 userAgreement = _userAgreement;
845	 verifier = SignatureVerifier(_signatureVerifier);
846	 }
847	 function _setTermsStatus(bool _status) internal virtual {
848	 termsActivated = _status;
849	 emit TermsActive(_status);
850	 }
851	 function acceptTerms() override external {
852	 require(termsActivated, "ERC721Cedar: terms not activated");
853	 termsAccepted[msg.sender] = true;
854	 emit AcceptTerms(userAgreement, msg.sender);
855	 }
856	 function _storeTermsAccepted(address _acceptor, bytes calldata _signature) internal virtual {
857	 require(termsActivated, "ERC721Cedar: terms not activated");
858	 require(verifier.verifySignature(_acceptor, _signature), "ERC721Cedar: signature cannot be verified");
859	 termsAccepted[_acceptor] = true;
860	 emit AcceptTerms(userAgreement, _acceptor);
861	 }
862	 function checkSignature(address _account, bytes calldata _signature) external view returns (bool) {
863	 return verifier.verifySignature(_account, _signature);
864	 }
865	 function getAgreementStatus(address _address) external override view returns (bool sig) {
866	 return termsAccepted[_address];
867	 }
868	 function _setOwnerDomain(string calldata _ownerDomain) internal virtual {
869	 ownerDomain = _ownerDomain;
870	 }
871	 }
872	 pragma solidity ^0.8.4;
873	 contract Greenlist {
874	 using Address for address;
875	 bool greenlistStatus;
876	 GreenlistManager greenlistManager;
877	 event GreenlistStatus(bool _status);
878	 function __Greenlist_init(address _greenlistManagerAddress) internal {
879	 greenlistManager = GreenlistManager(_greenlistManagerAddress);
880	 }
881	 function _setGreenlistStatus(bool _status) internal {
882	 greenlistStatus = _status;
883	 emit GreenlistStatus(_status);
884	 }
885	 function isGreenlistOn() public view returns (bool) {
886	 return greenlistStatus;
887	 }
888	 function checkGreenlist(address _operator) internal view {
889	 if (Address.isContract(_operator) && isGreenlistOn()) {
890	 require(greenlistManager.isGreenlisted(_operator), "ERC721Cedar: operator is not greenlisted");
891	 }
892	 }
893	 }
894	 pragma solidity ^0.8.4;
895	 interface ICedarNFTLazyMintV0 {
896	 event TokensLazyMinted(uint256 startTokenId, uint256 endTokenId, string baseURI, bytes encryptedBaseURI);
897	 function lazyMint( uint256 amount, string calldata baseURIForTokens, bytes calldata encryptedBaseURI ) external;
898	 }
899	 pragma solidity ^0.8.0;
900	 interface ICedarNFTMetadataV0 {
901	 function tokenURI(uint256 _tokenId) external returns (string memory);
902	 }
903	 pragma solidity ^0.8.0;
904	 abstract contract EIP712 {
905	 bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;
906	 uint256 private immutable _CACHED_CHAIN_ID;
907	 address private immutable _CACHED_THIS;
908	 bytes32 private immutable _HASHED_NAME;
909	 bytes32 private immutable _HASHED_VERSION;
910	 bytes32 private immutable _TYPE_HASH;
911	 constructor(string memory name, string memory version) {
912	 bytes32 hashedName = keccak256(bytes(name));
913	 bytes32 hashedVersion = keccak256(bytes(version));
914	 bytes32 typeHash = keccak256( "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)" );
915	 _HASHED_NAME = hashedName;
916	 _HASHED_VERSION = hashedVersion;
917	 _CACHED_CHAIN_ID = block.chainid;
918	 _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);
919	 _CACHED_THIS = address(this);
920	 _TYPE_HASH = typeHash;
921	 }
922	 function _domainSeparatorV4() internal view returns (bytes32) {
923	 if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {
924	 return _CACHED_DOMAIN_SEPARATOR;
925	 }
926	 else {
927	 return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);
928	 }
929	 }
930	 function _buildDomainSeparator( bytes32 typeHash, bytes32 nameHash, bytes32 versionHash ) private view returns (bytes32) {
931	 return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));
932	 }
933	 function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {
934	 return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);
935	 }
936	 }
937	 pragma solidity ^0.8.0;
938	 abstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {
939	 address private _owner;
940	 event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
941	 function __Ownable_init() internal onlyInitializing {
942	 __Ownable_init_unchained();
943	 }
944	 function __Ownable_init_unchained() internal onlyInitializing {
945	 _transferOwnership(_msgSender());
946	 }
947	 function owner() public view virtual returns (address) {
948	 return _owner;
949	 }
950	 modifier onlyOwner() {
951	 require(owner() == _msgSender(), "Ownable: caller is not the owner");
952	 _;
953	 }
954	 function renounceOwnership() public virtual onlyOwner {
955	 _transferOwnership(address(0));
956	 }
957	 function transferOwnership(address newOwner) public virtual onlyOwner {
958	 require(newOwner != address(0), "Ownable: new owner is the zero address");
959	 _transferOwnership(newOwner);
960	 }
961	 function _transferOwnership(address newOwner) internal virtual {
962	 address oldOwner = _owner;
963	 _owner = newOwner;
964	 emit OwnershipTransferred(oldOwner, newOwner);
965	 }
966	 uint256[49] private __gap;
967	 }
968	 pragma solidity ^0.8.0;
969	 abstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {
970	 function __UUPSUpgradeable_init() internal onlyInitializing {
971	 }
972	 function __UUPSUpgradeable_init_unchained() internal onlyInitializing {
973	 }
974	 address private immutable __self = address(this);
975	 modifier onlyProxy() {
976	 require(address(this) != __self, "Function must be called through delegatecall");
977	 require(_getImplementation() == __self, "Function must be called through active proxy");
978	 _;
979	 }
980	 modifier notDelegated() {
981	 require(address(this) == __self, "UUPSUpgradeable: must not be called through delegatecall");
982	 _;
983	 }
984	 function proxiableUUID() external view virtual override notDelegated returns (bytes32) {
985	 return _IMPLEMENTATION_SLOT;
986	 }
987	 function upgradeTo(address newImplementation) external virtual onlyProxy {
988	 _authorizeUpgrade(newImplementation);
989	 _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);
990	 }
991	 function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {
992	 _authorizeUpgrade(newImplementation);
993	 _upgradeToAndCallUUPS(newImplementation, data, true);
994	 }
995	 function _authorizeUpgrade(address newImplementation) internal virtual;
996	 uint256[50] private __gap;
997	 }
998	 pragma solidity ^0.8.4;
999	 interface ICedarPremintV0 {
1000	 struct TransferRequest {
1001	 address to;
1002	 uint256 tokenId;
1003	 }
1004	 function mintBatch(uint256 _quantity, address _to) external;
1005	 function transferFromBatch(TransferRequest[] calldata transferRequests) external;
1006	 }
1007	 pragma solidity ^0.8.4;
1008	 interface ICedarUpgradeBaseURIV0 {
1009	 function upgradeBaseURI(string calldata baseURI_) external;
1010	 }
1011	 interface ICedarSFTIssuanceV1 is ICedarSFTIssuanceV0 {
1012	 function getActiveClaimConditions(uint256 _tokenId) external view returns (ClaimCondition memory condition, uint256 conditionId, uint256 walletMaxClaimCount, uint256 remainingSupply);
1013	 function getUserClaimConditions(uint256 _tokenId, address _claimer) external view returns (uint256 conditionId, uint256 walletClaimedCount, uint256 lastClaimTimestamp, uint256 nextValidClaimTimestamp);
1014	 function verifyClaim( uint256 _conditionId, address _claimer, uint256 _tokenId, uint256 _quantity, address _currency, uint256 _pricePerToken, bool verifyMaxQuantityPerTransaction ) external view;
1015	 }
1016	 pragma solidity ^0.8.4;
1017	 interface ICedarSFTLazyMintV0 {
1018	 event TokensLazyMinted(uint256 startTokenId, uint256 endTokenId, string baseURI);
1019	 function lazyMint(uint256 amount, string calldata baseURIForTokens) external;
1020	 }
1021	 pragma solidity ^0.8.4;
1022	 interface IERC1155V0 is IERC1155Upgradeable {
1023	 }
1024	 pragma solidity ^0.8.4;
1025	 interface ICedarSplitPaymentV0 {
1026	 function getTotalReleased() external view returns (uint256);
1027	 function getTotalReleased(IERC20Upgradeable token) external view returns (uint256);
1028	 function getReleased(address account) external view returns (uint256);
1029	 function getReleased(IERC20Upgradeable token, address account) external view returns (uint256);
1030	 function releasePayment(address payable account) external;
1031	 function releasePayment(IERC20Upgradeable token, address account) external;
1032	 }
1033	 pragma solidity ^0.8.4;
1034	 contract CedarERC721DropFactory is Ownable, ICedarDeployerEventsV5, ICedarImplementationVersionedV0 {
1035	 CedarERC721Drop public implementation;
1036	 address public greenlistManagerAddress;
1037	 struct EventParams {
1038	 address contractAddress;
1039	 uint256 majorVersion;
1040	 uint256 minorVersion;
1041	 uint256 patchVersion;
1042	 }
1043	 constructor(address _greenlistManagerAddress) {
1044	 greenlistManagerAddress = _greenlistManagerAddress;
1045	 implementation = new CedarERC721Drop();
1046	 implementation.initialize(_msgSender(), "default", "default", "", new address[](0), address(0), address(0), 0, CedarERC721Drop.FeaturesInput("0", address(0), address(0)), 0, address(0));
1047	 (uint256 major, uint256 minor, uint256 patch) = implementation.implementationVersion();
1048	 emit CedarImplementationDeployed(address(implementation), major, minor, patch, "ICedarERC721DropV3");
1049	 }
1050	 function emitEvent( EventParams memory params ) private {
1051	 emit CedarERC721DropV2Deployment( params.contractAddress, params.majorVersion, params.minorVersion, params.patchVersion );
1052	 }
1053	 function deploy( address _defaultAdmin, string memory _name, string memory _symbol, string memory _contractURI, address[] memory _trustedForwarders, address _saleRecipient, address _royaltyRecipient, uint128 _royaltyBps, string memory _userAgreement, uint128 _platformFeeBps, address _platformFeeRecipient ) external onlyOwner returns (CedarERC721Drop newClone) {
1054	 newClone = CedarERC721Drop(Clones.clone(address(implementation)));
1055	 SignatureVerifier signatureVerifier = new SignatureVerifier(_userAgreement, "_", "_");
1056	 CedarERC721Drop.FeaturesInput memory input = CedarERC721Drop.FeaturesInput(_userAgreement, address(signatureVerifier), greenlistManagerAddress);
1057	 newClone.initialize( _defaultAdmin, _name, _symbol, _contractURI, _trustedForwarders, _saleRecipient, _royaltyRecipient, _royaltyBps, input, _platformFeeBps, _platformFeeRecipient );
1058	 (uint major, uint minor, uint patch) = newClone.implementationVersion();
1059	 EventParams memory params;
1060	 params.contractAddress = address(newClone);
1061	 params.majorVersion = major;
1062	 params.minorVersion = minor;
1063	 params.patchVersion = patch;
1064	 emitEvent(params);
1065	 }
1066	 function implementationVersion() external override view returns ( uint256 major, uint256 minor, uint256 patch ) {
1067	 return implementation.implementationVersion();
1068	 }
1069	 }
1070	 pragma solidity ^0.8.0;
1071	 library Clones {
1072	 function clone(address implementation) internal returns (address instance) {
1073	 assembly {
1074	 let ptr := mload(0x40) mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000) mstore(add(ptr, 0x14), shl(0x60, implementation)) mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000) instance := create(0, ptr, 0x37) }
1075	 require(instance != address(0), "ERC1167: create failed");
1076	 }
1077	 function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {
1078	 assembly {
1079	 let ptr := mload(0x40) mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000) mstore(add(ptr, 0x14), shl(0x60, implementation)) mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000) instance := create2(0, ptr, 0x37, salt) }
1080	 require(instance != address(0), "ERC1167: create2 failed");
1081	 }
1082	 function predictDeterministicAddress( address implementation, bytes32 salt, address deployer ) internal pure returns (address predicted) {
1083	 assembly {
1084	 let ptr := mload(0x40) mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000) mstore(add(ptr, 0x14), shl(0x60, implementation)) mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000) mstore(add(ptr, 0x38), shl(0x60, deployer)) mstore(add(ptr, 0x4c), salt) mstore(add(ptr, 0x6c), keccak256(ptr, 0x37)) predicted := keccak256(add(ptr, 0x37), 0x55) }
1085	 }
1086	 function predictDeterministicAddress(address implementation, bytes32 salt) internal view returns (address predicted) {
1087	 return predictDeterministicAddress(implementation, salt, address(this));
1088	 }
1089	 }
1090	 pragma solidity ^0.8.7;
1091	 contract CedarERC721Drop is Initializable, IThirdwebContract, IOwnable, IPrimarySale, ReentrancyGuardUpgradeable, ERC2771ContextUpgradeable, MulticallUpgradeable, AccessControlEnumerableUpgradeable, ERC721EnumerableUpgradeable, Agreement, Greenlist, IPlatformFee, BaseCedarERC721DropV3 {
1092	 using BitMapsUpgradeable for BitMapsUpgradeable.BitMap;
1093	 using StringsUpgradeable for uint256;
1094	 using CedarDropERC721ClaimLogicV0 for DataTypes.ClaimData;
1095	 event MaxTotalSupplyUpdated(uint256 maxTotalSupply);
1096	 event WalletClaimCountUpdated(address indexed wallet, uint256 count);
1097	 event MaxWalletClaimCountUpdated(uint256 count);
1098	 mapping(uint256 => string) private baseURI;
1099	 mapping(uint256 => RoyaltyInfo) private royaltyInfoForToken;
1100	 struct FeaturesInput {
1101	 string userAgreement;
1102	 address signatureVerifier;
1103	 address greenlistManagerAddress;
1104	 }
1105	 function owner() public view override returns (address) {
1106	 return hasRole(DEFAULT_ADMIN_ROLE, _owner) ? _owner : address(0);
1107	 }
1108	 function lazyMint( uint256 _amount, string calldata _baseURIForTokens ) external override onlyRole(MINTER_ROLE) {
1109	 uint256 startId = claimData.nextTokenIdToMint;
1110	 uint256 baseURIIndex = startId + _amount;
1111	 claimData.nextTokenIdToMint = baseURIIndex;
1112	 baseURI[baseURIIndex] = _baseURIForTokens;
1113	 baseURIIndices.push(baseURIIndex);
1114	 emit TokensLazyMinted(startId, startId + _amount - 1, _baseURIForTokens);
1115	 }
1116	 function supportsInterface(bytes4 interfaceId) public view override( AccessControlEnumerableUpgradeable, ERC721EnumerableUpgradeable, BaseCedarERC721DropV3 ) returns (bool) {
1117	 return ERC721EnumerableUpgradeable.supportsInterface(interfaceId);
1118	 }
1119	 function minorVersion() public pure override returns (uint256 minor, uint256 patch) {
1120	 minor = 0;
1121	 patch = 0;
1122	 }
1123	 function multicall(bytes[] calldata data) external override(IMulticallableV0, MulticallUpgradeable) returns (bytes[] memory results) {
1124	 return MulticallUpgradeable(this).multicall(data);
1125	 }
1126	 function updateBaseURI(uint256 baseURIIndex, string calldata _baseURIForTokens) override external onlyRole(MINTER_ROLE) {
1127	 baseURI[baseURIIndex] = _baseURIForTokens;
1128	 emit BaseURIUpdated(baseURIIndex, _baseURIForTokens);
1129	 }
1130	 function getBaseURIIndices() external override view returns(uint256[] memory) {
1131	 return baseURIIndices;
1132	 }
1133	 function getPlatformFeeInfo() override external view returns (address, uint16) {
1134	 return (claimData.platformFeeRecipient, uint16(claimData.platformFeeBps));
1135	 }
1136	 function setPlatformFeeInfo(address _platformFeeRecipient, uint256 _platformFeeBps) external override onlyRole(DEFAULT_ADMIN_ROLE) {
1137	 require(_platformFeeBps <= MAX_BPS, "> MAX_BPS.");
1138	 claimData.platformFeeBps = uint16(_platformFeeBps);
1139	 claimData.platformFeeRecipient = _platformFeeRecipient;
1140	 emit PlatformFeeInfoUpdated(_platformFeeRecipient, _platformFeeBps);
1141	 }
1142	 }
1143	 interface ICedarDeployerV1 is ICedarDeployerAddedV1, ICedarDeployerV0 {
1144	 }
1145	 interface ICedarDeployerV2 is ICedarDeployerAddedV2, ICedarDeployerAddedV1, ICedarDeployerV0 {
1146	 }
1147	 interface ICedarDeployerV3 is ICedarDeployerAddedV3, ICedarDeployerAddedV2, ICedarDeployerAddedV1, ICedarDeployerV0 {
1148	 }
1149	 interface ICedarDeployerV4 is ICedarDeployerEventsV4, ICedarDeployerAddedV4, ICedarDeployerAddedV3, ICedarDeployerAddedV2, ICedarDeployerIntrospectionV0 {
1150	 }
1151	 interface ICedarDeployerAddedV6 {
1152	 function deployCedarERC1155DropV1( address _defaultAdmin, string memory _name, string memory _symbol, string memory _contractURI, address[] memory _trustedForwarders, address _saleRecipient, address _royaltyRecipient, uint128 _royaltyBps, uint128 _platformFeeBps, address _platformFeeRecipient ) external returns (ICedarERC1155DropV1);
1153	 function deployCedarERC721DropV2( address _defaultAdmin, string memory _name, string memory _symbol, string memory _contractURI, address[] memory _trustedForwarders, address _saleRecipient, address _royaltyRecipient, uint128 _royaltyBps, string memory _userAgreement, uint128 _platformFeeBps, address _platformFeeRecipient ) external returns (ICedarERC721DropV2);
1154	 }
1155	 interface ICedarDeployerV5 is ICedarDeployerEventsV4, ICedarDeployerAddedV5, ICedarDeployerAddedV3, ICedarDeployerAddedV2, ICedarDeployerIntrospectionV0 {
1156	 }
1157	 interface ICedarDeployerV6 is ICedarDeployerEventsV5, ICedarDeployerAddedV7, ICedarDeployerAddedV3, ICedarDeployerAddedV2, ICedarDeployerIntrospectionV0 {
1158	 }
1159	 pragma solidity ^0.8.4;
1160	 contract SignatureVerifier is EIP712, Ownable {
1161	 bytes32 public constant MESSSAGE_HASH = keccak256("AgreeTerms(string url,string message)");
1162	 struct AgreeTerms {
1163	 string url;
1164	 string message;
1165	 }
1166	 AgreeTerms public terms;
1167	 constructor( string memory _url, string memory _message, string memory _name ) EIP712(_name, "1.0.0") {
1168	 require(bytes(_url).length != 0 && bytes(_message).length != 0, "Signature Verifier: invalid url and message");
1169	 terms.url = _url;
1170	 terms.message = _message;
1171	 }
1172	 function verifySignature(address _to, bytes memory _signature) external view returns (bool) {
1173	 if (_signature.length == 0) return false;
1174	 bytes32 hash = _hashMessage();
1175	 address signer = ECDSA.recover(hash, _signature);
1176	 return signer == _to;
1177	 }
1178	 function _hashMessage() private view returns (bytes32) {
1179	 return _hashTypedDataV4( keccak256(abi.encode(MESSSAGE_HASH, keccak256(bytes(terms.url)), keccak256(bytes(terms.message)))) );
1180	 }
1181	 }
1182	 pragma solidity ^0.8.0;
1183	 interface IERC2981Upgradeable is IERC165Upgradeable {
1184	 function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address receiver, uint256 royaltyAmount);
1185	 }
1186	 pragma solidity ^0.8.0;
1187	 library BitMapsUpgradeable {
1188	 struct BitMap {
1189	 mapping(uint256 => uint256) _data;
1190	 }
1191	 function get(BitMap storage bitmap, uint256 index) internal view returns (bool) {
1192	 uint256 bucket = index >> 8;
1193	 uint256 mask = 1 << (index & 0xff);
1194	 return bitmap._data[bucket] & mask != 0;
1195	 }
1196	 function setTo( BitMap storage bitmap, uint256 index, bool value ) internal {
1197	 if (value) {
1198	 set(bitmap, index);
1199	 }
1200	 else {
1201	 unset(bitmap, index);
1202	 }
1203	 }
1204	 function set(BitMap storage bitmap, uint256 index) internal {
1205	 uint256 bucket = index >> 8;
1206	 uint256 mask = 1 << (index & 0xff);
1207	 bitmap._data[bucket] |= mask;
1208	 }
1209	 function unset(BitMap storage bitmap, uint256 index) internal {
1210	 uint256 bucket = index >> 8;
1211	 uint256 mask = 1 << (index & 0xff);
1212	 bitmap._data[bucket] &= ~mask;
1213	 }
1214	 }
1215	 pragma solidity ^0.8.0;
1216	 library StringsUpgradeable {
1217	 bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";
1218	 function toString(uint256 value) internal pure returns (string memory) {
1219	 if (value == 0) {
1220	 return "0";
1221	 }
1222	 uint256 temp = value;
1223	 uint256 digits;
1224	 while (temp != 0) {
1225	 digits++;
1226	 temp /= 10;
1227	 }
1228	 bytes memory buffer = new bytes(digits);
1229	 while (value != 0) {
1230	 digits -= 1;
1231	 buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
1232	 value /= 10;
1233	 }
1234	 return string(buffer);
1235	 }
1236	 function toHexString(uint256 value) internal pure returns (string memory) {
1237	 if (value == 0) {
1238	 return "0x00";
1239	 }
1240	 uint256 temp = value;
1241	 uint256 length = 0;
1242	 while (temp != 0) {
1243	 length++;
1244	 temp >>= 8;
1245	 }
1246	 return toHexString(value, length);
1247	 }
1248	 function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
1249	 bytes memory buffer = new bytes(2 * length + 2);
1250	 buffer[0] = "0";
1251	 buffer[1] = "x";
1252	 for (uint256 i = 2 * length + 1; i > 1; --i) {
1253	 buffer[i] = _HEX_SYMBOLS[value & 0xf];
1254	 value >>= 4;
1255	 }
1256	 require(value == 0, "Strings: hex length insufficient");
1257	 return string(buffer);
1258	 }
1259	 }
1260	 pragma solidity ^0.8.4;
1261	 library FeeType {
1262	 uint256 internal constant PRIMARY_SALE = 0;
1263	 uint256 internal constant MARKET_SALE = 1;
1264	 uint256 internal constant SPLIT = 2;
1265	 }
1266	 pragma solidity ^0.8.4;
1267	 library MerkleProof {
1268	 function verify( bytes32[] memory proof, bytes32 root, bytes32 leaf ) internal pure returns (bool, uint256) {
1269	 bytes32 computedHash = leaf;
1270	 uint256 index = 0;
1271	 for (uint256 i = 0; i < proof.length; i++) {
1272	 index *= 2;
1273	 bytes32 proofElement = proof[i];
1274	 if (computedHash <= proofElement) {
1275	 computedHash = keccak256(abi.encodePacked(computedHash, proofElement));
1276	 }
1277	 else {
1278	 computedHash = keccak256(abi.encodePacked(proofElement, computedHash));
1279	 index += 1;
1280	 }
1281	 }
1282	 return (computedHash == root, index);
1283	 }
1284	 }
1285	 pragma solidity ^0.8.4;
1286	 error InvalidPermission();
1287	 error InvalidIndex();
1288	 error NothingToReveal();
1289	 error Bot();
1290	 error ST();
1291	 error CrossedLimit();
1292	 error InvalidPrice();
1293	 error InvalidQuantity();
1294	 error InvalidTime();
1295	 error InvalidProof();
1296	 error MaxBps();
1297	 pragma solidity ^0.8.7;
1298	 interface DataTypes {
1299	 struct ClaimData {
1300	 IDropClaimConditionV0.ClaimConditionList claimCondition;
1301	 uint256 nextTokenIdToClaim;
1302	 mapping(address => uint256) walletClaimCount;
1303	 uint256 nextTokenIdToMint;
1304	 uint256 maxTotalSupply;
1305	 uint256 maxWalletClaimCount;
1306	 address primarySaleRecipient;
1307	 address platformFeeRecipient;
1308	 uint16 platformFeeBps;
1309	 }
1310	 }
1311	 pragma solidity ^0.8.7;
1312	 library CedarDropERC721ClaimLogicV0 {
1313	 using CedarDropERC721ClaimLogicV0 for DataTypes.ClaimData;
1314	 using BitMapsUpgradeable for BitMapsUpgradeable.BitMap;
1315	 struct InternalClaim {
1316	 bool validMerkleProof;
1317	 uint256 merkleProofIndex;
1318	 bool toVerifyMaxQuantityPerTransaction;
1319	 uint256 activeConditionId;
1320	 uint256 tokenIdToClaim;
1321	 }
1322	 event TokensClaimed( uint256 indexed claimConditionIndex, address indexed claimer, address indexed receiver, uint256 startTokenId, uint256 quantityClaimed );
1323	 event ClaimConditionsUpdated(IDropClaimConditionV0.ClaimCondition[] claimConditions);
1324	 function transferClaimedTokens( DataTypes.ClaimData storage claimData, uint256 _conditionId, uint256 _quantityBeingClaimed, address msgSender ) public returns (uint256[] memory tokens) {
1325	 claimData.claimCondition.phases[_conditionId].supplyClaimed += _quantityBeingClaimed;
1326	 claimData.claimCondition.limitLastClaimTimestamp[_conditionId][msgSender] = block.timestamp;
1327	 claimData.walletClaimCount[msgSender] += _quantityBeingClaimed;
1328	 uint256 tokenIdToClaim = claimData.nextTokenIdToClaim;
1329	 tokens = new uint256[](_quantityBeingClaimed);
1330	 for (uint256 i = 0; i < _quantityBeingClaimed; i += 1) {
1331	 tokens[i] = tokenIdToClaim;
1332	 tokenIdToClaim += 1;
1333	 }
1334	 claimData.nextTokenIdToClaim = tokenIdToClaim;
1335	 }
1336	 function executeClaim( DataTypes.ClaimData storage claimData, address _receiver, uint256 _quantity, address _currency, uint256 _pricePerToken, bytes32[] calldata _proofs, uint256 _proofMaxQuantityPerTransaction, address msgSender ) public returns (uint256[] memory) {
1337	 InternalClaim memory internalData;
1338	 internalData.tokenIdToClaim = claimData.nextTokenIdToClaim;
1339	 internalData.activeConditionId = getActiveClaimConditionId(claimData);
1340	 (internalData.validMerkleProof, internalData.merkleProofIndex) = verifyClaimMerkleProof( claimData, internalData.activeConditionId, msgSender, _quantity, _proofs, _proofMaxQuantityPerTransaction );
1341	 internalData.toVerifyMaxQuantityPerTransaction = _proofMaxQuantityPerTransaction == 0 || claimData.claimCondition.phases[internalData.activeConditionId].merkleRoot == bytes32(0);
1342	 verifyClaim( claimData, internalData.activeConditionId, msgSender, _quantity, _currency, _pricePerToken, internalData.toVerifyMaxQuantityPerTransaction );
1343	 if (internalData.validMerkleProof && _proofMaxQuantityPerTransaction > 0) {
1344	 claimData.claimCondition.limitMerkleProofClaim[internalData.activeConditionId].set( internalData.merkleProofIndex );
1345	 }
1346	 claimData.collectClaimPrice(_quantity, _currency, _pricePerToken, msgSender);
1347	 uint256[] memory tokens = transferClaimedTokens( claimData, internalData.activeConditionId, _quantity, msgSender );
1348	 emit TokensClaimed( internalData.activeConditionId, msgSender, _receiver, internalData.tokenIdToClaim, _quantity );
1349	 return tokens;
1350	 }
1351	 function verifyClaimMerkleProof( DataTypes.ClaimData storage claimData, uint256 _conditionId, address _claimer, uint256 _quantity, bytes32[] calldata _proofs, uint256 _proofMaxQuantityPerTransaction ) public view returns (bool validMerkleProof, uint256 merkleProofIndex) {
1352	 IDropClaimConditionV0.ClaimCondition memory currentClaimPhase = claimData.claimCondition.phases[_conditionId];
1353	 if (currentClaimPhase.merkleRoot != bytes32(0)) {
1354	 (validMerkleProof, merkleProofIndex) = MerkleProof.verify( _proofs, currentClaimPhase.merkleRoot, keccak256(abi.encodePacked(_claimer, _proofMaxQuantityPerTransaction)) );
1355	 if (!validMerkleProof) revert InvalidProof();
1356	 if (!(!claimData.claimCondition.limitMerkleProofClaim[_conditionId].get(merkleProofIndex))) revert InvalidProof();
1357	 if (!(_proofMaxQuantityPerTransaction == 0 || _quantity <= _proofMaxQuantityPerTransaction)) revert InvalidProof();
1358	 }
1359	 }
1360	 function getActiveClaimConditionId(DataTypes.ClaimData storage claimData) public view returns (uint256) {
1361	 for ( uint256 i = claimData.claimCondition.currentStartId + claimData.claimCondition.count; i > claimData.claimCondition.currentStartId; i-- ) {
1362	 if (block.timestamp >= claimData.claimCondition.phases[i - 1].startTimestamp) {
1363	 return i - 1;
1364	 }
1365	 }
1366	 revert("!CONDITION.");
1367	 }
1368	 function verifyClaim( DataTypes.ClaimData storage claimData, uint256 _conditionId, address _claimer, uint256 _quantity, address _currency, uint256 _pricePerToken, bool verifyMaxQuantityPerTransaction ) public view {
1369	 IDropClaimConditionV0.ClaimCondition memory currentClaimPhase = claimData.claimCondition.phases[_conditionId];
1370	 if (!(_currency == currentClaimPhase.currency && _pricePerToken == currentClaimPhase.pricePerToken)) revert InvalidPrice();
1371	 if ( !(_quantity > 0 && (!verifyMaxQuantityPerTransaction || _quantity <= currentClaimPhase.quantityLimitPerTransaction)) ) revert InvalidQuantity();
1372	 if (!(currentClaimPhase.supplyClaimed + _quantity <= currentClaimPhase.maxClaimableSupply)) revert CrossedLimit();
1373	 if (!(claimData.nextTokenIdToClaim + _quantity <= claimData.nextTokenIdToMint)) revert CrossedLimit();
1374	 if (!(claimData.maxTotalSupply == 0 || claimData.nextTokenIdToClaim + _quantity <= claimData.maxTotalSupply)) revert CrossedLimit();
1375	 if ( !(claimData.maxWalletClaimCount == 0 || claimData.walletClaimCount[_claimer] + _quantity <= claimData.maxWalletClaimCount) ) revert CrossedLimit();
1376	 (uint256 lastClaimTimestamp, uint256 nextValidClaimTimestamp) = getClaimTimestamp( claimData, _conditionId, _claimer );
1377	 if (!(lastClaimTimestamp == 0 || block.timestamp >= nextValidClaimTimestamp)) revert InvalidTime();
1378	 }
1379	 function getClaimTimestamp( DataTypes.ClaimData storage claimData, uint256 _conditionId, address _claimer ) public view returns (uint256 lastClaimTimestamp, uint256 nextValidClaimTimestamp) {
1380	 lastClaimTimestamp = claimData.claimCondition.limitLastClaimTimestamp[_conditionId][_claimer];
1381	 unchecked {
1382	 nextValidClaimTimestamp = lastClaimTimestamp + claimData.claimCondition.phases[_conditionId].waitTimeInSecondsBetweenClaims;
1383	 if (nextValidClaimTimestamp < lastClaimTimestamp) {
1384	 nextValidClaimTimestamp = type(uint256).max;
1385	 }
1386	 }
1387	 }
1388	 function collectClaimPrice( DataTypes.ClaimData storage claimData, uint256 _quantityToClaim, address _currency, uint256 _pricePerToken, address msgSender ) internal {
1389	 if (_pricePerToken == 0) {
1390	 return;
1391	 }
1392	 uint256 MAX_BPS = 10_000;
1393	 uint256 totalPrice = _quantityToClaim * _pricePerToken;
1394	 uint256 platformFees = (totalPrice * claimData.platformFeeBps) / MAX_BPS;
1395	 if(_currency == CurrencyTransferLib.NATIVE_TOKEN && !(msg.value == totalPrice)) revert InvalidPrice();
1396	 CurrencyTransferLib.transferCurrency(_currency, msgSender, claimData.platformFeeRecipient, platformFees);
1397	 CurrencyTransferLib.transferCurrency(_currency, msgSender, claimData.primarySaleRecipient, totalPrice - platformFees);
1398	 }
1399	 function setClaimConditions( DataTypes.ClaimData storage claimData, IDropClaimConditionV0.ClaimCondition[] calldata _phases, bool _resetClaimEligibility ) public {
1400	 uint256 existingStartIndex = claimData.claimCondition.currentStartId;
1401	 uint256 existingPhaseCount = claimData.claimCondition.count;
1402	 uint256 newStartIndex = existingStartIndex;
1403	 if (_resetClaimEligibility) {
1404	 newStartIndex = existingStartIndex + existingPhaseCount;
1405	 }
1406	 claimData.claimCondition.count = _phases.length;
1407	 claimData.claimCondition.currentStartId = newStartIndex;
1408	 uint256 lastConditionStartTimestamp;
1409	 for (uint256 i = 0; i < _phases.length; i++) {
1410	 if (!(i == 0 || lastConditionStartTimestamp < _phases[i].startTimestamp)) revert ST();
1411	 uint256 supplyClaimedAlready = claimData.claimCondition.phases[newStartIndex + i].supplyClaimed;
1412	 if (!(supplyClaimedAlready <= _phases[i].maxClaimableSupply)) revert CrossedLimit();
1413	 claimData.claimCondition.phases[newStartIndex + i] = _phases[i];
1414	 claimData.claimCondition.phases[newStartIndex + i].supplyClaimed = supplyClaimedAlready;
1415	 lastConditionStartTimestamp = _phases[i].startTimestamp;
1416	 }
1417	 if (_resetClaimEligibility) {
1418	 for (uint256 i = existingStartIndex; i < newStartIndex; i++) {
1419	 delete claimData.claimCondition.phases[i];
1420	 delete claimData.claimCondition.limitMerkleProofClaim[i];
1421	 }
1422	 }
1423	 else {
1424	 if (existingPhaseCount > _phases.length) {
1425	 for (uint256 i = _phases.length; i < existingPhaseCount; i++) {
1426	 delete claimData.claimCondition.phases[newStartIndex + i];
1427	 delete claimData.claimCondition.limitMerkleProofClaim[newStartIndex + i];
1428	 }
1429	 }
1430	 }
1431	 emit ClaimConditionsUpdated(_phases);
1432	 }
1433	 function getActiveClaimConditions(DataTypes.ClaimData storage claimData) public view returns ( IDropClaimConditionV0.ClaimCondition memory condition, uint256 conditionId, uint256 walletMaxClaimCount, uint256 remainingSupply ) {
1434	 conditionId = getActiveClaimConditionId(claimData);
1435	 condition = claimData.claimCondition.phases[conditionId];
1436	 walletMaxClaimCount = claimData.maxWalletClaimCount;
1437	 remainingSupply = 0;
1438	 }
1439	 function getUserClaimConditions(DataTypes.ClaimData storage claimData, address _claimer) public view returns ( uint256 conditionId, uint256 walletClaimedCount, uint256 lastClaimTimestamp, uint256 nextValidClaimTimestamp ) {
1440	 conditionId = getActiveClaimConditionId(claimData);
1441	 (lastClaimTimestamp, nextValidClaimTimestamp) = getClaimTimestamp(claimData, conditionId, _claimer);
1442	 walletClaimedCount = claimData.walletClaimCount[_claimer];
1443	 }
1444	 }
1445	 pragma solidity ^0.8.0;
1446	 interface IERC721ReceiverUpgradeable {
1447	 function onERC721Received( address operator, address from, uint256 tokenId, bytes calldata data ) external returns (bytes4);
1448	 }
1449	 pragma solidity ^0.8.1;
1450	 library AddressUpgradeable {
1451	 function isContract(address account) internal view returns (bool) {
1452	 return account.code.length > 0;
1453	 }
1454	 function sendValue(address payable recipient, uint256 amount) internal {
1455	 require(address(this).balance >= amount, "Address: insufficient balance");
1456	 (bool success, ) = recipient.call{
1457	 value: amount}
1458	 ("");
1459	 require(success, "Address: unable to send value, recipient may have reverted");
1460	 }
1461	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
1462	 return functionCall(target, data, "Address: low-level call failed");
1463	 }
1464	 function functionCall( address target, bytes memory data, string memory errorMessage ) internal returns (bytes memory) {
1465	 return functionCallWithValue(target, data, 0, errorMessage);
1466	 }
1467	 function functionCallWithValue( address target, bytes memory data, uint256 value ) internal returns (bytes memory) {
1468	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
1469	 }
1470	 function functionCallWithValue( address target, bytes memory data, uint256 value, string memory errorMessage ) internal returns (bytes memory) {
1471	 require(address(this).balance >= value, "Address: insufficient balance for call");
1472	 require(isContract(target), "Address: call to non-contract");
1473	 (bool success, bytes memory returndata) = target.call{
1474	 value: value}
1475	 (data);
1476	 return verifyCallResult(success, returndata, errorMessage);
1477	 }
1478	 function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
1479	 return functionStaticCall(target, data, "Address: low-level static call failed");
1480	 }
1481	 function functionStaticCall( address target, bytes memory data, string memory errorMessage ) internal view returns (bytes memory) {
1482	 require(isContract(target), "Address: static call to non-contract");
1483	 (bool success, bytes memory returndata) = target.staticcall(data);
1484	 return verifyCallResult(success, returndata, errorMessage);
1485	 }
1486	 function verifyCallResult( bool success, bytes memory returndata, string memory errorMessage ) internal pure returns (bytes memory) {
1487	 if (success) {
1488	 return returndata;
1489	 }
1490	 else {
1491	 if (returndata.length > 0) {
1492	 assembly {
1493	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
1494	 }
1495	 else {
1496	 revert(errorMessage);
1497	 }
1498	 }
1499	 }
1500	 }
1501	 pragma solidity ^0.8.0;
1502	 library EnumerableSetUpgradeable {
1503	 struct Set {
1504	 bytes32[] _values;
1505	 mapping(bytes32 => uint256) _indexes;
1506	 }
1507	 function _add(Set storage set, bytes32 value) private returns (bool) {
1508	 if (!_contains(set, value)) {
1509	 set._values.push(value);
1510	 set._indexes[value] = set._values.length;
1511	 return true;
1512	 }
1513	 else {
1514	 return false;
1515	 }
1516	 }
1517	 function _remove(Set storage set, bytes32 value) private returns (bool) {
1518	 uint256 valueIndex = set._indexes[value];
1519	 if (valueIndex != 0) {
1520	 uint256 toDeleteIndex = valueIndex - 1;
1521	 uint256 lastIndex = set._values.length - 1;
1522	 if (lastIndex != toDeleteIndex) {
1523	 bytes32 lastvalue = set._values[lastIndex];
1524	 set._values[toDeleteIndex] = lastvalue;
1525	 set._indexes[lastvalue] = valueIndex;
1526	 }
1527	 set._values.pop();
1528	 delete set._indexes[value];
1529	 return true;
1530	 }
1531	 else {
1532	 return false;
1533	 }
1534	 }
1535	 function _contains(Set storage set, bytes32 value) private view returns (bool) {
1536	 return set._indexes[value] != 0;
1537	 }
1538	 function _length(Set storage set) private view returns (uint256) {
1539	 return set._values.length;
1540	 }
1541	 function _at(Set storage set, uint256 index) private view returns (bytes32) {
1542	 return set._values[index];
1543	 }
1544	 function _values(Set storage set) private view returns (bytes32[] memory) {
1545	 return set._values;
1546	 }
1547	 struct Bytes32Set {
1548	 Set _inner;
1549	 }
1550	 function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {
1551	 return _add(set._inner, value);
1552	 }
1553	 function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {
1554	 return _remove(set._inner, value);
1555	 }
1556	 function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {
1557	 return _contains(set._inner, value);
1558	 }
1559	 function length(Bytes32Set storage set) internal view returns (uint256) {
1560	 return _length(set._inner);
1561	 }
1562	 function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {
1563	 return _at(set._inner, index);
1564	 }
1565	 function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {
1566	 return _values(set._inner);
1567	 }
1568	 struct AddressSet {
1569	 Set _inner;
1570	 }
1571	 function add(AddressSet storage set, address value) internal returns (bool) {
1572	 return _add(set._inner, bytes32(uint256(uint160(value))));
1573	 }
1574	 function remove(AddressSet storage set, address value) internal returns (bool) {
1575	 return _remove(set._inner, bytes32(uint256(uint160(value))));
1576	 }
1577	 function contains(AddressSet storage set, address value) internal view returns (bool) {
1578	 return _contains(set._inner, bytes32(uint256(uint160(value))));
1579	 }
1580	 function length(AddressSet storage set) internal view returns (uint256) {
1581	 return _length(set._inner);
1582	 }
1583	 function at(AddressSet storage set, uint256 index) internal view returns (address) {
1584	 return address(uint160(uint256(_at(set._inner, index))));
1585	 }
1586	 function values(AddressSet storage set) internal view returns (address[] memory) {
1587	 bytes32[] memory store = _values(set._inner);
1588	 address[] memory result;
1589	 assembly {
1590	 result := store }
1591	 return result;
1592	 }
1593	 struct UintSet {
1594	 Set _inner;
1595	 }
1596	 function add(UintSet storage set, uint256 value) internal returns (bool) {
1597	 return _add(set._inner, bytes32(value));
1598	 }
1599	 function remove(UintSet storage set, uint256 value) internal returns (bool) {
1600	 return _remove(set._inner, bytes32(value));
1601	 }
1602	 function contains(UintSet storage set, uint256 value) internal view returns (bool) {
1603	 return _contains(set._inner, bytes32(value));
1604	 }
1605	 function length(UintSet storage set) internal view returns (uint256) {
1606	 return _length(set._inner);
1607	 }
1608	 function at(UintSet storage set, uint256 index) internal view returns (uint256) {
1609	 return uint256(_at(set._inner, index));
1610	 }
1611	 function values(UintSet storage set) internal view returns (uint256[] memory) {
1612	 bytes32[] memory store = _values(set._inner);
1613	 uint256[] memory result;
1614	 assembly {
1615	 result := store }
1616	 return result;
1617	 }
1618	 }
1619	 pragma solidity ^0.8.4;
1620	 interface ICedarERC721DropV0 is ICedarFeaturesV0, ICedarVersionedV0, ICedarNFTIssuanceV0, ICedarNFTLazyMintV0, IMulticallableV0, IERC721V0 {
1621	 }
1622	 interface ICedarERC721DropV1 is ICedarFeaturesV0, ICedarVersionedV0, IMulticallableV0, ICedarAgreementV0, ICedarNFTIssuanceV1, ICedarNFTLazyMintV0, IERC721V0, IRoyaltyV0 {
1623	 }
1624	 interface ICedarERC721DropV2 is ICedarFeaturesV0, ICedarVersionedV0, IMulticallableV0, ICedarAgreementV0, ICedarNFTIssuanceV1, ICedarNFTLazyMintV1, IERC721V0, IRoyaltyV0, ICedarUpdateBaseURIV0, ICedarNFTMetadataV0, ICedarMetadataV0 {
1625	 }
1626	 pragma solidity ^0.8.0;
1627	 library ECDSA {
1628	 enum RecoverError {
1629	 NoError, InvalidSignature, InvalidSignatureLength, InvalidSignatureS, InvalidSignatureV }
1630	 function _throwError(RecoverError error) private pure {
1631	 if (error == RecoverError.NoError) {
1632	 return;
1633	 }
1634	 else if (error == RecoverError.InvalidSignature) {
1635	 revert("ECDSA: invalid signature");
1636	 }
1637	 else if (error == RecoverError.InvalidSignatureLength) {
1638	 revert("ECDSA: invalid signature length");
1639	 }
1640	 else if (error == RecoverError.InvalidSignatureS) {
1641	 revert("ECDSA: invalid signature 's' value");
1642	 }
1643	 else if (error == RecoverError.InvalidSignatureV) {
1644	 revert("ECDSA: invalid signature 'v' value");
1645	 }
1646	 }
1647	 function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {
1648	 if (signature.length == 65) {
1649	 bytes32 r;
1650	 bytes32 s;
1651	 uint8 v;
1652	 assembly {
1653	 r := mload(add(signature, 0x20)) s := mload(add(signature, 0x40)) v := byte(0, mload(add(signature, 0x60))) }
1654	 return tryRecover(hash, v, r, s);
1655	 }
1656	 else if (signature.length == 64) {
1657	 bytes32 r;
1658	 bytes32 vs;
1659	 assembly {
1660	 r := mload(add(signature, 0x20)) vs := mload(add(signature, 0x40)) }
1661	 return tryRecover(hash, r, vs);
1662	 }
1663	 else {
1664	 return (address(0), RecoverError.InvalidSignatureLength);
1665	 }
1666	 }
1667	 function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {
1668	 (address recovered, RecoverError error) = tryRecover(hash, signature);
1669	 _throwError(error);
1670	 return recovered;
1671	 }
1672	 function tryRecover( bytes32 hash, bytes32 r, bytes32 vs ) internal pure returns (address, RecoverError) {
1673	 bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
1674	 uint8 v = uint8((uint256(vs) >> 255) + 27);
1675	 return tryRecover(hash, v, r, s);
1676	 }
1677	 function recover( bytes32 hash, bytes32 r, bytes32 vs ) internal pure returns (address) {
1678	 (address recovered, RecoverError error) = tryRecover(hash, r, vs);
1679	 _throwError(error);
1680	 return recovered;
1681	 }
1682	 function tryRecover( bytes32 hash, uint8 v, bytes32 r, bytes32 s ) internal pure returns (address, RecoverError) {
1683	 if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {
1684	 return (address(0), RecoverError.InvalidSignatureS);
1685	 }
1686	 if (v != 27 && v != 28) {
1687	 return (address(0), RecoverError.InvalidSignatureV);
1688	 }
1689	 address signer = ecrecover(hash, v, r, s);
1690	 if (signer == address(0)) {
1691	 return (address(0), RecoverError.InvalidSignature);
1692	 }
1693	 return (signer, RecoverError.NoError);
1694	 }
1695	 function recover( bytes32 hash, uint8 v, bytes32 r, bytes32 s ) internal pure returns (address) {
1696	 (address recovered, RecoverError error) = tryRecover(hash, v, r, s);
1697	 _throwError(error);
1698	 return recovered;
1699	 }
1700	 function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {
1701	 return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
1702	 }
1703	 function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {
1704	 return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n", Strings.toString(s.length), s));
1705	 }
1706	 function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {
1707	 return keccak256(abi.encodePacked("\x19\x01", domainSeparator, structHash));
1708	 }
1709	 }
1710	 pragma solidity ^0.8.0;
1711	 library Strings {
1712	 bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";
1713	 function toString(uint256 value) internal pure returns (string memory) {
1714	 if (value == 0) {
1715	 return "0";
1716	 }
1717	 uint256 temp = value;
1718	 uint256 digits;
1719	 while (temp != 0) {
1720	 digits++;
1721	 temp /= 10;
1722	 }
1723	 bytes memory buffer = new bytes(digits);
1724	 while (value != 0) {
1725	 digits -= 1;
1726	 buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
1727	 value /= 10;
1728	 }
1729	 return string(buffer);
1730	 }
1731	 function toHexString(uint256 value) internal pure returns (string memory) {
1732	 if (value == 0) {
1733	 return "0x00";
1734	 }
1735	 uint256 temp = value;
1736	 uint256 length = 0;
1737	 while (temp != 0) {
1738	 length++;
1739	 temp >>= 8;
1740	 }
1741	 return toHexString(value, length);
1742	 }
1743	 function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
1744	 bytes memory buffer = new bytes(2 * length + 2);
1745	 buffer[0] = "0";
1746	 buffer[1] = "x";
1747	 for (uint256 i = 2 * length + 1; i > 1; --i) {
1748	 buffer[i] = _HEX_SYMBOLS[value & 0xf];
1749	 value >>= 4;
1750	 }
1751	 require(value == 0, "Strings: hex length insufficient");
1752	 return string(buffer);
1753	 }
1754	 }
1755	 pragma solidity ^0.8.1;
1756	 library Address {
1757	 function isContract(address account) internal view returns (bool) {
1758	 return account.code.length > 0;
1759	 }
1760	 function sendValue(address payable recipient, uint256 amount) internal {
1761	 require(address(this).balance >= amount, "Address: insufficient balance");
1762	 (bool success, ) = recipient.call{
1763	 value: amount}
1764	 ("");
1765	 require(success, "Address: unable to send value, recipient may have reverted");
1766	 }
1767	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
1768	 return functionCall(target, data, "Address: low-level call failed");
1769	 }
1770	 function functionCall( address target, bytes memory data, string memory errorMessage ) internal returns (bytes memory) {
1771	 return functionCallWithValue(target, data, 0, errorMessage);
1772	 }
1773	 function functionCallWithValue( address target, bytes memory data, uint256 value ) internal returns (bytes memory) {
1774	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
1775	 }
1776	 function functionCallWithValue( address target, bytes memory data, uint256 value, string memory errorMessage ) internal returns (bytes memory) {
1777	 require(address(this).balance >= value, "Address: insufficient balance for call");
1778	 require(isContract(target), "Address: call to non-contract");
1779	 (bool success, bytes memory returndata) = target.call{
1780	 value: value}
1781	 (data);
1782	 return verifyCallResult(success, returndata, errorMessage);
1783	 }
1784	 function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
1785	 return functionStaticCall(target, data, "Address: low-level static call failed");
1786	 }
1787	 function functionStaticCall( address target, bytes memory data, string memory errorMessage ) internal view returns (bytes memory) {
1788	 require(isContract(target), "Address: static call to non-contract");
1789	 (bool success, bytes memory returndata) = target.staticcall(data);
1790	 return verifyCallResult(success, returndata, errorMessage);
1791	 }
1792	 function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
1793	 return functionDelegateCall(target, data, "Address: low-level delegate call failed");
1794	 }
1795	 function functionDelegateCall( address target, bytes memory data, string memory errorMessage ) internal returns (bytes memory) {
1796	 require(isContract(target), "Address: delegate call to non-contract");
1797	 (bool success, bytes memory returndata) = target.delegatecall(data);
1798	 return verifyCallResult(success, returndata, errorMessage);
1799	 }
1800	 function verifyCallResult( bool success, bytes memory returndata, string memory errorMessage ) internal pure returns (bytes memory) {
1801	 if (success) {
1802	 return returndata;
1803	 }
1804	 else {
1805	 if (returndata.length > 0) {
1806	 assembly {
1807	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
1808	 }
1809	 else {
1810	 revert(errorMessage);
1811	 }
1812	 }
1813	 }
1814	 }
1815	 pragma solidity ^0.8.4;
1816	 contract GreenlistManager is OwnableUpgradeable, UUPSUpgradeable {
1817	 address public operator;
1818	 function initialize() public initializer {
1819	 __Ownable_init();
1820	 __UUPSUpgradeable_init();
1821	 }
1822	 event OperatorAdded(address _address);
1823	 event OperatorDeleted(address _address);
1824	 function _authorizeUpgrade(address newImplementation) internal override onlyOwner {
1825	 }
1826	 function setAspenOperator(address _operator) external onlyOwner {
1827	 operator = _operator;
1828	 emit OperatorAdded(_operator);
1829	 }
1830	 function deleteAspenOperator(address _address) external onlyOwner {
1831	 delete operator;
1832	 emit OperatorDeleted(_address);
1833	 }
1834	 function isGreenlisted(address _address) public view returns (bool) {
1835	 return (operator == _address);
1836	 }
1837	 }
1838	 pragma solidity ^0.8.0;
1839	 interface IBeaconUpgradeable {
1840	 function implementation() external view returns (address);
1841	 }
1842	 pragma solidity ^0.8.0;
1843	 library StorageSlotUpgradeable {
1844	 struct AddressSlot {
1845	 address value;
1846	 }
1847	 struct BooleanSlot {
1848	 bool value;
1849	 }
1850	 struct Bytes32Slot {
1851	 bytes32 value;
1852	 }
1853	 struct Uint256Slot {
1854	 uint256 value;
1855	 }
1856	 function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {
1857	 assembly {
1858	 r.slot := slot }
1859	 }
1860	 function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {
1861	 assembly {
1862	 r.slot := slot }
1863	 }
1864	 function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {
1865	 assembly {
1866	 r.slot := slot }
1867	 }
1868	 function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {
1869	 assembly {
1870	 r.slot := slot }
1871	 }
1872	 }
1873	 pragma solidity ^0.8.4;
1874	 library CurrencyTransferLib {
1875	 using SafeERC20Upgradeable for IERC20Upgradeable;
1876	 address public constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
1877	 function transferCurrency( address _currency, address _from, address _to, uint256 _amount ) internal {
1878	 if (_amount == 0) {
1879	 return;
1880	 }
1881	 if (_currency == NATIVE_TOKEN) {
1882	 safeTransferNativeToken(_to, _amount);
1883	 }
1884	 else {
1885	 safeTransferERC20(_currency, _from, _to, _amount);
1886	 }
1887	 }
1888	 function transferCurrencyWithWrapper( address _currency, address _from, address _to, uint256 _amount, address _nativeTokenWrapper ) internal {
1889	 if (_amount == 0) {
1890	 return;
1891	 }
1892	 if (_currency == NATIVE_TOKEN) {
1893	 if (_from == address(this)) {
1894	 IWETH(_nativeTokenWrapper).withdraw(_amount);
1895	 safeTransferNativeTokenWithWrapper(_to, _amount, _nativeTokenWrapper);
1896	 }
1897	 else if (_to == address(this)) {
1898	 require(_amount == msg.value, "msg.value != amount");
1899	 IWETH(_nativeTokenWrapper).deposit{
1900	 value: _amount }
1901	 ();
1902	 }
1903	 else {
1904	 safeTransferNativeTokenWithWrapper(_to, _amount, _nativeTokenWrapper);
1905	 }
1906	 }
1907	 else {
1908	 safeTransferERC20(_currency, _from, _to, _amount);
1909	 }
1910	 }
1911	 function safeTransferERC20( address _currency, address _from, address _to, uint256 _amount ) internal {
1912	 if (_from == _to) {
1913	 return;
1914	 }
1915	 if (_from == address(this)) {
1916	 IERC20Upgradeable(_currency).safeTransfer(_to, _amount);
1917	 }
1918	 else {
1919	 IERC20Upgradeable(_currency).safeTransferFrom(_from, _to, _amount);
1920	 }
1921	 }
1922	 function safeTransferNativeToken(address to, uint256 value) internal {
1923	 (bool success, ) = to.call{
1924	 value: value }
1925	 ("");
1926	 require(success, "native token transfer failed");
1927	 }
1928	 function safeTransferNativeTokenWithWrapper( address to, uint256 value, address _nativeTokenWrapper ) internal {
1929	 (bool success, ) = to.call{
1930	 value: value }
1931	 ("");
1932	 if (!success) {
1933	 IWETH(_nativeTokenWrapper).deposit{
1934	 value: value }
1935	 ();
1936	 IERC20Upgradeable(_nativeTokenWrapper).safeTransfer(to, value);
1937	 }
1938	 }
1939	 }
1940	 pragma solidity ^0.8.4;
1941	 interface IWETH {
1942	 function deposit() external payable;
1943	 function withdraw(uint256 amount) external;
1944	 function transfer(address to, uint256 value) external returns (bool);
1945	 }
1946	 pragma solidity ^0.8.0;
1947	 interface IERC20Upgradeable {
1948	 function totalSupply() external view returns (uint256);
1949	 function balanceOf(address account) external view returns (uint256);
1950	 function transfer(address to, uint256 amount) external returns (bool);
1951	 function allowance(address owner, address spender) external view returns (uint256);
1952	 function approve(address spender, uint256 amount) external returns (bool);
1953	 function transferFrom( address from, address to, uint256 amount ) external returns (bool);
1954	 event Transfer(address indexed from, address indexed to, uint256 value);
1955	 event Approval(address indexed owner, address indexed spender, uint256 value);
1956	 }
1957	 pragma solidity ^0.8.0;
1958	 library SafeERC20Upgradeable {
1959	 using AddressUpgradeable for address;
1960	 function safeTransfer( IERC20Upgradeable token, address to, uint256 value ) internal {
1961	 _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
1962	 }
1963	 function safeTransferFrom( IERC20Upgradeable token, address from, address to, uint256 value ) internal {
1964	 _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
1965	 }
1966	 function safeApprove( IERC20Upgradeable token, address spender, uint256 value ) internal {
1967	 require( (value == 0) || (token.allowance(address(this), spender) == 0), "SafeERC20: approve from non-zero to non-zero allowance" );
1968	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
1969	 }
1970	 function safeIncreaseAllowance( IERC20Upgradeable token, address spender, uint256 value ) internal {
1971	 uint256 newAllowance = token.allowance(address(this), spender) + value;
1972	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
1973	 }
1974	 function safeDecreaseAllowance( IERC20Upgradeable token, address spender, uint256 value ) internal {
1975	 unchecked {
1976	 uint256 oldAllowance = token.allowance(address(this), spender);
1977	 require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");
1978	 uint256 newAllowance = oldAllowance - value;
1979	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
1980	 }
1981	 }
1982	 function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {
1983	 bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
1984	 if (returndata.length > 0) {
1985	 require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
1986	 }
1987	 }
1988	 }
1989	 pragma solidity ^0.8.4;
1990	 interface ICedarERC721PremintV0 is ICedarFeaturesV0, ICedarVersionedV0, ICedarPremintV0, ICedarAgreementV0, IMulticallableV0 {
1991	 }
1992	 interface ICedarERC721PremintV1 is ICedarFeaturesV0, ICedarVersionedV0, ICedarPremintV0, ICedarAgreementV0, IMulticallableV0, ICedarUpgradeBaseURIV0 {
1993	 }
1994	 pragma solidity ^0.8.4;
1995	 interface ICedarERC1155DropV0 is ICedarFeaturesV0, IMulticallableV0, ICedarVersionedV0, ICedarSFTIssuanceV0, ICedarSFTLazyMintV0, ICedarUpdateBaseURIV0, IERC1155V0 {
1996	 }
1997	 interface ICedarERC1155DropV1 is ICedarFeaturesV0, ICedarVersionedV0, IMulticallableV0, ICedarSFTIssuanceV1, ICedarSFTLazyMintV0, ICedarUpdateBaseURIV0, IERC1155V0, IRoyaltyV0 {
1998	 }
1999	 pragma solidity ^0.8.4;
2000	 interface ICedarPaymentSplitterV0 is ICedarFeaturesV0, ICedarVersionedV0, ICedarSplitPaymentV0 {
2001	 }
2002	 pragma solidity ^0.8.4;
2003	 interface ICedarIssuerV0 {
2004	 function issue(address recipient, uint256 tokenId) external;
2005	 }
2006	 pragma solidity ^0.8.4;
2007	 interface ICedarClaimableV0 {
2008	 function claim( uint256 quantity, address recipient, bytes32[] calldata proof ) external;
2009	 struct ClaimRequest {
2010	 ICedarIssuanceV0.AuthType authType;
2011	 uint256 quantity;
2012	 address recipient;
2013	 address erc20TokenContract;
2014	 bytes32[] proof;
2015	 }
2016	 function claim(ClaimRequest calldata claimRequest, bytes calldata signature) external;
2017	 }
2018	 pragma solidity ^0.8.4;
2019	 interface ICedarOrderFillerV0 {
2020	 function fillOrder(IOrderV0.Order calldata order, bytes calldata signature) external;
2021	 }
2022	 pragma solidity ^0.8.4;
2023	 interface ICedarNativePayableV0 {
2024	 function buy( uint256 quantity, address recipient, uint256 tokenId ) external payable;
2025	 }
2026	 pragma solidity ^0.8.4;
2027	 interface ICedarERC20PayableV0 {
2028	 function buy( address recipient, address erc20TokenContract, uint256 tokenId ) external;
2029	 function buyAny( address recipient, address erc20TokenContract, uint256 quantity ) external;
2030	 }
2031	 pragma solidity ^0.8.0;
2032	 interface ICedarIssuanceV0 {
2033	 enum IssuanceMode {
2034	 SpecificToken, AnyToken }
2035	 enum PaymentType {
2036	 None, Native, ERC20 }
2037	 enum AuthType {
2038	 TrustedSender, Merkle, Signature }
2039	 function issuanceModes() external view returns (IssuanceMode[] calldata);
2040	 function paymentTypes() external view returns (PaymentType[] calldata);
2041	 function authTypes() external view returns (AuthType[] calldata);
2042	 }
2043	 interface ICedarIssuanceV1 {
2044	 function foo() external view returns (uint256);
2045	 }
2046	 pragma solidity ^0.8.4;
2047	 interface IOrderV0 {
2048	 struct Order {
2049	 address maker;
2050	 address taker;
2051	 }
2052	 }
2053	 pragma solidity ^0.8.0;
2054	 interface ICedarSFTMetadataV0 {
2055	 function uri(uint256 _tokenId) external returns (string memory);
2056	 }
2057	 interface ICedarSFTMetadataV1 {
2058	 function uri(uint256 _tokenId) view external returns (string memory);
2059	 }
