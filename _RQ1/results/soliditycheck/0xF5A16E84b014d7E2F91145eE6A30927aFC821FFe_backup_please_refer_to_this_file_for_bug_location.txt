row number 
1	  pragma abicoder v2;
2	 pragma experimental ABIEncoderV2;
3	 pragma solidity >=0.4.24 <0.8.0;
4	 abstract contract Initializable {
5	 bool private _initialized;
6	 bool private _initializing;
7	 modifier initializer() {
8	 require(_initializing || _isConstructor() || !_initialized, "Initializable: contract is already initialized");
9	 bool isTopLevelCall = !_initializing;
10	 if (isTopLevelCall) {
11	 _initializing = true;
12	 _initialized = true;
13	 }
14	 _;
15	 if (isTopLevelCall) {
16	 _initializing = false;
17	 }
18	 }
19	 function _isConstructor() private view returns (bool) {
20	 return !AddressUpgradeable.isContract(address(this));
21	 }
22	 }
23	 pragma solidity >=0.6.0 <0.8.0;
24	 interface IERC165Upgradeable {
25	 function supportsInterface(bytes4 interfaceId) external view returns (bool);
26	 }
27	 pragma solidity >=0.6.0 <0.8.0;
28	 interface IERC1155ReceiverUpgradeable is IERC165Upgradeable {
29	 function onERC1155Received( address operator, address from, uint256 id, uint256 value, bytes calldata data ) external returns(bytes4);
30	 function onERC1155BatchReceived( address operator, address from, uint256[] calldata ids, uint256[] calldata values, bytes calldata data ) external returns(bytes4);
31	 }
32	 pragma solidity >=0.6.0 <0.8.0;
33	 abstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {
34	 bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;
35	 mapping(bytes4 => bool) private _supportedInterfaces;
36	 function __ERC165_init() internal initializer {
37	 __ERC165_init_unchained();
38	 }
39	 function __ERC165_init_unchained() internal initializer {
40	 _registerInterface(_INTERFACE_ID_ERC165);
41	 }
42	 function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
43	 return _supportedInterfaces[interfaceId];
44	 }
45	 function _registerInterface(bytes4 interfaceId) internal virtual {
46	 require(interfaceId != 0xffffffff, "ERC165: invalid interface id");
47	 _supportedInterfaces[interfaceId] = true;
48	 }
49	 uint256[49] private __gap;
50	 }
51	 pragma solidity >=0.6.0 <0.8.0;
52	 interface IERC20Upgradeable {
53	 function totalSupply() external view returns (uint256);
54	 function balanceOf(address account) external view returns (uint256);
55	 function transfer(address recipient, uint256 amount) external returns (bool);
56	 function allowance(address owner, address spender) external view returns (uint256);
57	 function approve(address spender, uint256 amount) external returns (bool);
58	 function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
59	 event Transfer(address indexed from, address indexed to, uint256 value);
60	 event Approval(address indexed owner, address indexed spender, uint256 value);
61	 }
62	 pragma solidity >=0.6.0 <0.8.0;
63	 abstract contract ContextUpgradeable is Initializable {
64	 function __Context_init() internal initializer {
65	 __Context_init_unchained();
66	 }
67	 function __Context_init_unchained() internal initializer {
68	 }
69	 function _msgSender() internal view virtual returns (address payable) {
70	 return msg.sender;
71	 }
72	 function _msgData() internal view virtual returns (bytes memory) {
73	 this;
74	 return msg.data;
75	 }
76	 uint256[50] private __gap;
77	 }
78	 pragma solidity >=0.6.0 <0.8.0;
79	 abstract contract ERC1155ReceiverUpgradeable is Initializable, ERC165Upgradeable, IERC1155ReceiverUpgradeable {
80	 function __ERC1155Receiver_init() internal initializer {
81	 __ERC165_init_unchained();
82	 __ERC1155Receiver_init_unchained();
83	 }
84	 function __ERC1155Receiver_init_unchained() internal initializer {
85	 _registerInterface( ERC1155ReceiverUpgradeable(address(0)).onERC1155Received.selector ^ ERC1155ReceiverUpgradeable(address(0)).onERC1155BatchReceived.selector );
86	 }
87	 uint256[50] private __gap;
88	 }
89	 pragma solidity >=0.6.0 <0.8.0;
90	 abstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {
91	 address private _owner;
92	 event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
93	 function __Ownable_init() internal initializer {
94	 __Context_init_unchained();
95	 __Ownable_init_unchained();
96	 }
97	 function __Ownable_init_unchained() internal initializer {
98	 address msgSender = _msgSender();
99	 _owner = msgSender;
100	 emit OwnershipTransferred(address(0), msgSender);
101	 }
102	 function owner() public view virtual returns (address) {
103	 return _owner;
104	 }
105	 modifier onlyOwner() {
106	 require(owner() == _msgSender(), "Ownable: caller is not the owner");
107	 _;
108	 }
109	 function renounceOwnership() public virtual onlyOwner {
110	 emit OwnershipTransferred(_owner, address(0));
111	 _owner = address(0);
112	 }
113	 function transferOwnership(address newOwner) public virtual onlyOwner {
114	 require(newOwner != address(0), "Ownable: new owner is the zero address");
115	 emit OwnershipTransferred(_owner, newOwner);
116	 _owner = newOwner;
117	 }
118	 uint256[49] private __gap;
119	 }
120	 pragma solidity >=0.6.0 <0.8.0;
121	 contract ERC1155HolderUpgradeable is Initializable, ERC1155ReceiverUpgradeable {
122	 function __ERC1155Holder_init() internal initializer {
123	 __ERC165_init_unchained();
124	 __ERC1155Receiver_init_unchained();
125	 __ERC1155Holder_init_unchained();
126	 }
127	 function __ERC1155Holder_init_unchained() internal initializer {
128	 }
129	 function onERC1155Received(address, address, uint256, uint256, bytes memory) public virtual override returns (bytes4) {
130	 return this.onERC1155Received.selector;
131	 }
132	 function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) public virtual override returns (bytes4) {
133	 return this.onERC1155BatchReceived.selector;
134	 }
135	 uint256[50] private __gap;
136	 }
137	 pragma solidity 0.7.6;
138	 interface IERC1155 is IERC165Upgradeable {
139	 event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);
140	 event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);
141	 event ApprovalForAll(address indexed account, address indexed operator, bool approved);
142	 event URI(string value, uint256 indexed id);
143	 function balanceOf(address account, uint256 id) external view returns (uint256);
144	 function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);
145	 function setApprovalForAll(address operator, bool approved) external;
146	 function isApprovedForAll(address account, address operator) external view returns (bool);
147	 function safeTransferFrom( address from, address to, uint256 id, uint256 amount, bytes calldata data ) external;
148	 function safeBatchTransferFrom( address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data ) external;
149	 function grantRole(bytes32 role, address account) external;
150	 function MINTER_ROLE() external view returns (bytes32);
151	 function mint( address to, uint64 _ammId, uint64 _periodIndex, uint32 _pairId, uint256 amount, bytes memory data ) external returns (uint256 id);
152	 function burnFrom( address account, uint256 id, uint256 value ) external;
153	 }
154	 pragma solidity 0.7.6;
155	 interface IERC20 is IERC20Upgradeable {
156	 function name() external returns (string memory);
157	 function symbol() external returns (string memory);
158	 function decimals() external view returns (uint8);
159	 function increaseAllowance(address spender, uint256 addedValue) external returns (bool);
160	 function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);
161	 }
162	 pragma solidity 0.7.6;
163	 contract MasterChef is OwnableUpgradeable, ERC1155HolderUpgradeable {
164	 using SafeMathUpgradeable for uint256;
165	 using SafeERC20Upgradeable for IERC20Upgradeable;
166	 using SafeERC20Upgradeable for ILPToken;
167	 using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;
168	 using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;
169	 uint256 private constant _NOT_ENTERED = 1;
170	 uint256 private constant _ENTERED = 2;
171	 struct UserInfo {
172	 uint256 amount;
173	 uint256 rewardDebt;
174	 uint256 periodId;
175	 }
176	 struct PoolInfo {
177	 uint256 allocPoint;
178	 uint256 accAPWPerShare;
179	 uint256 lastRewardBlock;
180	 uint256 ammId;
181	 uint256 pairId;
182	 }
183	 EnumerableSetUpgradeable.UintSet internal activePools;
184	 mapping(uint256 => mapping(uint256 => uint256)) internal poolToPeriodId;
185	 mapping(uint256 => mapping(uint256 => mapping(address => UserInfo))) public userInfo;
186	 mapping(uint256 => address) public lpIDToFutureAddress;
187	 mapping(uint256 => uint256) public nextUpgradeAllocPoint;
188	 mapping(uint256 => IRewarder) public rewarders;
189	 uint256 private constant TOKEN_PRECISION = 1e12;
190	 IERC20Upgradeable public apw;
191	 ILPToken public lpToken;
192	 uint256 public apwPerBlock;
193	 mapping(uint256 => PoolInfo) public poolInfo;
194	 bytes4 public constant ERC1155_ERC165 = 0xd9b67a26;
195	 mapping(address => EnumerableSetUpgradeable.UintSet) internal userLpTokensIds;
196	 uint256 public totalAllocPoint;
197	 uint256 public startBlock;
198	 uint256 private _status;
199	 modifier nonReentrant() {
200	 require(_status != _ENTERED, "MasterChef: reentrant call");
201	 _status = _ENTERED;
202	 _;
203	 _status = _NOT_ENTERED;
204	 }
205	 modifier validPool(uint256 _lpTokenId) {
206	 uint64 ammId = lpToken.getAMMId(_lpTokenId);
207	 uint256 pairId = lpToken.getPairId(_lpTokenId);
208	 require(poolToPeriodId[ammId][pairId] != 0, "MasterChef: invalid pool id");
209	 _;
210	 }
211	 event Deposit(address indexed user, uint256 indexed lpTokenId, uint256 amount);
212	 event Withdraw(address indexed user, uint256 indexed lpTokenId, uint256 amount);
213	 event EmergencyWithdraw(address indexed user, uint256 indexed lpTokenId, uint256 amount);
214	 event NextAllocPointSet(uint256 indexed previousLpTokenId, uint256 nextAllocPoint);
215	 event LpIdToFutureSet(uint256 _lpTokenId, address futureAddress);
216	 event Harvest(address indexed user, uint256 indexed lpTokenId, uint256 amount);
217	 function initialize( address _apw, address _lpToken, uint256 _apwPerBlock, uint256 _startBlock ) external initializer {
218	 require(_apw != address(0), "MasterChef: Invalid APW address provided");
219	 require(_lpToken != address(0), "MasterChef: Invalid LPToken address provided");
220	 require(_apwPerBlock > 0, "MasterChef: !apwPerBlock-0");
221	 apw = IERC20Upgradeable(_apw);
222	 lpToken = ILPToken(_lpToken);
223	 apwPerBlock = _apwPerBlock;
224	 startBlock = _startBlock;
225	 totalAllocPoint = 0;
226	 _status = _NOT_ENTERED;
227	 __Ownable_init();
228	 _registerInterface(ERC1155_ERC165);
229	 }
230	 function add( uint256 _allocPoint, uint256 _lpTokenId, IRewarder _rewarder, bool _withUpdate ) external onlyOwner {
231	 _add(_allocPoint, _lpTokenId, _rewarder, _withUpdate);
232	 }
233	 function _add( uint256 _allocPoint, uint256 _lpTokenId, IRewarder _rewarder, bool _withUpdate ) internal {
234	 uint64 ammId = lpToken.getAMMId(_lpTokenId);
235	 uint256 pairId = lpToken.getPairId(_lpTokenId);
236	 uint64 periodId = lpToken.getPeriodIndex(_lpTokenId);
237	 address ammAddress = lpToken.amms(ammId);
238	 require(ammAddress != address(0), "MasterChef: LPTokenId Invalid");
239	 require(poolToPeriodId[ammId][pairId] != periodId, "MasterChef: LP Token already added");
240	 address futureAddress = IAMM(ammAddress).getFutureAddress();
241	 uint256 lastPeriodId = IFutureVault(futureAddress).getCurrentPeriodIndex();
242	 require(periodId == lastPeriodId, "MasterChef: Invalid period ID for LP Token");
243	 lpIDToFutureAddress[_lpTokenId] = futureAddress;
244	 rewarders[_lpTokenId] = _rewarder;
245	 if (_withUpdate) {
246	 massUpdatePools();
247	 }
248	 uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock;
249	 totalAllocPoint = totalAllocPoint.add(_allocPoint);
250	 poolInfo[_lpTokenId] = PoolInfo({
251	 allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, accAPWPerShare: 0, ammId: ammId, pairId: pairId }
252	 );
253	 activePools.add(_lpTokenId);
254	 poolToPeriodId[ammId][pairId] = periodId;
255	 }
256	 function set( uint256 _lpTokenId, uint256 _allocPoint, IRewarder _rewarder, bool overwrite, bool _withUpdate ) external onlyOwner {
257	 _set(_lpTokenId, _allocPoint, _rewarder, overwrite, _withUpdate);
258	 }
259	 function _set( uint256 _lpTokenId, uint256 _allocPoint, IRewarder _rewarder, bool overwrite, bool _withUpdate ) internal validPool(_lpTokenId) {
260	 if (_withUpdate) {
261	 massUpdatePools();
262	 }
263	 totalAllocPoint = totalAllocPoint.sub(poolInfo[_lpTokenId].allocPoint).add(_allocPoint);
264	 poolInfo[_lpTokenId].allocPoint = _allocPoint;
265	 if (overwrite) {
266	 rewarders[_lpTokenId] = _rewarder;
267	 }
268	 }
269	 function pendingAPW(uint256 _lpTokenId, address _user) external view validPool(_lpTokenId) returns (uint256) {
270	 uint64 ammId = lpToken.getAMMId(_lpTokenId);
271	 uint256 pairId = lpToken.getPairId(_lpTokenId);
272	 UserInfo storage user = userInfo[ammId][pairId][_user];
273	 PoolInfo storage pool = poolInfo[_lpTokenId];
274	 uint256 accAPWPerShare = pool.accAPWPerShare;
275	 uint256 lpSupply = lpToken.balanceOf(address(this), _lpTokenId);
276	 if (block.number > pool.lastRewardBlock && lpSupply != 0 && totalAllocPoint != 0) {
277	 uint256 apwReward = (block.number.sub(pool.lastRewardBlock)).mul(apwPerBlock).mul(pool.allocPoint).div(totalAllocPoint);
278	 accAPWPerShare = accAPWPerShare.add(apwReward.mul(TOKEN_PRECISION).div(lpSupply));
279	 }
280	 return user.amount.mul(accAPWPerShare).div(TOKEN_PRECISION).sub(user.rewardDebt);
281	 }
282	 function massUpdatePools() public {
283	 uint256 length = activePools.length();
284	 for (uint256 i = 0; i < length; ++i) {
285	 updatePool(activePools.at(i));
286	 }
287	 }
288	 function updatePool(uint256 _lpTokenId) public validPool(_lpTokenId) {
289	 PoolInfo storage pool = poolInfo[_lpTokenId];
290	 if (block.number <= pool.lastRewardBlock) {
291	 return;
292	 }
293	 uint256 lpSupply = lpToken.balanceOf(address(this), _lpTokenId);
294	 if (lpSupply == 0) {
295	 pool.lastRewardBlock = block.number;
296	 return;
297	 }
298	 uint256 apwReward = totalAllocPoint == 0 ? 0 : (block.number.sub(pool.lastRewardBlock)).mul(apwPerBlock).mul(pool.allocPoint).div(totalAllocPoint);
299	 pool.accAPWPerShare = pool.accAPWPerShare.add(apwReward.mul(TOKEN_PRECISION).div(lpSupply));
300	 pool.lastRewardBlock = block.number;
301	 }
302	 function _upgradePoolRewardsIfNeeded(uint64 _ammId, uint256 _pairId) internal returns (bool) {
303	 address ammAddress = lpToken.amms(_ammId);
304	 uint256 lastPeriodId = IFutureVault(IAMM(ammAddress).getFutureAddress()).getCurrentPeriodIndex();
305	 uint256 previousPeriodId = poolToPeriodId[_ammId][_pairId];
306	 uint previousLpTokenId = IAMM(ammAddress).getLPTokenId(_ammId, previousPeriodId, _pairId);
307	 if (lastPeriodId > previousPeriodId) {
308	 _set(previousLpTokenId, 0, IRewarder(0x0), false, false);
309	 uint256 newLpTokenId = IAMM(ammAddress).getLPTokenId(_ammId, lastPeriodId, _pairId);
310	 activePools.remove(previousLpTokenId);
311	 IRewarder rewarder = rewarders[previousLpTokenId];
312	 _add(nextUpgradeAllocPoint[previousLpTokenId], newLpTokenId, rewarder, false);
313	 if (address(rewarder) != address(0x0)) rewarder.renewPool(previousLpTokenId, newLpTokenId);
314	 return true;
315	 }
316	 else {
317	 return false;
318	 }
319	 }
320	 function deposit(uint256 _lpTokenId, uint256 _amount) external validPool(_lpTokenId) nonReentrant {
321	 uint64 ammId = lpToken.getAMMId(_lpTokenId);
322	 uint256 pairId = lpToken.getPairId(_lpTokenId);
323	 _upgradePoolRewardsIfNeeded(ammId, pairId);
324	 uint256 periodOfToken = lpToken.getPeriodIndex(_lpTokenId);
325	 uint256 lastPeriodId = IFutureVault(lpIDToFutureAddress[_lpTokenId]).getCurrentPeriodIndex();
326	 require(periodOfToken == lastPeriodId, "Masterchef: Invalid period Id for Token");
327	 updatePool(_lpTokenId);
328	 PoolInfo storage pool = poolInfo[_lpTokenId];
329	 UserInfo storage user = userInfo[ammId][pairId][msg.sender];
330	 if (user.amount > 0) {
331	 uint256 lastUserLpTokenId = IAMM(lpToken.amms(ammId)).getLPTokenId(ammId, user.periodId, pairId);
332	 uint256 accAPWPerShare = (user.periodId != 0 && user.periodId < periodOfToken) ? poolInfo[lastUserLpTokenId].accAPWPerShare : pool.accAPWPerShare;
333	 uint256 pending = user.amount.mul(accAPWPerShare).div(TOKEN_PRECISION).sub(user.rewardDebt);
334	 if (pending > 0) require(safeAPWTransfer(msg.sender, pending), "Masterchef: SafeTransfer APW failed");
335	 }
336	 if (user.periodId != periodOfToken) {
337	 userLpTokensIds[msg.sender].remove(IAMM(lpToken.amms(ammId)).getLPTokenId(ammId, pairId, user.periodId));
338	 user.amount = 0;
339	 user.rewardDebt = 0;
340	 user.periodId = periodOfToken;
341	 }
342	 if (_amount > 0) lpToken.safeTransferFrom(address(msg.sender), address(this), _lpTokenId, _amount, "");
343	 user.amount = user.amount.add(_amount);
344	 userLpTokensIds[msg.sender].add(_lpTokenId);
345	 user.rewardDebt = user.amount.mul(pool.accAPWPerShare).div(TOKEN_PRECISION);
346	 IRewarder _rewarder = rewarders[_lpTokenId];
347	 if (address(_rewarder) != address(0)) {
348	 _rewarder.onAPWReward(_lpTokenId, msg.sender, msg.sender, user.amount);
349	 }
350	 emit Deposit(msg.sender, _lpTokenId, _amount);
351	 }
352	 function withdraw(uint256 _lpTokenId, uint256 _amount) external validPool(_lpTokenId) nonReentrant {
353	 PoolInfo storage pool = poolInfo[_lpTokenId];
354	 uint64 ammId = lpToken.getAMMId(_lpTokenId);
355	 uint256 pairId = lpToken.getPairId(_lpTokenId);
356	 UserInfo storage user = userInfo[ammId][pairId][msg.sender];
357	 if (totalAllocPoint != 0) updatePool(_lpTokenId);
358	 require(user.amount >= _amount, "withdraw: not good");
359	 uint256 pending = user.amount.mul(pool.accAPWPerShare).div(TOKEN_PRECISION).sub(user.rewardDebt);
360	 if (pending > 0) require(safeAPWTransfer(msg.sender, pending), "Masterchef: SafeTransfer APW failed");
361	 user.amount = user.amount.sub(_amount);
362	 if (user.amount == 0) userLpTokensIds[msg.sender].remove(_lpTokenId);
363	 user.rewardDebt = user.amount.mul(pool.accAPWPerShare).div(TOKEN_PRECISION);
364	 IRewarder _rewarder = rewarders[_lpTokenId];
365	 if (address(_rewarder) != address(0)) {
366	 _rewarder.onAPWReward(_lpTokenId, msg.sender, msg.sender, user.amount);
367	 }
368	 if (_amount > 0) lpToken.safeTransferFrom(address(this), address(msg.sender), _lpTokenId, _amount, "");
369	 emit Withdraw(msg.sender, _lpTokenId, _amount);
370	 }
371	 function harvest(uint256 _lpTokenId, address to) public nonReentrant {
372	 uint64 ammId = lpToken.getAMMId(_lpTokenId);
373	 uint256 pairId = lpToken.getPairId(_lpTokenId);
374	 UserInfo storage user = userInfo[ammId][pairId][msg.sender];
375	 require(user.amount != 0, "Masterchef: invalid lp address");
376	 uint256 accumulatedAPW = uint256(user.amount.mul(poolInfo[_lpTokenId].accAPWPerShare) / TOKEN_PRECISION);
377	 uint256 _pendingAPW = accumulatedAPW.sub(user.rewardDebt);
378	 user.rewardDebt = accumulatedAPW;
379	 if (_pendingAPW != 0) {
380	 safeAPWTransfer(to, _pendingAPW);
381	 }
382	 IRewarder _rewarder = rewarders[_lpTokenId];
383	 if (address(_rewarder) != address(0)) {
384	 _rewarder.onAPWReward(_lpTokenId, msg.sender, to, user.amount);
385	 }
386	 emit Harvest(msg.sender, _lpTokenId, _pendingAPW);
387	 }
388	 function emergencyWithdraw(uint256 _lpTokenId) external validPool(_lpTokenId) nonReentrant {
389	 uint64 ammId = lpToken.getAMMId(_lpTokenId);
390	 uint256 pairId = lpToken.getPairId(_lpTokenId);
391	 UserInfo storage user = userInfo[ammId][pairId][msg.sender];
392	 uint256 userAmount = user.amount;
393	 if (userAmount > 0) {
394	 user.amount = 0;
395	 user.rewardDebt = 0;
396	 lpToken.safeTransferFrom(address(this), address(msg.sender), _lpTokenId, userAmount, "");
397	 }
398	 IRewarder _rewarder = rewarders[_lpTokenId];
399	 if (address(_rewarder) != address(0)) {
400	 _rewarder.onAPWReward(_lpTokenId, msg.sender, msg.sender, 0);
401	 }
402	 userLpTokensIds[msg.sender].remove(_lpTokenId);
403	 emit EmergencyWithdraw(msg.sender, _lpTokenId, userAmount);
404	 }
405	 function safeAPWTransfer(address _to, uint256 _amount) internal returns (bool success) {
406	 uint256 apwBal = apw.balanceOf(address(this));
407	 uint256 transferAmount = (_amount > apwBal) ? apwBal : _amount;
408	 success = apw.transfer(_to, transferAmount);
409	 }
410	 function setAPWPerBlock(uint256 _apwPerBlock) external onlyOwner {
411	 massUpdatePools();
412	 require(_apwPerBlock > 0, "!apwPerBlock-0");
413	 apwPerBlock = _apwPerBlock;
414	 }
415	 function setlpIDToFuture(uint256 _lpTokenId, address futureAddress) external validPool(_lpTokenId) onlyOwner {
416	 lpIDToFutureAddress[_lpTokenId] = futureAddress;
417	 emit LpIdToFutureSet(_lpTokenId, futureAddress);
418	 }
419	 function withdrawAPW(address _recipient, uint256 _amount) external onlyOwner {
420	 if (_amount > 0) apw.transfer(_recipient, _amount);
421	 }
422	 function setNextUpgradeAllocPoint(uint256 _lpTokenId, uint256 _nextAllocPoint) external validPool(_lpTokenId) onlyOwner {
423	 uint64 ammId = lpToken.getAMMId(_lpTokenId);
424	 uint256 pairId = lpToken.getPairId(_lpTokenId);
425	 uint256 periodId = lpToken.getPeriodIndex(_lpTokenId);
426	 require(periodId == poolToPeriodId[ammId][pairId], "Masterchef: pool already upgraded");
427	 nextUpgradeAllocPoint[_lpTokenId] = _nextAllocPoint;
428	 emit NextAllocPointSet(_lpTokenId, _nextAllocPoint);
429	 }
430	 function isRegisteredPoolId(uint256 _poolId) external view returns (bool) {
431	 return activePools.contains(_poolId);
432	 }
433	 function poolIdsLength() external view returns (uint256) {
434	 return activePools.length();
435	 }
436	 function poolIdAt(uint256 _id) external view returns (uint256) {
437	 return activePools.at(_id);
438	 }
439	 function getUserLpTokenIdList(address _user) external view returns (uint256[] memory) {
440	 uint256 length = userLpTokensIds[_user].length();
441	 uint256[] memory _userLpTokenIds = new uint256[](length);
442	 for (uint256 i = 0; i < length; i++) {
443	 _userLpTokenIds[i] = userLpTokensIds[_user].at(i);
444	 }
445	 return _userLpTokenIds;
446	 }
447	 }
448	 pragma solidity >=0.6.0 <0.8.0;
449	 library SafeERC20Upgradeable {
450	 using SafeMathUpgradeable for uint256;
451	 using AddressUpgradeable for address;
452	 function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {
453	 _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
454	 }
455	 function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {
456	 _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
457	 }
458	 function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {
459	 require((value == 0) || (token.allowance(address(this), spender) == 0), "SafeERC20: approve from non-zero to non-zero allowance" );
460	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
461	 }
462	 function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {
463	 uint256 newAllowance = token.allowance(address(this), spender).add(value);
464	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
465	 }
466	 function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {
467	 uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
468	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
469	 }
470	 function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {
471	 bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
472	 if (returndata.length > 0) {
473	 require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
474	 }
475	 }
476	 }
477	 pragma solidity >=0.6.0 <0.8.0;
478	 library EnumerableSetUpgradeable {
479	 struct Set {
480	 bytes32[] _values;
481	 mapping (bytes32 => uint256) _indexes;
482	 }
483	 function _add(Set storage set, bytes32 value) private returns (bool) {
484	 if (!_contains(set, value)) {
485	 set._values.push(value);
486	 set._indexes[value] = set._values.length;
487	 return true;
488	 }
489	 else {
490	 return false;
491	 }
492	 }
493	 function _remove(Set storage set, bytes32 value) private returns (bool) {
494	 uint256 valueIndex = set._indexes[value];
495	 if (valueIndex != 0) {
496	 uint256 toDeleteIndex = valueIndex - 1;
497	 uint256 lastIndex = set._values.length - 1;
498	 bytes32 lastvalue = set._values[lastIndex];
499	 set._values[toDeleteIndex] = lastvalue;
500	 set._indexes[lastvalue] = toDeleteIndex + 1;
501	 set._values.pop();
502	 delete set._indexes[value];
503	 return true;
504	 }
505	 else {
506	 return false;
507	 }
508	 }
509	 function _contains(Set storage set, bytes32 value) private view returns (bool) {
510	 return set._indexes[value] != 0;
511	 }
512	 function _length(Set storage set) private view returns (uint256) {
513	 return set._values.length;
514	 }
515	 function _at(Set storage set, uint256 index) private view returns (bytes32) {
516	 require(set._values.length > index, "EnumerableSet: index out of bounds");
517	 return set._values[index];
518	 }
519	 struct Bytes32Set {
520	 Set _inner;
521	 }
522	 function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {
523	 return _add(set._inner, value);
524	 }
525	 function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {
526	 return _remove(set._inner, value);
527	 }
528	 function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {
529	 return _contains(set._inner, value);
530	 }
531	 function length(Bytes32Set storage set) internal view returns (uint256) {
532	 return _length(set._inner);
533	 }
534	 function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {
535	 return _at(set._inner, index);
536	 }
537	 struct AddressSet {
538	 Set _inner;
539	 }
540	 function add(AddressSet storage set, address value) internal returns (bool) {
541	 return _add(set._inner, bytes32(uint256(uint160(value))));
542	 }
543	 function remove(AddressSet storage set, address value) internal returns (bool) {
544	 return _remove(set._inner, bytes32(uint256(uint160(value))));
545	 }
546	 function contains(AddressSet storage set, address value) internal view returns (bool) {
547	 return _contains(set._inner, bytes32(uint256(uint160(value))));
548	 }
549	 function length(AddressSet storage set) internal view returns (uint256) {
550	 return _length(set._inner);
551	 }
552	 function at(AddressSet storage set, uint256 index) internal view returns (address) {
553	 return address(uint160(uint256(_at(set._inner, index))));
554	 }
555	 struct UintSet {
556	 Set _inner;
557	 }
558	 function add(UintSet storage set, uint256 value) internal returns (bool) {
559	 return _add(set._inner, bytes32(value));
560	 }
561	 function remove(UintSet storage set, uint256 value) internal returns (bool) {
562	 return _remove(set._inner, bytes32(value));
563	 }
564	 function contains(UintSet storage set, uint256 value) internal view returns (bool) {
565	 return _contains(set._inner, bytes32(value));
566	 }
567	 function length(UintSet storage set) internal view returns (uint256) {
568	 return _length(set._inner);
569	 }
570	 function at(UintSet storage set, uint256 index) internal view returns (uint256) {
571	 return uint256(_at(set._inner, index));
572	 }
573	 }
574	 pragma solidity >=0.6.0 <0.8.0;
575	 library SafeMathUpgradeable {
576	 function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
577	 uint256 c = a + b;
578	 if (c < a) return (false, 0);
579	 return (true, c);
580	 }
581	 function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
582	 if (b > a) return (false, 0);
583	 return (true, a - b);
584	 }
585	 function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
586	 if (a == 0) return (true, 0);
587	 uint256 c = a * b;
588	 if (c / a != b) return (false, 0);
589	 return (true, c);
590	 }
591	 function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
592	 if (b == 0) return (false, 0);
593	 return (true, a / b);
594	 }
595	 function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
596	 if (b == 0) return (false, 0);
597	 return (true, a % b);
598	 }
599	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
600	 uint256 c = a + b;
601	 require(c >= a, "SafeMath: addition overflow");
602	 return c;
603	 }
604	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
605	 require(b <= a, "SafeMath: subtraction overflow");
606	 return a - b;
607	 }
608	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
609	 if (a == 0) return 0;
610	 uint256 c = a * b;
611	 require(c / a == b, "SafeMath: multiplication overflow");
612	 return c;
613	 }
614	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
615	 require(b > 0, "SafeMath: division by zero");
616	 return a / b;
617	 }
618	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
619	 require(b > 0, "SafeMath: modulo by zero");
620	 return a % b;
621	 }
622	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
623	 require(b <= a, errorMessage);
624	 return a - b;
625	 }
626	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
627	 require(b > 0, errorMessage);
628	 return a / b;
629	 }
630	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
631	 require(b > 0, errorMessage);
632	 return a % b;
633	 }
634	 }
635	 pragma solidity 0.7.6;
636	 interface IAMM {
637	 struct Pair {
638	 address tokenAddress;
639	 uint256[2] weights;
640	 uint256[2] balances;
641	 bool liquidityIsInitialized;
642	 }
643	 function finalize() external;
644	 function switchPeriod() external;
645	 function togglePauseAmm() external;
646	 function withdrawExpiredToken(address _user, uint256 _lpTokenId) external;
647	 function getExpiredTokensInfo(address _user, uint256 _lpTokenId) external view returns ( uint256, uint256, uint256 );
648	 function swapExactAmountIn( uint256 _pairID, uint256 _tokenIn, uint256 _tokenAmountIn, uint256 _tokenOut, uint256 _minAmountOut, address _to ) external returns (uint256 tokenAmountOut, uint256 spotPriceAfter);
649	 function swapExactAmountOut( uint256 _pairID, uint256 _tokenIn, uint256 _maxAmountIn, uint256 _tokenOut, uint256 _tokenAmountOut, address _to ) external returns (uint256 tokenAmountIn, uint256 spotPriceAfter);
650	 function createLiquidity(uint256 _pairID, uint256[2] memory _tokenAmounts) external;
651	 function addLiquidity( uint256 _pairID, uint256 _poolAmountOut, uint256[2] memory _maxAmountsIn ) external;
652	 function removeLiquidity( uint256 _pairID, uint256 _poolAmountIn, uint256[2] memory _minAmountsOut ) external;
653	 function joinSwapExternAmountIn( uint256 _pairID, uint256 _tokenIn, uint256 _tokenAmountIn, uint256 _minPoolAmountOut ) external returns (uint256 poolAmountOut);
654	 function joinSwapPoolAmountOut( uint256 _pairID, uint256 _tokenIn, uint256 _poolAmountOut, uint256 _maxAmountIn ) external returns (uint256 tokenAmountIn);
655	 function exitSwapPoolAmountIn( uint256 _pairID, uint256 _tokenOut, uint256 _poolAmountIn, uint256 _minAmountOut ) external returns (uint256 tokenAmountOut);
656	 function exitSwapExternAmountOut( uint256 _pairID, uint256 _tokenOut, uint256 _tokenAmountOut, uint256 _maxPoolAmountIn ) external returns (uint256 poolAmountIn);
657	 function setSwappingFees(uint256 _swapFee) external;
658	 function calcOutAndSpotGivenIn( uint256 _pairID, uint256 _tokenIn, uint256 _tokenAmountIn, uint256 _tokenOut, uint256 _minAmountOut ) external view returns (uint256 tokenAmountOut, uint256 spotPriceAfter);
659	 function calcInAndSpotGivenOut( uint256 _pairID, uint256 _tokenIn, uint256 _maxAmountIn, uint256 _tokenOut, uint256 _tokenAmountOut ) external view returns (uint256 tokenAmountIn, uint256 spotPriceAfter);
660	 function getSpotPrice( uint256 _pairID, uint256 _tokenIn, uint256 _tokenOut ) external view returns (uint256);
661	 function getFutureAddress() external view returns (address);
662	 function getPTAddress() external view returns (address);
663	 function getUnderlyingOfIBTAddress() external view returns (address);
664	 function getFYTAddress() external view returns (address);
665	 function getPTWeightInPair() external view returns (uint256);
666	 function getPairWithID(uint256 _pairID) external view returns (Pair memory);
667	 function getLPTokenId( uint256 _ammId, uint256 _periodIndex, uint256 _pairID ) external pure returns (uint256);
668	 function ammId() external returns (uint64);
669	 }
670	 pragma solidity ^0.7.6;
671	 interface ILPToken is IERC1155 {
672	 function amms(uint64 _ammId) external view returns (address);
673	 function getAMMId(uint256 _id) external pure returns (uint64);
674	 function getPeriodIndex(uint256 _id) external pure returns (uint64);
675	 function getPairId(uint256 _id) external pure returns (uint32);
676	 }
677	 pragma solidity 0.7.6;
678	 interface IFutureVault {
679	 event NewPeriodStarted(uint256 _newPeriodIndex);
680	 event FutureWalletSet(address _futureWallet);
681	 event RegistrySet(IRegistry _registry);
682	 event FundsDeposited(address _user, uint256 _amount);
683	 event FundsWithdrawn(address _user, uint256 _amount);
684	 event PTSet(IPT _pt);
685	 event LiquidityTransfersPaused();
686	 event LiquidityTransfersResumed();
687	 event DelegationCreated(address _delegator, address _receiver, uint256 _amount);
688	 event DelegationRemoved(address _delegator, address _receiver, uint256 _amount);
689	 function PERIOD_DURATION() external view returns (uint256);
690	 function PLATFORM_NAME() external view returns (string memory);
691	 function startNewPeriod() external;
692	 function updateUserState(address _user) external;
693	 function claimFYT(address _user, uint256 _amount) external;
694	 function deposit(address _user, uint256 _amount) external;
695	 function withdraw(address _user, uint256 _amount) external;
696	 function createFYTDelegationTo( address _delegator, address _receiver, uint256 _amount ) external;
697	 function withdrawFYTDelegationFrom( address _delegator, address _receiver, uint256 _amount ) external;
698	 function getTotalDelegated(address _delegator) external view returns (uint256 totalDelegated);
699	 function getNextPeriodIndex() external view returns (uint256);
700	 function getCurrentPeriodIndex() external view returns (uint256);
701	 function getClaimablePT(address _user) external view returns (uint256);
702	 function getUserEarlyUnlockablePremium(address _user) external view returns (uint256 premiumLocked, uint256 amountRequired);
703	 function getUnlockableFunds(address _user) external view returns (uint256);
704	 function getClaimableFYTForPeriod(address _user, uint256 _periodIndex) external view returns (uint256);
705	 function getUnrealisedYieldPerPT() external view returns (uint256);
706	 function getPTPerAmountDeposited(uint256 _amount) external view returns (uint256);
707	 function getPremiumPerUnderlyingDeposited(uint256 _amount) external view returns (uint256);
708	 function getTotalUnderlyingDeposited() external view returns (uint256);
709	 function getYieldOfPeriod(uint256 _periodID) external view returns (uint256);
710	 function getControllerAddress() external view returns (address);
711	 function getFutureWalletAddress() external view returns (address);
712	 function getIBTAddress() external view returns (address);
713	 function getPTAddress() external view returns (address);
714	 function getFYTofPeriod(uint256 _periodIndex) external view returns (address);
715	 function isTerminated() external view returns (bool);
716	 function getPerformanceFeeFactor() external view returns (uint256);
717	 function harvestRewards() external;
718	 function redeemAllVaultRewards() external;
719	 function redeemVaultRewards(address _rewardToken) external;
720	 function addRewardsToken(address _token) external;
721	 function isRewardToken(address _token) external view returns (bool);
722	 function getRewardTokenAt(uint256 _index) external view returns (address);
723	 function getRewardTokensCount() external view returns (uint256);
724	 function getRewardsRecipient() external view returns (address);
725	 function setRewardRecipient(address _recipient) external;
726	 function setFutureWallet(IFutureWallet _futureWallet) external;
727	 function setRegistry(IRegistry _registry) external;
728	 function pauseLiquidityTransfers() external;
729	 function resumeLiquidityTransfers() external;
730	 function convertIBTToUnderlying(uint256 _amount) external view returns (uint256);
731	 function convertUnderlyingtoIBT(uint256 _amount) external view returns (uint256);
732	 }
733	 pragma solidity 0.7.6;
734	 interface IRewarder {
735	 function onAPWReward( uint256 pid, address user, address recipient, uint256 apwAmount ) external;
736	 function pendingTokens(uint256 pid, address user) external view returns (IERC20[] memory, uint256[] memory);
737	 function renewPool(uint256 _oldPid, uint256 _newPid) external;
738	 }
739	 pragma solidity >=0.6.2 <0.8.0;
740	 library AddressUpgradeable {
741	 function isContract(address account) internal view returns (bool) {
742	 uint256 size;
743	 assembly {
744	 size := extcodesize(account) }
745	 return size > 0;
746	 }
747	 function sendValue(address payable recipient, uint256 amount) internal {
748	 require(address(this).balance >= amount, "Address: insufficient balance");
749	 (bool success, ) = recipient.call{
750	 value: amount }
751	 ("");
752	 require(success, "Address: unable to send value, recipient may have reverted");
753	 }
754	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
755	 return functionCall(target, data, "Address: low-level call failed");
756	 }
757	 function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
758	 return functionCallWithValue(target, data, 0, errorMessage);
759	 }
760	 function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
761	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
762	 }
763	 function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
764	 require(address(this).balance >= value, "Address: insufficient balance for call");
765	 require(isContract(target), "Address: call to non-contract");
766	 (bool success, bytes memory returndata) = target.call{
767	 value: value }
768	 (data);
769	 return _verifyCallResult(success, returndata, errorMessage);
770	 }
771	 function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
772	 return functionStaticCall(target, data, "Address: low-level static call failed");
773	 }
774	 function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
775	 require(isContract(target), "Address: static call to non-contract");
776	 (bool success, bytes memory returndata) = target.staticcall(data);
777	 return _verifyCallResult(success, returndata, errorMessage);
778	 }
779	 function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
780	 if (success) {
781	 return returndata;
782	 }
783	 else {
784	 if (returndata.length > 0) {
785	 assembly {
786	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
787	 }
788	 else {
789	 revert(errorMessage);
790	 }
791	 }
792	 }
793	 }
794	 pragma solidity 0.7.6;
795	 interface IPT is IERC20 {
796	 function burn(uint256 amount) external;
797	 function mint(address to, uint256 amount) external;
798	 function burnFrom(address account, uint256 amount) external;
799	 function pause() external;
800	 function unpause() external;
801	 function recordedBalanceOf(address account) external view returns (uint256);
802	 function balanceOf(address account) external view override returns (uint256);
803	 function futureVault() external view returns (address);
804	 }
805	 pragma solidity 0.7.6;
806	 interface IRegistry {
807	 function initialize(address _admin) external;
808	 function setTreasury(address _newTreasury) external;
809	 function setController(address _newController) external;
810	 function setAPW(address _newAPW) external;
811	 function setProxyFactory(address _proxyFactory) external;
812	 function setPTLogic(address _PTLogic) external;
813	 function setFYTLogic(address _FYTLogic) external;
814	 function setMathsUtils(address _mathsUtils) external;
815	 function setNamingUtils(address _namingUtils) external;
816	 function getControllerAddress() external view returns (address);
817	 function getTreasuryAddress() external view returns (address);
818	 function getTokensFactoryAddress() external view returns (address);
819	 function getDAOAddress() external returns (address);
820	 function getAPWAddress() external view returns (address);
821	 function getAMMFactoryAddress() external view returns (address);
822	 function getTokenFactoryAddress() external view returns (address);
823	 function getProxyFactoryAddress() external view returns (address);
824	 function getPTLogicAddress() external view returns (address);
825	 function getFYTLogicAddress() external view returns (address);
826	 function getAMMLogicAddress() external view returns (address);
827	 function getAMMLPTokenLogicAddress() external view returns (address);
828	 function getMathsUtils() external view returns (address);
829	 function getNamingUtils() external view returns (address);
830	 function addFuture(address _future) external;
831	 function removeFuture(address _future) external;
832	 function isRegisteredFuture(address _future) external view returns (bool);
833	 function isRegisteredAMM(address _ammAddress) external view returns (bool);
834	 function getFutureAt(uint256 _index) external view returns (address);
835	 function futureCount() external view returns (uint256);
836	 }
837	 pragma solidity 0.7.6;
838	 interface IFutureWallet {
839	 function initialize(address _futureAddress, address _adminAddress) external;
840	 function registerExpiredFuture(uint256 _amount) external;
841	 function redeemYield(uint256 _periodIndex) external;
842	 function getRedeemableYield(uint256 _periodIndex, address _tokenHolder) external view returns (uint256);
843	 function getFutureAddress() external view returns (address);
844	 function getIBTAddress() external view returns (address);
845	 }
