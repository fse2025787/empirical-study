row number 
1	      pragma solidity ^0.5.0;
2	 contract ReentrancyGuard {
3	 bool private _notEntered;
4	 constructor () internal {
5	 _notEntered = true;
6	 }
7	 modifier nonReentrant() {
8	 require(_notEntered, "ReentrancyGuard: reentrant call");
9	 _notEntered = false;
10	 _;
11	 _notEntered = true;
12	 }
13	 }
14	 pragma solidity ^0.5.0;
15	 contract MasterAware {
16	 INXMMaster public master;
17	 modifier onlyMember {
18	 require(master.isMember(msg.sender), "Caller is not a member");
19	 _;
20	 }
21	 modifier onlyInternal {
22	 require(master.isInternal(msg.sender), "Caller is not an internal contract");
23	 _;
24	 }
25	 modifier onlyMaster {
26	 if (address(master) != address(0)) {
27	 require(address(master) == msg.sender, "Not master");
28	 }
29	 _;
30	 }
31	 modifier onlyGovernance {
32	 require( master.checkIsAuthToGoverned(msg.sender), "Caller is not authorized to govern" );
33	 _;
34	 }
35	 modifier whenPaused {
36	 require(master.isPause(), "System is not paused");
37	 _;
38	 }
39	 modifier whenNotPaused {
40	 require(!master.isPause(), "System is paused");
41	 _;
42	 }
43	 function changeDependentContractAddress() external;
44	 function changeMasterAddress(address masterAddress) public onlyMaster {
45	 master = INXMMaster(masterAddress);
46	 }
47	 }
48	 pragma solidity >=0.5.0;
49	 interface IPool {
50	 function transferAssetToSwapOperator(address asset, uint amount) external;
51	 function getAssetDetails(address _asset) external view returns ( uint112 min, uint112 max, uint32 lastAssetSwapTime, uint maxSlippageRatio );
52	 function setAssetDataLastSwapTime(address asset, uint32 lastSwapTime) external;
53	 function minPoolEth() external returns (uint);
54	 }
55	 pragma solidity ^0.5.0;
56	 interface OZIERC20 {
57	 function transfer(address to, uint256 value) external returns (bool);
58	 function approve(address spender, uint256 value) external returns (bool);
59	 function transferFrom(address from, address to, uint256 value) external returns (bool);
60	 function totalSupply() external view returns (uint256);
61	 function balanceOf(address who) external view returns (uint256);
62	 function allowance(address owner, address spender) external view returns (uint256);
63	 event Transfer( address indexed from, address indexed to, uint256 value );
64	 event Approval( address indexed owner, address indexed spender, uint256 value );
65	 }
66	 pragma solidity ^0.5.0;
67	 contract Iupgradable {
68	 INXMMaster public ms;
69	 address public nxMasterAddress;
70	 modifier onlyInternal {
71	 require(ms.isInternal(msg.sender));
72	 _;
73	 }
74	 modifier isMemberAndcheckPause {
75	 require(ms.isPause() == false && ms.isMember(msg.sender) == true);
76	 _;
77	 }
78	 modifier onlyOwner {
79	 require(ms.isOwner(msg.sender));
80	 _;
81	 }
82	 modifier checkPause {
83	 require(ms.isPause() == false);
84	 _;
85	 }
86	 modifier isMember {
87	 require(ms.isMember(msg.sender), "Not member");
88	 _;
89	 }
90	 function changeDependentContractAddress() public;
91	 function changeMasterAddress(address _masterAddress) public {
92	 if (address(ms) != address(0)) {
93	 require(address(ms) == msg.sender, "Not master");
94	 }
95	 ms = INXMMaster(_masterAddress);
96	 nxMasterAddress = _masterAddress;
97	 }
98	 }
99	 pragma solidity ^0.5.0;
100	 contract LockHandler {
101	 mapping(address => bytes32[]) public lockReason;
102	 struct LockToken {
103	 uint256 amount;
104	 uint256 validity;
105	 bool claimed;
106	 }
107	 mapping(address => mapping(bytes32 => LockToken)) public locked;
108	 }
109	 , address , uint , uint16 , CoverType , bytes calldata data ) external view returns (uint coverPrice) {
110	 this;
111	 ( coverPrice, , , , , , ) = abi.decode(data, (uint, uint, uint, uint, uint8, bytes32, bytes32));
112	 }
113	 function buyCover ( address contractAddress, address coverAsset, uint sumAssured, uint16 coverPeriod, CoverType coverType, bytes calldata data ) external payable onlyMember whenNotPaused returns (uint) {
114	 require(coverType == CoverType.SIGNED_QUOTE_CONTRACT_COVER, "Gateway: Unsupported cover type");
115	 require(sumAssured % 10 ** assetDecimals(coverAsset) == 0, "Gateway: Only whole unit sumAssured supported");
116	 {
117	 ( uint[] memory coverDetails, uint8 _v, bytes32 _r, bytes32 _s ) = convertToLegacyQuote(sumAssured, data, coverAsset);
118	 {
119	 uint premiumAmount = coverDetails[1];
120	 if (coverAsset == ETH) {
121	 require(msg.value == premiumAmount, "Gateway: ETH amount does not match premium");
122	 (bool ok, ) = address(pool).call.value(premiumAmount)("");
123	 require(ok, "Gateway: Transfer to Pool failed");
124	 }
125	 else {
126	 IERC20 token = IERC20(coverAsset);
127	 token.safeTransferFrom(msg.sender, address(pool), premiumAmount);
128	 }
129	 }
130	 quotation.createCover( msg.sender, contractAddress, getCurrencyFromAssetAddress(coverAsset), coverDetails, coverPeriod, _v, _r, _s );
131	 }
132	 uint coverId = quotationData.getCoverLength().sub(1);
133	 emit CoverBought(coverId, msg.sender, contractAddress, coverAsset, sumAssured, coverPeriod, coverType, data);
134	 return coverId;
135	 }
136	 function submitClaim(uint coverId, bytes calldata data) external returns (uint) {
137	 claims.submitClaimForMember(coverId, msg.sender);
138	 uint claimId = claimsData.actualClaimLength() - 1;
139	 emit ClaimSubmitted(claimId, coverId, msg.sender, data);
140	 return claimId;
141	 }
142	 function claimTokens(uint coverId, uint incidentId, uint coveredTokenAmount, address coveredToken) external returns (uint claimId, uint payoutAmount, address payoutToken) {
143	 IERC20 token = IERC20(coveredToken);
144	 token.safeTransferFrom(msg.sender, address(this), coveredTokenAmount);
145	 token.approve(address(incidents), coveredTokenAmount);
146	 (claimId, payoutAmount, payoutToken) = incidents.redeemPayoutForMember(coverId, incidentId, coveredTokenAmount, msg.sender);
147	 }
148	 function getClaimCoverId(uint claimId) public view returns (uint) {
149	 (, uint coverId) = claimsData.getClaimCoverId(claimId);
150	 return coverId;
151	 }
152	 function getPayoutOutcome(uint claimId) external view returns (ClaimStatus status, uint amountPaid, address coverAsset) {
153	 (, uint coverId) = claimsData.getClaimCoverId(claimId);
154	 (, uint internalClaimStatus) = claimsData.getClaimStatusNumber(claimId);
155	 coverAsset = getCurrencyAssetAddress(quotationData.getCurrencyOfCover(coverId));
156	 if (internalClaimStatus == 14) {
157	 (,address productId) = quotationData.getscAddressOfCover(coverId);
158	 address coveredTokenAddress = incidents.coveredToken(productId);
159	 if (coveredTokenAddress != address(0)) {
160	 amountPaid = incidents.claimPayout(claimId);
161	 }
162	 else {
163	 amountPaid = quotationData.getCoverSumAssured(coverId).mul(10 ** assetDecimals(coverAsset));
164	 }
165	 }
166	 else {
167	 amountPaid = 0;
168	 }
169	 if (internalClaimStatus == 6 || internalClaimStatus == 9 || internalClaimStatus == 11) {
170	 status = ClaimStatus.REJECTED;
171	 }
172	 else if (internalClaimStatus == 13 || internalClaimStatus == 14) {
173	 status = ClaimStatus.ACCEPTED;
174	 }
175	 else {
176	 status = ClaimStatus.IN_PROGRESS;
177	 }
178	 }
179	 function getCover(uint coverId) public view returns ( uint8 status, uint sumAssured, uint16 coverPeriod, uint validUntil, address contractAddress, address coverAsset, uint premiumInNXM, address memberAddress ) {
180	 bytes4 currency;
181	 (, memberAddress, contractAddress, currency, , premiumInNXM) = quotationData.getCoverDetailsByCoverID1(coverId);
182	 (, status, sumAssured, coverPeriod, validUntil) = quotationData.getCoverDetailsByCoverID2(coverId);
183	 coverAsset = getCurrencyAssetAddress(currency);
184	 sumAssured = sumAssured.mul(10 ** assetDecimals(coverAsset));
185	 }
186	 function switchMembership(address newAddress) external {
187	 memberRoles.switchMembershipOf(msg.sender, newAddress);
188	 nxmToken.transferFrom(msg.sender, newAddress, nxmToken.balanceOf(msg.sender));
189	 }
190	 function executeCoverAction(uint , uint8 , bytes calldata ) external payable returns (bytes memory, uint) {
191	 revert("Gateway: Unsupported action");
192	 }
193	 function convertToLegacyQuote(uint sumAssured, bytes memory data, address asset) internal view returns (uint[] memory coverDetails, uint8, bytes32, bytes32) {
194	 ( uint coverPrice, uint coverPriceNXM, uint expiresAt, uint generatedAt, uint8 v, bytes32 r, bytes32 s ) = abi.decode(data, (uint, uint, uint, uint, uint8, bytes32, bytes32));
195	 coverDetails = new uint[](5);
196	 coverDetails[0] = sumAssured.div(10 ** assetDecimals(asset));
197	 coverDetails[1] = coverPrice;
198	 coverDetails[2] = coverPriceNXM;
199	 coverDetails[3] = expiresAt;
200	 coverDetails[4] = generatedAt;
201	 return (coverDetails, v, r, s);
202	 }
203	 function assetDecimals(address asset) public view returns (uint) {
204	 return asset == ETH ? 18 : IERC20Detailed(asset).decimals();
205	 }
206	 function getCurrencyFromAssetAddress(address asset) public view returns (bytes4) {
207	 if (asset == ETH) {
208	 return "ETH";
209	 }
210	 if (asset == DAI) {
211	 return "DAI";
212	 }
213	 revert("Gateway: unknown asset");
214	 }
215	 function getCurrencyAssetAddress(bytes4 currency) public view returns (address) {
216	 if (currency == "ETH") {
217	 return ETH;
218	 }
219	 if (currency == "DAI") {
220	 return DAI;
221	 }
222	 revert("Gateway: unknown currency");
223	 }
224	 }
225	 address[] public assets;
226	 mapping(address => AssetData) public assetData;
227	 Quotation public quotation;
228	 NXMToken public nxmToken;
229	 TokenController public tokenController;
230	 MCR public mcr;
231	 address public swapController;
232	 uint public minPoolEth;
233	 PriceFeedOracle public priceFeedOracle;
234	 address public swapOperator;
235	 address constant public ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
236	 uint public constant MCR_RATIO_DECIMALS = 4;
237	 uint public constant MAX_MCR_RATIO = 40000;
238	 uint public constant MAX_BUY_SELL_MCR_ETH_FRACTION = 500;
239	 uint internal constant CONSTANT_C = 5800000;
240	 uint internal constant CONSTANT_A = 1028 * 1e13;
241	 uint internal constant TOKEN_EXPONENT = 4;
242	 event Payout(address indexed to, address indexed asset, uint amount);
243	 event NXMSold (address indexed member, uint nxmIn, uint ethOut);
244	 event NXMBought (address indexed member, uint ethIn, uint nxmOut);
245	 event Swapped(address indexed fromAsset, address indexed toAsset, uint amountIn, uint amountOut);
246	 modifier onlySwapOperator {
247	 require(msg.sender == swapOperator, "Pool: not swapOperator");
248	 _;
249	 }
250	 constructor ( address[] memory _assets, uint112[] memory _minAmounts, uint112[] memory _maxAmounts, uint[] memory _maxSlippageRatios, address _master, address _priceOracle, address _swapOperator ) public {
251	 require(_assets.length == _minAmounts.length, "Pool: length mismatch");
252	 require(_assets.length == _maxAmounts.length, "Pool: length mismatch");
253	 require(_assets.length == _maxSlippageRatios.length, "Pool: length mismatch");
254	 for (uint i = 0; i < _assets.length; i++) {
255	 address asset = _assets[i];
256	 require(asset != address(0), "Pool: asset is zero address");
257	 require(_maxAmounts[i] >= _minAmounts[i], "Pool: max < min");
258	 require(_maxSlippageRatios[i] <= 1 ether, "Pool: max < min");
259	 assets.push(asset);
260	 assetData[asset].minAmount = _minAmounts[i];
261	 assetData[asset].maxAmount = _maxAmounts[i];
262	 assetData[asset].maxSlippageRatio = _maxSlippageRatios[i];
263	 }
264	 master = INXMMaster(_master);
265	 priceFeedOracle = PriceFeedOracle(_priceOracle);
266	 swapOperator = _swapOperator;
267	 }
268	 function() external payable {
269	 }
270	 function sendEther() external payable {
271	 }
272	 function getPoolValueInEth() public view returns (uint) {
273	 uint total = address(this).balance;
274	 for (uint i = 0; i < assets.length; i++) {
275	 address assetAddress = assets[i];
276	 IERC20 token = IERC20(assetAddress);
277	 uint rate = priceFeedOracle.getAssetToEthRate(assetAddress);
278	 require(rate > 0, "Pool: zero rate");
279	 uint assetBalance = token.balanceOf(address(this));
280	 uint assetValue = assetBalance.mul(rate).div(1e18);
281	 total = total.add(assetValue);
282	 }
283	 return total;
284	 }
285	 function getAssets() external view returns (address[] memory) {
286	 return assets;
287	 }
288	 function getAssetDetails(address _asset) external view returns ( uint112 min, uint112 max, uint32 lastAssetSwapTime, uint maxSlippageRatio ) {
289	 AssetData memory data = assetData[_asset];
290	 return (data.minAmount, data.maxAmount, data.lastSwapTime, data.maxSlippageRatio);
291	 }
292	 function addAsset( address _asset, uint112 _min, uint112 _max, uint _maxSlippageRatio ) external onlyGovernance {
293	 require(_asset != address(0), "Pool: asset is zero address");
294	 require(_max >= _min, "Pool: max < min");
295	 require(_maxSlippageRatio <= 1 ether, "Pool: max slippage ratio > 1");
296	 for (uint i = 0; i < assets.length; i++) {
297	 require(_asset != assets[i], "Pool: asset exists");
298	 }
299	 assets.push(_asset);
300	 assetData[_asset] = AssetData(_min, _max, 0, _maxSlippageRatio);
301	 }
302	 function removeAsset(address _asset) external onlyGovernance {
303	 for (uint i = 0; i < assets.length; i++) {
304	 if (_asset != assets[i]) {
305	 continue;
306	 }
307	 delete assetData[_asset];
308	 assets[i] = assets[assets.length - 1];
309	 assets.pop();
310	 return;
311	 }
312	 revert("Pool: asset not found");
313	 }
314	 function setAssetDetails( address _asset, uint112 _min, uint112 _max, uint _maxSlippageRatio ) external onlyGovernance {
315	 require(_min <= _max, "Pool: min > max");
316	 require(_maxSlippageRatio <= 1 ether, "Pool: max slippage ratio > 1");
317	 for (uint i = 0; i < assets.length; i++) {
318	 if (_asset != assets[i]) {
319	 continue;
320	 }
321	 assetData[_asset].minAmount = _min;
322	 assetData[_asset].maxAmount = _max;
323	 assetData[_asset].maxSlippageRatio = _maxSlippageRatio;
324	 return;
325	 }
326	 revert("Pool: asset not found");
327	 }
328	 function sendClaimPayout ( address asset, address payable payoutAddress, uint amount ) external onlyInternal nonReentrant returns (bool success) {
329	 bool ok;
330	 if (asset == ETH) {
331	 (ok, ) = payoutAddress.call.value(amount)("");
332	 }
333	 else {
334	 ok = _safeTokenTransfer(asset, payoutAddress, amount);
335	 }
336	 if (ok) {
337	 emit Payout(payoutAddress, asset, amount);
338	 }
339	 return ok;
340	 }
341	 function _safeTokenTransfer ( address tokenAddress, address to, uint256 value ) internal returns (bool) {
342	 if (!tokenAddress.isContract()) {
343	 return false;
344	 }
345	 IERC20 token = IERC20(tokenAddress);
346	 bytes memory data = abi.encodeWithSelector(token.transfer.selector, to, value);
347	 (bool success, bytes memory returndata) = tokenAddress.call(data);
348	 if (!success) {
349	 return false;
350	 }
351	 if (returndata.length == 0) {
352	 return true;
353	 }
354	 return abi.decode(returndata, (bool));
355	 }
356	 function transferAsset( address asset, address payable destination, uint amount ) external onlyGovernance nonReentrant {
357	 require(assetData[asset].maxAmount == 0, "Pool: max not zero");
358	 require(destination != address(0), "Pool: dest zero");
359	 IERC20 token = IERC20(asset);
360	 uint balance = token.balanceOf(address(this));
361	 uint transferableAmount = amount > balance ? balance : amount;
362	 token.safeTransfer(destination, transferableAmount);
363	 }
364	 function upgradeCapitalPool(address payable newPoolAddress) external onlyMaster nonReentrant {
365	 uint ethBalance = address(this).balance;
366	 (bool ok, ) = newPoolAddress.call.value(ethBalance)("");
367	 require(ok, "Pool: transfer failed");
368	 for (uint i = 0; i < assets.length; i++) {
369	 IERC20 token = IERC20(assets[i]);
370	 uint tokenBalance = token.balanceOf(address(this));
371	 token.safeTransfer(newPoolAddress, tokenBalance);
372	 }
373	 }
374	 function changeDependentContractAddress() public {
375	 nxmToken = NXMToken(master.tokenAddress());
376	 tokenController = TokenController(master.getLatestAddress("TC"));
377	 quotation = Quotation(master.getLatestAddress("QT"));
378	 mcr = MCR(master.getLatestAddress("MC"));
379	 }
380	 function makeCoverBegin( address smartCAdd, bytes4 coverCurr, uint[] memory coverDetails, uint16 coverPeriod, uint8 _v, bytes32 _r, bytes32 _s ) public payable onlyMember whenNotPaused {
381	 require(coverCurr == "ETH", "Pool: Unexpected asset type");
382	 require(msg.value == coverDetails[1], "Pool: ETH amount does not match premium");
383	 quotation.verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);
384	 }
385	 function makeCoverUsingCA( address smartCAdd, bytes4 coverCurr, uint[] memory coverDetails, uint16 coverPeriod, uint8 _v, bytes32 _r, bytes32 _s ) public onlyMember whenNotPaused {
386	 require(coverCurr != "ETH", "Pool: Unexpected asset type");
387	 quotation.verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);
388	 }
389	 function transferAssetFrom (address asset, address from, uint amount) public onlyInternal whenNotPaused {
390	 IERC20 token = IERC20(asset);
391	 token.safeTransferFrom(from, address(this), amount);
392	 }
393	 function transferAssetToSwapOperator (address asset, uint amount) public onlySwapOperator nonReentrant whenNotPaused {
394	 if (asset == ETH) {
395	 (bool ok, ) = swapOperator.call.value(amount)("");
396	 require(ok, "Pool: Eth transfer failed");
397	 return;
398	 }
399	 IERC20 token = IERC20(asset);
400	 token.safeTransfer(swapOperator, amount);
401	 }
402	 function setAssetDataLastSwapTime(address asset, uint32 lastSwapTime) public onlySwapOperator whenNotPaused {
403	 assetData[asset].lastSwapTime = lastSwapTime;
404	 }
405	 function sellNXMTokens(uint _amount) public onlyMember whenNotPaused returns (bool success) {
406	 sellNXM(_amount, 0);
407	 return true;
408	 }
409	 function getWei(uint amount) external view returns (uint weiToPay) {
410	 return getEthForNXM(amount);
411	 }
412	 function buyNXM(uint minTokensOut) public payable onlyMember whenNotPaused {
413	 uint ethIn = msg.value;
414	 require(ethIn > 0, "Pool: ethIn > 0");
415	 uint totalAssetValue = getPoolValueInEth().sub(ethIn);
416	 uint mcrEth = mcr.getMCR();
417	 uint mcrRatio = calculateMCRRatio(totalAssetValue, mcrEth);
418	 require(mcrRatio <= MAX_MCR_RATIO, "Pool: Cannot purchase if MCR% > 400%");
419	 uint tokensOut = calculateNXMForEth(ethIn, totalAssetValue, mcrEth);
420	 require(tokensOut >= minTokensOut, "Pool: tokensOut is less than minTokensOut");
421	 tokenController.mint(msg.sender, tokensOut);
422	 mcr.updateMCRInternal(totalAssetValue.add(ethIn), false);
423	 emit NXMBought(msg.sender, ethIn, tokensOut);
424	 }
425	 function sellNXM(uint tokenAmount, uint minEthOut) public onlyMember nonReentrant whenNotPaused {
426	 require(nxmToken.balanceOf(msg.sender) >= tokenAmount, "Pool: Not enough balance");
427	 require(nxmToken.isLockedForMV(msg.sender) <= now, "Pool: NXM tokens are locked for voting");
428	 uint currentTotalAssetValue = getPoolValueInEth();
429	 uint mcrEth = mcr.getMCR();
430	 uint ethOut = calculateEthForNXM(tokenAmount, currentTotalAssetValue, mcrEth);
431	 require(currentTotalAssetValue.sub(ethOut) >= mcrEth, "Pool: MCR% cannot fall below 100%");
432	 require(ethOut >= minEthOut, "Pool: ethOut < minEthOut");
433	 tokenController.burnFrom(msg.sender, tokenAmount);
434	 (bool ok, ) = msg.sender.call.value(ethOut)("");
435	 require(ok, "Pool: Sell transfer failed");
436	 mcr.updateMCRInternal(currentTotalAssetValue.sub(ethOut), false);
437	 emit NXMSold(msg.sender, tokenAmount, ethOut);
438	 }
439	 function getNXMForEth( uint ethAmount ) public view returns (uint) {
440	 uint totalAssetValue = getPoolValueInEth();
441	 uint mcrEth = mcr.getMCR();
442	 return calculateNXMForEth(ethAmount, totalAssetValue, mcrEth);
443	 }
444	 function calculateNXMForEth( uint ethAmount, uint currentTotalAssetValue, uint mcrEth ) public pure returns (uint) {
445	 require( ethAmount <= mcrEth.mul(MAX_BUY_SELL_MCR_ETH_FRACTION).div(10 ** MCR_RATIO_DECIMALS), "Pool: Purchases worth higher than 5% of MCReth are not allowed" );
446	 if (currentTotalAssetValue == 0 || mcrEth.div(currentTotalAssetValue) > 1e12) {
447	 uint tokenPrice = CONSTANT_A;
448	 return ethAmount.mul(1e18).div(tokenPrice);
449	 }
450	 uint point0 = calculateIntegralAtPoint(currentTotalAssetValue, mcrEth);
451	 uint nextTotalAssetValue = currentTotalAssetValue.add(ethAmount);
452	 uint point1 = calculateIntegralAtPoint(nextTotalAssetValue, mcrEth);
453	 uint adjustedTokenAmount = point0.sub(point1);
454	 uint adjustedTokenPrice = ethAmount.mul(1e18).div(adjustedTokenAmount);
455	 uint tokenPrice = adjustedTokenPrice.add(CONSTANT_A);
456	 return ethAmount.mul(1e18).div(tokenPrice);
457	 }
458	 function calculateIntegralAtPoint( uint assetValue, uint mcrEth ) internal pure returns (uint) {
459	 return CONSTANT_C .mul(1e18) .div(3) .mul(mcrEth).div(assetValue) .mul(mcrEth).div(assetValue) .mul(mcrEth).div(assetValue);
460	 }
461	 function getEthForNXM(uint nxmAmount) public view returns (uint ethAmount) {
462	 uint currentTotalAssetValue = getPoolValueInEth();
463	 uint mcrEth = mcr.getMCR();
464	 return calculateEthForNXM(nxmAmount, currentTotalAssetValue, mcrEth);
465	 }
466	 function calculateEthForNXM( uint nxmAmount, uint currentTotalAssetValue, uint mcrEth ) public pure returns (uint) {
467	 uint spotPrice0 = calculateTokenSpotPrice(currentTotalAssetValue, mcrEth);
468	 uint spotEthAmount = nxmAmount.mul(spotPrice0).div(1e18);
469	 uint totalValuePostSpotPriceSell = currentTotalAssetValue.sub(spotEthAmount);
470	 uint spotPrice1 = calculateTokenSpotPrice(totalValuePostSpotPriceSell, mcrEth);
471	 uint averagePriceWithSpread = spotPrice0.add(spotPrice1).div(2).mul(975).div(1000);
472	 uint finalPrice = averagePriceWithSpread < spotPrice1 ? averagePriceWithSpread : spotPrice1;
473	 uint ethAmount = finalPrice.mul(nxmAmount).div(1e18);
474	 require( ethAmount <= mcrEth.mul(MAX_BUY_SELL_MCR_ETH_FRACTION).div(10 ** MCR_RATIO_DECIMALS), "Pool: Sales worth more than 5% of MCReth are not allowed" );
475	 return ethAmount;
476	 }
477	 function calculateMCRRatio(uint totalAssetValue, uint mcrEth) public pure returns (uint) {
478	 return totalAssetValue.mul(10 ** MCR_RATIO_DECIMALS).div(mcrEth);
479	 }
480	 function calculateTokenSpotPrice(uint totalAssetValue, uint mcrEth) public pure returns (uint tokenPrice) {
481	 uint mcrRatio = calculateMCRRatio(totalAssetValue, mcrEth);
482	 uint precisionDecimals = 10 ** TOKEN_EXPONENT.mul(MCR_RATIO_DECIMALS);
483	 return mcrEth .mul(mcrRatio ** TOKEN_EXPONENT) .div(CONSTANT_C) .div(precisionDecimals) .add(CONSTANT_A);
484	 }
485	 function getTokenPrice(address asset) public view returns (uint tokenPrice) {
486	 uint totalAssetValue = getPoolValueInEth();
487	 uint mcrEth = mcr.getMCR();
488	 uint tokenSpotPriceEth = calculateTokenSpotPrice(totalAssetValue, mcrEth);
489	 return priceFeedOracle.getAssetForEth(asset, tokenSpotPriceEth);
490	 }
491	 function getMCRRatio() public view returns (uint) {
492	 uint totalAssetValue = getPoolValueInEth();
493	 uint mcrEth = mcr.getMCR();
494	 return calculateMCRRatio(totalAssetValue, mcrEth);
495	 }
496	 function updateUintParameters(bytes8 code, uint value) external onlyGovernance {
497	 if (code == "MIN_ETH") {
498	 minPoolEth = value;
499	 return;
500	 }
501	 revert("Pool: unknown parameter");
502	 }
503	 function updateAddressParameters(bytes8 code, address value) external onlyGovernance {
504	 if (code == "SWP_OP") {
505	 swapOperator = value;
506	 return;
507	 }
508	 if (code == "PRC_FEED") {
509	 priceFeedOracle = PriceFeedOracle(value);
510	 return;
511	 }
512	 revert("Pool: unknown parameter");
513	 }
514	 }
515	 function swapABMember( address _newABAddress, address _removeAB ) external checkRoleAuthority(uint(Role.AdvisoryBoard)) {
516	 _updateRole(_newABAddress, uint(Role.AdvisoryBoard), true);
517	 _updateRole(_removeAB, uint(Role.AdvisoryBoard), false);
518	 }
519	 function swapOwner( address _newOwnerAddress ) external {
520	 require(msg.sender == address(ms));
521	 _updateRole(ms.owner(), uint(Role.Owner), false);
522	 _updateRole(_newOwnerAddress, uint(Role.Owner), true);
523	 }
524	 function addInitialABMembers(address[] calldata abArray) external onlyOwner {
525	 require(ms.masterInitialized());
526	 require(maxABCount >= SafeMath.add(numberOfMembers(uint(Role.AdvisoryBoard)), abArray.length) );
527	 for (uint i = 0; i < abArray.length; i++) {
528	 require(checkRole(abArray[i], uint(MemberRoles.Role.Member)));
529	 _updateRole(abArray[i], uint(Role.AdvisoryBoard), true);
530	 }
531	 }
532	 function changeMaxABCount(uint _val) external onlyInternal {
533	 maxABCount = _val;
534	 }
535	 function changeDependentContractAddress() public {
536	 td = TokenData(ms.getLatestAddress("TD"));
537	 cr = ClaimsReward(ms.getLatestAddress("CR"));
538	 qd = QuotationData(ms.getLatestAddress("QD"));
539	 gv = Governance(ms.getLatestAddress("GV"));
540	 tf = TokenFunctions(ms.getLatestAddress("TF"));
541	 tk = NXMToken(ms.tokenAddress());
542	 tc = TokenController(ms.getLatestAddress("TC"));
543	 }
544	 function changeMasterAddress(address _masterAddress) public {
545	 if (masterAddress != address(0)) {
546	 require(masterAddress == msg.sender);
547	 }
548	 masterAddress = _masterAddress;
549	 ms = INXMMaster(_masterAddress);
550	 nxMasterAddress = _masterAddress;
551	 }
552	 function memberRolesInitiate(address _firstAB, address memberAuthority) public {
553	 require(!constructorCheck);
554	 _addInitialMemberRoles(_firstAB, memberAuthority);
555	 constructorCheck = true;
556	 }
557	 function addRole( bytes32 _roleName, string memory _roleDescription, address _authorized ) public onlyAuthorizedToGovern {
558	 _addRole(_roleName, _roleDescription, _authorized);
559	 }
560	 function updateRole( address _memberAddress, uint _roleId, bool _active ) public checkRoleAuthority(_roleId) {
561	 _updateRole(_memberAddress, _roleId, _active);
562	 }
563	 function addMembersBeforeLaunch(address[] memory userArray, uint[] memory tokens) public onlyOwner {
564	 require(!launched);
565	 for (uint i = 0; i < userArray.length; i++) {
566	 require(!ms.isMember(userArray[i]));
567	 tc.addToWhitelist(userArray[i]);
568	 _updateRole(userArray[i], uint(Role.Member), true);
569	 tc.mint(userArray[i], tokens[i]);
570	 }
571	 launched = true;
572	 launchedOn = now;
573	 }
574	 function payJoiningFee(address _userAddress) public payable {
575	 require(_userAddress != address(0));
576	 require(!ms.isPause(), "Emergency Pause Applied");
577	 if (msg.sender == address(ms.getLatestAddress("QT"))) {
578	 require(td.walletAddress() != address(0), "No walletAddress present");
579	 tc.addToWhitelist(_userAddress);
580	 _updateRole(_userAddress, uint(Role.Member), true);
581	 td.walletAddress().transfer(msg.value);
582	 }
583	 else {
584	 require(!qd.refundEligible(_userAddress));
585	 require(!ms.isMember(_userAddress));
586	 require(msg.value == td.joiningFee());
587	 qd.setRefundEligible(_userAddress, true);
588	 }
589	 }
590	 function kycVerdict(address payable _userAddress, bool verdict) public {
591	 require(msg.sender == qd.kycAuthAddress());
592	 require(!ms.isPause());
593	 require(_userAddress != address(0));
594	 require(!ms.isMember(_userAddress));
595	 require(qd.refundEligible(_userAddress));
596	 if (verdict) {
597	 qd.setRefundEligible(_userAddress, false);
598	 uint fee = td.joiningFee();
599	 tc.addToWhitelist(_userAddress);
600	 _updateRole(_userAddress, uint(Role.Member), true);
601	 td.walletAddress().transfer(fee);
602	 }
603	 else {
604	 qd.setRefundEligible(_userAddress, false);
605	 _userAddress.transfer(td.joiningFee());
606	 }
607	 }
608	 function withdrawMembership() public {
609	 require(!ms.isPause() && ms.isMember(msg.sender));
610	 require(tc.totalLockedBalance(msg.sender) == 0);
611	 require(!tf.isLockedForMemberVote(msg.sender));
612	 require(cr.getAllPendingRewardOfUser(msg.sender) == 0);
613	 gv.removeDelegation(msg.sender);
614	 tc.burnFrom(msg.sender, tk.balanceOf(msg.sender));
615	 _updateRole(msg.sender, uint(Role.Member), false);
616	 tc.removeFromWhitelist(msg.sender);
617	 if (claimPayoutAddress[msg.sender] != address(0)) {
618	 claimPayoutAddress[msg.sender] = address(0);
619	 emit ClaimPayoutAddressSet(msg.sender, address(0));
620	 }
621	 }
622	 function switchMembership(address newAddress) external {
623	 _switchMembership(msg.sender, newAddress);
624	 tk.transferFrom(msg.sender, newAddress, tk.balanceOf(msg.sender));
625	 }
626	 function switchMembershipOf(address member, address newAddress) external onlyInternal {
627	 _switchMembership(member, newAddress);
628	 }
629	 function _switchMembership(address member, address newAddress) internal {
630	 require(!ms.isPause() && ms.isMember(member) && !ms.isMember(newAddress));
631	 require(tc.totalLockedBalance(member) == 0);
632	 require(!tf.isLockedForMemberVote(member));
633	 require(cr.getAllPendingRewardOfUser(member) == 0);
634	 gv.removeDelegation(member);
635	 tc.addToWhitelist(newAddress);
636	 _updateRole(newAddress, uint(Role.Member), true);
637	 _updateRole(member, uint(Role.Member), false);
638	 tc.removeFromWhitelist(member);
639	 address payable previousPayoutAddress = claimPayoutAddress[member];
640	 if (previousPayoutAddress != address(0)) {
641	 address payable storedAddress = previousPayoutAddress == newAddress ? address(0) : previousPayoutAddress;
642	 claimPayoutAddress[member] = address(0);
643	 claimPayoutAddress[newAddress] = storedAddress;
644	 emit ClaimPayoutAddressSet(member, address(0));
645	 if (storedAddress != address(0)) {
646	 emit ClaimPayoutAddressSet(newAddress, storedAddress);
647	 }
648	 }
649	 emit switchedMembership(member, newAddress, now);
650	 }
651	 function getClaimPayoutAddress(address payable _member) external view returns (address payable) {
652	 address payable payoutAddress = claimPayoutAddress[_member];
653	 return payoutAddress != address(0) ? payoutAddress : _member;
654	 }
655	 function setClaimPayoutAddress(address payable _address) external {
656	 require(!ms.isPause(), "system is paused");
657	 require(ms.isMember(msg.sender), "sender is not a member");
658	 require(_address != msg.sender, "should be different than the member address");
659	 claimPayoutAddress[msg.sender] = _address;
660	 emit ClaimPayoutAddressSet(msg.sender, _address);
661	 }
662	 function totalRoles() public view returns (uint256) {
663	 return memberRoleData.length;
664	 }
665	 function changeAuthorized(uint _roleId, address _newAuthorized) public checkRoleAuthority(_roleId) {
666	 memberRoleData[_roleId].authorized = _newAuthorized;
667	 }
668	 function members(uint _memberRoleId) public view returns (uint, address[] memory memberArray) {
669	 uint length = memberRoleData[_memberRoleId].memberAddress.length;
670	 uint i;
671	 uint j = 0;
672	 memberArray = new address[](memberRoleData[_memberRoleId].memberCounter);
673	 for (i = 0; i < length; i++) {
674	 address member = memberRoleData[_memberRoleId].memberAddress[i];
675	 if (memberRoleData[_memberRoleId].memberActive[member] && !_checkMemberInArray(member, memberArray)) {
676	 memberArray[j] = member;
677	 j++;
678	 }
679	 }
680	 return (_memberRoleId, memberArray);
681	 }
682	 function numberOfMembers(uint _memberRoleId) public view returns (uint) {
683	 return memberRoleData[_memberRoleId].memberCounter;
684	 }
685	 function authorized(uint _memberRoleId) public view returns (address) {
686	 return memberRoleData[_memberRoleId].authorized;
687	 }
688	 function roles(address _memberAddress) public view returns (uint[] memory) {
689	 uint length = memberRoleData.length;
690	 uint[] memory assignedRoles = new uint[](length);
691	 uint counter = 0;
692	 for (uint i = 1; i < length; i++) {
693	 if (memberRoleData[i].memberActive[_memberAddress]) {
694	 assignedRoles[counter] = i;
695	 counter++;
696	 }
697	 }
698	 return assignedRoles;
699	 }
700	 function checkRole(address _memberAddress, uint _roleId) public view returns (bool) {
701	 if (_roleId == uint(Role.UnAssigned)) return true;
702	 else if (memberRoleData[_roleId].memberActive[_memberAddress]) return true;
703	 else return false;
704	 }
705	 function getMemberLengthForAllRoles() public view returns (uint[] memory totalMembers) {
706	 totalMembers = new uint[](memberRoleData.length);
707	 for (uint i = 0; i < memberRoleData.length; i++) {
708	 totalMembers[i] = numberOfMembers(i);
709	 }
710	 }
711	 function _updateRole(address _memberAddress, uint _roleId, bool _active) internal {
712	 if (_active) {
713	 require(!memberRoleData[_roleId].memberActive[_memberAddress]);
714	 memberRoleData[_roleId].memberCounter = SafeMath.add(memberRoleData[_roleId].memberCounter, 1);
715	 memberRoleData[_roleId].memberActive[_memberAddress] = true;
716	 memberRoleData[_roleId].memberAddress.push(_memberAddress);
717	 }
718	 else {
719	 require(memberRoleData[_roleId].memberActive[_memberAddress]);
720	 memberRoleData[_roleId].memberCounter = SafeMath.sub(memberRoleData[_roleId].memberCounter, 1);
721	 delete memberRoleData[_roleId].memberActive[_memberAddress];
722	 }
723	 }
724	 function _addRole( bytes32 _roleName, string memory _roleDescription, address _authorized ) internal {
725	 emit MemberRole(memberRoleData.length, _roleName, _roleDescription);
726	 memberRoleData.push(MemberRoleDetails(0, new address[](0), _authorized));
727	 }
728	 function _checkMemberInArray( address _memberAddress, address[] memory memberArray ) internal pure returns (bool memberExists) {
729	 uint i;
730	 for (i = 0; i < memberArray.length; i++) {
731	 if (memberArray[i] == _memberAddress) {
732	 memberExists = true;
733	 break;
734	 }
735	 }
736	 }
737	 function _addInitialMemberRoles(address _firstAB, address memberAuthority) internal {
738	 maxABCount = 5;
739	 _addRole("Unassigned", "Unassigned", address(0));
740	 _addRole( "Advisory Board", "Selected few members that are deeply entrusted by the dApp. An ideal advisory board should be a mix of skills of domain, governance, research, technology, consulting etc to improve the performance of the dApp.", address(0) );
741	 _addRole( "Member", "Represents all users of Mutual.", memberAuthority );
742	 _addRole( "Owner", "Represents Owner of Mutual.", address(0) );
743	 _updateRole(_firstAB, uint(Role.Owner), true);
744	 launchedOn = 0;
745	 }
746	 function memberAtIndex(uint _memberRoleId, uint index) external view returns (address, bool) {
747	 address memberAddress = memberRoleData[_memberRoleId].memberAddress[index];
748	 return (memberAddress, memberRoleData[_memberRoleId].memberActive[memberAddress]);
749	 }
750	 function membersLength(uint _memberRoleId) external view returns (uint) {
751	 return memberRoleData[_memberRoleId].memberAddress.length;
752	 }
753	 }
754	 function changeDependentContractAddress() public {
755	 token = NXMToken(ms.tokenAddress());
756	 pooledStaking = IPooledStaking(ms.getLatestAddress("PS"));
757	 }
758	 function markCoverClaimOpen(uint coverId) external onlyInternal {
759	 CoverInfo storage info = coverInfo[coverId];
760	 uint16 claimCount;
761	 bool hasOpenClaim;
762	 bool hasAcceptedClaim;
763	 (claimCount, hasOpenClaim, hasAcceptedClaim) = (info.claimCount, info.hasOpenClaim, info.hasAcceptedClaim);
764	 claimCount = claimCount + 1;
765	 require(claimCount <= 2, "TokenController: Max claim count exceeded");
766	 require(hasOpenClaim == false, "TokenController: Cover already has an open claim");
767	 require(hasAcceptedClaim == false, "TokenController: Cover already has accepted claims");
768	 (info.claimCount, info.hasOpenClaim) = (claimCount, true);
769	 }
770	 function markCoverClaimClosed(uint coverId, bool isAccepted) external onlyInternal {
771	 CoverInfo storage info = coverInfo[coverId];
772	 require(info.hasOpenClaim == true, "TokenController: Cover claim is not marked as open");
773	 (info.hasOpenClaim, info.hasAcceptedClaim) = (false, isAccepted);
774	 }
775	 function changeOperator(address _newOperator) public onlyInternal {
776	 token.changeOperator(_newOperator);
777	 }
778	 function operatorTransfer(address _from, address _to, uint _value) external onlyInternal returns (bool) {
779	 require(msg.sender == address(pooledStaking), "TokenController: Call is only allowed from PooledStaking address");
780	 token.operatorTransfer(_from, _value);
781	 token.transfer(_to, _value);
782	 return true;
783	 }
784	 function lockClaimAssessmentTokens(uint256 _amount, uint256 _time) external checkPause {
785	 require(minCALockTime <= _time, "TokenController: Must lock for minimum time");
786	 require(_time <= 180 days, "TokenController: Tokens can be locked for 180 days maximum");
787	 _lock(msg.sender, "CLA", _amount, _time);
788	 }
789	 function lockOf(address _of, bytes32 _reason, uint256 _amount, uint256 _time) public onlyInternal returns (bool) {
790	 _lock(_of, _reason, _amount, _time);
791	 return true;
792	 }
793	 function mintCoverNote( address _of, bytes32 _reason, uint256 _amount, uint256 _time ) external onlyInternal {
794	 require(_tokensLocked(_of, _reason) == 0, "TokenController: An amount of tokens is already locked");
795	 require(_amount != 0, "TokenController: Amount shouldn't be zero");
796	 if (locked[_of][_reason].amount == 0) {
797	 lockReason[_of].push(_reason);
798	 }
799	 token.mint(address(this), _amount);
800	 uint256 lockedUntil = now.add(_time);
801	 locked[_of][_reason] = LockToken(_amount, lockedUntil, false);
802	 emit Locked(_of, _reason, _amount, lockedUntil);
803	 }
804	 function extendClaimAssessmentLock(uint256 _time) external checkPause {
805	 uint256 validity = getLockedTokensValidity(msg.sender, "CLA");
806	 require(validity.add(_time).sub(block.timestamp) <= 180 days, "TokenController: Tokens can be locked for 180 days maximum");
807	 _extendLock(msg.sender, "CLA", _time);
808	 }
809	 function extendLockOf(address _of, bytes32 _reason, uint256 _time) public onlyInternal returns (bool) {
810	 _extendLock(_of, _reason, _time);
811	 return true;
812	 }
813	 function increaseClaimAssessmentLock(uint256 _amount) external checkPause {
814	 require(_tokensLocked(msg.sender, "CLA") > 0, "TokenController: No tokens locked");
815	 token.operatorTransfer(msg.sender, _amount);
816	 locked[msg.sender]["CLA"].amount = locked[msg.sender]["CLA"].amount.add(_amount);
817	 emit Locked(msg.sender, "CLA", _amount, locked[msg.sender]["CLA"].validity);
818	 }
819	 function burnFrom(address _of, uint amount) public onlyInternal returns (bool) {
820	 return token.burnFrom(_of, amount);
821	 }
822	 function burnLockedTokens(address _of, bytes32 _reason, uint256 _amount) public onlyInternal {
823	 _burnLockedTokens(_of, _reason, _amount);
824	 }
825	 function reduceLock(address _of, bytes32 _reason, uint256 _time) public onlyInternal {
826	 _reduceLock(_of, _reason, _time);
827	 }
828	 function releaseLockedTokens(address _of, bytes32 _reason, uint256 _amount) public onlyInternal {
829	 _releaseLockedTokens(_of, _reason, _amount);
830	 }
831	 function addToWhitelist(address _member) public onlyInternal {
832	 token.addToWhiteList(_member);
833	 }
834	 function removeFromWhitelist(address _member) public onlyInternal {
835	 token.removeFromWhiteList(_member);
836	 }
837	 function mint(address _member, uint _amount) public onlyInternal {
838	 token.mint(_member, _amount);
839	 }
840	 function lockForMemberVote(address _of, uint _days) public onlyInternal {
841	 token.lockForMemberVote(_of, _days);
842	 }
843	 function withdrawClaimAssessmentTokens(address _of) external checkPause {
844	 uint256 withdrawableTokens = _tokensUnlockable(_of, "CLA");
845	 if (withdrawableTokens > 0) {
846	 locked[_of]["CLA"].claimed = true;
847	 emit Unlocked(_of, "CLA", withdrawableTokens);
848	 token.transfer(_of, withdrawableTokens);
849	 }
850	 }
851	 function updateUintParameters(bytes8 code, uint value) external onlyGovernance {
852	 if (code == "MNCLT") {
853	 minCALockTime = value;
854	 return;
855	 }
856	 if (code == "GRACEPER") {
857	 claimSubmissionGracePeriod = value;
858	 return;
859	 }
860	 revert("TokenController: invalid param code");
861	 }
862	 function getLockReasons(address _of) external view returns (bytes32[] memory reasons) {
863	 return lockReason[_of];
864	 }
865	 function getLockedTokensValidity(address _of, bytes32 reason) public view returns (uint256 validity) {
866	 validity = locked[_of][reason].validity;
867	 }
868	 function getUnlockableTokens(address _of) public view returns (uint256 unlockableTokens) {
869	 for (uint256 i = 0; i < lockReason[_of].length; i++) {
870	 unlockableTokens = unlockableTokens.add(_tokensUnlockable(_of, lockReason[_of][i]));
871	 }
872	 }
873	 function tokensLocked(address _of, bytes32 _reason) public view returns (uint256 amount) {
874	 return _tokensLocked(_of, _reason);
875	 }
876	 function tokensLockedWithValidity(address _of, bytes32 _reason) public view returns (uint256 amount, uint256 validity) {
877	 bool claimed = locked[_of][_reason].claimed;
878	 amount = locked[_of][_reason].amount;
879	 validity = locked[_of][_reason].validity;
880	 if (claimed) {
881	 amount = 0;
882	 }
883	 }
884	 function tokensUnlockable(address _of, bytes32 _reason) public view returns (uint256 amount) {
885	 return _tokensUnlockable(_of, _reason);
886	 }
887	 function totalSupply() public view returns (uint256) {
888	 return token.totalSupply();
889	 }
890	 function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time) public view returns (uint256 amount) {
891	 return _tokensLockedAtTime(_of, _reason, _time);
892	 }
893	 function totalBalanceOf(address _of) public view returns (uint256 amount) {
894	 amount = token.balanceOf(_of);
895	 for (uint256 i = 0; i < lockReason[_of].length; i++) {
896	 amount = amount.add(_tokensLocked(_of, lockReason[_of][i]));
897	 }
898	 uint stakerReward = pooledStaking.stakerReward(_of);
899	 uint stakerDeposit = pooledStaking.stakerDeposit(_of);
900	 amount = amount.add(stakerDeposit).add(stakerReward);
901	 }
902	 function totalLockedBalance(address _of) public view returns (uint256 amount) {
903	 for (uint256 i = 0; i < lockReason[_of].length; i++) {
904	 amount = amount.add(_tokensLocked(_of, lockReason[_of][i]));
905	 }
906	 amount = amount.add(pooledStaking.stakerDeposit(_of));
907	 }
908	 function _lock(address _of, bytes32 _reason, uint256 _amount, uint256 _time) internal {
909	 require(_tokensLocked(_of, _reason) == 0, "TokenController: An amount of tokens is already locked");
910	 require(_amount != 0, "TokenController: Amount shouldn't be zero");
911	 if (locked[_of][_reason].amount == 0) {
912	 lockReason[_of].push(_reason);
913	 }
914	 token.operatorTransfer(_of, _amount);
915	 uint256 validUntil = now.add(_time);
916	 locked[_of][_reason] = LockToken(_amount, validUntil, false);
917	 emit Locked(_of, _reason, _amount, validUntil);
918	 }
919	 function _tokensLocked(address _of, bytes32 _reason) internal view returns (uint256 amount) {
920	 if (!locked[_of][_reason].claimed) {
921	 amount = locked[_of][_reason].amount;
922	 }
923	 }
924	 function _tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time) internal view returns (uint256 amount) {
925	 if (locked[_of][_reason].validity > _time) {
926	 amount = locked[_of][_reason].amount;
927	 }
928	 }
929	 function _extendLock(address _of, bytes32 _reason, uint256 _time) internal {
930	 require(_tokensLocked(_of, _reason) > 0, "TokenController: No tokens locked");
931	 emit Unlocked(_of, _reason, locked[_of][_reason].amount);
932	 locked[_of][_reason].validity = locked[_of][_reason].validity.add(_time);
933	 emit Locked(_of, _reason, locked[_of][_reason].amount, locked[_of][_reason].validity);
934	 }
935	 function _reduceLock(address _of, bytes32 _reason, uint256 _time) internal {
936	 require(_tokensLocked(_of, _reason) > 0, "TokenController: No tokens locked");
937	 emit Unlocked(_of, _reason, locked[_of][_reason].amount);
938	 locked[_of][_reason].validity = locked[_of][_reason].validity.sub(_time);
939	 emit Locked(_of, _reason, locked[_of][_reason].amount, locked[_of][_reason].validity);
940	 }
941	 function _tokensUnlockable(address _of, bytes32 _reason) internal view returns (uint256 amount) {
942	 if (locked[_of][_reason].validity <= now && !locked[_of][_reason].claimed) {
943	 amount = locked[_of][_reason].amount;
944	 }
945	 }
946	 function _burnLockedTokens(address _of, bytes32 _reason, uint256 _amount) internal {
947	 uint256 amount = _tokensLocked(_of, _reason);
948	 require(amount >= _amount, "TokenController: Amount exceedes locked tokens amount");
949	 if (amount == _amount) {
950	 locked[_of][_reason].claimed = true;
951	 }
952	 locked[_of][_reason].amount = locked[_of][_reason].amount.sub(_amount);
953	 token.burn(_amount);
954	 emit Burned(_of, _reason, _amount);
955	 }
956	 function _releaseLockedTokens(address _of, bytes32 _reason, uint256 _amount) internal {
957	 uint256 amount = _tokensLocked(_of, _reason);
958	 require(amount >= _amount, "TokenController: Amount exceedes locked tokens amount");
959	 if (amount == _amount) {
960	 locked[_of][_reason].claimed = true;
961	 }
962	 locked[_of][_reason].amount = locked[_of][_reason].amount.sub(_amount);
963	 token.transfer(_of, _amount);
964	 emit Unlocked(_of, _reason, _amount);
965	 }
966	 function withdrawCoverNote( address _of, uint[] calldata _coverIds, uint[] calldata _indexes ) external onlyInternal {
967	 uint reasonCount = lockReason[_of].length;
968	 uint lastReasonIndex = reasonCount.sub(1, "TokenController: No locked cover notes found");
969	 uint totalAmount = 0;
970	 for (uint i = _coverIds.length; i > 0; i--) {
971	 bool hasOpenClaim = coverInfo[_coverIds[i - 1]].hasOpenClaim;
972	 require(hasOpenClaim == false, "TokenController: Cannot withdraw for cover with an open claim");
973	 bytes32 _reason = keccak256(abi.encodePacked("CN", _of, _coverIds[i - 1]));
974	 uint _reasonIndex = _indexes[i - 1];
975	 require(lockReason[_of][_reasonIndex] == _reason, "TokenController: Bad reason index");
976	 uint amount = locked[_of][_reason].amount;
977	 totalAmount = totalAmount.add(amount);
978	 delete locked[_of][_reason];
979	 if (lastReasonIndex != _reasonIndex) {
980	 lockReason[_of][_reasonIndex] = lockReason[_of][lastReasonIndex];
981	 }
982	 lockReason[_of].pop();
983	 emit Unlocked(_of, _reason, amount);
984	 if (lastReasonIndex > 0) {
985	 lastReasonIndex = lastReasonIndex.sub(1, "TokenController: Reason count mismatch");
986	 }
987	 }
988	 token.transfer(_of, totalAmount);
989	 }
990	 function removeEmptyReason(address _of, bytes32 _reason, uint _index) external {
991	 _removeEmptyReason(_of, _reason, _index);
992	 }
993	 function removeMultipleEmptyReasons( address[] calldata _members, bytes32[] calldata _reasons, uint[] calldata _indexes ) external {
994	 require(_members.length == _reasons.length, "TokenController: members and reasons array lengths differ");
995	 require(_reasons.length == _indexes.length, "TokenController: reasons and indexes array lengths differ");
996	 for (uint i = _members.length; i > 0; i--) {
997	 uint idx = i - 1;
998	 _removeEmptyReason(_members[idx], _reasons[idx], _indexes[idx]);
999	 }
1000	 }
1001	 function _removeEmptyReason(address _of, bytes32 _reason, uint _index) internal {
1002	 uint lastReasonIndex = lockReason[_of].length.sub(1, "TokenController: lockReason is empty");
1003	 require(lockReason[_of][_index] == _reason, "TokenController: bad reason index");
1004	 require(locked[_of][_reason].amount == 0, "TokenController: reason amount is not zero");
1005	 if (lastReasonIndex != _index) {
1006	 lockReason[_of][_index] = lockReason[_of][lastReasonIndex];
1007	 }
1008	 lockReason[_of].pop();
1009	 }
1010	 function initialize() external {
1011	 require(claimSubmissionGracePeriod == 0, "TokenController: Already initialized");
1012	 claimSubmissionGracePeriod = 120 days;
1013	 migrate();
1014	 }
1015	 function migrate() internal {
1016	 ClaimsData cd = ClaimsData(ms.getLatestAddress("CD"));
1017	 uint totalClaims = cd.actualClaimLength() - 1;
1018	 cd.changeFinalVerdict(20, -1);
1019	 cd.setClaimStatus(20, 6);
1020	 cd.changeFinalVerdict(21, -1);
1021	 cd.setClaimStatus(21, 6);
1022	 address payable[3] memory members = [ 0x4a9fA34da6d2378c8f3B9F6b83532B169beaEDFc, 0x6b5DCDA27b5c3d88e71867D6b10b35372208361F, 0x8B6D1e5b4db5B6f9aCcc659e2b9619B0Cd90D617 ];
1023	 for (uint i = 0; i < members.length; i++) {
1024	 if (locked[members[i]]["CLA"].validity > now + 180 days) {
1025	 locked[members[i]]["CLA"].validity = now + 180 days;
1026	 }
1027	 }
1028	 for (uint i = 1; i <= totalClaims; i++) {
1029	 (, uint status) = cd.getClaimStatusNumber(i);
1030	 (, uint coverId) = cd.getClaimCoverId(i);
1031	 int8 verdict = cd.getFinalVerdict(i);
1032	 CoverInfo memory info = coverInfo[coverId];
1033	 info.claimCount = info.claimCount + 1;
1034	 info.hasAcceptedClaim = (status == 14);
1035	 info.hasOpenClaim = (verdict == 0);
1036	 coverInfo[coverId] = info;
1037	 }
1038	 }
1039	 }
1040	 mapping(address => Stake[]) public stakerStakedContracts;
1041	 mapping(address => Staker[]) public stakedContractStakers;
1042	 mapping(address => mapping(uint => StakeCommission)) public stakedContractStakeCommission;
1043	 mapping(address => uint) public lastCompletedStakeCommission;
1044	 mapping(address => uint) public stakedContractCurrentCommissionIndex;
1045	 mapping(address => uint) public stakedContractCurrentBurnIndex;
1046	 mapping(uint => CoverNote) public depositedCN;
1047	 mapping(address => uint) internal isBookedTokens;
1048	 event Commission( address indexed stakedContractAddress, address indexed stakerAddress, uint indexed scIndex, uint commissionAmount );
1049	 constructor(address payable _walletAdd) public {
1050	 walletAddress = _walletAdd;
1051	 bookTime = 12 hours;
1052	 joiningFee = 2000000000000000;
1053	 lockTokenTimeAfterCoverExp = 35 days;
1054	 scValidDays = 250;
1055	 lockCADays = 7 days;
1056	 lockMVDays = 2 days;
1057	 stakerCommissionPer = 20;
1058	 stakerMaxCommissionPer = 50;
1059	 tokenExponent = 4;
1060	 priceStep = 1000;
1061	 }
1062	 function changeWalletAddress(address payable _address) external onlyInternal {
1063	 walletAddress = _address;
1064	 }
1065	 function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val) {
1066	 codeVal = code;
1067	 if (code == "TOKEXP") {
1068	 val = tokenExponent;
1069	 }
1070	 else if (code == "TOKSTEP") {
1071	 val = priceStep;
1072	 }
1073	 else if (code == "RALOCKT") {
1074	 val = scValidDays;
1075	 }
1076	 else if (code == "RACOMM") {
1077	 val = stakerCommissionPer;
1078	 }
1079	 else if (code == "RAMAXC") {
1080	 val = stakerMaxCommissionPer;
1081	 }
1082	 else if (code == "CABOOKT") {
1083	 val = bookTime / (1 hours);
1084	 }
1085	 else if (code == "CALOCKT") {
1086	 val = lockCADays / (1 days);
1087	 }
1088	 else if (code == "MVLOCKT") {
1089	 val = lockMVDays / (1 days);
1090	 }
1091	 else if (code == "QUOLOCKT") {
1092	 val = lockTokenTimeAfterCoverExp / (1 days);
1093	 }
1094	 else if (code == "JOINFEE") {
1095	 val = joiningFee;
1096	 }
1097	 }
1098	 function changeDependentContractAddress() public {
1099	 }
1100	 function getStakerStakedContractByIndex( address _stakerAddress, uint _stakerIndex ) public view returns (address stakedContractAddress) {
1101	 stakedContractAddress = stakerStakedContracts[ _stakerAddress][_stakerIndex].stakedContractAddress;
1102	 }
1103	 function getStakerStakedBurnedByIndex( address _stakerAddress, uint _stakerIndex ) public view returns (uint burnedAmount) {
1104	 burnedAmount = stakerStakedContracts[ _stakerAddress][_stakerIndex].burnedAmount;
1105	 }
1106	 function getStakerStakedUnlockableBeforeLastBurnByIndex( address _stakerAddress, uint _stakerIndex ) public view returns (uint unlockable) {
1107	 unlockable = stakerStakedContracts[ _stakerAddress][_stakerIndex].unLockableBeforeLastBurn;
1108	 }
1109	 function getStakerStakedContractIndex( address _stakerAddress, uint _stakerIndex ) public view returns (uint scIndex) {
1110	 scIndex = stakerStakedContracts[ _stakerAddress][_stakerIndex].stakedContractIndex;
1111	 }
1112	 function getStakedContractStakerIndex( address _stakedContractAddress, uint _stakedContractIndex ) public view returns (uint sIndex) {
1113	 sIndex = stakedContractStakers[ _stakedContractAddress][_stakedContractIndex].stakerIndex;
1114	 }
1115	 function getStakerInitialStakedAmountOnContract( address _stakerAddress, uint _stakerIndex ) public view returns (uint amount) {
1116	 amount = stakerStakedContracts[ _stakerAddress][_stakerIndex].stakeAmount;
1117	 }
1118	 function getStakerStakedContractLength( address _stakerAddress ) public view returns (uint length) {
1119	 length = stakerStakedContracts[_stakerAddress].length;
1120	 }
1121	 function getStakerUnlockedStakedTokens( address _stakerAddress, uint _stakerIndex ) public view returns (uint amount) {
1122	 amount = stakerStakedContracts[ _stakerAddress][_stakerIndex].unlockedAmount;
1123	 }
1124	 function pushUnlockedStakedTokens( address _stakerAddress, uint _stakerIndex, uint _amount ) public onlyInternal {
1125	 stakerStakedContracts[_stakerAddress][ _stakerIndex].unlockedAmount = stakerStakedContracts[_stakerAddress][ _stakerIndex].unlockedAmount.add(_amount);
1126	 }
1127	 function pushBurnedTokens( address _stakerAddress, uint _stakerIndex, uint _amount ) public onlyInternal {
1128	 stakerStakedContracts[_stakerAddress][ _stakerIndex].burnedAmount = stakerStakedContracts[_stakerAddress][ _stakerIndex].burnedAmount.add(_amount);
1129	 }
1130	 function pushUnlockableBeforeLastBurnTokens( address _stakerAddress, uint _stakerIndex, uint _amount ) public onlyInternal {
1131	 stakerStakedContracts[_stakerAddress][ _stakerIndex].unLockableBeforeLastBurn = stakerStakedContracts[_stakerAddress][ _stakerIndex].unLockableBeforeLastBurn.add(_amount);
1132	 }
1133	 function setUnlockableBeforeLastBurnTokens( address _stakerAddress, uint _stakerIndex, uint _amount ) public onlyInternal {
1134	 stakerStakedContracts[_stakerAddress][ _stakerIndex].unLockableBeforeLastBurn = _amount;
1135	 }
1136	 function pushEarnedStakeCommissions( address _stakerAddress, address _stakedContractAddress, uint _stakedContractIndex, uint _commissionAmount ) public onlyInternal {
1137	 stakedContractStakeCommission[_stakedContractAddress][_stakedContractIndex]. commissionEarned = stakedContractStakeCommission[_stakedContractAddress][ _stakedContractIndex].commissionEarned.add(_commissionAmount);
1138	 emit Commission( _stakerAddress, _stakedContractAddress, _stakedContractIndex, _commissionAmount );
1139	 }
1140	 function pushRedeemedStakeCommissions( address _stakerAddress, uint _stakerIndex, uint _amount ) public onlyInternal {
1141	 uint stakedContractIndex = stakerStakedContracts[ _stakerAddress][_stakerIndex].stakedContractIndex;
1142	 address stakedContractAddress = stakerStakedContracts[ _stakerAddress][_stakerIndex].stakedContractAddress;
1143	 stakedContractStakeCommission[stakedContractAddress][stakedContractIndex]. commissionRedeemed = stakedContractStakeCommission[ stakedContractAddress][stakedContractIndex].commissionRedeemed.add(_amount);
1144	 }
1145	 function getStakerEarnedStakeCommission( address _stakerAddress, uint _stakerIndex ) public view returns (uint) {
1146	 return _getStakerEarnedStakeCommission(_stakerAddress, _stakerIndex);
1147	 }
1148	 function getStakerRedeemedStakeCommission( address _stakerAddress, uint _stakerIndex ) public view returns (uint) {
1149	 return _getStakerRedeemedStakeCommission(_stakerAddress, _stakerIndex);
1150	 }
1151	 function getStakerTotalEarnedStakeCommission( address _stakerAddress ) public view returns (uint totalCommissionEarned) {
1152	 totalCommissionEarned = 0;
1153	 for (uint i = 0; i < stakerStakedContracts[_stakerAddress].length; i++) {
1154	 totalCommissionEarned = totalCommissionEarned. add(_getStakerEarnedStakeCommission(_stakerAddress, i));
1155	 }
1156	 }
1157	 function getStakerTotalReedmedStakeCommission( address _stakerAddress ) public view returns (uint totalCommissionRedeemed) {
1158	 totalCommissionRedeemed = 0;
1159	 for (uint i = 0; i < stakerStakedContracts[_stakerAddress].length; i++) {
1160	 totalCommissionRedeemed = totalCommissionRedeemed.add( _getStakerRedeemedStakeCommission(_stakerAddress, i));
1161	 }
1162	 }
1163	 function setDepositCN(uint coverId, bool flag) public onlyInternal {
1164	 if (flag == true) {
1165	 require(!depositedCN[coverId].isDeposited, "Cover note already deposited");
1166	 }
1167	 depositedCN[coverId].isDeposited = flag;
1168	 }
1169	 function setDepositCNAmount(uint coverId, uint amount) public onlyInternal {
1170	 depositedCN[coverId].amount = amount;
1171	 }
1172	 function getStakedContractStakerByIndex( address _stakedContractAddress, uint _stakedContractIndex ) public view returns (address stakerAddress) {
1173	 stakerAddress = stakedContractStakers[ _stakedContractAddress][_stakedContractIndex].stakerAddress;
1174	 }
1175	 function getStakedContractStakersLength( address _stakedContractAddress ) public view returns (uint length) {
1176	 length = stakedContractStakers[_stakedContractAddress].length;
1177	 }
1178	 function addStake( address _stakerAddress, address _stakedContractAddress, uint _amount ) public onlyInternal returns (uint scIndex) {
1179	 scIndex = (stakedContractStakers[_stakedContractAddress].push( Staker(_stakerAddress, stakerStakedContracts[_stakerAddress].length))).sub(1);
1180	 stakerStakedContracts[_stakerAddress].push( Stake(_stakedContractAddress, scIndex, now, _amount, 0, 0, 0));
1181	 }
1182	 function bookCATokens(address _of) public onlyInternal {
1183	 require(!isCATokensBooked(_of), "Tokens already booked");
1184	 isBookedTokens[_of] = now.add(bookTime);
1185	 }
1186	 function isCATokensBooked(address _of) public view returns (bool res) {
1187	 if (now < isBookedTokens[_of]) res = true;
1188	 }
1189	 function setStakedContractCurrentCommissionIndex( address _stakedContractAddress, uint _index ) public onlyInternal {
1190	 stakedContractCurrentCommissionIndex[_stakedContractAddress] = _index;
1191	 }
1192	 function setLastCompletedStakeCommissionIndex( address _stakerAddress, uint _index ) public onlyInternal {
1193	 lastCompletedStakeCommission[_stakerAddress] = _index;
1194	 }
1195	 function setStakedContractCurrentBurnIndex( address _stakedContractAddress, uint _index ) public onlyInternal {
1196	 stakedContractCurrentBurnIndex[_stakedContractAddress] = _index;
1197	 }
1198	 function updateUintParameters(bytes8 code, uint val) public {
1199	 require(ms.checkIsAuthToGoverned(msg.sender));
1200	 if (code == "TOKEXP") {
1201	 _setTokenExponent(val);
1202	 }
1203	 else if (code == "TOKSTEP") {
1204	 _setPriceStep(val);
1205	 }
1206	 else if (code == "RALOCKT") {
1207	 _changeSCValidDays(val);
1208	 }
1209	 else if (code == "RACOMM") {
1210	 _setStakerCommissionPer(val);
1211	 }
1212	 else if (code == "RAMAXC") {
1213	 _setStakerMaxCommissionPer(val);
1214	 }
1215	 else if (code == "CABOOKT") {
1216	 _changeBookTime(val * 1 hours);
1217	 }
1218	 else if (code == "CALOCKT") {
1219	 _changelockCADays(val * 1 days);
1220	 }
1221	 else if (code == "MVLOCKT") {
1222	 _changelockMVDays(val * 1 days);
1223	 }
1224	 else if (code == "QUOLOCKT") {
1225	 _setLockTokenTimeAfterCoverExp(val * 1 days);
1226	 }
1227	 else if (code == "JOINFEE") {
1228	 _setJoiningFee(val);
1229	 }
1230	 else {
1231	 revert("Invalid param code");
1232	 }
1233	 }
1234	 function _getStakerEarnedStakeCommission( address _stakerAddress, uint _stakerIndex ) internal view returns (uint amount) {
1235	 uint _stakedContractIndex;
1236	 address _stakedContractAddress;
1237	 _stakedContractAddress = stakerStakedContracts[ _stakerAddress][_stakerIndex].stakedContractAddress;
1238	 _stakedContractIndex = stakerStakedContracts[ _stakerAddress][_stakerIndex].stakedContractIndex;
1239	 amount = stakedContractStakeCommission[ _stakedContractAddress][_stakedContractIndex].commissionEarned;
1240	 }
1241	 function _getStakerRedeemedStakeCommission( address _stakerAddress, uint _stakerIndex ) internal view returns (uint amount) {
1242	 uint _stakedContractIndex;
1243	 address _stakedContractAddress;
1244	 _stakedContractAddress = stakerStakedContracts[ _stakerAddress][_stakerIndex].stakedContractAddress;
1245	 _stakedContractIndex = stakerStakedContracts[ _stakerAddress][_stakerIndex].stakedContractIndex;
1246	 amount = stakedContractStakeCommission[ _stakedContractAddress][_stakedContractIndex].commissionRedeemed;
1247	 }
1248	 function _setStakerCommissionPer(uint _val) internal {
1249	 stakerCommissionPer = _val;
1250	 }
1251	 function _setStakerMaxCommissionPer(uint _val) internal {
1252	 stakerMaxCommissionPer = _val;
1253	 }
1254	 function _setTokenExponent(uint _val) internal {
1255	 tokenExponent = _val;
1256	 }
1257	 function _setPriceStep(uint _val) internal {
1258	 priceStep = _val;
1259	 }
1260	 function _changeSCValidDays(uint _days) internal {
1261	 scValidDays = _days;
1262	 }
1263	 function _changeBookTime(uint _time) internal {
1264	 bookTime = _time;
1265	 }
1266	 function _changelockCADays(uint _val) internal {
1267	 lockCADays = _val;
1268	 }
1269	 function _changelockMVDays(uint _val) internal {
1270	 lockMVDays = _val;
1271	 }
1272	 function _setLockTokenTimeAfterCoverExp(uint time) internal {
1273	 lockTokenTimeAfterCoverExp = time;
1274	 }
1275	 function _setJoiningFee(uint _amount) internal {
1276	 joiningFee = _amount;
1277	 }
1278	 }
1279	 function getUserAllLockedCNTokens(address _of) external view returns (uint) {
1280	 uint[] memory coverIds = qd.getAllCoversOfUser(_of);
1281	 uint total;
1282	 for (uint i = 0; i < coverIds.length; i++) {
1283	 bytes32 reason = keccak256(abi.encodePacked("CN", _of, coverIds[i]));
1284	 uint coverNote = tc.tokensLocked(_of, reason);
1285	 total = total.add(coverNote);
1286	 }
1287	 return total;
1288	 }
1289	 function changeDependentContractAddress() public {
1290	 tc = TokenController(master.getLatestAddress("TC"));
1291	 tk = NXMToken(master.tokenAddress());
1292	 qd = QuotationData(master.getLatestAddress("QD"));
1293	 }
1294	 function burnCAToken(uint claimid, uint _value, address _of) external onlyGovernance {
1295	 tc.burnLockedTokens(_of, "CLA", _value);
1296	 emit BurnCATokens(claimid, _of, _value);
1297	 }
1298	 function isLockedForMemberVote(address _of) public view returns (bool) {
1299	 return now < tk.isLockedForMV(_of);
1300	 }
1301	 }
1302	 function setKycAuthAddress(address _add) external onlyInternal {
1303	 kycAuthAddress = _add;
1304	 }
1305	 function changeAuthQuoteEngine(address _add) external onlyInternal {
1306	 authQuoteEngine = _add;
1307	 }
1308	 function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val) {
1309	 codeVal = code;
1310	 if (code == "STLP") {
1311	 val = stlp;
1312	 }
1313	 else if (code == "STL") {
1314	 val = stl;
1315	 }
1316	 else if (code == "PM") {
1317	 val = pm;
1318	 }
1319	 else if (code == "QUOMIND") {
1320	 val = minDays;
1321	 }
1322	 else if (code == "QUOTOK") {
1323	 val = tokensRetained;
1324	 }
1325	 }
1326	 function getProductDetails() external view returns ( uint _minDays, uint _pm, uint _stl, uint _stlp ) {
1327	 _minDays = minDays;
1328	 _pm = pm;
1329	 _stl = stl;
1330	 _stlp = stlp;
1331	 }
1332	 function getCoverLength() external view returns (uint len) {
1333	 return (allCovers.length);
1334	 }
1335	 function getAuthQuoteEngine() external view returns (address _add) {
1336	 _add = authQuoteEngine;
1337	 }
1338	 function getTotalSumAssured(bytes4 _curr) external view returns (uint amount) {
1339	 amount = currencyCSA[_curr];
1340	 }
1341	 function getAllCoversOfUser(address _add) external view returns (uint[] memory allCover) {
1342	 return (userCover[_add]);
1343	 }
1344	 function getUserCoverLength(address _add) external view returns (uint len) {
1345	 len = userCover[_add].length;
1346	 }
1347	 function getCoverStatusNo(uint _cid) external view returns (uint8) {
1348	 return coverStatus[_cid];
1349	 }
1350	 function getCoverPeriod(uint _cid) external view returns (uint32 cp) {
1351	 cp = allCovers[_cid].coverPeriod;
1352	 }
1353	 function getCoverSumAssured(uint _cid) external view returns (uint sa) {
1354	 sa = allCovers[_cid].sumAssured;
1355	 }
1356	 function getCurrencyOfCover(uint _cid) external view returns (bytes4 curr) {
1357	 curr = allCovers[_cid].currencyCode;
1358	 }
1359	 function getValidityOfCover(uint _cid) external view returns (uint date) {
1360	 date = allCovers[_cid].validUntil;
1361	 }
1362	 function getscAddressOfCover(uint _cid) external view returns (uint, address) {
1363	 return (_cid, allCovers[_cid].scAddress);
1364	 }
1365	 function getCoverMemberAddress(uint _cid) external view returns (address payable _add) {
1366	 _add = allCovers[_cid].memberAddress;
1367	 }
1368	 function getCoverPremiumNXM(uint _cid) external view returns (uint _premiumNXM) {
1369	 _premiumNXM = allCovers[_cid].premiumNXM;
1370	 }
1371	 function getCoverDetailsByCoverID1( uint _cid ) external view returns ( uint cid, address _memberAddress, address _scAddress, bytes4 _currencyCode, uint _sumAssured, uint premiumNXM ) {
1372	 return ( _cid, allCovers[_cid].memberAddress, allCovers[_cid].scAddress, allCovers[_cid].currencyCode, allCovers[_cid].sumAssured, allCovers[_cid].premiumNXM );
1373	 }
1374	 function getCoverDetailsByCoverID2( uint _cid ) external view returns ( uint cid, uint8 status, uint sumAssured, uint16 coverPeriod, uint validUntil ) {
1375	 return ( _cid, coverStatus[_cid], allCovers[_cid].sumAssured, allCovers[_cid].coverPeriod, allCovers[_cid].validUntil );
1376	 }
1377	 function getHoldedCoverDetailsByID1( uint _hcid ) external view returns ( uint hcid, address scAddress, bytes4 coverCurr, uint16 coverPeriod ) {
1378	 return ( _hcid, allCoverHolded[_hcid].scAddress, allCoverHolded[_hcid].coverCurr, allCoverHolded[_hcid].coverPeriod );
1379	 }
1380	 function getUserHoldedCoverLength(address _add) external view returns (uint) {
1381	 return userHoldedCover[_add].length;
1382	 }
1383	 function getUserHoldedCoverByIndex(address _add, uint index) external view returns (uint) {
1384	 return userHoldedCover[_add][index];
1385	 }
1386	 function getHoldedCoverDetailsByID2( uint _hcid ) external view returns ( uint hcid, address payable memberAddress, uint[] memory coverDetails ) {
1387	 return ( _hcid, allCoverHolded[_hcid].userAddress, allCoverHolded[_hcid].coverDetails );
1388	 }
1389	 function getTotalSumAssuredSC(address _add, bytes4 _curr) external view returns (uint amount) {
1390	 amount = currencyCSAOfSCAdd[_add][_curr];
1391	 }
1392	 function changeDependentContractAddress() public {
1393	 }
1394	 function changeCoverStatusNo(uint _cid, uint8 _stat) public onlyInternal {
1395	 coverStatus[_cid] = _stat;
1396	 emit CoverStatusEvent(_cid, _stat);
1397	 }
1398	 function updateUintParameters(bytes8 code, uint val) public {
1399	 require(ms.checkIsAuthToGoverned(msg.sender));
1400	 if (code == "STLP") {
1401	 _changeSTLP(val);
1402	 }
1403	 else if (code == "STL") {
1404	 _changeSTL(val);
1405	 }
1406	 else if (code == "PM") {
1407	 _changePM(val);
1408	 }
1409	 else if (code == "QUOMIND") {
1410	 _changeMinDays(val);
1411	 }
1412	 else if (code == "QUOTOK") {
1413	 _setTokensRetained(val);
1414	 }
1415	 else {
1416	 revert("Invalid param code");
1417	 }
1418	 }
1419	 function _changePM(uint _pm) internal {
1420	 pm = _pm;
1421	 }
1422	 function _changeSTLP(uint _stlp) internal {
1423	 stlp = _stlp;
1424	 }
1425	 function _changeSTL(uint _stl) internal {
1426	 stl = _stl;
1427	 }
1428	 function _changeMinDays(uint _days) internal {
1429	 minDays = _days;
1430	 }
1431	 function _setTokensRetained(uint val) internal {
1432	 tokensRetained = val;
1433	 }
1434	 }
1435	 , _coverOwner, productId, currency, sumAssured, ) = qd.getCoverDetailsByCoverID1(coverId);
1436	 require(coverOwner == _coverOwner, "Incidents: Not cover owner");
1437	 require(productId == incident.productId, "Incidents: Bad incident id");
1438	 }
1439	 {
1440	 uint coverPeriod = uint(qd.getCoverPeriod(coverId)).mul(1 days);
1441	 uint coverExpirationDate = qd.getValidityOfCover(coverId);
1442	 uint coverStartDate = coverExpirationDate.sub(coverPeriod);
1443	 require(coverStartDate <= incident.date, "Incidents: Cover start date is after the incident");
1444	 require(coverExpirationDate >= incident.date, "Incidents: Cover end date is before the incident");
1445	 uint gracePeriod = tokenController().claimSubmissionGracePeriod();
1446	 require(coverExpirationDate.add(gracePeriod) >= block.timestamp, "Incidents: Grace period has expired");
1447	 }
1448	 {
1449	 uint decimalPrecision = 1e18;
1450	 uint maxAmount;
1451	 uint coverAmount = sumAssured.mul(decimalPrecision);
1452	 {
1453	 uint deductiblePriceBefore = incident.priceBefore.mul(DEDUCTIBLE_RATIO).div(BASIS_PRECISION);
1454	 maxAmount = coverAmount.mul(decimalPrecision).div(deductiblePriceBefore);
1455	 require(coveredTokenAmount <= maxAmount, "Incidents: Amount exceeds sum assured");
1456	 }
1457	 payoutAmount = coveredTokenAmount.mul(coverAmount).div(maxAmount);
1458	 }
1459	 {
1460	 TokenController tc = tokenController();
1461	 tc.markCoverClaimOpen(coverId);
1462	 tc.markCoverClaimClosed(coverId, true);
1463	 ClaimsData cd = claimsData();
1464	 claimId = cd.actualClaimLength();
1465	 cd.addClaim(claimId, coverId, coverOwner, now);
1466	 cd.callClaimEvent(coverId, coverOwner, claimId, now);
1467	 cd.setClaimStatus(claimId, 14);
1468	 qd.changeCoverStatusNo(coverId, uint8(QuotationData.CoverStatus.ClaimAccepted));
1469	 claimPayout[claimId] = payoutAmount;
1470	 }
1471	 coverAsset = claimsReward().getCurrencyAssetAddress(currency);
1472	 _sendPayoutAndPushBurn( incident.productId, address(uint160(coverOwner)), coveredTokenAmount, coverAsset, payoutAmount );
1473	 qd.subFromTotalSumAssured(currency, sumAssured);
1474	 qd.subFromTotalSumAssuredSC(incident.productId, currency, sumAssured);
1475	 mcr().updateMCRInternal(pool().getPoolValueInEth(), true);
1476	 }
1477	 function pushBurns(address productId, uint maxIterations) external {
1478	 uint burnAmount = accumulatedBurn[productId];
1479	 delete accumulatedBurn[productId];
1480	 require(burnAmount > 0, "Incidents: No burns to push");
1481	 require(maxIterations >= 30, "Incidents: Pass at least 30 iterations");
1482	 IPooledStaking ps = pooledStaking();
1483	 ps.pushBurn(productId, burnAmount);
1484	 ps.processPendingActions(maxIterations);
1485	 }
1486	 function withdrawAsset(address asset, address destination, uint amount) external onlyGovernance {
1487	 IERC20 token = IERC20(asset);
1488	 uint balance = token.balanceOf(address(this));
1489	 uint transferAmount = amount > balance ? balance : amount;
1490	 token.safeTransfer(destination, transferAmount);
1491	 }
1492	 function _sendPayoutAndPushBurn( address productId, address payable coverOwner, uint coveredTokenAmount, address coverAsset, uint payoutAmount ) internal {
1493	 address _coveredToken = coveredToken[productId];
1494	 IERC20(_coveredToken).safeTransferFrom(msg.sender, address(this), coveredTokenAmount);
1495	 Pool p1 = pool();
1496	 {
1497	 address payable payoutAddress = memberRoles().getClaimPayoutAddress(coverOwner);
1498	 bool success = p1.sendClaimPayout(coverAsset, payoutAddress, payoutAmount);
1499	 require(success, "Incidents: Payout failed");
1500	 }
1501	 {
1502	 uint decimalPrecision = 1e18;
1503	 uint assetPerNxm = p1.getTokenPrice(coverAsset);
1504	 uint maxBurnAmount = payoutAmount.mul(decimalPrecision).div(assetPerNxm);
1505	 uint burnAmount = maxBurnAmount.mul(BURN_RATIO).div(BASIS_PRECISION);
1506	 accumulatedBurn[productId] = accumulatedBurn[productId].add(burnAmount);
1507	 }
1508	 }
1509	 function claimsData() internal view returns (ClaimsData) {
1510	 return ClaimsData(internalContracts[uint(ID.CD)]);
1511	 }
1512	 function claimsReward() internal view returns (ClaimsReward) {
1513	 return ClaimsReward(internalContracts[uint(ID.CR)]);
1514	 }
1515	 function quotationData() internal view returns (QuotationData) {
1516	 return QuotationData(internalContracts[uint(ID.QD)]);
1517	 }
1518	 function tokenController() internal view returns (TokenController) {
1519	 return TokenController(internalContracts[uint(ID.TC)]);
1520	 }
1521	 function memberRoles() internal view returns (MemberRoles) {
1522	 return MemberRoles(internalContracts[uint(ID.MR)]);
1523	 }
1524	 function pool() internal view returns (Pool) {
1525	 return Pool(internalContracts[uint(ID.P1)]);
1526	 }
1527	 function pooledStaking() internal view returns (IPooledStaking) {
1528	 return IPooledStaking(internalContracts[uint(ID.PS)]);
1529	 }
1530	 function mcr() internal view returns (MCR) {
1531	 return MCR(internalContracts[uint(ID.MC)]);
1532	 }
1533	 function updateUintParameters(bytes8 code, uint value) external onlyGovernance {
1534	 if (code == "BURNRATE") {
1535	 require(value <= BASIS_PRECISION, "Incidents: Burn ratio cannot exceed 10000");
1536	 BURN_RATIO = value;
1537	 return;
1538	 }
1539	 if (code == "DEDUCTIB") {
1540	 require(value <= BASIS_PRECISION, "Incidents: Deductible ratio cannot exceed 10000");
1541	 DEDUCTIBLE_RATIO = value;
1542	 return;
1543	 }
1544	 revert("Incidents: Invalid parameter");
1545	 }
1546	 function changeDependentContractAddress() external {
1547	 INXMMaster master = INXMMaster(master);
1548	 internalContracts[uint(ID.CD)] = master.getLatestAddress("CD");
1549	 internalContracts[uint(ID.CR)] = master.getLatestAddress("CR");
1550	 internalContracts[uint(ID.QD)] = master.getLatestAddress("QD");
1551	 internalContracts[uint(ID.TC)] = master.getLatestAddress("TC");
1552	 internalContracts[uint(ID.MR)] = master.getLatestAddress("MR");
1553	 internalContracts[uint(ID.P1)] = master.getLatestAddress("P1");
1554	 internalContracts[uint(ID.PS)] = master.getLatestAddress("PS");
1555	 internalContracts[uint(ID.MC)] = master.getLatestAddress("MC");
1556	 }
1557	 }
1558	 pragma solidity ^0.5.0;
1559	 library SafeMath {
1560	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
1561	 uint256 c = a + b;
1562	 require(c >= a, "SafeMath: addition overflow");
1563	 return c;
1564	 }
1565	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
1566	 return sub(a, b, "SafeMath: subtraction overflow");
1567	 }
1568	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
1569	 require(b <= a, errorMessage);
1570	 uint256 c = a - b;
1571	 return c;
1572	 }
1573	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
1574	 if (a == 0) {
1575	 return 0;
1576	 }
1577	 uint256 c = a * b;
1578	 require(c / a == b, "SafeMath: multiplication overflow");
1579	 return c;
1580	 }
1581	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
1582	 return div(a, b, "SafeMath: division by zero");
1583	 }
1584	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
1585	 require(b > 0, errorMessage);
1586	 uint256 c = a / b;
1587	 return c;
1588	 }
1589	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
1590	 return mod(a, b, "SafeMath: modulo by zero");
1591	 }
1592	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
1593	 require(b != 0, errorMessage);
1594	 return a % b;
1595	 }
1596	 }
1597	 pragma solidity ^0.5.0;
1598	 interface IERC20 {
1599	 function totalSupply() external view returns (uint256);
1600	 function balanceOf(address account) external view returns (uint256);
1601	 function transfer(address recipient, uint256 amount) external returns (bool);
1602	 function allowance(address owner, address spender) external view returns (uint256);
1603	 function approve(address spender, uint256 amount) external returns (bool);
1604	 function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
1605	 event Transfer(address indexed from, address indexed to, uint256 value);
1606	 event Approval(address indexed owner, address indexed spender, uint256 value);
1607	 }
1608	 pragma solidity ^0.5.0;
1609	 library SafeERC20 {
1610	 using SafeMath for uint256;
1611	 using Address for address;
1612	 function safeTransfer(IERC20 token, address to, uint256 value) internal {
1613	 callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
1614	 }
1615	 function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
1616	 callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
1617	 }
1618	 function safeApprove(IERC20 token, address spender, uint256 value) internal {
1619	 require((value == 0) || (token.allowance(address(this), spender) == 0), "SafeERC20: approve from non-zero to non-zero allowance" );
1620	 callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
1621	 }
1622	 function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
1623	 uint256 newAllowance = token.allowance(address(this), spender).add(value);
1624	 callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
1625	 }
1626	 function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
1627	 uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
1628	 callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
1629	 }
1630	 function callOptionalReturn(IERC20 token, bytes memory data) private {
1631	 require(address(token).isContract(), "SafeERC20: call to non-contract");
1632	 (bool success, bytes memory returndata) = address(token).call(data);
1633	 require(success, "SafeERC20: low-level call failed");
1634	 if (returndata.length > 0) {
1635	 require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
1636	 }
1637	 }
1638	 }
1639	 pragma solidity ^0.5.5;
1640	 library Address {
1641	 function isContract(address account) internal view returns (bool) {
1642	 bytes32 codehash;
1643	 bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
1644	 assembly {
1645	 codehash := extcodehash(account) }
1646	 return (codehash != accountHash && codehash != 0x0);
1647	 }
1648	 function toPayable(address account) internal pure returns (address payable) {
1649	 return address(uint160(account));
1650	 }
1651	 function sendValue(address payable recipient, uint256 amount) internal {
1652	 require(address(this).balance >= amount, "Address: insufficient balance");
1653	 (bool success, ) = recipient.call.value(amount)("");
1654	 require(success, "Address: unable to send value, recipient may have reverted");
1655	 }
1656	 }
1657	 function changeDependentContractAddress() public onlyInternal {
1658	 cr = ClaimsReward(master.getLatestAddress("CR"));
1659	 pool = Pool(master.getLatestAddress("P1"));
1660	 pooledStaking = IPooledStaking(master.getLatestAddress("PS"));
1661	 qd = QuotationData(master.getLatestAddress("QD"));
1662	 tc = TokenController(master.getLatestAddress("TC"));
1663	 td = TokenData(master.getLatestAddress("TD"));
1664	 incidents = Incidents(master.getLatestAddress("IC"));
1665	 }
1666	 function sendEther() public payable {
1667	 }
1668	 function expireCover(uint coverId) external {
1669	 uint expirationDate = qd.getValidityOfCover(coverId);
1670	 require(expirationDate < now, "Quotation: cover is not due to expire");
1671	 uint coverStatus = qd.getCoverStatusNo(coverId);
1672	 require(coverStatus != uint(QuotationData.CoverStatus.CoverExpired), "Quotation: cover already expired");
1673	 (, bool hasOpenClaim, ) = tc.coverInfo(coverId);
1674	 require(!hasOpenClaim, "Quotation: cover has an open claim");
1675	 if (coverStatus != uint(QuotationData.CoverStatus.ClaimAccepted)) {
1676	 (,, address contractAddress, bytes4 currency, uint amount,) = qd.getCoverDetailsByCoverID1(coverId);
1677	 qd.subFromTotalSumAssured(currency, amount);
1678	 qd.subFromTotalSumAssuredSC(contractAddress, currency, amount);
1679	 }
1680	 qd.changeCoverStatusNo(coverId, uint8(QuotationData.CoverStatus.CoverExpired));
1681	 }
1682	 function withdrawCoverNote(address coverOwner, uint[] calldata coverIds, uint[] calldata reasonIndexes) external {
1683	 uint gracePeriod = tc.claimSubmissionGracePeriod();
1684	 for (uint i = 0; i < coverIds.length; i++) {
1685	 uint expirationDate = qd.getValidityOfCover(coverIds[i]);
1686	 require(expirationDate.add(gracePeriod) < now, "Quotation: cannot withdraw before grace period expiration");
1687	 }
1688	 tc.withdrawCoverNote(coverOwner, coverIds, reasonIndexes);
1689	 }
1690	 function getWithdrawableCoverNoteCoverIds( address coverOwner ) public view returns ( uint[] memory expiredCoverIds, bytes32[] memory lockReasons ) {
1691	 uint[] memory coverIds = qd.getAllCoversOfUser(coverOwner);
1692	 uint[] memory expiredIdsQueue = new uint[](coverIds.length);
1693	 uint gracePeriod = tc.claimSubmissionGracePeriod();
1694	 uint expiredQueueLength = 0;
1695	 for (uint i = 0; i < coverIds.length; i++) {
1696	 uint coverExpirationDate = qd.getValidityOfCover(coverIds[i]);
1697	 uint gracePeriodExpirationDate = coverExpirationDate.add(gracePeriod);
1698	 (, bool hasOpenClaim, ) = tc.coverInfo(coverIds[i]);
1699	 if (!hasOpenClaim && gracePeriodExpirationDate < now) {
1700	 expiredIdsQueue[expiredQueueLength] = coverIds[i];
1701	 expiredQueueLength++;
1702	 }
1703	 }
1704	 expiredCoverIds = new uint[](expiredQueueLength);
1705	 lockReasons = new bytes32[](expiredQueueLength);
1706	 for (uint i = 0; i < expiredQueueLength; i++) {
1707	 expiredCoverIds[i] = expiredIdsQueue[i];
1708	 lockReasons[i] = keccak256(abi.encodePacked("CN", coverOwner, expiredIdsQueue[i]));
1709	 }
1710	 }
1711	 function getWithdrawableCoverNotesAmount(address coverOwner) external view returns (uint) {
1712	 uint withdrawableAmount;
1713	 bytes32[] memory lockReasons;
1714	 (, lockReasons) = getWithdrawableCoverNoteCoverIds(coverOwner);
1715	 for (uint i = 0; i < lockReasons.length; i++) {
1716	 uint coverNoteAmount = tc.tokensLocked(coverOwner, lockReasons[i]);
1717	 withdrawableAmount = withdrawableAmount.add(coverNoteAmount);
1718	 }
1719	 return withdrawableAmount;
1720	 }
1721	 function makeCoverUsingNXMTokens( uint[] calldata coverDetails, uint16 coverPeriod, bytes4 coverCurr, address smartCAdd, uint8 _v, bytes32 _r, bytes32 _s ) external onlyMember whenNotPaused {
1722	 tc.burnFrom(msg.sender, coverDetails[2]);
1723	 _verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s, true);
1724	 }
1725	 function verifyCoverDetails( address payable from, address scAddress, bytes4 coverCurr, uint[] memory coverDetails, uint16 coverPeriod, uint8 _v, bytes32 _r, bytes32 _s ) public onlyInternal {
1726	 _verifyCoverDetails( from, scAddress, coverCurr, coverDetails, coverPeriod, _v, _r, _s, false );
1727	 }
1728	 function verifySignature( uint[] memory coverDetails, uint16 coverPeriod, bytes4 currency, address contractAddress, uint8 _v, bytes32 _r, bytes32 _s ) public view returns (bool) {
1729	 require(contractAddress != address(0));
1730	 bytes32 hash = getOrderHash(coverDetails, coverPeriod, currency, contractAddress);
1731	 return isValidSignature(hash, _v, _r, _s);
1732	 }
1733	 function getOrderHash( uint[] memory coverDetails, uint16 coverPeriod, bytes4 currency, address contractAddress ) public view returns (bytes32) {
1734	 return keccak256( abi.encodePacked( coverDetails[0], currency, coverPeriod, contractAddress, coverDetails[1], coverDetails[2], coverDetails[3], coverDetails[4], address(this) ) );
1735	 }
1736	 function isValidSignature(bytes32 hash, uint8 v, bytes32 r, bytes32 s) public view returns (bool) {
1737	 bytes memory prefix = "\x19Ethereum Signed Message:\n32";
1738	 bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, hash));
1739	 address a = ecrecover(prefixedHash, v, r, s);
1740	 return (a == qd.getAuthQuoteEngine());
1741	 }
1742	 function _makeCover( address payable from, address contractAddress, bytes4 coverCurrency, uint[] memory coverDetails, uint16 coverPeriod ) internal {
1743	 address underlyingToken = incidents.underlyingToken(contractAddress);
1744	 if (underlyingToken != address(0)) {
1745	 address coverAsset = cr.getCurrencyAssetAddress(coverCurrency);
1746	 require(coverAsset == underlyingToken, "Quotation: Unsupported cover asset for this product");
1747	 }
1748	 uint cid = qd.getCoverLength();
1749	 qd.addCover( coverPeriod, coverDetails[0], from, coverCurrency, contractAddress, coverDetails[1], coverDetails[2] );
1750	 uint coverNoteAmount = coverDetails[2].mul(qd.tokensRetained()).div(100);
1751	 if (underlyingToken == address(0)) {
1752	 uint gracePeriod = tc.claimSubmissionGracePeriod();
1753	 uint claimSubmissionPeriod = uint(coverPeriod).mul(1 days).add(gracePeriod);
1754	 bytes32 reason = keccak256(abi.encodePacked("CN", from, cid));
1755	 td.setDepositCNAmount(cid, coverNoteAmount);
1756	 tc.mintCoverNote(from, reason, coverNoteAmount, claimSubmissionPeriod);
1757	 }
1758	 else {
1759	 tc.mint(from, coverNoteAmount);
1760	 }
1761	 qd.addInTotalSumAssured(coverCurrency, coverDetails[0]);
1762	 qd.addInTotalSumAssuredSC(contractAddress, coverCurrency, coverDetails[0]);
1763	 uint coverPremiumInNXM = coverDetails[2];
1764	 uint stakersRewardPercentage = td.stakerCommissionPer();
1765	 uint rewardValue = coverPremiumInNXM.mul(stakersRewardPercentage).div(100);
1766	 pooledStaking.accumulateReward(contractAddress, rewardValue);
1767	 }
1768	 function _verifyCoverDetails( address payable from, address scAddress, bytes4 coverCurr, uint[] memory coverDetails, uint16 coverPeriod, uint8 _v, bytes32 _r, bytes32 _s, bool isNXM ) internal {
1769	 require(coverDetails[3] > now, "Quotation: Quote has expired");
1770	 require(coverPeriod >= 30 && coverPeriod <= 365, "Quotation: Cover period out of bounds");
1771	 require(!qd.timestampRepeated(coverDetails[4]), "Quotation: Quote already used");
1772	 qd.setTimestampRepeated(coverDetails[4]);
1773	 address asset = cr.getCurrencyAssetAddress(coverCurr);
1774	 if (coverCurr != "ETH" && !isNXM) {
1775	 pool.transferAssetFrom(asset, from, coverDetails[1]);
1776	 }
1777	 require(verifySignature(coverDetails, coverPeriod, coverCurr, scAddress, _v, _r, _s), "Quotation: signature mismatch");
1778	 _makeCover(from, scAddress, coverCurr, coverDetails, coverPeriod);
1779	 }
1780	 function createCover( address payable from, address scAddress, bytes4 currency, uint[] calldata coverDetails, uint16 coverPeriod, uint8 _v, bytes32 _r, bytes32 _s ) external onlyInternal {
1781	 require(coverDetails[3] > now, "Quotation: Quote has expired");
1782	 require(coverPeriod >= 30 && coverPeriod <= 365, "Quotation: Cover period out of bounds");
1783	 require(!qd.timestampRepeated(coverDetails[4]), "Quotation: Quote already used");
1784	 qd.setTimestampRepeated(coverDetails[4]);
1785	 require(verifySignature(coverDetails, coverPeriod, currency, scAddress, _v, _r, _s), "Quotation: signature mismatch");
1786	 _makeCover(from, scAddress, currency, coverDetails, coverPeriod);
1787	 }
1788	 function transferAssetsToNewContract(address) external pure {
1789	 }
1790	 function freeUpHeldCovers() external nonReentrant {
1791	 IERC20 dai = IERC20(cr.getCurrencyAssetAddress("DAI"));
1792	 uint membershipFee = td.joiningFee();
1793	 uint lastCoverId = 106;
1794	 for (uint id = 1; id <= lastCoverId; id++) {
1795	 if (qd.holdedCoverIDStatus(id) != uint(QuotationData.HCIDStatus.kycPending)) {
1796	 continue;
1797	 }
1798	 (, , bytes4 currency, ) = qd.getHoldedCoverDetailsByID1(id);
1799	 (, address payable userAddress, uint[] memory coverDetails) = qd.getHoldedCoverDetailsByID2(id);
1800	 uint refundedETH = membershipFee;
1801	 uint coverPremium = coverDetails[1];
1802	 if (qd.refundEligible(userAddress)) {
1803	 qd.setRefundEligible(userAddress, false);
1804	 }
1805	 qd.setHoldedCoverIDStatus(id, uint(QuotationData.HCIDStatus.kycFailedOrRefunded));
1806	 if (currency == "ETH") {
1807	 refundedETH = refundedETH.add(coverPremium);
1808	 }
1809	 else {
1810	 require(dai.transfer(userAddress, coverPremium), "Quotation: DAI refund transfer failed");
1811	 }
1812	 userAddress.transfer(refundedETH);
1813	 }
1814	 }
1815	 }
1816	 function getAssetToEthRate(address asset) public view returns (uint) {
1817	 if (asset == ETH || asset == stETH) {
1818	 return 1 ether;
1819	 }
1820	 address aggregatorAddress = aggregators[asset];
1821	 if (aggregatorAddress == address(0)) {
1822	 revert("PriceFeedOracle: Oracle asset not found");
1823	 }
1824	 int rate = Aggregator(aggregatorAddress).latestAnswer();
1825	 require(rate > 0, "PriceFeedOracle: Rate must be > 0");
1826	 return uint(rate);
1827	 }
1828	 function getAssetForEth(address asset, uint ethIn) external view returns (uint) {
1829	 if (asset == daiAddress) {
1830	 return ethIn.mul(1e18).div(getAssetToEthRate(daiAddress));
1831	 }
1832	 if (asset == ETH || asset == stETH) {
1833	 return ethIn;
1834	 }
1835	 revert("PriceFeedOracle: Unknown asset");
1836	 }
1837	 }
1838	 function totalSupply() public view returns (uint256) {
1839	 return _totalSupply;
1840	 }
1841	 function balanceOf(address owner) public view returns (uint256) {
1842	 return _balances[owner];
1843	 }
1844	 function allowance( address owner, address spender ) public view returns (uint256) {
1845	 return _allowed[owner][spender];
1846	 }
1847	 function approve(address spender, uint256 value) public returns (bool) {
1848	 require(spender != address(0));
1849	 _allowed[msg.sender][spender] = value;
1850	 emit Approval(msg.sender, spender, value);
1851	 return true;
1852	 }
1853	 function increaseAllowance( address spender, uint256 addedValue ) public returns (bool) {
1854	 require(spender != address(0));
1855	 _allowed[msg.sender][spender] = ( _allowed[msg.sender][spender].add(addedValue));
1856	 emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
1857	 return true;
1858	 }
1859	 function decreaseAllowance( address spender, uint256 subtractedValue ) public returns (bool) {
1860	 require(spender != address(0));
1861	 _allowed[msg.sender][spender] = ( _allowed[msg.sender][spender].sub(subtractedValue));
1862	 emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
1863	 return true;
1864	 }
1865	 function addToWhiteList(address _member) public onlyOperator returns (bool) {
1866	 whiteListed[_member] = true;
1867	 emit WhiteListed(_member);
1868	 return true;
1869	 }
1870	 function removeFromWhiteList(address _member) public onlyOperator returns (bool) {
1871	 whiteListed[_member] = false;
1872	 emit BlackListed(_member);
1873	 return true;
1874	 }
1875	 function changeOperator(address _newOperator) public onlyOperator returns (bool) {
1876	 operator = _newOperator;
1877	 return true;
1878	 }
1879	 function burn(uint256 amount) public returns (bool) {
1880	 _burn(msg.sender, amount);
1881	 return true;
1882	 }
1883	 function burnFrom(address from, uint256 value) public returns (bool) {
1884	 _burnFrom(from, value);
1885	 return true;
1886	 }
1887	 function mint(address account, uint256 amount) public onlyOperator {
1888	 _mint(account, amount);
1889	 }
1890	 function transfer(address to, uint256 value) public canTransfer(to) returns (bool) {
1891	 require(isLockedForMV[msg.sender] < now);
1892	 require(value <= _balances[msg.sender]);
1893	 _transfer(to, value);
1894	 return true;
1895	 }
1896	 function operatorTransfer(address from, uint256 value) public onlyOperator returns (bool) {
1897	 require(value <= _balances[from]);
1898	 _transferFrom(from, operator, value);
1899	 return true;
1900	 }
1901	 function transferFrom( address from, address to, uint256 value ) public canTransfer(to) returns (bool) {
1902	 require(isLockedForMV[from] < now);
1903	 require(value <= _balances[from]);
1904	 require(value <= _allowed[from][msg.sender]);
1905	 _transferFrom(from, to, value);
1906	 return true;
1907	 }
1908	 function lockForMemberVote(address _of, uint _days) public onlyOperator {
1909	 if (_days.add(now) > isLockedForMV[_of]) isLockedForMV[_of] = _days.add(now);
1910	 }
1911	 function _transfer(address to, uint256 value) internal {
1912	 _balances[msg.sender] = _balances[msg.sender].sub(value);
1913	 _balances[to] = _balances[to].add(value);
1914	 emit Transfer(msg.sender, to, value);
1915	 }
1916	 function _transferFrom( address from, address to, uint256 value ) internal {
1917	 _balances[from] = _balances[from].sub(value);
1918	 _balances[to] = _balances[to].add(value);
1919	 _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);
1920	 emit Transfer(from, to, value);
1921	 }
1922	 function _mint(address account, uint256 amount) internal {
1923	 require(account != address(0));
1924	 _totalSupply = _totalSupply.add(amount);
1925	 _balances[account] = _balances[account].add(amount);
1926	 emit Transfer(address(0), account, amount);
1927	 }
1928	 function _burn(address account, uint256 amount) internal {
1929	 require(amount <= _balances[account]);
1930	 _totalSupply = _totalSupply.sub(amount);
1931	 _balances[account] = _balances[account].sub(amount);
1932	 emit Transfer(account, address(0), amount);
1933	 }
1934	 function _burnFrom(address account, uint256 value) internal {
1935	 require(value <= _allowed[account][msg.sender]);
1936	 _allowed[account][msg.sender] = _allowed[account][msg.sender].sub( value);
1937	 _burn(account, value);
1938	 }
1939	 }
1940	 function changeDependentContractAddress() public {
1941	 qd = QuotationData(master.getLatestAddress("QD"));
1942	 pool = Pool(master.getLatestAddress("P1"));
1943	 initialize();
1944	 }
1945	 function initialize() internal {
1946	 address currentMCR = master.getLatestAddress("MC");
1947	 if (address(previousMCR) == address(0) || currentMCR != address(this)) {
1948	 return;
1949	 }
1950	 uint112 minCap = 7000 * 1e18;
1951	 mcrFloor = uint112(previousMCR.variableMincap()) + minCap;
1952	 mcr = uint112(previousMCR.getLastMCREther());
1953	 desiredMCR = mcr;
1954	 mcrFloorIncrementThreshold = uint24(previousMCR.dynamicMincapThresholdx100());
1955	 maxMCRFloorIncrement = uint24(previousMCR.dynamicMincapIncrementx100());
1956	 lastUpdateTime = uint32(block.timestamp);
1957	 previousMCR = LegacyMCR(address(0));
1958	 }
1959	 function getAllSumAssurance() public view returns (uint) {
1960	 PriceFeedOracle priceFeed = pool.priceFeedOracle();
1961	 address daiAddress = priceFeed.daiAddress();
1962	 uint ethAmount = qd.getTotalSumAssured("ETH").mul(1e18);
1963	 uint daiAmount = qd.getTotalSumAssured("DAI").mul(1e18);
1964	 uint daiRate = priceFeed.getAssetToEthRate(daiAddress);
1965	 uint daiAmountInEth = daiAmount.mul(daiRate).div(1e18);
1966	 return ethAmount.add(daiAmountInEth);
1967	 }
1968	 function updateMCR() public {
1969	 _updateMCR(pool.getPoolValueInEth(), false);
1970	 }
1971	 function updateMCRInternal(uint poolValueInEth, bool forceUpdate) public onlyInternal {
1972	 _updateMCR(poolValueInEth, forceUpdate);
1973	 }
1974	 function _updateMCR(uint poolValueInEth, bool forceUpdate) internal {
1975	 uint _mcrFloorIncrementThreshold = mcrFloorIncrementThreshold;
1976	 uint _maxMCRFloorIncrement = maxMCRFloorIncrement;
1977	 uint _gearingFactor = gearingFactor;
1978	 uint _minUpdateTime = minUpdateTime;
1979	 uint _mcrFloor = mcrFloor;
1980	 uint112 _mcr = mcr;
1981	 uint112 _desiredMCR = desiredMCR;
1982	 uint32 _lastUpdateTime = lastUpdateTime;
1983	 if (!forceUpdate && _lastUpdateTime + _minUpdateTime > block.timestamp) {
1984	 return;
1985	 }
1986	 if (block.timestamp > _lastUpdateTime && pool.calculateMCRRatio(poolValueInEth, _mcr) >= _mcrFloorIncrementThreshold) {
1987	 uint basisPointsAdjustment = min( _maxMCRFloorIncrement.mul(block.timestamp - _lastUpdateTime).div(1 days), _maxMCRFloorIncrement );
1988	 uint newMCRFloor = _mcrFloor.mul(basisPointsAdjustment.add(BASIS_PRECISION)).div(BASIS_PRECISION);
1989	 require(newMCRFloor <= uint112(~0), 'MCR: newMCRFloor overflow');
1990	 mcrFloor = uint112(newMCRFloor);
1991	 }
1992	 uint112 newMCR = uint112(getMCR());
1993	 if (newMCR != _mcr) {
1994	 mcr = newMCR;
1995	 }
1996	 uint totalSumAssured = getAllSumAssurance();
1997	 uint gearedMCR = totalSumAssured.mul(BASIS_PRECISION).div(_gearingFactor);
1998	 uint112 newDesiredMCR = uint112(max(gearedMCR, mcrFloor));
1999	 if (newDesiredMCR != _desiredMCR) {
2000	 desiredMCR = newDesiredMCR;
2001	 }
2002	 lastUpdateTime = uint32(block.timestamp);
2003	 emit MCRUpdated(mcr, desiredMCR, mcrFloor, gearedMCR, totalSumAssured);
2004	 }
2005	 function getMCR() public view returns (uint) {
2006	 uint _mcr = mcr;
2007	 uint _desiredMCR = desiredMCR;
2008	 uint _lastUpdateTime = lastUpdateTime;
2009	 if (block.timestamp == _lastUpdateTime) {
2010	 return _mcr;
2011	 }
2012	 uint _maxMCRIncrement = maxMCRIncrement;
2013	 uint basisPointsAdjustment = _maxMCRIncrement.mul(block.timestamp - _lastUpdateTime).div(1 days);
2014	 basisPointsAdjustment = min(basisPointsAdjustment, MAX_MCR_ADJUSTMENT);
2015	 if (_desiredMCR > _mcr) {
2016	 return min(_mcr.mul(basisPointsAdjustment.add(BASIS_PRECISION)).div(BASIS_PRECISION), _desiredMCR);
2017	 }
2018	 return max(_mcr.mul(BASIS_PRECISION - basisPointsAdjustment).div(BASIS_PRECISION), _desiredMCR);
2019	 }
2020	 function getGearedMCR() external view returns (uint) {
2021	 return getAllSumAssurance().mul(BASIS_PRECISION).div(gearingFactor);
2022	 }
2023	 function min(uint x, uint y) pure internal returns (uint) {
2024	 return x < y ? x : y;
2025	 }
2026	 function max(uint x, uint y) pure internal returns (uint) {
2027	 return x > y ? x : y;
2028	 }
2029	 function updateUintParameters(bytes8 code, uint val) public {
2030	 require(master.checkIsAuthToGoverned(msg.sender));
2031	 if (code == "DMCT") {
2032	 require(val <= UINT24_MAX, "MCR: value too large");
2033	 mcrFloorIncrementThreshold = uint24(val);
2034	 }
2035	 else if (code == "DMCI") {
2036	 require(val <= UINT24_MAX, "MCR: value too large");
2037	 maxMCRFloorIncrement = uint24(val);
2038	 }
2039	 else if (code == "MMIC") {
2040	 require(val <= UINT24_MAX, "MCR: value too large");
2041	 maxMCRIncrement = uint24(val);
2042	 }
2043	 else if (code == "GEAR") {
2044	 require(val <= UINT24_MAX, "MCR: value too large");
2045	 gearingFactor = uint24(val);
2046	 }
2047	 else if (code == "MUTI") {
2048	 require(val <= UINT24_MAX, "MCR: value too large");
2049	 minUpdateTime = uint24(val);
2050	 }
2051	 else {
2052	 revert("Invalid param code");
2053	 }
2054	 }
2055	 }
2056	 function claimAllPendingReward(uint records) public isMemberAndcheckPause {
2057	 _claimRewardToBeDistributed(records);
2058	 pooledStaking.withdrawReward(msg.sender);
2059	 uint governanceRewards = gv.claimReward(msg.sender, records);
2060	 if (governanceRewards > 0) {
2061	 require(tk.transfer(msg.sender, governanceRewards));
2062	 }
2063	 }
2064	 function getAllPendingRewardOfUser(address _add) public view returns (uint) {
2065	 uint caReward = getRewardToBeDistributedByUser(_add);
2066	 uint pooledStakingReward = pooledStaking.stakerReward(_add);
2067	 uint governanceReward = gv.getPendingReward(_add);
2068	 return caReward.add(pooledStakingReward).add(governanceReward);
2069	 }
2070	 function _rewardAgainstClaim(uint claimid, uint coverid, uint status) internal {
2071	 uint premiumNXM = qd.getCoverPremiumNXM(coverid);
2072	 uint distributableTokens = premiumNXM.mul(cd.claimRewardPerc()).div(100);
2073	 uint percCA;
2074	 uint percMV;
2075	 (percCA, percMV) = cd.getRewardStatus(status);
2076	 cd.setClaimRewardDetail(claimid, percCA, percMV, distributableTokens);
2077	 if (percCA > 0 || percMV > 0) {
2078	 tc.mint(address(this), distributableTokens);
2079	 }
2080	 if (status == 6 || status == 9 || status == 11) {
2081	 cd.changeFinalVerdict(claimid, -1);
2082	 tc.markCoverClaimClosed(coverid, false);
2083	 _burnCoverNoteDeposit(coverid);
2084	 }
2085	 else if (status == 7 || status == 8 || status == 10) {
2086	 cd.changeFinalVerdict(claimid, 1);
2087	 tc.markCoverClaimClosed(coverid, true);
2088	 _unlockCoverNote(coverid);
2089	 bool payoutSucceeded = attemptClaimPayout(coverid);
2090	 uint nextStatus = payoutSucceeded ? 14 : 12;
2091	 c1.setClaimStatus(claimid, nextStatus);
2092	 }
2093	 }
2094	 function _burnCoverNoteDeposit(uint coverId) internal {
2095	 address _of = qd.getCoverMemberAddress(coverId);
2096	 bytes32 reason = keccak256(abi.encodePacked("CN", _of, coverId));
2097	 uint lockedAmount = tc.tokensLocked(_of, reason);
2098	 (uint amount,) = td.depositedCN(coverId);
2099	 amount = amount.div(2);
2100	 uint burnAmount = lockedAmount < amount ? lockedAmount : amount;
2101	 if (burnAmount != 0) {
2102	 tc.burnLockedTokens(_of, reason, amount);
2103	 }
2104	 }
2105	 function _unlockCoverNote(uint coverId) internal {
2106	 address coverHolder = qd.getCoverMemberAddress(coverId);
2107	 bytes32 reason = keccak256(abi.encodePacked("CN", coverHolder, coverId));
2108	 uint lockedCN = tc.tokensLocked(coverHolder, reason);
2109	 if (lockedCN != 0) {
2110	 tc.releaseLockedTokens(coverHolder, reason, lockedCN);
2111	 }
2112	 }
2113	 function _changeClaimStatusCA(uint claimid, uint coverid, uint status) internal {
2114	 if (c1.checkVoteClosing(claimid) == 1) {
2115	 uint caTokens = c1.getCATokens(claimid, 0);
2116	 uint accept;
2117	 uint deny;
2118	 uint acceptAndDeny;
2119	 bool rewardOrPunish;
2120	 uint sumAssured;
2121	 (, accept) = cd.getClaimVote(claimid, 1);
2122	 (, deny) = cd.getClaimVote(claimid, - 1);
2123	 acceptAndDeny = accept.add(deny);
2124	 accept = accept.mul(100);
2125	 deny = deny.mul(100);
2126	 if (caTokens == 0) {
2127	 status = 3;
2128	 }
2129	 else {
2130	 sumAssured = qd.getCoverSumAssured(coverid).mul(DECIMAL1E18);
2131	 if (caTokens > sumAssured.mul(5)) {
2132	 if (accept.div(acceptAndDeny) > 70) {
2133	 status = 7;
2134	 qd.changeCoverStatusNo(coverid, uint8(QuotationData.CoverStatus.ClaimAccepted));
2135	 rewardOrPunish = true;
2136	 }
2137	 else if (deny.div(acceptAndDeny) > 70) {
2138	 status = 6;
2139	 qd.changeCoverStatusNo(coverid, uint8(QuotationData.CoverStatus.ClaimDenied));
2140	 rewardOrPunish = true;
2141	 }
2142	 else if (accept.div(acceptAndDeny) > deny.div(acceptAndDeny)) {
2143	 status = 4;
2144	 }
2145	 else {
2146	 status = 5;
2147	 }
2148	 }
2149	 else {
2150	 if (accept.div(acceptAndDeny) > deny.div(acceptAndDeny)) {
2151	 status = 2;
2152	 }
2153	 else {
2154	 status = 3;
2155	 }
2156	 }
2157	 }
2158	 c1.setClaimStatus(claimid, status);
2159	 if (rewardOrPunish) {
2160	 _rewardAgainstClaim(claimid, coverid, status);
2161	 }
2162	 }
2163	 }
2164	 function _changeClaimStatusMV(uint claimid, uint coverid, uint status) internal {
2165	 if (c1.checkVoteClosing(claimid) == 1) {
2166	 uint8 coverStatus;
2167	 uint statusOrig = status;
2168	 uint mvTokens = c1.getCATokens(claimid, 1);
2169	 uint sumAssured = qd.getCoverSumAssured(coverid).mul(DECIMAL1E18);
2170	 uint thresholdUnreached = 0;
2171	 if (mvTokens < sumAssured.mul(5)) {
2172	 thresholdUnreached = 1;
2173	 }
2174	 uint accept;
2175	 (, accept) = cd.getClaimMVote(claimid, 1);
2176	 uint deny;
2177	 (, deny) = cd.getClaimMVote(claimid, - 1);
2178	 if (accept.add(deny) > 0) {
2179	 if (accept.mul(100).div(accept.add(deny)) >= 50 && statusOrig > 1 && statusOrig <= 5 && thresholdUnreached == 0) {
2180	 status = 8;
2181	 coverStatus = uint8(QuotationData.CoverStatus.ClaimAccepted);
2182	 }
2183	 else if (deny.mul(100).div(accept.add(deny)) >= 50 && statusOrig > 1 && statusOrig <= 5 && thresholdUnreached == 0) {
2184	 status = 9;
2185	 coverStatus = uint8(QuotationData.CoverStatus.ClaimDenied);
2186	 }
2187	 }
2188	 if (thresholdUnreached == 1 && (statusOrig == 2 || statusOrig == 4)) {
2189	 status = 10;
2190	 coverStatus = uint8(QuotationData.CoverStatus.ClaimAccepted);
2191	 }
2192	 else if (thresholdUnreached == 1 && (statusOrig == 5 || statusOrig == 3 || statusOrig == 1)) {
2193	 status = 11;
2194	 coverStatus = uint8(QuotationData.CoverStatus.ClaimDenied);
2195	 }
2196	 c1.setClaimStatus(claimid, status);
2197	 qd.changeCoverStatusNo(coverid, uint8(coverStatus));
2198	 _rewardAgainstClaim(claimid, coverid, status);
2199	 }
2200	 }
2201	 function _claimRewardToBeDistributed(uint _records) internal {
2202	 uint lengthVote = cd.getVoteAddressCALength(msg.sender);
2203	 uint voteid;
2204	 uint lastIndex;
2205	 (lastIndex,) = cd.getRewardDistributedIndex(msg.sender);
2206	 uint total = 0;
2207	 uint tokenForVoteId = 0;
2208	 bool lastClaimedCheck;
2209	 uint _days = td.lockCADays();
2210	 bool claimed;
2211	 uint counter = 0;
2212	 uint claimId;
2213	 uint perc;
2214	 uint i;
2215	 uint lastClaimed = lengthVote;
2216	 for (i = lastIndex; i < lengthVote && counter < _records; i++) {
2217	 voteid = cd.getVoteAddressCA(msg.sender, i);
2218	 (tokenForVoteId, lastClaimedCheck, , perc) = getRewardToBeGiven(1, voteid, 0);
2219	 if (lastClaimed == lengthVote && lastClaimedCheck == true) {
2220	 lastClaimed = i;
2221	 }
2222	 (, claimId, , claimed) = cd.getVoteDetails(voteid);
2223	 if (perc > 0 && !claimed) {
2224	 counter++;
2225	 cd.setRewardClaimed(voteid, true);
2226	 }
2227	 else if (perc == 0 && cd.getFinalVerdict(claimId) != 0 && !claimed) {
2228	 (perc,,) = cd.getClaimRewardDetail(claimId);
2229	 if (perc == 0) {
2230	 counter++;
2231	 }
2232	 cd.setRewardClaimed(voteid, true);
2233	 }
2234	 if (tokenForVoteId > 0) {
2235	 total = tokenForVoteId.add(total);
2236	 }
2237	 }
2238	 if (lastClaimed == lengthVote) {
2239	 cd.setRewardDistributedIndexCA(msg.sender, i);
2240	 }
2241	 else {
2242	 cd.setRewardDistributedIndexCA(msg.sender, lastClaimed);
2243	 }
2244	 lengthVote = cd.getVoteAddressMemberLength(msg.sender);
2245	 lastClaimed = lengthVote;
2246	 _days = _days.mul(counter);
2247	 if (tc.tokensLockedAtTime(msg.sender, "CLA", now) > 0) {
2248	 tc.reduceLock(msg.sender, "CLA", _days);
2249	 }
2250	 (, lastIndex) = cd.getRewardDistributedIndex(msg.sender);
2251	 lastClaimed = lengthVote;
2252	 counter = 0;
2253	 for (i = lastIndex; i < lengthVote && counter < _records; i++) {
2254	 voteid = cd.getVoteAddressMember(msg.sender, i);
2255	 (tokenForVoteId, lastClaimedCheck,,) = getRewardToBeGiven(0, voteid, 0);
2256	 if (lastClaimed == lengthVote && lastClaimedCheck == true) {
2257	 lastClaimed = i;
2258	 }
2259	 (, claimId, , claimed) = cd.getVoteDetails(voteid);
2260	 if (claimed == false && cd.getFinalVerdict(claimId) != 0) {
2261	 cd.setRewardClaimed(voteid, true);
2262	 counter++;
2263	 }
2264	 if (tokenForVoteId > 0) {
2265	 total = tokenForVoteId.add(total);
2266	 }
2267	 }
2268	 if (total > 0) {
2269	 require(tk.transfer(msg.sender, total));
2270	 }
2271	 if (lastClaimed == lengthVote) {
2272	 cd.setRewardDistributedIndexMV(msg.sender, i);
2273	 }
2274	 else {
2275	 cd.setRewardDistributedIndexMV(msg.sender, lastClaimed);
2276	 }
2277	 }
2278	 function _claimStakeCommission(uint _records, address _user) external onlyInternal {
2279	 uint total = 0;
2280	 uint len = td.getStakerStakedContractLength(_user);
2281	 uint lastCompletedStakeCommission = td.lastCompletedStakeCommission(_user);
2282	 uint commissionEarned;
2283	 uint commissionRedeemed;
2284	 uint maxCommission;
2285	 uint lastCommisionRedeemed = len;
2286	 uint counter;
2287	 uint i;
2288	 for (i = lastCompletedStakeCommission; i < len && counter < _records; i++) {
2289	 commissionRedeemed = td.getStakerRedeemedStakeCommission(_user, i);
2290	 commissionEarned = td.getStakerEarnedStakeCommission(_user, i);
2291	 maxCommission = td.getStakerInitialStakedAmountOnContract( _user, i).mul(td.stakerMaxCommissionPer()).div(100);
2292	 if (lastCommisionRedeemed == len && maxCommission != commissionEarned) lastCommisionRedeemed = i;
2293	 td.pushRedeemedStakeCommissions(_user, i, commissionEarned.sub(commissionRedeemed));
2294	 total = total.add(commissionEarned.sub(commissionRedeemed));
2295	 counter++;
2296	 }
2297	 if (lastCommisionRedeemed == len) {
2298	 td.setLastCompletedStakeCommissionIndex(_user, i);
2299	 }
2300	 else {
2301	 td.setLastCompletedStakeCommissionIndex(_user, lastCommisionRedeemed);
2302	 }
2303	 if (total > 0) require(tk.transfer(_user, total));
2304	 }
2305	 }
2306	 pragma solidity ^0.5.0;
2307	 library OZSafeMath {
2308	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
2309	 if (a == 0) {
2310	 return 0;
2311	 }
2312	 uint256 c = a * b;
2313	 require(c / a == b);
2314	 return c;
2315	 }
2316	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
2317	 require(b > 0);
2318	 uint256 c = a / b;
2319	 return c;
2320	 }
2321	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
2322	 require(b <= a);
2323	 uint256 c = a - b;
2324	 return c;
2325	 }
2326	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
2327	 uint256 c = a + b;
2328	 require(c >= a);
2329	 return c;
2330	 }
2331	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
2332	 require(b != 0);
2333	 return a % b;
2334	 }
2335	 }
2336	 pragma solidity ^0.5.0;
2337	 interface IPooledStaking {
2338	 function accumulateReward(address contractAddress, uint amount) external;
2339	 function pushBurn(address contractAddress, uint amount) external;
2340	 function hasPendingActions() external view returns (bool);
2341	 function processPendingActions(uint maxIterations) external returns (bool finished);
2342	 function contractStake(address contractAddress) external view returns (uint);
2343	 function stakerReward(address staker) external view returns (uint);
2344	 function stakerDeposit(address staker) external view returns (uint);
2345	 function stakerContractStake(address staker, address contractAddress) external view returns (uint);
2346	 function withdraw(uint amount) external;
2347	 function stakerMaxWithdrawable(address stakerAddress) external view returns (uint);
2348	 function withdrawReward(address stakerAddress) external;
2349	 }
2350	 function setpendingClaimStart(uint _start) external onlyInternal {
2351	 require(pendingClaimStart <= _start);
2352	 pendingClaimStart = _start;
2353	 }
2354	 function setRewardDistributedIndexCA(address _voter, uint caIndex) external onlyInternal {
2355	 voterVoteRewardReceived[_voter].lastCAvoteIndex = caIndex;
2356	 }
2357	 function setUserClaimVotePausedOn(address user) external {
2358	 require(ms.checkIsAuthToGoverned(msg.sender));
2359	 userClaimVotePausedOn[user] = now;
2360	 }
2361	 function setRewardDistributedIndexMV(address _voter, uint mvIndex) external onlyInternal {
2362	 voterVoteRewardReceived[_voter].lastMVvoteIndex = mvIndex;
2363	 }
2364	 function setClaimRewardDetail( uint claimid, uint percCA, uint percMV, uint tokens ) external onlyInternal {
2365	 claimRewardDetail[claimid].percCA = percCA;
2366	 claimRewardDetail[claimid].percMV = percMV;
2367	 claimRewardDetail[claimid].tokenToBeDist = tokens;
2368	 }
2369	 function setRewardClaimed(uint _voteid, bool claimed) external onlyInternal {
2370	 allvotes[_voteid].rewardClaimed = claimed;
2371	 }
2372	 function changeFinalVerdict(uint _claimId, int8 _verdict) external onlyInternal {
2373	 claimVote[_claimId] = _verdict;
2374	 }
2375	 function addClaim( uint _claimId, uint _coverId, address _from, uint _nowtime ) external onlyInternal {
2376	 allClaims.push(Claim(_coverId, _nowtime));
2377	 allClaimsByAddress[_from].push(_claimId);
2378	 }
2379	 function addVote( address _voter, uint _tokens, uint claimId, int8 _verdict ) external onlyInternal {
2380	 allvotes.push(Vote(_voter, _tokens, claimId, _verdict, false));
2381	 }
2382	 function addClaimVoteCA(uint _claimId, uint _voteid) external onlyInternal {
2383	 claimVoteCA[_claimId].push(_voteid);
2384	 }
2385	 function setUserClaimVoteCA( address _from, uint _claimId, uint _voteid ) external onlyInternal {
2386	 userClaimVoteCA[_from][_claimId] = _voteid;
2387	 voteAddressCA[_from].push(_voteid);
2388	 }
2389	 function setClaimTokensCA(uint _claimId, int8 _vote, uint _tokens) external onlyInternal {
2390	 if (_vote == 1) claimTokensCA[_claimId].accept = claimTokensCA[_claimId].accept.add(_tokens);
2391	 if (_vote == - 1) claimTokensCA[_claimId].deny = claimTokensCA[_claimId].deny.add(_tokens);
2392	 }
2393	 function setClaimTokensMV(uint _claimId, int8 _vote, uint _tokens) external onlyInternal {
2394	 if (_vote == 1) claimTokensMV[_claimId].accept = claimTokensMV[_claimId].accept.add(_tokens);
2395	 if (_vote == - 1) claimTokensMV[_claimId].deny = claimTokensMV[_claimId].deny.add(_tokens);
2396	 }
2397	 function addClaimVotemember(uint _claimId, uint _voteid) external onlyInternal {
2398	 claimVoteMember[_claimId].push(_voteid);
2399	 }
2400	 function setUserClaimVoteMember( address _from, uint _claimId, uint _voteid ) external onlyInternal {
2401	 userClaimVoteMember[_from][_claimId] = _voteid;
2402	 voteAddressMember[_from].push(_voteid);
2403	 }
2404	 function updateState12Count(uint _claimId, uint _cnt) external onlyInternal {
2405	 claimState12Count[_claimId] = claimState12Count[_claimId].add(_cnt);
2406	 }
2407	 function setClaimStatus(uint _claimId, uint _stat) external onlyInternal {
2408	 claimsStatus[_claimId] = _stat;
2409	 }
2410	 function setClaimdateUpd(uint _claimId, uint _dateUpd) external onlyInternal {
2411	 allClaims[_claimId].dateUpd = _dateUpd;
2412	 }
2413	 function setClaimAtEmergencyPause( uint _coverId, uint _dateUpd, bool _submit ) external onlyInternal {
2414	 claimPause.push(ClaimsPause(_coverId, _dateUpd, _submit));
2415	 }
2416	 function setClaimSubmittedAtEPTrue(uint _index, bool _submit) external onlyInternal {
2417	 claimPause[_index].submit = _submit;
2418	 }
2419	 function setFirstClaimIndexToSubmitAfterEP( uint _firstClaimIndexToSubmit ) external onlyInternal {
2420	 claimPauseLastsubmit = _firstClaimIndexToSubmit;
2421	 }
2422	 function setPendingClaimDetails( uint _claimId, uint _pendingTime, bool _voting ) external onlyInternal {
2423	 claimPauseVotingEP.push(ClaimPauseVoting(_claimId, _pendingTime, _voting));
2424	 }
2425	 function setPendingClaimVoteStatus(uint _claimId, bool _vote) external onlyInternal {
2426	 claimPauseVotingEP[_claimId].voting = _vote;
2427	 }
2428	 function setFirstClaimIndexToStartVotingAfterEP( uint _claimStartVotingFirstIndex ) external onlyInternal {
2429	 claimStartVotingFirstIndex = _claimStartVotingFirstIndex;
2430	 }
2431	 function callVoteEvent( address _userAddress, uint _claimId, bytes4 _typeOf, uint _tokens, uint _submitDate, int8 _verdict ) external onlyInternal {
2432	 emit VoteCast( _userAddress, _claimId, _typeOf, _tokens, _submitDate, _verdict );
2433	 }
2434	 function callClaimEvent( uint _coverId, address _userAddress, uint _claimId, uint _datesubmit ) external onlyInternal {
2435	 emit ClaimRaise(_coverId, _userAddress, _claimId, _datesubmit);
2436	 }
2437	 function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val) {
2438	 codeVal = code;
2439	 if (code == "CAMAXVT") {
2440	 val = maxVotingTime / (1 hours);
2441	 }
2442	 else if (code == "CAMINVT") {
2443	 val = minVotingTime / (1 hours);
2444	 }
2445	 else if (code == "CAPRETRY") {
2446	 val = payoutRetryTime / (1 hours);
2447	 }
2448	 else if (code == "CADEPT") {
2449	 val = claimDepositTime / (1 days);
2450	 }
2451	 else if (code == "CAREWPER") {
2452	 val = claimRewardPerc;
2453	 }
2454	 else if (code == "CAMINTH") {
2455	 val = minVoteThreshold;
2456	 }
2457	 else if (code == "CAMAXTH") {
2458	 val = maxVoteThreshold;
2459	 }
2460	 else if (code == "CACONPER") {
2461	 val = majorityConsensus;
2462	 }
2463	 else if (code == "CAPAUSET") {
2464	 val = pauseDaysCA / (1 days);
2465	 }
2466	 }
2467	 function getClaimOfEmergencyPauseByIndex( uint _index ) external view returns ( uint coverId, uint dateUpd, bool submit ) {
2468	 coverId = claimPause[_index].coverid;
2469	 dateUpd = claimPause[_index].dateUpd;
2470	 submit = claimPause[_index].submit;
2471	 }
2472	 function getAllClaimsByIndex( uint _claimId ) external view returns ( uint coverId, int8 vote, uint status, uint dateUpd, uint state12Count ) {
2473	 return ( allClaims[_claimId].coverId, claimVote[_claimId], claimsStatus[_claimId], allClaims[_claimId].dateUpd, claimState12Count[_claimId] );
2474	 }
2475	 function getUserClaimVoteCA( address _add, uint _claimId ) external view returns (uint idVote) {
2476	 return userClaimVoteCA[_add][_claimId];
2477	 }
2478	 function getUserClaimVoteMember( address _add, uint _claimId ) external view returns (uint idVote) {
2479	 return userClaimVoteMember[_add][_claimId];
2480	 }
2481	 function getAllVoteLength() external view returns (uint voteCount) {
2482	 return allvotes.length.sub(1);
2483	 }
2484	 function getClaimStatusNumber(uint _claimId) external view returns (uint claimId, uint statno) {
2485	 return (_claimId, claimsStatus[_claimId]);
2486	 }
2487	 function getRewardStatus(uint statusNumber) external view returns (uint percCA, uint percMV) {
2488	 return (rewardStatus[statusNumber].percCA, rewardStatus[statusNumber].percMV);
2489	 }
2490	 function getClaimState12Count(uint _claimId) external view returns (uint num) {
2491	 num = claimState12Count[_claimId];
2492	 }
2493	 function getClaimDateUpd(uint _claimId) external view returns (uint dateupd) {
2494	 dateupd = allClaims[_claimId].dateUpd;
2495	 }
2496	 function getAllClaimsByAddress(address _member) external view returns (uint[] memory claimarr) {
2497	 return allClaimsByAddress[_member];
2498	 }
2499	 function getClaimsTokenCA( uint _claimId ) external view returns ( uint claimId, uint accept, uint deny ) {
2500	 return ( _claimId, claimTokensCA[_claimId].accept, claimTokensCA[_claimId].deny );
2501	 }
2502	 function getClaimsTokenMV( uint _claimId ) external view returns ( uint claimId, uint accept, uint deny ) {
2503	 return ( _claimId, claimTokensMV[_claimId].accept, claimTokensMV[_claimId].deny );
2504	 }
2505	 function getCaClaimVotesToken(uint _claimId) external view returns (uint claimId, uint cnt) {
2506	 claimId = _claimId;
2507	 cnt = 0;
2508	 for (uint i = 0; i < claimVoteCA[_claimId].length; i++) {
2509	 cnt = cnt.add(allvotes[claimVoteCA[_claimId][i]].tokens);
2510	 }
2511	 }
2512	 function getMemberClaimVotesToken( uint _claimId ) external view returns (uint claimId, uint cnt) {
2513	 claimId = _claimId;
2514	 cnt = 0;
2515	 for (uint i = 0; i < claimVoteMember[_claimId].length; i++) {
2516	 cnt = cnt.add(allvotes[claimVoteMember[_claimId][i]].tokens);
2517	 }
2518	 }
2519	 function getVoteDetails(uint _voteid) external view returns ( uint tokens, uint claimId, int8 verdict, bool rewardClaimed ) {
2520	 return ( allvotes[_voteid].tokens, allvotes[_voteid].claimId, allvotes[_voteid].verdict, allvotes[_voteid].rewardClaimed );
2521	 }
2522	 function getVoterVote(uint _voteid) external view returns (address voter) {
2523	 return allvotes[_voteid].voter;
2524	 }
2525	 function getClaim( uint _claimId ) external view returns ( uint claimId, uint coverId, int8 vote, uint status, uint dateUpd, uint state12Count ) {
2526	 return ( _claimId, allClaims[_claimId].coverId, claimVote[_claimId], claimsStatus[_claimId], allClaims[_claimId].dateUpd, claimState12Count[_claimId] );
2527	 }
2528	 function getClaimVoteLength( uint _claimId, uint8 _ca ) external view returns (uint claimId, uint len) {
2529	 claimId = _claimId;
2530	 if (_ca == 1) len = claimVoteCA[_claimId].length;
2531	 else len = claimVoteMember[_claimId].length;
2532	 }
2533	 function getVoteVerdict( uint _claimId, uint _index, uint8 _ca ) external view returns (int8 ver) {
2534	 if (_ca == 1) ver = allvotes[claimVoteCA[_claimId][_index]].verdict;
2535	 else ver = allvotes[claimVoteMember[_claimId][_index]].verdict;
2536	 }
2537	 function getVoteToken( uint _claimId, uint _index, uint8 _ca ) external view returns (uint tok) {
2538	 if (_ca == 1) tok = allvotes[claimVoteCA[_claimId][_index]].tokens;
2539	 else tok = allvotes[claimVoteMember[_claimId][_index]].tokens;
2540	 }
2541	 function getVoteVoter( uint _claimId, uint _index, uint8 _ca ) external view returns (address voter) {
2542	 if (_ca == 1) voter = allvotes[claimVoteCA[_claimId][_index]].voter;
2543	 else voter = allvotes[claimVoteMember[_claimId][_index]].voter;
2544	 }
2545	 function getUserClaimCount(address _add) external view returns (uint len) {
2546	 len = allClaimsByAddress[_add].length;
2547	 }
2548	 function getClaimLength() external view returns (uint len) {
2549	 len = allClaims.length.sub(pendingClaimStart);
2550	 }
2551	 function actualClaimLength() external view returns (uint len) {
2552	 len = allClaims.length;
2553	 }
2554	 function getClaimFromNewStart( uint _index, address _add ) external view returns ( uint coverid, uint claimId, int8 voteCA, int8 voteMV, uint statusnumber ) {
2555	 uint i = pendingClaimStart.add(_index);
2556	 coverid = allClaims[i].coverId;
2557	 claimId = i;
2558	 if (userClaimVoteCA[_add][i] > 0) voteCA = allvotes[userClaimVoteCA[_add][i]].verdict;
2559	 else voteCA = 0;
2560	 if (userClaimVoteMember[_add][i] > 0) voteMV = allvotes[userClaimVoteMember[_add][i]].verdict;
2561	 else voteMV = 0;
2562	 statusnumber = claimsStatus[i];
2563	 }
2564	 function getUserClaimByIndex( uint _index, address _add ) external view returns ( uint status, uint coverid, uint claimId ) {
2565	 claimId = allClaimsByAddress[_add][_index];
2566	 status = claimsStatus[claimId];
2567	 coverid = allClaims[claimId].coverId;
2568	 }
2569	 function getAllVotesForClaim( uint _claimId ) external view returns ( uint claimId, uint[] memory ca, uint[] memory mv ) {
2570	 return (_claimId, claimVoteCA[_claimId], claimVoteMember[_claimId]);
2571	 }
2572	 function getTokensClaim( address _of, uint _claimId ) external view returns ( uint claimId, uint tokens ) {
2573	 return (_claimId, allvotes[userClaimVoteCA[_of][_claimId]].tokens);
2574	 }
2575	 function getRewardDistributedIndex( address _voter ) external view returns ( uint lastCAvoteIndex, uint lastMVvoteIndex ) {
2576	 return ( voterVoteRewardReceived[_voter].lastCAvoteIndex, voterVoteRewardReceived[_voter].lastMVvoteIndex );
2577	 }
2578	 function getClaimRewardDetail( uint claimid ) external view returns ( uint percCA, uint percMV, uint tokens ) {
2579	 return ( claimRewardDetail[claimid].percCA, claimRewardDetail[claimid].percMV, claimRewardDetail[claimid].tokenToBeDist );
2580	 }
2581	 function getClaimCoverId(uint _claimId) external view returns (uint claimId, uint coverid) {
2582	 return (_claimId, allClaims[_claimId].coverId);
2583	 }
2584	 function getClaimVote(uint _claimId, int8 _verdict) external view returns (uint claimId, uint token) {
2585	 claimId = _claimId;
2586	 token = 0;
2587	 for (uint i = 0; i < claimVoteCA[_claimId].length; i++) {
2588	 if (allvotes[claimVoteCA[_claimId][i]].verdict == _verdict) token = token.add(allvotes[claimVoteCA[_claimId][i]].tokens);
2589	 }
2590	 }
2591	 function getClaimMVote(uint _claimId, int8 _verdict) external view returns (uint claimId, uint token) {
2592	 claimId = _claimId;
2593	 token = 0;
2594	 for (uint i = 0; i < claimVoteMember[_claimId].length; i++) {
2595	 if (allvotes[claimVoteMember[_claimId][i]].verdict == _verdict) token = token.add(allvotes[claimVoteMember[_claimId][i]].tokens);
2596	 }
2597	 }
2598	 function getVoteAddressCA(address _voter, uint index) external view returns (uint) {
2599	 return voteAddressCA[_voter][index];
2600	 }
2601	 function getVoteAddressMember(address _voter, uint index) external view returns (uint) {
2602	 return voteAddressMember[_voter][index];
2603	 }
2604	 function getVoteAddressCALength(address _voter) external view returns (uint) {
2605	 return voteAddressCA[_voter].length;
2606	 }
2607	 function getVoteAddressMemberLength(address _voter) external view returns (uint) {
2608	 return voteAddressMember[_voter].length;
2609	 }
2610	 function getFinalVerdict(uint _claimId) external view returns (int8 verdict) {
2611	 return claimVote[_claimId];
2612	 }
2613	 function getLengthOfClaimSubmittedAtEP() external view returns (uint len) {
2614	 len = claimPause.length;
2615	 }
2616	 function getFirstClaimIndexToSubmitAfterEP() external view returns (uint indexToSubmit) {
2617	 indexToSubmit = claimPauseLastsubmit;
2618	 }
2619	 function getLengthOfClaimVotingPause() external view returns (uint len) {
2620	 len = claimPauseVotingEP.length;
2621	 }
2622	 function getPendingClaimDetailsByIndex( uint _index ) external view returns ( uint claimId, uint pendingTime, bool voting ) {
2623	 claimId = claimPauseVotingEP[_index].claimid;
2624	 pendingTime = claimPauseVotingEP[_index].pendingTime;
2625	 voting = claimPauseVotingEP[_index].voting;
2626	 }
2627	 function getFirstClaimIndexToStartVotingAfterEP() external view returns (uint firstindex) {
2628	 firstindex = claimStartVotingFirstIndex;
2629	 }
2630	 function updateUintParameters(bytes8 code, uint val) public {
2631	 require(ms.checkIsAuthToGoverned(msg.sender));
2632	 if (code == "CAMAXVT") {
2633	 _setMaxVotingTime(val * 1 hours);
2634	 }
2635	 else if (code == "CAMINVT") {
2636	 _setMinVotingTime(val * 1 hours);
2637	 }
2638	 else if (code == "CAPRETRY") {
2639	 _setPayoutRetryTime(val * 1 hours);
2640	 }
2641	 else if (code == "CADEPT") {
2642	 _setClaimDepositTime(val * 1 days);
2643	 }
2644	 else if (code == "CAREWPER") {
2645	 _setClaimRewardPerc(val);
2646	 }
2647	 else if (code == "CAMINTH") {
2648	 _setMinVoteThreshold(val);
2649	 }
2650	 else if (code == "CAMAXTH") {
2651	 _setMaxVoteThreshold(val);
2652	 }
2653	 else if (code == "CACONPER") {
2654	 _setMajorityConsensus(val);
2655	 }
2656	 else if (code == "CAPAUSET") {
2657	 _setPauseDaysCA(val * 1 days);
2658	 }
2659	 else {
2660	 revert("Invalid param code");
2661	 }
2662	 }
2663	 function changeDependentContractAddress() public onlyInternal {
2664	 }
2665	 function _pushStatus(uint percCA, uint percMV) internal {
2666	 rewardStatus.push(ClaimRewardStatus(percCA, percMV));
2667	 }
2668	 function _addRewardIncentive() internal {
2669	 _pushStatus(0, 0);
2670	 _pushStatus(0, 0);
2671	 _pushStatus(0, 0);
2672	 _pushStatus(0, 0);
2673	 _pushStatus(0, 0);
2674	 _pushStatus(0, 0);
2675	 _pushStatus(100, 0);
2676	 _pushStatus(100, 0);
2677	 _pushStatus(0, 100);
2678	 _pushStatus(0, 100);
2679	 _pushStatus(0, 0);
2680	 _pushStatus(0, 0);
2681	 _pushStatus(0, 0);
2682	 _pushStatus(0, 0);
2683	 _pushStatus(0, 0);
2684	 }
2685	 function _setMaxVotingTime(uint _time) internal {
2686	 maxVotingTime = _time;
2687	 }
2688	 function _setMinVotingTime(uint _time) internal {
2689	 minVotingTime = _time;
2690	 }
2691	 function _setMinVoteThreshold(uint val) internal {
2692	 minVoteThreshold = val;
2693	 }
2694	 function _setMaxVoteThreshold(uint val) internal {
2695	 maxVoteThreshold = val;
2696	 }
2697	 function _setMajorityConsensus(uint val) internal {
2698	 majorityConsensus = val;
2699	 }
2700	 function _setPayoutRetryTime(uint _time) internal {
2701	 payoutRetryTime = _time;
2702	 }
2703	 function _setClaimRewardPerc(uint _val) internal {
2704	 claimRewardPerc = _val;
2705	 }
2706	 function _setClaimDepositTime(uint _time) internal {
2707	 claimDepositTime = _time;
2708	 }
2709	 function _setPauseDaysCA(uint val) internal {
2710	 pauseDaysCA = val;
2711	 }
2712	 }
2713	 pragma solidity ^0.5.0;
2714	 interface LegacyMCR {
2715	 function addMCRData(uint mcrP, uint mcrE, uint vF, bytes4[] calldata curr, uint[] calldata _threeDayAvg, uint64 onlyDate) external;
2716	 function addLastMCRData(uint64 date) external;
2717	 function changeDependentContractAddress() external;
2718	 function getAllSumAssurance() external view returns (uint amount);
2719	 function _calVtpAndMCRtp(uint poolBalance) external view returns (uint vtp, uint mcrtp);
2720	 function calculateStepTokenPrice(bytes4 curr, uint mcrtp) external view returns (uint tokenPrice);
2721	 function calculateTokenPrice(bytes4 curr) external view returns (uint tokenPrice);
2722	 function calVtpAndMCRtp() external view returns (uint vtp, uint mcrtp);
2723	 function calculateVtpAndMCRtp(uint poolBalance) external view returns (uint vtp, uint mcrtp);
2724	 function getThresholdValues(uint vtp, uint vF, uint totalSA, uint minCap) external view returns (uint lowerThreshold, uint upperThreshold);
2725	 function getMaxSellTokens() external view returns (uint maxTokens);
2726	 function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val);
2727	 function updateUintParameters(bytes8 code, uint val) external;
2728	 function variableMincap() external view returns (uint);
2729	 function dynamicMincapThresholdx100() external view returns (uint);
2730	 function dynamicMincapIncrementx100() external view returns (uint);
2731	 function getLastMCREther() external view returns (uint);
2732	 }
2733	 pragma solidity ^0.5.0;
2734	 contract Governance is IGovernance, Iupgradable {
2735	 using SafeMath for uint;
2736	 enum ProposalStatus {
2737	 Draft, AwaitingSolution, VotingStarted, Accepted, Rejected, Majority_Not_Reached_But_Accepted, Denied }
2738	 struct ProposalData {
2739	 uint propStatus;
2740	 uint finalVerdict;
2741	 uint category;
2742	 uint commonIncentive;
2743	 uint dateUpd;
2744	 address owner;
2745	 }
2746	 struct ProposalVote {
2747	 address voter;
2748	 uint proposalId;
2749	 uint dateAdd;
2750	 }
2751	 struct VoteTally {
2752	 mapping(uint => uint) memberVoteValue;
2753	 mapping(uint => uint) abVoteValue;
2754	 uint voters;
2755	 }
2756	 struct DelegateVote {
2757	 address follower;
2758	 address leader;
2759	 uint lastUpd;
2760	 }
2761	 ProposalVote[] internal allVotes;
2762	 DelegateVote[] public allDelegation;
2763	 mapping(uint => ProposalData) internal allProposalData;
2764	 mapping(uint => bytes[]) internal allProposalSolutions;
2765	 mapping(address => uint[]) internal allVotesByMember;
2766	 mapping(uint => mapping(address => bool)) public rewardClaimed;
2767	 mapping(address => mapping(uint => uint)) public memberProposalVote;
2768	 mapping(address => uint) public followerDelegation;
2769	 mapping(address => uint) internal followerCount;
2770	 mapping(address => uint[]) internal leaderDelegation;
2771	 mapping(uint => VoteTally) public proposalVoteTally;
2772	 mapping(address => bool) public isOpenForDelegation;
2773	 mapping(address => uint) public lastRewardClaimed;
2774	 bool internal constructorCheck;
2775	 uint public tokenHoldingTime;
2776	 uint internal roleIdAllowedToCatgorize;
2777	 uint internal maxVoteWeigthPer;
2778	 uint internal specialResolutionMajPerc;
2779	 uint internal maxFollowers;
2780	 uint internal totalProposals;
2781	 uint internal maxDraftTime;
2782	 MemberRoles internal memberRole;
2783	 ProposalCategory internal proposalCategory;
2784	 TokenController internal tokenInstance;
2785	 mapping(uint => uint) public proposalActionStatus;
2786	 mapping(uint => uint) internal proposalExecutionTime;
2787	 mapping(uint => mapping(address => bool)) public proposalRejectedByAB;
2788	 mapping(uint => uint) internal actionRejectedCount;
2789	 bool internal actionParamsInitialised;
2790	 uint internal actionWaitingTime;
2791	 uint constant internal AB_MAJ_TO_REJECT_ACTION = 3;
2792	 enum ActionStatus {
2793	 Pending, Accepted, Rejected, Executed, NoAction }
2794	 event ActionFailed ( uint256 proposalId );
2795	 event ActionRejected ( uint256 indexed proposalId, address rejectedBy );
2796	 modifier onlyProposalOwner(uint _proposalId) {
2797	 require(msg.sender == allProposalData[_proposalId].owner, "Not allowed");
2798	 _;
2799	 }
2800	 modifier voteNotStarted(uint _proposalId) {
2801	 require(allProposalData[_proposalId].propStatus < uint(ProposalStatus.VotingStarted));
2802	 _;
2803	 }
2804	 modifier isAllowed(uint _categoryId) {
2805	 require(allowedToCreateProposal(_categoryId), "Not allowed");
2806	 _;
2807	 }
2808	 modifier isAllowedToCategorize() {
2809	 require(memberRole.checkRole(msg.sender, roleIdAllowedToCatgorize), "Not allowed");
2810	 _;
2811	 }
2812	 modifier checkPendingRewards {
2813	 require(getPendingReward(msg.sender) == 0, "Claim reward");
2814	 _;
2815	 }
2816	 event ProposalCategorized( uint indexed proposalId, address indexed categorizedBy, uint categoryId );
2817	 function removeDelegation(address _add) external onlyInternal {
2818	 _unDelegate(_add);
2819	 }
2820	 function createProposal( string calldata _proposalTitle, string calldata _proposalSD, string calldata _proposalDescHash, uint _categoryId ) external isAllowed(_categoryId) {
2821	 require(ms.isMember(msg.sender), "Not Member");
2822	 _createProposal(_proposalTitle, _proposalSD, _proposalDescHash, _categoryId);
2823	 }
2824	 function updateProposal( uint _proposalId, string calldata _proposalTitle, string calldata _proposalSD, string calldata _proposalDescHash ) external onlyProposalOwner(_proposalId) {
2825	 require( allProposalSolutions[_proposalId].length < 2, "Not allowed" );
2826	 allProposalData[_proposalId].propStatus = uint(ProposalStatus.Draft);
2827	 allProposalData[_proposalId].category = 0;
2828	 allProposalData[_proposalId].commonIncentive = 0;
2829	 emit Proposal( allProposalData[_proposalId].owner, _proposalId, now, _proposalTitle, _proposalSD, _proposalDescHash );
2830	 }
2831	 function categorizeProposal( uint _proposalId, uint _categoryId, uint _incentive ) external voteNotStarted(_proposalId) isAllowedToCategorize {
2832	 _categorizeProposal(_proposalId, _categoryId, _incentive);
2833	 }
2834	 function submitProposalWithSolution( uint _proposalId, string calldata _solutionHash, bytes calldata _action ) external onlyProposalOwner(_proposalId) {
2835	 require(allProposalData[_proposalId].propStatus == uint(ProposalStatus.AwaitingSolution));
2836	 _proposalSubmission(_proposalId, _solutionHash, _action);
2837	 }
2838	 function createProposalwithSolution( string calldata _proposalTitle, string calldata _proposalSD, string calldata _proposalDescHash, uint _categoryId, string calldata _solutionHash, bytes calldata _action ) external isAllowed(_categoryId) {
2839	 uint proposalId = totalProposals;
2840	 _createProposal(_proposalTitle, _proposalSD, _proposalDescHash, _categoryId);
2841	 require(_categoryId > 0);
2842	 _proposalSubmission( proposalId, _solutionHash, _action );
2843	 }
2844	 function submitVote(uint _proposalId, uint _solutionChosen) external {
2845	 require(allProposalData[_proposalId].propStatus == uint(Governance.ProposalStatus.VotingStarted), "Not allowed");
2846	 require(_solutionChosen < allProposalSolutions[_proposalId].length);
2847	 _submitVote(_proposalId, _solutionChosen);
2848	 }
2849	 function closeProposal(uint _proposalId) external {
2850	 uint category = allProposalData[_proposalId].category;
2851	 uint _memberRole;
2852	 if (allProposalData[_proposalId].dateUpd.add(maxDraftTime) <= now && allProposalData[_proposalId].propStatus < uint(ProposalStatus.VotingStarted)) {
2853	 _updateProposalStatus(_proposalId, uint(ProposalStatus.Denied));
2854	 }
2855	 else {
2856	 require(canCloseProposal(_proposalId) == 1);
2857	 (, _memberRole,,,,,) = proposalCategory.category(allProposalData[_proposalId].category);
2858	 if (_memberRole == uint(MemberRoles.Role.AdvisoryBoard)) {
2859	 _closeAdvisoryBoardVote(_proposalId, category);
2860	 }
2861	 else {
2862	 _closeMemberVote(_proposalId, category);
2863	 }
2864	 }
2865	 }
2866	 function claimReward(address _memberAddress, uint _maxRecords) external returns (uint pendingDAppReward) {
2867	 uint voteId;
2868	 address leader;
2869	 uint lastUpd;
2870	 require(msg.sender == ms.getLatestAddress("CR"));
2871	 uint delegationId = followerDelegation[_memberAddress];
2872	 DelegateVote memory delegationData = allDelegation[delegationId];
2873	 if (delegationId > 0 && delegationData.leader != address(0)) {
2874	 leader = delegationData.leader;
2875	 lastUpd = delegationData.lastUpd;
2876	 }
2877	 else leader = _memberAddress;
2878	 uint proposalId;
2879	 uint totalVotes = allVotesByMember[leader].length;
2880	 uint lastClaimed = totalVotes;
2881	 uint j;
2882	 uint i;
2883	 for (i = lastRewardClaimed[_memberAddress]; i < totalVotes && j < _maxRecords; i++) {
2884	 voteId = allVotesByMember[leader][i];
2885	 proposalId = allVotes[voteId].proposalId;
2886	 if (proposalVoteTally[proposalId].voters > 0 && (allVotes[voteId].dateAdd > ( lastUpd.add(tokenHoldingTime)) || leader == _memberAddress)) {
2887	 if (allProposalData[proposalId].propStatus > uint(ProposalStatus.VotingStarted)) {
2888	 if (!rewardClaimed[voteId][_memberAddress]) {
2889	 pendingDAppReward = pendingDAppReward.add( allProposalData[proposalId].commonIncentive.div( proposalVoteTally[proposalId].voters ) );
2890	 rewardClaimed[voteId][_memberAddress] = true;
2891	 j++;
2892	 }
2893	 }
2894	 else {
2895	 if (lastClaimed == totalVotes) {
2896	 lastClaimed = i;
2897	 }
2898	 }
2899	 }
2900	 }
2901	 if (lastClaimed == totalVotes) {
2902	 lastRewardClaimed[_memberAddress] = i;
2903	 }
2904	 else {
2905	 lastRewardClaimed[_memberAddress] = lastClaimed;
2906	 }
2907	 if (j > 0) {
2908	 emit RewardClaimed( _memberAddress, pendingDAppReward );
2909	 }
2910	 }
2911	 function setDelegationStatus(bool _status) external isMemberAndcheckPause checkPendingRewards {
2912	 isOpenForDelegation[msg.sender] = _status;
2913	 }
2914	 function delegateVote(address _add) external isMemberAndcheckPause checkPendingRewards {
2915	 require(ms.masterInitialized());
2916	 require(allDelegation[followerDelegation[_add]].leader == address(0));
2917	 if (followerDelegation[msg.sender] > 0) {
2918	 require((allDelegation[followerDelegation[msg.sender]].lastUpd).add(tokenHoldingTime) < now);
2919	 }
2920	 require(!alreadyDelegated(msg.sender));
2921	 require(!memberRole.checkRole(msg.sender, uint(MemberRoles.Role.Owner)));
2922	 require(!memberRole.checkRole(msg.sender, uint(MemberRoles.Role.AdvisoryBoard)));
2923	 require(followerCount[_add] < maxFollowers);
2924	 if (allVotesByMember[msg.sender].length > 0) {
2925	 require((allVotes[allVotesByMember[msg.sender][allVotesByMember[msg.sender].length - 1]].dateAdd).add(tokenHoldingTime) < now);
2926	 }
2927	 require(ms.isMember(_add));
2928	 require(isOpenForDelegation[_add]);
2929	 allDelegation.push(DelegateVote(msg.sender, _add, now));
2930	 followerDelegation[msg.sender] = allDelegation.length - 1;
2931	 leaderDelegation[_add].push(allDelegation.length - 1);
2932	 followerCount[_add]++;
2933	 lastRewardClaimed[msg.sender] = allVotesByMember[_add].length;
2934	 }
2935	 function unDelegate() external isMemberAndcheckPause checkPendingRewards {
2936	 _unDelegate(msg.sender);
2937	 }
2938	 function triggerAction(uint _proposalId) external {
2939	 require(proposalActionStatus[_proposalId] == uint(ActionStatus.Accepted) && proposalExecutionTime[_proposalId] <= now, "Cannot trigger");
2940	 _triggerAction(_proposalId, allProposalData[_proposalId].category);
2941	 }
2942	 function rejectAction(uint _proposalId) external {
2943	 require(memberRole.checkRole(msg.sender, uint(MemberRoles.Role.AdvisoryBoard)) && proposalExecutionTime[_proposalId] > now);
2944	 require(proposalActionStatus[_proposalId] == uint(ActionStatus.Accepted));
2945	 require(!proposalRejectedByAB[_proposalId][msg.sender]);
2946	 require( keccak256(proposalCategory.categoryActionHashes(allProposalData[_proposalId].category)) != keccak256(abi.encodeWithSignature("swapABMember(address,address)")) );
2947	 proposalRejectedByAB[_proposalId][msg.sender] = true;
2948	 actionRejectedCount[_proposalId]++;
2949	 emit ActionRejected(_proposalId, msg.sender);
2950	 if (actionRejectedCount[_proposalId] == AB_MAJ_TO_REJECT_ACTION) {
2951	 proposalActionStatus[_proposalId] = uint(ActionStatus.Rejected);
2952	 }
2953	 }
2954	 function setInitialActionParameters() external onlyOwner {
2955	 require(!actionParamsInitialised);
2956	 actionParamsInitialised = true;
2957	 actionWaitingTime = 24 * 1 hours;
2958	 }
2959	 function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val) {
2960	 codeVal = code;
2961	 if (code == "GOVHOLD") {
2962	 val = tokenHoldingTime / (1 days);
2963	 }
2964	 else if (code == "MAXFOL") {
2965	 val = maxFollowers;
2966	 }
2967	 else if (code == "MAXDRFT") {
2968	 val = maxDraftTime / (1 days);
2969	 }
2970	 else if (code == "EPTIME") {
2971	 val = ms.pauseTime() / (1 days);
2972	 }
2973	 else if (code == "ACWT") {
2974	 val = actionWaitingTime / (1 hours);
2975	 }
2976	 }
2977	 function proposal(uint _proposalId) external view returns ( uint proposalId, uint category, uint status, uint finalVerdict, uint totalRewar ) {
2978	 return ( _proposalId, allProposalData[_proposalId].category, allProposalData[_proposalId].propStatus, allProposalData[_proposalId].finalVerdict, allProposalData[_proposalId].commonIncentive );
2979	 }
2980	 function proposalDetails(uint _proposalId) external view returns (uint, uint, uint) {
2981	 return ( _proposalId, allProposalSolutions[_proposalId].length, proposalVoteTally[_proposalId].voters );
2982	 }
2983	 function getSolutionAction(uint _proposalId, uint _solution) external view returns (uint, bytes memory) {
2984	 return ( _solution, allProposalSolutions[_proposalId][_solution] );
2985	 }
2986	 function getProposalLength() external view returns (uint) {
2987	 return totalProposals;
2988	 }
2989	 function getFollowers(address _add) external view returns (uint[] memory) {
2990	 return leaderDelegation[_add];
2991	 }
2992	 function getPendingReward(address _memberAddress) public view returns (uint pendingDAppReward) {
2993	 uint delegationId = followerDelegation[_memberAddress];
2994	 address leader;
2995	 uint lastUpd;
2996	 DelegateVote memory delegationData = allDelegation[delegationId];
2997	 if (delegationId > 0 && delegationData.leader != address(0)) {
2998	 leader = delegationData.leader;
2999	 lastUpd = delegationData.lastUpd;
3000	 }
3001	 else leader = _memberAddress;
3002	 uint proposalId;
3003	 for (uint i = lastRewardClaimed[_memberAddress]; i < allVotesByMember[leader].length; i++) {
3004	 if (allVotes[allVotesByMember[leader][i]].dateAdd > ( lastUpd.add(tokenHoldingTime)) || leader == _memberAddress) {
3005	 if (!rewardClaimed[allVotesByMember[leader][i]][_memberAddress]) {
3006	 proposalId = allVotes[allVotesByMember[leader][i]].proposalId;
3007	 if (proposalVoteTally[proposalId].voters > 0 && allProposalData[proposalId].propStatus > uint(ProposalStatus.VotingStarted)) {
3008	 pendingDAppReward = pendingDAppReward.add( allProposalData[proposalId].commonIncentive.div( proposalVoteTally[proposalId].voters ) );
3009	 }
3010	 }
3011	 }
3012	 }
3013	 }
3014	 function updateUintParameters(bytes8 code, uint val) public {
3015	 require(ms.checkIsAuthToGoverned(msg.sender));
3016	 if (code == "GOVHOLD") {
3017	 tokenHoldingTime = val * 1 days;
3018	 }
3019	 else if (code == "MAXFOL") {
3020	 maxFollowers = val;
3021	 }
3022	 else if (code == "MAXDRFT") {
3023	 maxDraftTime = val * 1 days;
3024	 }
3025	 else if (code == "EPTIME") {
3026	 ms.updatePauseTime(val * 1 days);
3027	 }
3028	 else if (code == "ACWT") {
3029	 actionWaitingTime = val * 1 hours;
3030	 }
3031	 else {
3032	 revert("Invalid code");
3033	 }
3034	 }
3035	 function changeDependentContractAddress() public {
3036	 tokenInstance = TokenController(ms.dAppLocker());
3037	 memberRole = MemberRoles(ms.getLatestAddress("MR"));
3038	 proposalCategory = ProposalCategory(ms.getLatestAddress("PC"));
3039	 }
3040	 function allowedToCreateProposal(uint category) public view returns (bool check) {
3041	 if (category == 0) return true;
3042	 uint[] memory mrAllowed;
3043	 (,,,, mrAllowed,,) = proposalCategory.category(category);
3044	 for (uint i = 0; i < mrAllowed.length; i++) {
3045	 if (mrAllowed[i] == 0 || memberRole.checkRole(msg.sender, mrAllowed[i])) return true;
3046	 }
3047	 }
3048	 function alreadyDelegated(address _add) public view returns (bool delegated) {
3049	 for (uint i = 0; i < leaderDelegation[_add].length; i++) {
3050	 if (allDelegation[leaderDelegation[_add][i]].leader == _add) {
3051	 return true;
3052	 }
3053	 }
3054	 }
3055	 function canCloseProposal(uint _proposalId) public view returns (uint) {
3056	 uint dateUpdate;
3057	 uint pStatus;
3058	 uint _closingTime;
3059	 uint _roleId;
3060	 uint majority;
3061	 pStatus = allProposalData[_proposalId].propStatus;
3062	 dateUpdate = allProposalData[_proposalId].dateUpd;
3063	 (, _roleId, majority, , , _closingTime,) = proposalCategory.category(allProposalData[_proposalId].category);
3064	 if ( pStatus == uint(ProposalStatus.VotingStarted) ) {
3065	 uint numberOfMembers = memberRole.numberOfMembers(_roleId);
3066	 if (_roleId == uint(MemberRoles.Role.AdvisoryBoard)) {
3067	 if (proposalVoteTally[_proposalId].abVoteValue[1].mul(100).div(numberOfMembers) >= majority || proposalVoteTally[_proposalId].abVoteValue[1].add(proposalVoteTally[_proposalId].abVoteValue[0]) == numberOfMembers || dateUpdate.add(_closingTime) <= now) {
3068	 return 1;
3069	 }
3070	 }
3071	 else {
3072	 if (numberOfMembers == proposalVoteTally[_proposalId].voters || dateUpdate.add(_closingTime) <= now) return 1;
3073	 }
3074	 }
3075	 else if (pStatus > uint(ProposalStatus.VotingStarted)) {
3076	 return 2;
3077	 }
3078	 else {
3079	 return 0;
3080	 }
3081	 }
3082	 function allowedToCatgorize() public view returns (uint roleId) {
3083	 return roleIdAllowedToCatgorize;
3084	 }
3085	 function voteTallyData(uint _proposalId, uint _solution) public view returns (uint, uint, uint) {
3086	 return (proposalVoteTally[_proposalId].memberVoteValue[_solution], proposalVoteTally[_proposalId].abVoteValue[_solution], proposalVoteTally[_proposalId].voters);
3087	 }
3088	 function _createProposal( string memory _proposalTitle, string memory _proposalSD, string memory _proposalDescHash, uint _categoryId ) internal {
3089	 require(proposalCategory.categoryABReq(_categoryId) == 0 || _categoryId == 0);
3090	 uint _proposalId = totalProposals;
3091	 allProposalData[_proposalId].owner = msg.sender;
3092	 allProposalData[_proposalId].dateUpd = now;
3093	 allProposalSolutions[_proposalId].push("");
3094	 totalProposals++;
3095	 emit Proposal( msg.sender, _proposalId, now, _proposalTitle, _proposalSD, _proposalDescHash );
3096	 if (_categoryId > 0) _categorizeProposal(_proposalId, _categoryId, 0);
3097	 }
3098	 function _categorizeProposal( uint _proposalId, uint _categoryId, uint _incentive ) internal {
3099	 require( _categoryId > 0 && _categoryId < proposalCategory.totalCategories(), "Invalid category" );
3100	 allProposalData[_proposalId].category = _categoryId;
3101	 allProposalData[_proposalId].commonIncentive = _incentive;
3102	 allProposalData[_proposalId].propStatus = uint(ProposalStatus.AwaitingSolution);
3103	 emit ProposalCategorized(_proposalId, msg.sender, _categoryId);
3104	 }
3105	 function _addSolution(uint _proposalId, bytes memory _action, string memory _solutionHash) internal {
3106	 allProposalSolutions[_proposalId].push(_action);
3107	 emit Solution(_proposalId, msg.sender, allProposalSolutions[_proposalId].length - 1, _solutionHash, now);
3108	 }
3109	 function _proposalSubmission( uint _proposalId, string memory _solutionHash, bytes memory _action ) internal {
3110	 uint _categoryId = allProposalData[_proposalId].category;
3111	 if (proposalCategory.categoryActionHashes(_categoryId).length == 0) {
3112	 require(keccak256(_action) == keccak256(""));
3113	 proposalActionStatus[_proposalId] = uint(ActionStatus.NoAction);
3114	 }
3115	 _addSolution( _proposalId, _action, _solutionHash );
3116	 _updateProposalStatus(_proposalId, uint(ProposalStatus.VotingStarted));
3117	 (, , , , , uint closingTime,) = proposalCategory.category(_categoryId);
3118	 emit CloseProposalOnTime(_proposalId, closingTime.add(now));
3119	 }
3120	 function _submitVote(uint _proposalId, uint _solution) internal {
3121	 uint delegationId = followerDelegation[msg.sender];
3122	 uint mrSequence;
3123	 uint majority;
3124	 uint closingTime;
3125	 (, mrSequence, majority, , , closingTime,) = proposalCategory.category(allProposalData[_proposalId].category);
3126	 require(allProposalData[_proposalId].dateUpd.add(closingTime) > now, "Closed");
3127	 require(memberProposalVote[msg.sender][_proposalId] == 0, "Not allowed");
3128	 require((delegationId == 0) || (delegationId > 0 && allDelegation[delegationId].leader == address(0) && _checkLastUpd(allDelegation[delegationId].lastUpd)));
3129	 require(memberRole.checkRole(msg.sender, mrSequence), "Not Authorized");
3130	 uint totalVotes = allVotes.length;
3131	 allVotesByMember[msg.sender].push(totalVotes);
3132	 memberProposalVote[msg.sender][_proposalId] = totalVotes;
3133	 allVotes.push(ProposalVote(msg.sender, _proposalId, now));
3134	 emit Vote(msg.sender, _proposalId, totalVotes, now, _solution);
3135	 if (mrSequence == uint(MemberRoles.Role.Owner)) {
3136	 if (_solution == 1) _callIfMajReached(_proposalId, uint(ProposalStatus.Accepted), allProposalData[_proposalId].category, 1, MemberRoles.Role.Owner);
3137	 else _updateProposalStatus(_proposalId, uint(ProposalStatus.Rejected));
3138	 }
3139	 else {
3140	 uint numberOfMembers = memberRole.numberOfMembers(mrSequence);
3141	 _setVoteTally(_proposalId, _solution, mrSequence);
3142	 if (mrSequence == uint(MemberRoles.Role.AdvisoryBoard)) {
3143	 if (proposalVoteTally[_proposalId].abVoteValue[1].mul(100).div(numberOfMembers) >= majority || (proposalVoteTally[_proposalId].abVoteValue[1].add(proposalVoteTally[_proposalId].abVoteValue[0])) == numberOfMembers) {
3144	 emit VoteCast(_proposalId);
3145	 }
3146	 }
3147	 else {
3148	 if (numberOfMembers == proposalVoteTally[_proposalId].voters) emit VoteCast(_proposalId);
3149	 }
3150	 }
3151	 }
3152	 function _setVoteTally(uint _proposalId, uint _solution, uint mrSequence) internal {
3153	 uint categoryABReq;
3154	 uint isSpecialResolution;
3155	 (, categoryABReq, isSpecialResolution) = proposalCategory.categoryExtendedData(allProposalData[_proposalId].category);
3156	 if (memberRole.checkRole(msg.sender, uint(MemberRoles.Role.AdvisoryBoard)) && (categoryABReq > 0) || mrSequence == uint(MemberRoles.Role.AdvisoryBoard)) {
3157	 proposalVoteTally[_proposalId].abVoteValue[_solution]++;
3158	 }
3159	 tokenInstance.lockForMemberVote(msg.sender, tokenHoldingTime);
3160	 if (mrSequence != uint(MemberRoles.Role.AdvisoryBoard)) {
3161	 uint voteWeight;
3162	 uint voters = 1;
3163	 uint tokenBalance = tokenInstance.totalBalanceOf(msg.sender);
3164	 uint totalSupply = tokenInstance.totalSupply();
3165	 if (isSpecialResolution == 1) {
3166	 voteWeight = tokenBalance.add(10 ** 18);
3167	 }
3168	 else {
3169	 voteWeight = (_minOf(tokenBalance, maxVoteWeigthPer.mul(totalSupply).div(100))).add(10 ** 18);
3170	 }
3171	 DelegateVote memory delegationData;
3172	 for (uint i = 0; i < leaderDelegation[msg.sender].length; i++) {
3173	 delegationData = allDelegation[leaderDelegation[msg.sender][i]];
3174	 if (delegationData.leader == msg.sender && _checkLastUpd(delegationData.lastUpd)) {
3175	 if (memberRole.checkRole(delegationData.follower, mrSequence)) {
3176	 tokenBalance = tokenInstance.totalBalanceOf(delegationData.follower);
3177	 tokenInstance.lockForMemberVote(delegationData.follower, tokenHoldingTime);
3178	 voters++;
3179	 if (isSpecialResolution == 1) {
3180	 voteWeight = voteWeight.add(tokenBalance.add(10 ** 18));
3181	 }
3182	 else {
3183	 voteWeight = voteWeight.add((_minOf(tokenBalance, maxVoteWeigthPer.mul(totalSupply).div(100))).add(10 ** 18));
3184	 }
3185	 }
3186	 }
3187	 }
3188	 proposalVoteTally[_proposalId].memberVoteValue[_solution] = proposalVoteTally[_proposalId].memberVoteValue[_solution].add(voteWeight);
3189	 proposalVoteTally[_proposalId].voters = proposalVoteTally[_proposalId].voters + voters;
3190	 }
3191	 }
3192	 function _minOf(uint a, uint b) internal pure returns (uint res) {
3193	 res = a;
3194	 if (res > b) res = b;
3195	 }
3196	 function _checkLastUpd(uint _lastUpd) internal view returns (bool) {
3197	 return (now - _lastUpd) > tokenHoldingTime;
3198	 }
3199	 function _checkForThreshold(uint _proposalId, uint _category) internal view returns (bool check) {
3200	 uint categoryQuorumPerc;
3201	 uint roleAuthorized;
3202	 (, roleAuthorized, , categoryQuorumPerc, , ,) = proposalCategory.category(_category);
3203	 check = ((proposalVoteTally[_proposalId].memberVoteValue[0] .add(proposalVoteTally[_proposalId].memberVoteValue[1])) .mul(100)) .div( tokenInstance.totalSupply().add( memberRole.numberOfMembers(roleAuthorized).mul(10 ** 18) ) ) >= categoryQuorumPerc;
3204	 }
3205	 function _callIfMajReached(uint _proposalId, uint _status, uint category, uint max, MemberRoles.Role role) internal {
3206	 allProposalData[_proposalId].finalVerdict = max;
3207	 _updateProposalStatus(_proposalId, _status);
3208	 emit ProposalAccepted(_proposalId);
3209	 if (proposalActionStatus[_proposalId] != uint(ActionStatus.NoAction)) {
3210	 if (role == MemberRoles.Role.AdvisoryBoard) {
3211	 _triggerAction(_proposalId, category);
3212	 }
3213	 else {
3214	 proposalActionStatus[_proposalId] = uint(ActionStatus.Accepted);
3215	 proposalExecutionTime[_proposalId] = actionWaitingTime.add(now);
3216	 }
3217	 }
3218	 }
3219	 function _triggerAction(uint _proposalId, uint _categoryId) internal {
3220	 proposalActionStatus[_proposalId] = uint(ActionStatus.Executed);
3221	 bytes2 contractName;
3222	 address actionAddress;
3223	 bytes memory _functionHash;
3224	 (, actionAddress, contractName, , _functionHash) = proposalCategory.categoryActionDetails(_categoryId);
3225	 if (contractName == "MS") {
3226	 actionAddress = address(ms);
3227	 }
3228	 else if (contractName != "EX") {
3229	 actionAddress = ms.getLatestAddress(contractName);
3230	 }
3231	 (bool actionStatus,) = actionAddress.call(abi.encodePacked(_functionHash, allProposalSolutions[_proposalId][1]));
3232	 if (actionStatus) {
3233	 emit ActionSuccess(_proposalId);
3234	 }
3235	 else {
3236	 proposalActionStatus[_proposalId] = uint(ActionStatus.Accepted);
3237	 emit ActionFailed(_proposalId);
3238	 }
3239	 }
3240	 function _updateProposalStatus(uint _proposalId, uint _status) internal {
3241	 if (_status == uint(ProposalStatus.Rejected) || _status == uint(ProposalStatus.Denied)) {
3242	 proposalActionStatus[_proposalId] = uint(ActionStatus.NoAction);
3243	 }
3244	 allProposalData[_proposalId].dateUpd = now;
3245	 allProposalData[_proposalId].propStatus = _status;
3246	 }
3247	 function _unDelegate(address _follower) internal {
3248	 uint followerId = followerDelegation[_follower];
3249	 if (followerId > 0) {
3250	 followerCount[allDelegation[followerId].leader] = followerCount[allDelegation[followerId].leader].sub(1);
3251	 allDelegation[followerId].leader = address(0);
3252	 allDelegation[followerId].lastUpd = now;
3253	 lastRewardClaimed[_follower] = allVotesByMember[_follower].length;
3254	 }
3255	 }
3256	 function _closeMemberVote(uint _proposalId, uint category) internal {
3257	 uint isSpecialResolution;
3258	 uint abMaj;
3259	 (, abMaj, isSpecialResolution) = proposalCategory.categoryExtendedData(category);
3260	 if (isSpecialResolution == 1) {
3261	 uint acceptedVotePerc = proposalVoteTally[_proposalId].memberVoteValue[1].mul(100) .div( tokenInstance.totalSupply().add( memberRole.numberOfMembers(uint(MemberRoles.Role.Member)).mul(10 ** 18) ));
3262	 if (acceptedVotePerc >= specialResolutionMajPerc) {
3263	 _callIfMajReached(_proposalId, uint(ProposalStatus.Accepted), category, 1, MemberRoles.Role.Member);
3264	 }
3265	 else {
3266	 _updateProposalStatus(_proposalId, uint(ProposalStatus.Denied));
3267	 }
3268	 }
3269	 else {
3270	 if (_checkForThreshold(_proposalId, category)) {
3271	 uint majorityVote;
3272	 (,, majorityVote,,,,) = proposalCategory.category(category);
3273	 if ( ((proposalVoteTally[_proposalId].memberVoteValue[1].mul(100)) .div(proposalVoteTally[_proposalId].memberVoteValue[0] .add(proposalVoteTally[_proposalId].memberVoteValue[1]) )) >= majorityVote ) {
3274	 _callIfMajReached(_proposalId, uint(ProposalStatus.Accepted), category, 1, MemberRoles.Role.Member);
3275	 }
3276	 else {
3277	 _updateProposalStatus(_proposalId, uint(ProposalStatus.Rejected));
3278	 }
3279	 }
3280	 else {
3281	 if (abMaj > 0 && proposalVoteTally[_proposalId].abVoteValue[1].mul(100) .div(memberRole.numberOfMembers(uint(MemberRoles.Role.AdvisoryBoard))) >= abMaj) {
3282	 _callIfMajReached(_proposalId, uint(ProposalStatus.Accepted), category, 1, MemberRoles.Role.Member);
3283	 }
3284	 else {
3285	 _updateProposalStatus(_proposalId, uint(ProposalStatus.Denied));
3286	 }
3287	 }
3288	 }
3289	 if (proposalVoteTally[_proposalId].voters > 0) {
3290	 tokenInstance.mint(ms.getLatestAddress("CR"), allProposalData[_proposalId].commonIncentive);
3291	 }
3292	 }
3293	 function _closeAdvisoryBoardVote(uint _proposalId, uint category) internal {
3294	 uint _majorityVote;
3295	 MemberRoles.Role _roleId = MemberRoles.Role.AdvisoryBoard;
3296	 (,, _majorityVote,,,,) = proposalCategory.category(category);
3297	 if (proposalVoteTally[_proposalId].abVoteValue[1].mul(100) .div(memberRole.numberOfMembers(uint(_roleId))) >= _majorityVote) {
3298	 _callIfMajReached(_proposalId, uint(ProposalStatus.Accepted), category, 1, _roleId);
3299	 }
3300	 else {
3301	 _updateProposalStatus(_proposalId, uint(ProposalStatus.Denied));
3302	 }
3303	 }
3304	 }
3305	 function setClaimStatus(uint claimId, uint stat) external onlyInternal {
3306	 _setClaimStatus(claimId, stat);
3307	 }
3308	 function getCATokens(uint claimId, uint member) external view returns (uint tokens) {
3309	 uint coverId;
3310	 (, coverId) = cd.getClaimCoverId(claimId);
3311	 bytes4 currency = qd.getCurrencyOfCover(coverId);
3312	 address asset = cr.getCurrencyAssetAddress(currency);
3313	 uint tokenx1e18 = p1.getTokenPrice(asset);
3314	 uint accept;
3315	 uint deny;
3316	 if (member == 0) {
3317	 (, accept, deny) = cd.getClaimsTokenCA(claimId);
3318	 }
3319	 else {
3320	 (, accept, deny) = cd.getClaimsTokenMV(claimId);
3321	 }
3322	 tokens = ((accept.add(deny)).mul(tokenx1e18)).div(DECIMAL1E18);
3323	 }
3324	 function changeDependentContractAddress() public onlyInternal {
3325	 td = TokenData(ms.getLatestAddress("TD"));
3326	 tc = TokenController(ms.getLatestAddress("TC"));
3327	 p1 = Pool(ms.getLatestAddress("P1"));
3328	 cr = ClaimsReward(ms.getLatestAddress("CR"));
3329	 cd = ClaimsData(ms.getLatestAddress("CD"));
3330	 qd = QuotationData(ms.getLatestAddress("QD"));
3331	 incidents = Incidents(ms.getLatestAddress("IC"));
3332	 }
3333	 function submitClaim(uint coverId) external {
3334	 _submitClaim(coverId, msg.sender);
3335	 }
3336	 function submitClaimForMember(uint coverId, address member) external onlyInternal {
3337	 _submitClaim(coverId, member);
3338	 }
3339	 function _submitClaim(uint coverId, address member) internal {
3340	 require(!ms.isPause(), "Claims: System is paused");
3341	 (, address contractAddress) = qd.getscAddressOfCover(coverId);
3342	 address token = incidents.coveredToken(contractAddress);
3343	 require(token == address(0), "Claims: Product type does not allow claims");
3344	 address coverOwner = qd.getCoverMemberAddress(coverId);
3345	 require(coverOwner == member, "Claims: Not cover owner");
3346	 uint expirationDate = qd.getValidityOfCover(coverId);
3347	 uint gracePeriod = tc.claimSubmissionGracePeriod();
3348	 require(expirationDate.add(gracePeriod) > now, "Claims: Grace period has expired");
3349	 tc.markCoverClaimOpen(coverId);
3350	 qd.changeCoverStatusNo(coverId, uint8(QuotationData.CoverStatus.ClaimSubmitted));
3351	 uint claimId = cd.actualClaimLength();
3352	 cd.addClaim(claimId, coverId, coverOwner, now);
3353	 cd.callClaimEvent(coverId, coverOwner, claimId, now);
3354	 }
3355	 function submitClaimAfterEPOff() external pure {
3356	 }
3357	 function submitCAVote(uint claimId, int8 verdict) public isMemberAndcheckPause {
3358	 require(checkVoteClosing(claimId) != 1);
3359	 require(cd.userClaimVotePausedOn(msg.sender).add(cd.pauseDaysCA()) < now);
3360	 uint tokens = tc.tokensLockedAtTime(msg.sender, "CLA", now.add(cd.claimDepositTime()));
3361	 require(tokens > 0);
3362	 uint stat;
3363	 (, stat) = cd.getClaimStatusNumber(claimId);
3364	 require(stat == 0);
3365	 require(cd.getUserClaimVoteCA(msg.sender, claimId) == 0);
3366	 td.bookCATokens(msg.sender);
3367	 cd.addVote(msg.sender, tokens, claimId, verdict);
3368	 cd.callVoteEvent(msg.sender, claimId, "CAV", tokens, now, verdict);
3369	 uint voteLength = cd.getAllVoteLength();
3370	 cd.addClaimVoteCA(claimId, voteLength);
3371	 cd.setUserClaimVoteCA(msg.sender, claimId, voteLength);
3372	 cd.setClaimTokensCA(claimId, verdict, tokens);
3373	 tc.extendLockOf(msg.sender, "CLA", td.lockCADays());
3374	 int close = checkVoteClosing(claimId);
3375	 if (close == 1) {
3376	 cr.changeClaimStatus(claimId);
3377	 }
3378	 }
3379	 function submitMemberVote(uint claimId, int8 verdict) public isMemberAndcheckPause {
3380	 require(checkVoteClosing(claimId) != 1);
3381	 uint stat;
3382	 uint tokens = tc.totalBalanceOf(msg.sender);
3383	 (, stat) = cd.getClaimStatusNumber(claimId);
3384	 require(stat >= 1 && stat <= 5);
3385	 require(cd.getUserClaimVoteMember(msg.sender, claimId) == 0);
3386	 cd.addVote(msg.sender, tokens, claimId, verdict);
3387	 cd.callVoteEvent(msg.sender, claimId, "MV", tokens, now, verdict);
3388	 tc.lockForMemberVote(msg.sender, td.lockMVDays());
3389	 uint voteLength = cd.getAllVoteLength();
3390	 cd.addClaimVotemember(claimId, voteLength);
3391	 cd.setUserClaimVoteMember(msg.sender, claimId, voteLength);
3392	 cd.setClaimTokensMV(claimId, verdict, tokens);
3393	 int close = checkVoteClosing(claimId);
3394	 if (close == 1) {
3395	 cr.changeClaimStatus(claimId);
3396	 }
3397	 }
3398	 function pauseAllPendingClaimsVoting() external pure {
3399	 }
3400	 function startAllPendingClaimsVoting() external pure {
3401	 }
3402	 function checkVoteClosing(uint claimId) public view returns (int8 close) {
3403	 close = 0;
3404	 uint status;
3405	 (, status) = cd.getClaimStatusNumber(claimId);
3406	 uint dateUpd = cd.getClaimDateUpd(claimId);
3407	 if (status == 12 && dateUpd.add(cd.payoutRetryTime()) < now) {
3408	 if (cd.getClaimState12Count(claimId) < 60) close = 1;
3409	 }
3410	 if (status > 5 && status != 12) {
3411	 close = - 1;
3412	 }
3413	 else if (status != 12 && dateUpd.add(cd.maxVotingTime()) <= now) {
3414	 close = 1;
3415	 }
3416	 else if (status != 12 && dateUpd.add(cd.minVotingTime()) >= now) {
3417	 close = 0;
3418	 }
3419	 else if (status == 0 || (status >= 1 && status <= 5)) {
3420	 close = _checkVoteClosingFinal(claimId, status);
3421	 }
3422	 }
3423	 function _checkVoteClosingFinal(uint claimId, uint status) internal view returns (int8 close) {
3424	 close = 0;
3425	 uint coverId;
3426	 (, coverId) = cd.getClaimCoverId(claimId);
3427	 bytes4 currency = qd.getCurrencyOfCover(coverId);
3428	 address asset = cr.getCurrencyAssetAddress(currency);
3429	 uint tokenx1e18 = p1.getTokenPrice(asset);
3430	 uint accept;
3431	 uint deny;
3432	 (, accept, deny) = cd.getClaimsTokenCA(claimId);
3433	 uint caTokens = ((accept.add(deny)).mul(tokenx1e18)).div(DECIMAL1E18);
3434	 (, accept, deny) = cd.getClaimsTokenMV(claimId);
3435	 uint mvTokens = ((accept.add(deny)).mul(tokenx1e18)).div(DECIMAL1E18);
3436	 uint sumassured = qd.getCoverSumAssured(coverId).mul(DECIMAL1E18);
3437	 if (status == 0 && caTokens >= sumassured.mul(10)) {
3438	 close = 1;
3439	 }
3440	 else if (status >= 1 && status <= 5 && mvTokens >= sumassured.mul(10)) {
3441	 close = 1;
3442	 }
3443	 }
3444	 function _setClaimStatus(uint claimId, uint stat) internal {
3445	 uint origstat;
3446	 uint state12Count;
3447	 uint dateUpd;
3448	 uint coverId;
3449	 (, coverId, , origstat, dateUpd, state12Count) = cd.getClaim(claimId);
3450	 (, origstat) = cd.getClaimStatusNumber(claimId);
3451	 if (stat == 12 && origstat == 12) {
3452	 cd.updateState12Count(claimId, 1);
3453	 }
3454	 cd.setClaimStatus(claimId, stat);
3455	 if (state12Count >= 60 && stat == 12) {
3456	 cd.setClaimStatus(claimId, 13);
3457	 qd.changeCoverStatusNo(coverId, uint8(QuotationData.CoverStatus.ClaimDenied));
3458	 }
3459	 cd.setClaimdateUpd(claimId, now);
3460	 }
3461	 }
3462	 function addCategory( string calldata _name, uint _memberRoleToVote, uint _majorityVotePerc, uint _quorumPerc, uint[] calldata _allowedToCreateProposal, uint _closingTime, string calldata _actionHash, address _contractAddress, bytes2 _contractName, uint[] calldata _incentives ) external {
3463	 }
3464	 function proposalCategoryInitiate() external {
3465	 }
3466	 function updateCategoryActionHashes() external onlyOwner {
3467	 require(!categoryActionHashUpdated, "Category action hashes already updated");
3468	 categoryActionHashUpdated = true;
3469	 categoryActionHashes[1] = abi.encodeWithSignature("addRole(bytes32,string,address)");
3470	 categoryActionHashes[2] = abi.encodeWithSignature("updateRole(address,uint256,bool)");
3471	 categoryActionHashes[3] = abi.encodeWithSignature("newCategory(string,uint256,uint256,uint256,uint256[],uint256,string,address,bytes2,uint256[],string)");
3472	 categoryActionHashes[4] = abi.encodeWithSignature("editCategory(uint256,string,uint256,uint256,uint256,uint256[],uint256,string,address,bytes2,uint256[],string)");
3473	 categoryActionHashes[5] = abi.encodeWithSignature("upgradeContractImplementation(bytes2,address)");
3474	 categoryActionHashes[6] = abi.encodeWithSignature("startEmergencyPause()");
3475	 categoryActionHashes[7] = abi.encodeWithSignature("addEmergencyPause(bool,bytes4)");
3476	 categoryActionHashes[8] = abi.encodeWithSignature("burnCAToken(uint256,uint256,address)");
3477	 categoryActionHashes[9] = abi.encodeWithSignature("setUserClaimVotePausedOn(address)");
3478	 categoryActionHashes[12] = abi.encodeWithSignature("transferEther(uint256,address)");
3479	 categoryActionHashes[13] = abi.encodeWithSignature("addInvestmentAssetCurrency(bytes4,address,bool,uint64,uint64,uint8)");
3480	 categoryActionHashes[14] = abi.encodeWithSignature("changeInvestmentAssetHoldingPerc(bytes4,uint64,uint64)");
3481	 categoryActionHashes[15] = abi.encodeWithSignature("changeInvestmentAssetStatus(bytes4,bool)");
3482	 categoryActionHashes[16] = abi.encodeWithSignature("swapABMember(address,address)");
3483	 categoryActionHashes[17] = abi.encodeWithSignature("addCurrencyAssetCurrency(bytes4,address,uint256)");
3484	 categoryActionHashes[20] = abi.encodeWithSignature("updateUintParameters(bytes8,uint256)");
3485	 categoryActionHashes[21] = abi.encodeWithSignature("updateUintParameters(bytes8,uint256)");
3486	 categoryActionHashes[22] = abi.encodeWithSignature("updateUintParameters(bytes8,uint256)");
3487	 categoryActionHashes[23] = abi.encodeWithSignature("updateUintParameters(bytes8,uint256)");
3488	 categoryActionHashes[24] = abi.encodeWithSignature("updateUintParameters(bytes8,uint256)");
3489	 categoryActionHashes[25] = abi.encodeWithSignature("updateUintParameters(bytes8,uint256)");
3490	 categoryActionHashes[26] = abi.encodeWithSignature("updateUintParameters(bytes8,uint256)");
3491	 categoryActionHashes[27] = abi.encodeWithSignature("updateAddressParameters(bytes8,address)");
3492	 categoryActionHashes[28] = abi.encodeWithSignature("updateOwnerParameters(bytes8,address)");
3493	 categoryActionHashes[29] = abi.encodeWithSignature("upgradeMultipleContracts(bytes2[],address[])");
3494	 categoryActionHashes[30] = abi.encodeWithSignature("changeCurrencyAssetAddress(bytes4,address)");
3495	 categoryActionHashes[31] = abi.encodeWithSignature("changeCurrencyAssetBaseMin(bytes4,uint256)");
3496	 categoryActionHashes[32] = abi.encodeWithSignature("changeInvestmentAssetAddressAndDecimal(bytes4,address,uint8)");
3497	 categoryActionHashes[33] = abi.encodeWithSignature("externalLiquidityTrade()");
3498	 }
3499	 function totalCategories() external view returns (uint) {
3500	 return allCategory.length;
3501	 }
3502	 function category(uint _categoryId) external view returns (uint, uint, uint, uint, uint[] memory, uint, uint) {
3503	 return ( _categoryId, allCategory[_categoryId].memberRoleToVote, allCategory[_categoryId].majorityVotePerc, allCategory[_categoryId].quorumPerc, allCategory[_categoryId].allowedToCreateProposal, allCategory[_categoryId].closingTime, allCategory[_categoryId].minStake );
3504	 }
3505	 function categoryExtendedData(uint _categoryId) external view returns (uint, uint, uint) {
3506	 return ( _categoryId, categoryABReq[_categoryId], isSpecialResolution[_categoryId] );
3507	 }
3508	 function categoryAction(uint _categoryId) external view returns (uint, address, bytes2, uint) {
3509	 return ( _categoryId, categoryActionData[_categoryId].contractAddress, categoryActionData[_categoryId].contractName, categoryActionData[_categoryId].defaultIncentive );
3510	 }
3511	 function categoryActionDetails(uint _categoryId) external view returns (uint, address, bytes2, uint, bytes memory) {
3512	 return ( _categoryId, categoryActionData[_categoryId].contractAddress, categoryActionData[_categoryId].contractName, categoryActionData[_categoryId].defaultIncentive, categoryActionHashes[_categoryId] );
3513	 }
3514	 function changeDependentContractAddress() public {
3515	 mr = MemberRoles(ms.getLatestAddress("MR"));
3516	 }
3517	 function newCategory( string memory _name, uint _memberRoleToVote, uint _majorityVotePerc, uint _quorumPerc, uint[] memory _allowedToCreateProposal, uint _closingTime, string memory _actionHash, address _contractAddress, bytes2 _contractName, uint[] memory _incentives, string memory _functionHash ) public onlyAuthorizedToGovern {
3518	 require(_quorumPerc <= 100 && _majorityVotePerc <= 100, "Invalid percentage");
3519	 require((_contractName == "EX" && _contractAddress == address(0)) || bytes(_functionHash).length > 0);
3520	 require(_incentives[3] <= 1, "Invalid special resolution flag");
3521	 if (_incentives[3] == 1) {
3522	 require(_memberRoleToVote == uint(MemberRoles.Role.Member));
3523	 _majorityVotePerc = 0;
3524	 _quorumPerc = 0;
3525	 }
3526	 _addCategory( _name, _memberRoleToVote, _majorityVotePerc, _quorumPerc, _allowedToCreateProposal, _closingTime, _actionHash, _contractAddress, _contractName, _incentives );
3527	 if (bytes(_functionHash).length > 0 && abi.encodeWithSignature(_functionHash).length == 4) {
3528	 categoryActionHashes[allCategory.length - 1] = abi.encodeWithSignature(_functionHash);
3529	 }
3530	 }
3531	 function changeMasterAddress(address _masterAddress) public {
3532	 if (masterAddress != address(0)) require(masterAddress == msg.sender);
3533	 masterAddress = _masterAddress;
3534	 ms = INXMMaster(_masterAddress);
3535	 nxMasterAddress = _masterAddress;
3536	 }
3537	 function updateCategory( uint _categoryId, string memory _name, uint _memberRoleToVote, uint _majorityVotePerc, uint _quorumPerc, uint[] memory _allowedToCreateProposal, uint _closingTime, string memory _actionHash, address _contractAddress, bytes2 _contractName, uint[] memory _incentives ) public {
3538	 }
3539	 function editCategory( uint _categoryId, string memory _name, uint _memberRoleToVote, uint _majorityVotePerc, uint _quorumPerc, uint[] memory _allowedToCreateProposal, uint _closingTime, string memory _actionHash, address _contractAddress, bytes2 _contractName, uint[] memory _incentives, string memory _functionHash ) public onlyAuthorizedToGovern {
3540	 require(_verifyMemberRoles(_memberRoleToVote, _allowedToCreateProposal) == 1, "Invalid Role");
3541	 require(_quorumPerc <= 100 && _majorityVotePerc <= 100, "Invalid percentage");
3542	 require((_contractName == "EX" && _contractAddress == address(0)) || bytes(_functionHash).length > 0);
3543	 require(_incentives[3] <= 1, "Invalid special resolution flag");
3544	 if (_incentives[3] == 1) {
3545	 require(_memberRoleToVote == uint(MemberRoles.Role.Member));
3546	 _majorityVotePerc = 0;
3547	 _quorumPerc = 0;
3548	 }
3549	 delete categoryActionHashes[_categoryId];
3550	 if (bytes(_functionHash).length > 0 && abi.encodeWithSignature(_functionHash).length == 4) {
3551	 categoryActionHashes[_categoryId] = abi.encodeWithSignature(_functionHash);
3552	 }
3553	 allCategory[_categoryId].memberRoleToVote = _memberRoleToVote;
3554	 allCategory[_categoryId].majorityVotePerc = _majorityVotePerc;
3555	 allCategory[_categoryId].closingTime = _closingTime;
3556	 allCategory[_categoryId].allowedToCreateProposal = _allowedToCreateProposal;
3557	 allCategory[_categoryId].minStake = _incentives[0];
3558	 allCategory[_categoryId].quorumPerc = _quorumPerc;
3559	 categoryActionData[_categoryId].defaultIncentive = _incentives[1];
3560	 categoryActionData[_categoryId].contractName = _contractName;
3561	 categoryActionData[_categoryId].contractAddress = _contractAddress;
3562	 categoryABReq[_categoryId] = _incentives[2];
3563	 isSpecialResolution[_categoryId] = _incentives[3];
3564	 emit Category(_categoryId, _name, _actionHash);
3565	 }
3566	 function _addCategory( string memory _name, uint _memberRoleToVote, uint _majorityVotePerc, uint _quorumPerc, uint[] memory _allowedToCreateProposal, uint _closingTime, string memory _actionHash, address _contractAddress, bytes2 _contractName, uint[] memory _incentives ) internal {
3567	 require(_verifyMemberRoles(_memberRoleToVote, _allowedToCreateProposal) == 1, "Invalid Role");
3568	 allCategory.push( CategoryStruct( _memberRoleToVote, _majorityVotePerc, _quorumPerc, _allowedToCreateProposal, _closingTime, _incentives[0] ) );
3569	 uint categoryId = allCategory.length - 1;
3570	 categoryActionData[categoryId] = CategoryAction(_incentives[1], _contractAddress, _contractName);
3571	 categoryABReq[categoryId] = _incentives[2];
3572	 isSpecialResolution[categoryId] = _incentives[3];
3573	 emit Category(categoryId, _name, _actionHash);
3574	 }
3575	 function _verifyMemberRoles(uint _memberRoleToVote, uint[] memory _allowedToCreateProposal) internal view returns (uint) {
3576	 uint totalRoles = mr.totalRoles();
3577	 if (_memberRoleToVote >= totalRoles) {
3578	 return 0;
3579	 }
3580	 for (uint i = 0; i < _allowedToCreateProposal.length; i++) {
3581	 if (_allowedToCreateProposal[i] >= totalRoles) {
3582	 return 0;
3583	 }
3584	 }
3585	 return 1;
3586	 }
3587	 }
