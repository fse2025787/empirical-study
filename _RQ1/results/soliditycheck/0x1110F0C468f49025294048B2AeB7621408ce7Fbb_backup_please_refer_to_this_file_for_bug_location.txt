row number 
1	         pragma solidity 0.6.12;
2	 abstract contract Context {
3	 function _msgSender() internal view virtual returns (address payable) {
4	 return msg.sender;
5	 }
6	 function _msgData() internal view virtual returns (bytes memory) {
7	 this;
8	 return msg.data;
9	 }
10	 }
11	 pragma solidity 0.6.12;
12	 contract Ownable is Context {
13	 address private _owner;
14	 event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
15	 constructor () internal {
16	 address msgSender = _msgSender();
17	 _owner = msgSender;
18	 emit OwnershipTransferred(address(0), msgSender);
19	 }
20	 function owner() public view returns (address) {
21	 return _owner;
22	 }
23	 modifier onlyOwner() {
24	 require(_owner == _msgSender(), "Ownable: caller is not the owner");
25	 _;
26	 }
27	 function renounceOwnership() public virtual onlyOwner {
28	 emit OwnershipTransferred(_owner, address(0));
29	 _owner = address(0);
30	 }
31	 function transferOwnership(address newOwner) public virtual onlyOwner {
32	 require(newOwner != address(0), "Ownable: new owner is the zero address");
33	 emit OwnershipTransferred(_owner, newOwner);
34	 _owner = newOwner;
35	 }
36	 }
37	 pragma solidity 0.6.12;
38	 interface IFlashLoanReceiver {
39	 function executeOperation(address _reserve, uint256 _amount, uint256 _fee, bytes calldata _params) external;
40	 }
41	 pragma solidity 0.6.12;
42	 contract Withdrawable is Ownable {
43	 using SafeERC20 for ERC20;
44	 address constant ETHER = address(0);
45	 event LogWithdraw( address indexed _from, address indexed _assetAddress, uint amount );
46	 function withdraw(address _assetAddress) public onlyOwner {
47	 uint assetBalance;
48	 if (_assetAddress == ETHER) {
49	 address self = address(this);
50	 assetBalance = self.balance;
51	 msg.sender.transfer(assetBalance);
52	 }
53	 else {
54	 assetBalance = ERC20(_assetAddress).balanceOf(address(this));
55	 ERC20(_assetAddress).safeTransfer(msg.sender, assetBalance);
56	 }
57	 emit LogWithdraw(msg.sender, _assetAddress, assetBalance);
58	 }
59	 }
60	 pragma solidity 0.6.12;
61	 interface IUniswapV2ERC20 {
62	 event Approval(address indexed owner, address indexed spender, uint value);
63	 event Transfer(address indexed from, address indexed to, uint value);
64	 function name() external pure returns (string memory);
65	 function symbol() external pure returns (string memory);
66	 function decimals() external pure returns (uint8);
67	 function totalSupply() external view returns (uint);
68	 function balanceOf(address owner) external view returns (uint);
69	 function allowance(address owner, address spender) external view returns (uint);
70	 function approve(address spender, uint value) external returns (bool);
71	 function transfer(address to, uint value) external returns (bool);
72	 function transferFrom(address from, address to, uint value) external returns (bool);
73	 }
74	 pragma solidity 0.6.12;
75	 abstract contract FlashLoanReceiverBase is IFlashLoanReceiver, Withdrawable {
76	 using SafeERC20 for IERC20;
77	 using SafeMath for uint256;
78	 address constant ethAddress = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
79	 ILendingPoolAddressesProvider public addressesProvider;
80	 constructor(address _addressProvider) public {
81	 addressesProvider = ILendingPoolAddressesProvider(_addressProvider);
82	 }
83	 receive() payable external {
84	 }
85	 function transferFundsBackToPoolInternal(address _reserve, uint256 _amount) internal {
86	 address payable core = addressesProvider.getLendingPoolCore();
87	 transferInternal(core, _reserve, _amount);
88	 }
89	 function transferInternal(address payable _destination, address _reserve, uint256 _amount) internal {
90	 if(_reserve == ethAddress) {
91	 (bool success, ) = _destination.call{
92	 value: _amount}
93	 ("");
94	 require(success == true, "Couldn't transfer ETH");
95	 return;
96	 }
97	 IERC20(_reserve).safeTransfer(_destination, _amount);
98	 }
99	 function getBalanceInternal(address _target, address _reserve) internal view returns(uint256) {
100	 if(_reserve == ethAddress) {
101	 return _target.balance;
102	 }
103	 return IERC20(_reserve).balanceOf(_target);
104	 }
105	 }
106	 pragma solidity 0.6.12;
107	 interface IERC20 {
108	 function totalSupply() external view returns (uint256);
109	 function balanceOf(address account) external view returns (uint256);
110	 function transfer(address recipient, uint256 amount) external returns (bool);
111	 function allowance(address owner, address spender) external view returns (uint256);
112	 function approve(address spender, uint256 amount) external returns (bool);
113	 function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
114	 event Transfer(address indexed from, address indexed to, uint256 value);
115	 event Approval(address indexed owner, address indexed spender, uint256 value);
116	 }
117	 pragma solidity 0.6.12;
118	 interface IMinter {
119	 function enableMint(uint256 ethReserve) external;
120	 function mint(address receiver) external payable;
121	 }
122	 pragma solidity 0.6.12;
123	 interface IUniswapV2Router {
124	 function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);
125	 function swapExactTokensForETHSupportingFeeOnTransferTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external;
126	 function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);
127	 function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);
128	 function addLiquidity( address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline ) external returns (uint amountA, uint amountB, uint liquidity);
129	 function addLiquidityETH( address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
130	 function removeLiquidity( address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline ) external returns (uint amountA, uint amountB);
131	 function removeLiquidityETH( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) external returns (uint amountToken, uint amountETH);
132	 }
133	 pragma solidity 0.6.12;
134	 contract ReentrancyGuard {
135	 uint256 private constant _NOT_ENTERED = 1;
136	 uint256 private constant _ENTERED = 2;
137	 uint256 private _status;
138	 constructor () internal {
139	 _status = _NOT_ENTERED;
140	 }
141	 modifier nonReentrant() {
142	 require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
143	 _status = _ENTERED;
144	 _;
145	 _status = _NOT_ENTERED;
146	 }
147	 }
148	 pragma solidity 0.6.12;
149	 interface ILGEToken {
150	 function mint(address account, uint256 amount) external returns (bool);
151	 function burn(address account, uint256 amount) external returns (bool);
152	 function token() external view returns (address);
153	 function refBalance() external view returns (uint256);
154	 function setRefBalance(uint256 balance) external returns (bool);
155	 function refSupply() external view returns (uint256);
156	 function setRefSupply(uint256 supply) external returns (bool);
157	 }
158	 pragma solidity 0.6.12;
159	 interface IXVIX {
160	 function setGov(address gov) external;
161	 function setFund(address fund) external;
162	 function createSafe(address account) external;
163	 function maxSupply() external view returns (uint256);
164	 function mint(address account, uint256 amount) external returns (bool);
165	 function burn(address account, uint256 amount) external returns (bool);
166	 function toast(uint256 amount) external returns (bool);
167	 function rebase() external returns (bool);
168	 function setTransferConfig( address msgSender, uint256 senderBurnBasisPoints, uint256 senderFundBasisPoints, uint256 receiverBurnBasisPoints, uint256 receiverFundBasisPoints ) external;
169	 }
170	 pragma solidity 0.6.12;
171	 interface IFloor {
172	 function refund(address receiver, uint256 burnAmount) external returns (uint256);
173	 function capital() external view returns (uint256);
174	 function getMaxMintAmount(uint256 ethAmount) external view returns (uint256);
175	 function getRefundAmount(uint256 _tokenAmount) external view returns (uint256);
176	 }
177	 pragma solidity 0.6.12;
178	 interface IUniswapV2Factory {
179	 event PairCreated(address indexed token0, address indexed token1, address pair, uint);
180	 function feeTo() external view returns (address);
181	 function feeToSetter() external view returns (address);
182	 function getPair(address tokenA, address tokenB) external view returns (address pair);
183	 function allPairs(uint) external view returns (address pair);
184	 function allPairsLength() external view returns (uint);
185	 function createPair(address tokenA, address tokenB) external returns (address pair);
186	 function setFeeTo(address) external;
187	 function setFeeToSetter(address) external;
188	 }
189	 pragma solidity 0.6.12;
190	 interface IFarm {
191	 function rewardToken() external view returns (IERC20);
192	 function stakingToken() external view returns (IERC20);
193	 function totalStaked() external view returns (uint256);
194	 function stake(uint256 amount) external;
195	 function unstake(address receiver, uint256 amount) external;
196	 function claim(address receiver) external;
197	 function exit(address receiver, uint256 amount) external;
198	 }
199	 pragma solidity 0.6.12;
200	 interface IFarmDistributor {
201	 function distribute(address farm) external;
202	 }
203	 pragma solidity 0.6.12;
204	 interface ITimeVault {
205	 function withdrawalSlots(uint256 slot) external view returns (uint256);
206	 }
207	 pragma solidity 0.6.12;
208	 interface IUniswapV2Pair {
209	 event Approval(address indexed owner, address indexed spender, uint value);
210	 event Transfer(address indexed from, address indexed to, uint value);
211	 event Mint(address indexed sender, uint amount0, uint amount1);
212	 event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
213	 event Swap( address indexed sender, uint amount0In, uint amount1In, uint amount0Out, uint amount1Out, address indexed to );
214	 event Sync(uint112 reserve0, uint112 reserve1);
215	 function MINIMUM_LIQUIDITY() external pure returns (uint);
216	 function factory() external view returns (address);
217	 function token0() external view returns (address);
218	 function token1() external view returns (address);
219	 function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
220	 function price0CumulativeLast() external view returns (uint);
221	 function price1CumulativeLast() external view returns (uint);
222	 function kLast() external view returns (uint);
223	 function mint(address to) external returns (uint liquidity);
224	 function burn(address to) external returns (uint amount0, uint amount1);
225	 function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
226	 function skim(address to) external;
227	 function sync() external;
228	 function initialize(address, address) external;
229	 }
230	 pragma solidity 0.6.12;
231	 contract UniswapV2ERC20 is IUniswapV2ERC20 {
232	 using SafeMath for uint;
233	 string public constant override name = 'Uniswap V2';
234	 string public constant override symbol = 'UNI-V2';
235	 uint8 public constant override decimals = 18;
236	 uint private _totalSupply;
237	 mapping(address => uint) private _balances;
238	 mapping(address => mapping(address => uint)) private _allowances;
239	 event Approval(address indexed owner, address indexed spender, uint value);
240	 event Transfer(address indexed from, address indexed to, uint value);
241	 constructor() public {
242	 }
243	 function _mint(address to, uint value) internal {
244	 _totalSupply = _totalSupply.add(value);
245	 _balances[to] = _balances[to].add(value);
246	 emit Transfer(address(0), to, value);
247	 }
248	 function _burn(address from, uint value) internal {
249	 _balances[from] = _balances[from].sub(value);
250	 _totalSupply = _totalSupply.sub(value);
251	 emit Transfer(from, address(0), value);
252	 }
253	 function _approve(address owner, address spender, uint value) private {
254	 _allowances[owner][spender] = value;
255	 emit Approval(owner, spender, value);
256	 }
257	 function _transfer(address from, address to, uint value) private {
258	 _balances[from] = _balances[from].sub(value);
259	 _balances[to] = _balances[to].add(value);
260	 emit Transfer(from, to, value);
261	 }
262	 function totalSupply() public view override returns (uint256) {
263	 return _totalSupply;
264	 }
265	 function balanceOf(address _account) public view override returns (uint256) {
266	 return _balances[_account];
267	 }
268	 function allowance(address _owner, address _spender) public view override returns (uint256) {
269	 return _allowances[_owner][_spender];
270	 }
271	 function approve(address spender, uint value) external virtual override returns (bool) {
272	 _approve(msg.sender, spender, value);
273	 return true;
274	 }
275	 function transfer(address to, uint value) external virtual override returns (bool) {
276	 _transfer(msg.sender, to, value);
277	 return true;
278	 }
279	 function transferFrom(address from, address to, uint value) external virtual override returns (bool) {
280	 if (_allowances[from][msg.sender] != uint(-1)) {
281	 _allowances[from][msg.sender] = _allowances[from][msg.sender].sub(value);
282	 }
283	 _transfer(from, to, value);
284	 return true;
285	 }
286	 }
287	 pragma solidity 0.6.12;
288	 library SafeMath {
289	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
290	 uint256 c = a + b;
291	 require(c >= a, "SafeMath: addition overflow");
292	 return c;
293	 }
294	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
295	 return sub(a, b, "SafeMath: subtraction overflow");
296	 }
297	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
298	 require(b <= a, errorMessage);
299	 uint256 c = a - b;
300	 return c;
301	 }
302	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
303	 if (a == 0) {
304	 return 0;
305	 }
306	 uint256 c = a * b;
307	 require(c / a == b, "SafeMath: multiplication overflow");
308	 return c;
309	 }
310	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
311	 return div(a, b, "SafeMath: division by zero");
312	 }
313	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
314	 require(b > 0, errorMessage);
315	 uint256 c = a / b;
316	 return c;
317	 }
318	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
319	 return mod(a, b, "SafeMath: modulo by zero");
320	 }
321	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
322	 require(b != 0, errorMessage);
323	 return a % b;
324	 }
325	 }
326	 pragma solidity 0.6.12;
327	 library SafeERC20 {
328	 using SafeMath for uint256;
329	 using Address for address;
330	 function safeTransfer(IERC20 token, address to, uint256 value) internal {
331	 _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
332	 }
333	 function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
334	 _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
335	 }
336	 function safeApprove(IERC20 token, address spender, uint256 value) internal {
337	 require((value == 0) || (token.allowance(address(this), spender) == 0), "SafeERC20: approve from non-zero to non-zero allowance" );
338	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
339	 }
340	 function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
341	 uint256 newAllowance = token.allowance(address(this), spender).add(value);
342	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
343	 }
344	 function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
345	 uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
346	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
347	 }
348	 function _callOptionalReturn(IERC20 token, bytes memory data) private {
349	 bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
350	 if (returndata.length > 0) {
351	 require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
352	 }
353	 }
354	 }
355	 pragma solidity ^0.6.2;
356	 library Address {
357	 function isContract(address account) internal view returns (bool) {
358	 uint256 size;
359	 assembly {
360	 size := extcodesize(account) }
361	 return size > 0;
362	 }
363	 function sendValue(address payable recipient, uint256 amount) internal {
364	 require(address(this).balance >= amount, "Address: insufficient balance");
365	 (bool success, ) = recipient.call{
366	 value: amount }
367	 ("");
368	 require(success, "Address: unable to send value, recipient may have reverted");
369	 }
370	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
371	 return functionCall(target, data, "Address: low-level call failed");
372	 }
373	 function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
374	 return functionCallWithValue(target, data, 0, errorMessage);
375	 }
376	 function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
377	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
378	 }
379	 function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
380	 require(address(this).balance >= value, "Address: insufficient balance for call");
381	 require(isContract(target), "Address: call to non-contract");
382	 (bool success, bytes memory returndata) = target.call{
383	 value: value }
384	 (data);
385	 return _verifyCallResult(success, returndata, errorMessage);
386	 }
387	 function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
388	 return functionStaticCall(target, data, "Address: low-level static call failed");
389	 }
390	 function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
391	 require(isContract(target), "Address: static call to non-contract");
392	 (bool success, bytes memory returndata) = target.staticcall(data);
393	 return _verifyCallResult(success, returndata, errorMessage);
394	 }
395	 function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
396	 return functionDelegateCall(target, data, "Address: low-level delegate call failed");
397	 }
398	 function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
399	 require(isContract(target), "Address: delegate call to non-contract");
400	 (bool success, bytes memory returndata) = target.delegatecall(data);
401	 return _verifyCallResult(success, returndata, errorMessage);
402	 }
403	 function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
404	 if (success) {
405	 return returndata;
406	 }
407	 else {
408	 if (returndata.length > 0) {
409	 assembly {
410	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
411	 }
412	 else {
413	 revert(errorMessage);
414	 }
415	 }
416	 }
417	 }
418	 pragma solidity 0.6.12;
419	 interface ILendingPoolAddressesProvider {
420	 function getLendingPoolCore() external view returns (address payable);
421	 function getLendingPool() external view returns (address);
422	 }
423	 pragma solidity 0.6.12;
424	 contract ERC20 is Context, IERC20 {
425	 using SafeMath for uint256;
426	 mapping (address => uint256) private _balances;
427	 mapping (address => mapping (address => uint256)) private _allowances;
428	 uint256 private _totalSupply;
429	 string private _name;
430	 string private _symbol;
431	 uint8 private _decimals;
432	 constructor (string memory name, string memory symbol) public {
433	 _name = name;
434	 _symbol = symbol;
435	 _decimals = 18;
436	 }
437	 function name() public view returns (string memory) {
438	 return _name;
439	 }
440	 function symbol() public view returns (string memory) {
441	 return _symbol;
442	 }
443	 function decimals() public view returns (uint8) {
444	 return _decimals;
445	 }
446	 function totalSupply() public view override returns (uint256) {
447	 return _totalSupply;
448	 }
449	 function balanceOf(address account) public view override returns (uint256) {
450	 return _balances[account];
451	 }
452	 function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
453	 _transfer(_msgSender(), recipient, amount);
454	 return true;
455	 }
456	 function allowance(address owner, address spender) public view virtual override returns (uint256) {
457	 return _allowances[owner][spender];
458	 }
459	 function approve(address spender, uint256 amount) public virtual override returns (bool) {
460	 _approve(_msgSender(), spender, amount);
461	 return true;
462	 }
463	 function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
464	 _transfer(sender, recipient, amount);
465	 _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
466	 return true;
467	 }
468	 function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
469	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
470	 return true;
471	 }
472	 function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
473	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
474	 return true;
475	 }
476	 function _transfer(address sender, address recipient, uint256 amount) internal virtual {
477	 require(sender != address(0), "ERC20: transfer from the zero address");
478	 require(recipient != address(0), "ERC20: transfer to the zero address");
479	 _beforeTokenTransfer(sender, recipient, amount);
480	 _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
481	 _balances[recipient] = _balances[recipient].add(amount);
482	 emit Transfer(sender, recipient, amount);
483	 }
484	 function _mint(address account, uint256 amount) internal virtual {
485	 require(account != address(0), "ERC20: mint to the zero address");
486	 _beforeTokenTransfer(address(0), account, amount);
487	 _totalSupply = _totalSupply.add(amount);
488	 _balances[account] = _balances[account].add(amount);
489	 emit Transfer(address(0), account, amount);
490	 }
491	 function _burn(address account, uint256 amount) internal virtual {
492	 require(account != address(0), "ERC20: burn from the zero address");
493	 _beforeTokenTransfer(account, address(0), amount);
494	 _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
495	 _totalSupply = _totalSupply.sub(amount);
496	 emit Transfer(account, address(0), amount);
497	 }
498	 function _approve(address owner, address spender, uint256 amount) internal virtual {
499	 require(owner != address(0), "ERC20: approve from the zero address");
500	 require(spender != address(0), "ERC20: approve to the zero address");
501	 _allowances[owner][spender] = amount;
502	 emit Approval(owner, spender, amount);
503	 }
504	 function _setupDecimals(uint8 decimals_) internal {
505	 _decimals = decimals_;
506	 }
507	 function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {
508	 }
509	 }
510	 pragma solidity 0.6.12;
511	 interface ILendingPool {
512	 function addressesProvider () external view returns ( address );
513	 function deposit ( address _reserve, uint256 _amount, uint16 _referralCode ) external payable;
514	 function redeemUnderlying ( address _reserve, address _user, uint256 _amount ) external;
515	 function borrow ( address _reserve, uint256 _amount, uint256 _interestRateMode, uint16 _referralCode ) external;
516	 function repay ( address _reserve, uint256 _amount, address _onBehalfOf ) external payable;
517	 function swapBorrowRateMode ( address _reserve ) external;
518	 function rebalanceFixedBorrowRate ( address _reserve, address _user ) external;
519	 function setUserUseReserveAsCollateral ( address _reserve, bool _useAsCollateral ) external;
520	 function liquidationCall ( address _collateral, address _reserve, address _user, uint256 _purchaseAmount, bool _receiveAToken ) external payable;
521	 function flashLoan ( address _receiver, address _reserve, uint256 _amount, bytes calldata _params ) external;
522	 function getReserveConfigurationData ( address _reserve ) external view returns ( uint256 ltv, uint256 liquidationThreshold, uint256 liquidationDiscount, address interestRateStrategyAddress, bool usageAsCollateralEnabled, bool borrowingEnabled, bool fixedBorrowRateEnabled, bool isActive );
523	 function getReserveData ( address _reserve ) external view returns ( uint256 totalLiquidity, uint256 availableLiquidity, uint256 totalBorrowsFixed, uint256 totalBorrowsVariable, uint256 liquidityRate, uint256 variableBorrowRate, uint256 fixedBorrowRate, uint256 averageFixedBorrowRate, uint256 utilizationRate, uint256 liquidityIndex, uint256 variableBorrowIndex, address aTokenAddress, uint40 lastUpdateTimestamp );
524	 function getUserAccountData ( address _user ) external view returns ( uint256 totalLiquidityETH, uint256 totalCollateralETH, uint256 totalBorrowsETH, uint256 availableBorrowsETH, uint256 currentLiquidationThreshold, uint256 ltv, uint256 healthFactor );
525	 function getUserReserveData ( address _reserve, address _user ) external view returns ( uint256 currentATokenBalance, uint256 currentUnderlyingBalance, uint256 currentBorrowBalance, uint256 principalBorrowBalance, uint256 borrowRateMode, uint256 borrowRate, uint256 liquidityRate, uint256 originationFee, uint256 variableBorrowIndex, uint256 lastUpdateTimestamp, bool usageAsCollateralEnabled );
526	 function getReserves () external view;
527	 }
528	 pragma solidity 0.6.12;
529	 contract LendingPool {
530	 using SafeMath for uint256;
531	 receive() payable external {
532	 }
533	 function flashLoan(address _receiver, address _reserve, uint256 _amount, bytes memory _params) external {
534	 uint256 availableLiquidityBefore = address(this).balance;
535	 require( availableLiquidityBefore >= _amount, "There is not enough liquidity available to borrow" );
536	 uint256 amountFee = _amount.mul(30).div(10000);
537	 IFlashLoanReceiver receiver = IFlashLoanReceiver(_receiver);
538	 (bool success,) = _receiver.call{
539	 value: _amount}
540	 ("");
541	 require(success, "LendingPool: transfer to receiver failed");
542	 receiver.executeOperation(_reserve, _amount, amountFee, _params);
543	 uint256 availableLiquidityAfter = address(this).balance;
544	 require( availableLiquidityAfter == availableLiquidityBefore.add(amountFee), "The actual balance of the protocol is inconsistent" );
545	 }
546	 }
547	 pragma solidity 0.6.12;
548	 contract LendingPoolAddressesProvider {
549	 address lendingPool;
550	 constructor(address _lendingPool) public {
551	 lendingPool = _lendingPool;
552	 }
553	 function getLendingPool() external view returns (address) {
554	 return lendingPool;
555	 }
556	 function getLendingPoolCore() external view returns (address) {
557	 return lendingPool;
558	 }
559	 }
560	 pragma solidity 0.6.12;
561	 contract Arb is FlashLoanReceiverBase {
562	 using SafeMath for uint256;
563	 address public xvix;
564	 address public weth;
565	 address public minter;
566	 address public floor;
567	 address public router;
568	 address public receiver;
569	 address[] public path;
570	 address public gov;
571	 modifier onlyGov() {
572	 require(msg.sender == gov, "Arb: forbidden");
573	 _;
574	 }
575	 constructor( address _xvix, address _weth, address _minter, address _floor, address _router, address _receiver, address _lendingPoolAddressesProvider ) FlashLoanReceiverBase(_lendingPoolAddressesProvider) public {
576	 xvix = _xvix;
577	 weth = _weth;
578	 minter = _minter;
579	 floor = _floor;
580	 router = _router;
581	 receiver = _receiver;
582	 path.push(xvix);
583	 path.push(weth);
584	 gov = msg.sender;
585	 }
586	 function setGov(address _gov) external onlyGov {
587	 gov = _gov;
588	 }
589	 function setReceiver(address _receiver) external onlyGov {
590	 receiver = _receiver;
591	 }
592	 function rebalanceMinter(uint256 _ethAmount) external onlyGov {
593	 address asset = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
594	 bytes memory data = "";
595	 ILendingPool lendingPool = ILendingPool(addressesProvider.getLendingPool());
596	 lendingPool.flashLoan(address(this), asset, _ethAmount, data);
597	 }
598	 function executeOperation( address _asset, uint256 _amount, uint256 _fee, bytes calldata ) external override {
599	 require(_asset == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE, "Arb: loaned asset is not ETH");
600	 require(_amount <= getBalanceInternal(address(this), _asset), "Arb: flashLoan failed");
601	 IMinter(minter).mint{
602	 value: _amount}
603	 (address(this));
604	 uint256 amountXVIX = IERC20(xvix).balanceOf(address(this));
605	 IERC20(xvix).approve(router, amountXVIX);
606	 IUniswapV2Router(router).swapExactTokensForETHSupportingFeeOnTransferTokens( amountXVIX, 0, path, address(this), block.timestamp );
607	 uint256 totalDebt = _amount.add(_fee);
608	 transferFundsBackToPoolInternal(_asset, totalDebt);
609	 uint256 profit = address(this).balance;
610	 (bool success,) = receiver.call{
611	 value: profit}
612	 ("");
613	 require(success, "Arb: transfer to receiver failed");
614	 }
615	 }
616	 pragma solidity 0.6.12;
617	 contract Distributor is ReentrancyGuard {
618	 using SafeMath for uint256;
619	 uint256 public constant FLOOR_BASIS_POINTS = 5000;
620	 uint256 public constant BASIS_POINTS_DIVISOR = 10000;
621	 bool public isInitialized;
622	 uint256 public lgeEndTime;
623	 uint256 public lpUnlockTime;
624	 bool public lgeIsActive;
625	 uint256 public ethReceived;
626	 address public xvix;
627	 address public weth;
628	 address public dai;
629	 address public lgeTokenWETH;
630	 address public lgeTokenDAI;
631	 address public floor;
632	 address public minter;
633	 address public router;
634	 address public factory;
635	 address[] public path;
636	 address public gov;
637	 event Join(address indexed account, uint256 value);
638	 event RemoveLiquidity(address indexed to, address lgeToken, uint256 amountLGEToken);
639	 event EndLGE();
640	 constructor() public {
641	 lgeIsActive = true;
642	 gov = msg.sender;
643	 }
644	 receive() external payable {
645	 assert(msg.sender == weth);
646	 }
647	 function initialize( address[] memory _addresses, uint256 _lgeEndTime, uint256 _lpUnlockTime ) public nonReentrant {
648	 require(msg.sender == gov, "Distributor: forbidden");
649	 require(!isInitialized, "Distributor: already initialized");
650	 isInitialized = true;
651	 xvix = _addresses[0];
652	 weth = _addresses[1];
653	 dai = _addresses[2];
654	 lgeTokenWETH = _addresses[3];
655	 lgeTokenDAI = _addresses[4];
656	 floor = _addresses[5];
657	 minter = _addresses[6];
658	 router = _addresses[7];
659	 factory = _addresses[8];
660	 require(ILGEToken(lgeTokenWETH).token() == weth, "Distributor: misconfigured lgeTokenWETH");
661	 require(ILGEToken(lgeTokenDAI).token() == dai, "Distributor: misconfigured lgeTokenDAI");
662	 path.push(weth);
663	 path.push(dai);
664	 lgeEndTime = _lgeEndTime;
665	 lpUnlockTime = _lpUnlockTime;
666	 }
667	 function join(address _receiver, uint256 _minDAI, uint256 _deadline) public payable nonReentrant {
668	 require(lgeIsActive, "Distributor: LGE has ended");
669	 require(msg.value > 0, "Distributor: insufficient value");
670	 uint256 floorETH = msg.value.mul(FLOOR_BASIS_POINTS).div(BASIS_POINTS_DIVISOR);
671	 (bool success,) = floor.call{
672	 value: floorETH}
673	 ("");
674	 require(success, "Distributor: transfer to floor failed");
675	 uint256 toSwap = msg.value.sub(floorETH).div(2);
676	 IUniswapV2Router(router).swapExactETHForTokens{
677	 value: toSwap}
678	 ( _minDAI, path, address(this), _deadline );
679	 ILGEToken(lgeTokenWETH).mint(_receiver, msg.value);
680	 ILGEToken(lgeTokenDAI).mint(_receiver, msg.value);
681	 ethReceived = ethReceived.add(msg.value);
682	 emit Join(_receiver, msg.value);
683	 }
684	 function endLGE(uint256 _deadline) public nonReentrant {
685	 require(lgeIsActive, "Distributor: LGE already ended");
686	 if (block.timestamp < lgeEndTime) {
687	 require(msg.sender == gov, "Distributor: forbidden");
688	 }
689	 lgeIsActive = false;
690	 IXVIX(xvix).rebase();
691	 uint256 totalXVIX = IERC20(xvix).balanceOf(address(this));
692	 require(totalXVIX > 0, "Distributor: insufficient XVIX");
693	 uint256 amountXVIX = totalXVIX.div(2);
694	 _addLiquidityETH(_deadline, amountXVIX);
695	 _addLiquidityDAI(_deadline, amountXVIX);
696	 IMinter(minter).enableMint(ethReceived);
697	 emit EndLGE();
698	 }
699	 function removeLiquidityETH( uint256 _amountLGEToken, uint256 _amountXVIXMin, uint256 _amountETHMin, address _to, uint256 _deadline ) public nonReentrant {
700	 uint256 amountWETH = _removeLiquidity( lgeTokenWETH, _amountLGEToken, _amountXVIXMin, _amountETHMin, _to, _deadline );
701	 IWETH(weth).withdraw(amountWETH);
702	 (bool success,) = _to.call{
703	 value: amountWETH}
704	 ("");
705	 require(success, "Distributor: ETH transfer failed");
706	 }
707	 function removeLiquidityDAI( uint256 _amountLGEToken, uint256 _amountXVIXMin, uint256 _amountTokenMin, address _to, uint256 _deadline ) public nonReentrant {
708	 uint256 amountDAI = _removeLiquidity( lgeTokenDAI, _amountLGEToken, _amountXVIXMin, _amountTokenMin, _to, _deadline );
709	 IERC20(dai).transfer(_to, amountDAI);
710	 }
711	 function _removeLiquidity( address _lgeToken, uint256 _amountLGEToken, uint256 _amountXVIXMin, uint256 _amountTokenMin, address _to, uint256 _deadline ) private returns (uint256) {
712	 require(!lgeIsActive, "Distributor: LGE has not ended");
713	 require(block.timestamp >= lpUnlockTime, "Distributor: unlock time not yet reached");
714	 uint256 liquidity = _getLiquidityAmount(_lgeToken, _amountLGEToken);
715	 ILGEToken(_lgeToken).burn(msg.sender, _amountLGEToken);
716	 if (liquidity == 0) {
717	 return 0;
718	 }
719	 address pair = _getPair(_lgeToken);
720	 IERC20(pair).approve(router, liquidity);
721	 IUniswapV2Router(router).removeLiquidity( xvix, ILGEToken(_lgeToken).token(), liquidity, _amountXVIXMin, _amountTokenMin, address(this), _deadline );
722	 uint256 amountXVIX = IERC20(xvix).balanceOf(address(this));
723	 uint256 amountToken = IERC20(ILGEToken(_lgeToken).token()).balanceOf(address(this));
724	 uint256 refundBasisPoints = _getRefundBasisPoints(_lgeToken, _amountLGEToken, amountToken);
725	 uint256 refundAmount = amountXVIX.mul(refundBasisPoints).div(BASIS_POINTS_DIVISOR);
726	 if (refundAmount > 0) {
727	 IFloor(floor).refund(_to, refundAmount);
728	 }
729	 uint256 toastAmount = amountXVIX.sub(refundAmount);
730	 if (toastAmount > 0) {
731	 IXVIX(xvix).toast(toastAmount);
732	 }
733	 emit RemoveLiquidity(_to, _lgeToken, _amountLGEToken);
734	 return amountToken;
735	 }
736	 function _getRefundBasisPoints( address _lgeToken, uint256 _amountLGEToken, uint256 _amountToken ) private view returns (uint256) {
737	 uint256 refBalance = ILGEToken(_lgeToken).refBalance();
738	 uint256 refSupply = ILGEToken(_lgeToken).refSupply();
739	 uint256 refAmount = _amountLGEToken.mul(refBalance).div(refSupply);
740	 uint256 minExpectedAmount = refAmount.mul(2);
741	 if (_amountToken >= minExpectedAmount) {
742	 return 0;
743	 }
744	 uint256 diff = minExpectedAmount.sub(_amountToken);
745	 uint256 refundBasisPoints = diff.mul(BASIS_POINTS_DIVISOR).div(refAmount);
746	 if (refundBasisPoints >= BASIS_POINTS_DIVISOR) {
747	 return BASIS_POINTS_DIVISOR;
748	 }
749	 return refundBasisPoints;
750	 }
751	 function _getLiquidityAmount(address _lgeToken, uint256 _amountLGEToken) private view returns (uint256) {
752	 address pair = _getPair(_lgeToken);
753	 uint256 pairBalance = IERC20(pair).balanceOf(address(this));
754	 uint256 totalSupply = IERC20(_lgeToken).totalSupply();
755	 if (totalSupply == 0) {
756	 return 0;
757	 }
758	 return pairBalance.mul(_amountLGEToken).div(totalSupply);
759	 }
760	 function _getPair(address _lgeToken) private view returns (address) {
761	 return IUniswapV2Factory(factory).getPair(xvix, ILGEToken(_lgeToken).token());
762	 }
763	 function _addLiquidityETH(uint256 _deadline, uint256 _amountXVIX) private {
764	 uint256 amountETH = address(this).balance;
765	 require(amountETH > 0, "Distributor: insufficient ETH");
766	 IERC20(xvix).approve(router, _amountXVIX);
767	 IUniswapV2Router(router).addLiquidityETH{
768	 value: amountETH}
769	 ( xvix, _amountXVIX, 0, 0, address(this), _deadline );
770	 ILGEToken(lgeTokenWETH).setRefBalance(amountETH);
771	 uint256 totalSupply = IERC20(lgeTokenWETH).totalSupply();
772	 ILGEToken(lgeTokenWETH).setRefSupply(totalSupply);
773	 }
774	 function _addLiquidityDAI(uint256 _deadline, uint256 _amountXVIX) private {
775	 uint256 amountDAI = IERC20(dai).balanceOf(address(this));
776	 require(amountDAI > 0, "Distributor: insufficient DAI");
777	 IERC20(xvix).approve(router, _amountXVIX);
778	 IERC20(dai).approve(router, amountDAI);
779	 IUniswapV2Router(router).addLiquidity( xvix, dai, _amountXVIX, amountDAI, 0, 0, address(this), _deadline );
780	 ILGEToken(lgeTokenDAI).setRefBalance(amountDAI);
781	 uint256 totalSupply = IERC20(lgeTokenDAI).totalSupply();
782	 ILGEToken(lgeTokenDAI).setRefSupply(totalSupply);
783	 }
784	 }
785	 pragma solidity 0.6.12;
786	 interface IWETH {
787	 function deposit() external payable;
788	 function transfer(address to, uint value) external returns (bool);
789	 function withdraw(uint) external;
790	 }
791	 pragma solidity 0.6.12;
792	 contract Farm is IFarm {
793	 using SafeMath for uint256;
794	 uint256 constant PRECISION = 1e30;
795	 string public name;
796	 IERC20 public override stakingToken;
797	 IERC20 public override rewardToken;
798	 IFarmDistributor public farmDistributor;
799	 uint256 public override totalStaked;
800	 mapping(address => uint256) public staked;
801	 uint256 public cumulativeRewardPerToken;
802	 mapping(address => uint256) public previousCumulatedRewardPerToken;
803	 mapping(address => uint256) public claimableReward;
804	 uint256 public totalClaimedRewards;
805	 uint256 public totalFarmRewards;
806	 address public gov;
807	 event Stake(address indexed who, uint256 amountStaked);
808	 event Unstake(address indexed who, uint256 amountUnstaked);
809	 event Claim(address indexed who, uint256 amountClaimed);
810	 event GovChange(address gov);
811	 event DistributorChange(address distributor);
812	 modifier onlyGov() {
813	 require(msg.sender == gov, "Farm: forbidden");
814	 _;
815	 }
816	 constructor(string memory _name, IERC20 _stakingToken, IERC20 _rewardToken) public {
817	 name = _name;
818	 stakingToken = _stakingToken;
819	 rewardToken = _rewardToken;
820	 gov = msg.sender;
821	 }
822	 function setGov(address _gov) public onlyGov {
823	 gov = _gov;
824	 emit GovChange(_gov);
825	 }
826	 function setFarmDistributor(IFarmDistributor _farmDistributor) public onlyGov {
827	 farmDistributor = _farmDistributor;
828	 emit DistributorChange(address(_farmDistributor));
829	 }
830	 function stake(uint256 amount) external override update {
831	 staked[msg.sender] = staked[msg.sender].add(amount);
832	 totalStaked = totalStaked.add(amount);
833	 require(stakingToken.transferFrom(msg.sender, address(this), amount));
834	 emit Stake(msg.sender, amount);
835	 }
836	 function _unstake(address receiver, uint256 amount) internal {
837	 require(amount <= staked[msg.sender], "Farm: Cannot withdraw amount bigger than available balance");
838	 staked[msg.sender] = staked[msg.sender].sub(amount);
839	 totalStaked = totalStaked.sub(amount);
840	 stakingToken.transfer(receiver, amount);
841	 emit Unstake(receiver, amount);
842	 }
843	 function _claim(address receiver) internal {
844	 totalClaimedRewards = totalClaimedRewards.add(claimableReward[msg.sender]);
845	 uint256 rewardToClaim = claimableReward[msg.sender];
846	 claimableReward[msg.sender] = 0;
847	 rewardToken.transfer(receiver, rewardToClaim);
848	 emit Claim(receiver, rewardToClaim);
849	 }
850	 function unstake(address receiver, uint256 amount) external override update {
851	 _unstake(receiver, amount);
852	 }
853	 function claim(address receiver) external override update {
854	 _claim(receiver);
855	 }
856	 function exit(address receiver, uint256 amount) external override update {
857	 _unstake(receiver, amount);
858	 _claim(receiver);
859	 }
860	 modifier update() {
861	 if (address(farmDistributor) != address(0)) {
862	 farmDistributor.distribute(address(this));
863	 }
864	 uint256 newTotalFarmRewards = rewardToken.balanceOf(address(this)).add(totalClaimedRewards).mul(PRECISION);
865	 uint256 totalBlockReward = newTotalFarmRewards.sub(totalFarmRewards);
866	 totalFarmRewards = newTotalFarmRewards;
867	 if (totalStaked > 0) {
868	 cumulativeRewardPerToken = cumulativeRewardPerToken.add(totalBlockReward.div(totalStaked));
869	 }
870	 claimableReward[msg.sender] = claimableReward[msg.sender].add( staked[msg.sender].mul(cumulativeRewardPerToken.sub(previousCumulatedRewardPerToken[msg.sender])).div(PRECISION) );
871	 previousCumulatedRewardPerToken[msg.sender] = cumulativeRewardPerToken;
872	 _;
873	 }
874	 }
875	 pragma solidity 0.6.12;
876	 contract FarmDistributor is IFarmDistributor {
877	 using SafeMath for uint256;
878	 IERC20 public rewardToken;
879	 constructor(IERC20 _rewardToken) public {
880	 rewardToken = _rewardToken;
881	 }
882	 function distribute(address farm) external override {
883	 uint256 amount = rewardToken.balanceOf(address(this));
884	 if (amount == 0) {
885	 return;
886	 }
887	 rewardToken.transfer(farm, amount);
888	 }
889	 }
890	 pragma solidity 0.6.12;
891	 contract Floor is IFloor, ReentrancyGuard {
892	 using SafeMath for uint256;
893	 uint256 public constant BASIS_POINTS_DIVISOR = 10000;
894	 uint256 public constant REFUND_BASIS_POINTS = 9000;
895	 address public immutable xvix;
896	 uint256 public override capital;
897	 event Refund(address indexed to, uint256 refundAmount, uint256 burnAmount);
898	 event FloorPrice(uint256 capital, uint256 supply);
899	 constructor(address _xvix) public {
900	 xvix = _xvix;
901	 }
902	 receive() external payable nonReentrant {
903	 capital = capital.add(msg.value);
904	 }
905	 function refund(address _receiver, uint256 _burnAmount) public override nonReentrant returns (uint256) {
906	 uint256 refundAmount = getRefundAmount(_burnAmount);
907	 require(refundAmount > 0, "Floor: refund amount is zero");
908	 capital = capital.sub(refundAmount);
909	 IXVIX(xvix).burn(msg.sender, _burnAmount);
910	 (bool success,) = _receiver.call{
911	 value: refundAmount}
912	 ("");
913	 require(success, "Floor: transfer to receiver failed");
914	 emit Refund(_receiver, refundAmount, _burnAmount);
915	 emit FloorPrice(capital, IERC20(xvix).totalSupply());
916	 return refundAmount;
917	 }
918	 function getMaxMintAmount(uint256 _ethAmount) public override view returns (uint256) {
919	 if (capital == 0) {
920	 return 0;
921	 }
922	 uint256 totalSupply = IERC20(xvix).totalSupply();
923	 return _ethAmount.mul(totalSupply).div(capital);
924	 }
925	 function getRefundAmount(uint256 _tokenAmount) public override view returns (uint256) {
926	 uint256 totalSupply = IERC20(xvix).totalSupply();
927	 uint256 amount = capital.mul(_tokenAmount).div(totalSupply);
928	 return amount.mul(REFUND_BASIS_POINTS).div(BASIS_POINTS_DIVISOR);
929	 }
930	 }
931	 pragma solidity 0.6.12;
932	 contract Fund {
933	 using SafeMath for uint256;
934	 uint256 public constant BASIS_POINTS_DIVISOR = 10000;
935	 address[] public receivers;
936	 uint256[] public feeBasisPoints;
937	 address public gov;
938	 address public xvix;
939	 constructor(address _xvix) public {
940	 xvix = _xvix;
941	 gov = msg.sender;
942	 }
943	 function setReceivers(address[] memory _receivers, uint256[] memory _feeBasisPoints) public {
944	 require(msg.sender == gov, "Fund: forbidden");
945	 _validateInput(_receivers, _feeBasisPoints);
946	 receivers = _receivers;
947	 feeBasisPoints = _feeBasisPoints;
948	 }
949	 function withdraw(address _token) public {
950	 uint256 balance = IERC20(_token).balanceOf(address(this));
951	 for (uint256 i = 0; i < receivers.length; i++) {
952	 uint256 feePoints = feeBasisPoints[i];
953	 uint256 amount = balance.mul(feePoints).div(BASIS_POINTS_DIVISOR);
954	 IERC20(_token).transfer(receivers[i], amount);
955	 }
956	 }
957	 function withdrawXVIX() public {
958	 address token = xvix;
959	 uint256 balance = IERC20(token).balanceOf(address(this));
960	 for (uint256 i = 0; i < receivers.length; i++) {
961	 uint256 feePoints = feeBasisPoints[i];
962	 uint256 amount = balance.mul(feePoints).div(BASIS_POINTS_DIVISOR);
963	 IERC20(token).transfer(receivers[i], amount);
964	 }
965	 }
966	 function _validateInput(address[] memory _receivers, uint256[] memory _feeBasisPoints) private pure {
967	 require(_receivers.length == _feeBasisPoints.length, "Fund: invalid input");
968	 uint256 totalBasisPoints = 0;
969	 for (uint256 i = 0; i < _feeBasisPoints.length; i++) {
970	 totalBasisPoints = totalBasisPoints.add(_feeBasisPoints[i]);
971	 }
972	 require(totalBasisPoints == BASIS_POINTS_DIVISOR, "Fund: invalid input");
973	 }
974	 }
975	 pragma solidity 0.6.12;
976	 contract Gov {
977	 address public xvix;
978	 uint256 public govHandoverTime;
979	 address public admin;
980	 constructor(address _xvix, uint256 _govHandoverTime) public {
981	 xvix = _xvix;
982	 govHandoverTime = _govHandoverTime;
983	 admin = msg.sender;
984	 }
985	 modifier onlyAdmin() {
986	 require(msg.sender == admin, "Gov: forbidden");
987	 _;
988	 }
989	 function setAdmin(address _admin) public onlyAdmin {
990	 admin = _admin;
991	 }
992	 function extendHandoverTime(uint256 _govHandoverTime) public onlyAdmin {
993	 require(_govHandoverTime > govHandoverTime, "Gov: invalid handover time");
994	 govHandoverTime = _govHandoverTime;
995	 }
996	 function setGov(address _gov) public onlyAdmin {
997	 require(block.timestamp > govHandoverTime, "Gov: handover time has not passed");
998	 IXVIX(xvix).setGov(_gov);
999	 }
1000	 function setFund(address _fund) public onlyAdmin {
1001	 IXVIX(xvix).setFund(_fund);
1002	 }
1003	 function createSafe(address _account) public onlyAdmin {
1004	 IXVIX(xvix).createSafe(_account);
1005	 }
1006	 function setTransferConfig( address _msgSender, uint256 _senderBurnBasisPoints, uint256 _senderFundBasisPoints, uint256 _receiverBurnBasisPoints, uint256 _receiverFundBasisPoints ) public onlyAdmin {
1007	 IXVIX(xvix).setTransferConfig( _msgSender, _senderBurnBasisPoints, _senderFundBasisPoints, _receiverBurnBasisPoints, _receiverFundBasisPoints );
1008	 }
1009	 }
1010	 pragma solidity 0.6.12;
1011	 contract InfoReader {
1012	 function getTokenBalances(IERC20 _token, address[] memory _accounts) public view returns (uint256[] memory) {
1013	 uint256[] memory balances = new uint256[](_accounts.length);
1014	 for (uint256 i = 0; i < _accounts.length; i++) {
1015	 balances[i] = _token.balanceOf(_accounts[i]);
1016	 }
1017	 return balances;
1018	 }
1019	 function getContractInfo(address[] memory _accounts) public view returns (bool[] memory) {
1020	 bool[] memory info = new bool[](_accounts.length);
1021	 for (uint256 i = 0; i < _accounts.length; i++) {
1022	 info[i] = isContract(_accounts[i]);
1023	 }
1024	 return info;
1025	 }
1026	 function isContract(address account) public view returns (bool) {
1027	 uint256 size;
1028	 assembly {
1029	 size := extcodesize(account) }
1030	 return size > 0;
1031	 }
1032	 }
1033	 pragma solidity 0.6.12;
1034	 interface IDistributor {
1035	 function active() external view returns (bool);
1036	 }
1037	 pragma solidity 0.6.12;
1038	 interface IUniFarm {
1039	 function deposit(uint256 amount, address receiver) external;
1040	 }
1041	 pragma solidity 0.6.12;
1042	 interface IUniswapV2Callee {
1043	 function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;
1044	 }
1045	 pragma solidity 0.6.12;
1046	 contract LGEToken is IERC20, ILGEToken {
1047	 using SafeMath for uint256;
1048	 string public name;
1049	 string public symbol;
1050	 uint8 public decimals;
1051	 uint256 public override totalSupply;
1052	 address public distributor;
1053	 address public override token;
1054	 uint256 public override refBalance;
1055	 uint256 public override refSupply;
1056	 mapping (address => uint256) public balances;
1057	 mapping (address => mapping (address => uint256)) public allowances;
1058	 event SetRefBalance(uint256 refBalance);
1059	 event SetRefSupply(uint256 refSupply);
1060	 modifier onlyDistributor() {
1061	 require(msg.sender == distributor, "LGEToken: forbidden");
1062	 _;
1063	 }
1064	 constructor( string memory _name, string memory _symbol, address _distributor, address _token ) public {
1065	 name = _name;
1066	 symbol = _symbol;
1067	 decimals = 18;
1068	 distributor = _distributor;
1069	 token = _token;
1070	 }
1071	 function mint(address _account, uint256 _amount) public override onlyDistributor returns (bool) {
1072	 _mint(_account, _amount);
1073	 return true;
1074	 }
1075	 function burn(address _account, uint256 _amount) public override onlyDistributor returns (bool) {
1076	 _burn(_account, _amount);
1077	 return true;
1078	 }
1079	 function setRefBalance(uint256 _refBalance) public override onlyDistributor returns (bool) {
1080	 refBalance = _refBalance;
1081	 emit SetRefBalance(_refBalance);
1082	 return true;
1083	 }
1084	 function setRefSupply(uint256 _refSupply) public override onlyDistributor returns (bool) {
1085	 refSupply = _refSupply;
1086	 emit SetRefSupply(_refSupply);
1087	 return true;
1088	 }
1089	 function balanceOf(address _account) public view override returns (uint256) {
1090	 return balances[_account];
1091	 }
1092	 function transfer(address _recipient, uint256 _amount) public override returns (bool) {
1093	 _transfer(msg.sender, _recipient, _amount);
1094	 return true;
1095	 }
1096	 function allowance(address _owner, address _spender) public view override returns (uint256) {
1097	 return allowances[_owner][_spender];
1098	 }
1099	 function approve(address _spender, uint256 _amount) public override returns (bool) {
1100	 _approve(msg.sender, _spender, _amount);
1101	 return true;
1102	 }
1103	 function transferFrom(address _sender, address _recipient, uint256 _amount) public override returns (bool) {
1104	 uint256 nextAllowance = allowances[_sender][msg.sender].sub(_amount, "LGEToken: transfer amount exceeds allowance");
1105	 _approve(_sender, msg.sender, nextAllowance);
1106	 _transfer(_sender, _recipient, _amount);
1107	 return true;
1108	 }
1109	 function _transfer(address _sender, address _recipient, uint256 _amount) private {
1110	 require(_sender != address(0), "LGEToken: transfer from the zero address");
1111	 require(_recipient != address(0), "LGEToken: transfer to the zero address");
1112	 balances[_sender] = balances[_sender].sub(_amount, "LGEToken: transfer amount exceeds balance");
1113	 balances[_recipient] = balances[_recipient].add(_amount);
1114	 emit Transfer(_sender, _recipient, _amount);
1115	 }
1116	 function _mint(address account, uint256 _amount) private {
1117	 require(account != address(0), "LGEToken: mint to the zero address");
1118	 balances[account] = balances[account].add(_amount);
1119	 totalSupply = totalSupply.add(_amount);
1120	 emit Transfer(address(0), account, _amount);
1121	 }
1122	 function _burn(address _account, uint256 _amount) private {
1123	 require(_account != address(0), "LGEToken: burn from the zero address");
1124	 balances[_account] = balances[_account].sub(_amount, "LGEToken: burn amount exceeds balance");
1125	 totalSupply = totalSupply.sub(_amount);
1126	 emit Transfer(_account, address(0), _amount);
1127	 }
1128	 function _approve(address _owner, address _spender, uint256 _amount) private {
1129	 require(_owner != address(0), "LGEToken: approve from the zero address");
1130	 require(_spender != address(0), "LGEToken: approve to the zero address");
1131	 allowances[_owner][_spender] = _amount;
1132	 emit Approval(_owner, _spender, _amount);
1133	 }
1134	 }
1135	 pragma solidity 0.6.12;
1136	 library Math {
1137	 function min(uint x, uint y) internal pure returns (uint z) {
1138	 z = x < y ? x : y;
1139	 }
1140	 function sqrt(uint y) internal pure returns (uint z) {
1141	 if (y > 3) {
1142	 z = y;
1143	 uint x = y / 2 + 1;
1144	 while (x < z) {
1145	 z = x;
1146	 x = (y / x + x) / 2;
1147	 }
1148	 }
1149	 else if (y != 0) {
1150	 z = 1;
1151	 }
1152	 }
1153	 }
1154	 pragma solidity 0.6.12;
1155	 library UQ112x112 {
1156	 uint224 constant Q112 = 2**112;
1157	 function encode(uint112 y) internal pure returns (uint224 z) {
1158	 z = uint224(y) * Q112;
1159	 }
1160	 function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {
1161	 z = x / uint224(y);
1162	 }
1163	 }
1164	 pragma solidity 0.6.12;
1165	 contract Minter is IMinter, ReentrancyGuard {
1166	 using SafeMath for uint256;
1167	 address public immutable xvix;
1168	 address public immutable floor;
1169	 address public immutable distributor;
1170	 uint256 public ethReserve;
1171	 bool public active = false;
1172	 event Mint(address indexed to, uint256 value);
1173	 event FloorPrice(uint256 capital, uint256 supply);
1174	 constructor(address _xvix, address _floor, address _distributor) public {
1175	 xvix = _xvix;
1176	 floor = _floor;
1177	 distributor = _distributor;
1178	 }
1179	 function enableMint(uint256 _ethReserve) public override nonReentrant {
1180	 require(msg.sender == distributor, "Minter: forbidden");
1181	 require(_ethReserve != 0, "Minter: insufficient eth reserve");
1182	 require(!active, "Minter: already active");
1183	 active = true;
1184	 ethReserve = _ethReserve;
1185	 }
1186	 function mint(address _receiver) public override payable nonReentrant {
1187	 require(active, "Minter: not active");
1188	 require(ethReserve > 0, "Minter: insufficient eth reserve");
1189	 require(msg.value > 0, "Minter: insufficient value");
1190	 uint256 toMint = getMintAmount(msg.value);
1191	 require(toMint > 0, "Minter: mint amount is zero");
1192	 IXVIX(xvix).mint(_receiver, toMint);
1193	 ethReserve = ethReserve.add(msg.value);
1194	 (bool success,) = floor.call{
1195	 value: msg.value}
1196	 ("");
1197	 require(success, "Minter: transfer to floor failed");
1198	 emit Mint(_receiver, toMint);
1199	 emit FloorPrice(IFloor(floor).capital(), IERC20(xvix).totalSupply());
1200	 }
1201	 function getMintAmount(uint256 _ethAmount) public view returns (uint256) {
1202	 if (!active) {
1203	 return 0;
1204	 }
1205	 if (IFloor(floor).capital() == 0) {
1206	 return 0;
1207	 }
1208	 uint256 numerator = _ethAmount.mul(tokenReserve());
1209	 uint256 denominator = ethReserve.add(_ethAmount);
1210	 uint256 mintable = numerator.div(denominator);
1211	 uint256 max = IFloor(floor).getMaxMintAmount(_ethAmount);
1212	 return mintable < max ? mintable : max;
1213	 }
1214	 function tokenReserve() public view returns (uint256) {
1215	 uint256 maxSupply = IXVIX(xvix).maxSupply();
1216	 uint256 totalSupply = IERC20(xvix).totalSupply();
1217	 return maxSupply.sub(totalSupply);
1218	 }
1219	 }
1220	 pragma solidity 0.6.12;
1221	 library UniswapV2LibraryMock {
1222	 using SafeMath for uint;
1223	 function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
1224	 require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
1225	 (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
1226	 require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
1227	 }
1228	 function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {
1229	 (address token0, address token1) = sortTokens(tokenA, tokenB);
1230	 pair = address(uint(keccak256(abi.encodePacked( hex'ff', factory, keccak256(abi.encodePacked(token0, token1)), hex'bf679b48085b196f9d52b03e95c7440ff82bf0e67fff5c19e2da17fd628ba9b2' ))));
1231	 }
1232	 function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {
1233	 (address token0,) = sortTokens(tokenA, tokenB);
1234	 (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();
1235	 (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);
1236	 }
1237	 function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {
1238	 require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');
1239	 require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
1240	 amountB = amountA.mul(reserveB) / reserveA;
1241	 }
1242	 function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {
1243	 require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');
1244	 require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
1245	 uint amountInWithFee = amountIn.mul(997);
1246	 uint numerator = amountInWithFee.mul(reserveOut);
1247	 uint denominator = reserveIn.mul(1000).add(amountInWithFee);
1248	 amountOut = numerator / denominator;
1249	 }
1250	 function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {
1251	 require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');
1252	 require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
1253	 uint numerator = reserveIn.mul(amountOut).mul(1000);
1254	 uint denominator = reserveOut.sub(amountOut).mul(997);
1255	 amountIn = (numerator / denominator).add(1);
1256	 }
1257	 function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {
1258	 require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');
1259	 amounts = new uint[](path.length);
1260	 amounts[0] = amountIn;
1261	 for (uint i; i < path.length - 1; i++) {
1262	 (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);
1263	 amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);
1264	 }
1265	 }
1266	 function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {
1267	 require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');
1268	 amounts = new uint[](path.length);
1269	 amounts[amounts.length - 1] = amountOut;
1270	 for (uint i = path.length - 1; i > 0; i--) {
1271	 (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);
1272	 amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);
1273	 }
1274	 }
1275	 }
1276	 pragma solidity 0.6.12;
1277	 contract Reader {
1278	 using SafeMath for uint256;
1279	 uint256 public constant BASIS_POINTS_DIVISOR = 10000;
1280	 address public immutable factory;
1281	 address public immutable xvix;
1282	 address public immutable dai;
1283	 address public immutable lgeTokenWETH;
1284	 address public immutable distributor;
1285	 address public immutable floor;
1286	 constructor( address _factory, address _xvix, address _dai, address _lgeTokenWETH, address _distributor, address _floor ) public {
1287	 factory = _factory;
1288	 xvix = _xvix;
1289	 dai = _dai;
1290	 lgeTokenWETH = _lgeTokenWETH;
1291	 distributor = _distributor;
1292	 floor = _floor;
1293	 }
1294	 function getWithdrawalSlots(ITimeVault vault, uint256[] memory slots) public view returns (uint256[] memory) {
1295	 uint256[] memory amounts = new uint256[](slots.length);
1296	 for (uint256 i = 0; i < slots.length; i++) {
1297	 amounts[i] = vault.withdrawalSlots(slots[i]);
1298	 }
1299	 return amounts;
1300	 }
1301	 function getBalances(IERC20 _token, address[] memory _accounts) public view returns (uint256[] memory) {
1302	 uint256[] memory balances = new uint256[](_accounts.length + 1);
1303	 balances[0] = _token.totalSupply();
1304	 for (uint256 i = 0; i < _accounts.length; i++) {
1305	 balances[i + 1] = _token.balanceOf(_accounts[i]);
1306	 }
1307	 return balances;
1308	 }
1309	 function getPoolAmounts( address _account, address _token0, address _token1 ) external view returns (uint256, uint256, uint256, uint256, uint256) {
1310	 address pair = UniswapV2Library.pairFor(factory, _token0, _token1);
1311	 uint256 supply = IERC20(pair).totalSupply();
1312	 if (supply == 0) {
1313	 return (0, 0, 0, 0, 0);
1314	 }
1315	 uint256 accountBalance = IERC20(pair).balanceOf(_account);
1316	 uint256 balance0 = IERC20(_token0).balanceOf(pair);
1317	 uint256 balance1 = IERC20(_token1).balanceOf(pair);
1318	 uint256 pool0 = balance0.mul(accountBalance).div(supply);
1319	 uint256 pool1 = balance1.mul(accountBalance).div(supply);
1320	 return (pool0, pool1, balance0, balance1, supply);
1321	 }
1322	 function getLGEAmounts(address _account) public view returns (uint256, uint256, uint256, uint256) {
1323	 uint256 accountBalance = IERC20(lgeTokenWETH).balanceOf(_account);
1324	 uint256 supply = IERC20(lgeTokenWETH).totalSupply();
1325	 if (supply == 0) {
1326	 return (0, 0, 0, 0);
1327	 }
1328	 return ( accountBalance, distributor.balance.mul(accountBalance).div(supply), IERC20(dai).balanceOf(distributor).mul(accountBalance).div(supply), IERC20(xvix).balanceOf(distributor).mul(accountBalance).div(supply) );
1329	 }
1330	 function getLPAmounts(address _account, address _lgeToken) public view returns (uint256, uint256, uint256, uint256, uint256) {
1331	 uint256 supply = IERC20(_lgeToken).totalSupply();
1332	 if (supply == 0) {
1333	 return (0, 0, 0, 0, 0);
1334	 }
1335	 uint256 amountLGEToken = IERC20(_lgeToken).balanceOf(_account);
1336	 address pair = UniswapV2Library.pairFor(factory, xvix, ILGEToken(_lgeToken).token());
1337	 uint256 amountToken = getLPAmount(_account, pair, _lgeToken, ILGEToken(_lgeToken).token());
1338	 uint256 amountXVIX = getLPAmount(_account, pair, _lgeToken, xvix);
1339	 uint256 refundBasisPoints = getRefundBasisPoints(_lgeToken, amountLGEToken, amountToken);
1340	 return ( amountLGEToken, amountToken, amountXVIX, refundBasisPoints, IFloor(floor).getRefundAmount(amountXVIX) );
1341	 }
1342	 function getLPAmount(address _account, address _pair, address _lgeToken, address _token) public view returns (uint256) {
1343	 if (IERC20(_pair).totalSupply() == 0) {
1344	 return 0;
1345	 }
1346	 uint256 amountLGEToken = IERC20(_lgeToken).balanceOf(_account);
1347	 uint256 totalTokenBalance = IERC20(_token).balanceOf(_pair);
1348	 uint256 distributorTokenBalance = totalTokenBalance .mul(IERC20(_pair).balanceOf(distributor)) .div(IERC20(_pair).totalSupply());
1349	 return distributorTokenBalance .mul(amountLGEToken) .div(IERC20(_lgeToken).totalSupply());
1350	 }
1351	 function getRefundBasisPoints(address _lgeToken, uint256 _amountLGEToken, uint256 _amountToken) public view returns (uint256) {
1352	 uint256 refBalance = ILGEToken(_lgeToken).refBalance();
1353	 uint256 refSupply = ILGEToken(_lgeToken).refSupply();
1354	 uint256 refAmount = _amountLGEToken.mul(refBalance).div(refSupply);
1355	 uint256 minExpectedAmount = refAmount.mul(2);
1356	 if (_amountToken >= minExpectedAmount) {
1357	 return 0;
1358	 }
1359	 uint256 diff = minExpectedAmount.sub(_amountToken);
1360	 uint256 refundBasisPoints = diff.mul(BASIS_POINTS_DIVISOR).div(refAmount);
1361	 if (refundBasisPoints >= BASIS_POINTS_DIVISOR) {
1362	 return BASIS_POINTS_DIVISOR;
1363	 }
1364	 return refundBasisPoints;
1365	 }
1366	 }
1367	 pragma solidity 0.6.12;
1368	 library UniswapV2Library {
1369	 using SafeMath for uint;
1370	 function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
1371	 require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
1372	 (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
1373	 require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
1374	 }
1375	 function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {
1376	 (address token0, address token1) = sortTokens(tokenA, tokenB);
1377	 pair = address(uint(keccak256(abi.encodePacked( hex'ff', factory, keccak256(abi.encodePacked(token0, token1)), hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' ))));
1378	 }
1379	 function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {
1380	 (address token0,) = sortTokens(tokenA, tokenB);
1381	 (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();
1382	 (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);
1383	 }
1384	 function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {
1385	 require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');
1386	 require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
1387	 amountB = amountA.mul(reserveB) / reserveA;
1388	 }
1389	 function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {
1390	 require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');
1391	 require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
1392	 uint amountInWithFee = amountIn.mul(997);
1393	 uint numerator = amountInWithFee.mul(reserveOut);
1394	 uint denominator = reserveIn.mul(1000).add(amountInWithFee);
1395	 amountOut = numerator / denominator;
1396	 }
1397	 function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {
1398	 require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');
1399	 require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
1400	 uint numerator = reserveIn.mul(amountOut).mul(1000);
1401	 uint denominator = reserveOut.sub(amountOut).mul(997);
1402	 amountIn = (numerator / denominator).add(1);
1403	 }
1404	 function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {
1405	 require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');
1406	 amounts = new uint[](path.length);
1407	 amounts[0] = amountIn;
1408	 for (uint i; i < path.length - 1; i++) {
1409	 (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);
1410	 amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);
1411	 }
1412	 }
1413	 function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {
1414	 require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');
1415	 amounts = new uint[](path.length);
1416	 amounts[amounts.length - 1] = amountOut;
1417	 for (uint i = path.length - 1; i > 0; i--) {
1418	 (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);
1419	 amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);
1420	 }
1421	 }
1422	 }
1423	 pragma solidity 0.6.12;
1424	 contract Timelock {
1425	 using SafeMath for uint256;
1426	 uint256 public constant DELAY = 5 days;
1427	 address public xvix;
1428	 address public owner;
1429	 address public nextGov;
1430	 uint256 public unlockTime;
1431	 event SuggestGov(address gov, uint256 unlockTime);
1432	 modifier onlyOwner() {
1433	 require(msg.sender == owner, "Timelock: forbidden");
1434	 _;
1435	 }
1436	 constructor(address _xvix) public {
1437	 owner = msg.sender;
1438	 xvix = _xvix;
1439	 }
1440	 function suggestGov(address _gov) public onlyOwner {
1441	 require(_gov != address(0), "Timelock: gov address is empty");
1442	 unlockTime = block.timestamp.add(DELAY);
1443	 nextGov = _gov;
1444	 emit SuggestGov(_gov, unlockTime);
1445	 }
1446	 function setGov() public onlyOwner {
1447	 require(unlockTime != 0 && unlockTime < block.timestamp, "Timelock: not unlocked");
1448	 IXVIX(xvix).setGov(nextGov);
1449	 }
1450	 }
1451	 pragma solidity 0.6.12;
1452	 contract TimeVault is ITimeVault, ReentrancyGuard {
1453	 using SafeMath for uint256;
1454	 uint256 public constant WITHDRAWAL_DELAY = 7 days;
1455	 uint256 public constant WITHDRAWAL_WINDOW = 48 hours;
1456	 address public token;
1457	 mapping (address => uint256) public balances;
1458	 mapping (address => uint256) public withdrawalTimestamps;
1459	 mapping (address => uint256) public withdrawalAmounts;
1460	 mapping (uint256 => uint256) public override withdrawalSlots;
1461	 event Deposit(address account, uint256 amount);
1462	 event BeginWithdrawal(address account, uint256 amount);
1463	 event Withdraw(address account, uint256 amount);
1464	 constructor(address _token) public {
1465	 token = _token;
1466	 }
1467	 function deposit(uint256 _amount) external nonReentrant {
1468	 require(_amount > 0, "TimeVault: insufficient amount");
1469	 address account = msg.sender;
1470	 IERC20(token).transferFrom(account, address(this), _amount);
1471	 balances[account] = balances[account].add(_amount);
1472	 emit Deposit(account, _amount);
1473	 }
1474	 function beginWithdrawal(uint256 _amount) external nonReentrant {
1475	 address account = msg.sender;
1476	 require(_amount > 0, "TimeVault: insufficient amount");
1477	 require(_amount <= balanceOf(account), "TimeVault: insufficient balance");
1478	 _decreaseWithdrawalSlot(withdrawalTimestamps[account], withdrawalAmounts[account]);
1479	 uint256 time = block.timestamp.add(WITHDRAWAL_DELAY);
1480	 withdrawalTimestamps[account] = time;
1481	 withdrawalAmounts[account] = _amount;
1482	 _increaseWithdrawalSlot(time, _amount);
1483	 emit BeginWithdrawal(account, _amount);
1484	 }
1485	 function withdraw(address _receiver) external nonReentrant {
1486	 address account = msg.sender;
1487	 uint256 currentTime = block.timestamp;
1488	 uint256 minTime = withdrawalTimestamps[account];
1489	 require(minTime != 0, "TimeVault: withdrawal not initiated");
1490	 require(currentTime > minTime, "TimeVault: withdrawal timing not reached");
1491	 uint256 maxTime = minTime.add(WITHDRAWAL_WINDOW);
1492	 require(currentTime < maxTime, "TimeVault: withdrawal window already passed");
1493	 uint256 amount = withdrawalAmounts[account];
1494	 require(amount <= balanceOf(account), "TimeVault: insufficient amount");
1495	 _decreaseWithdrawalSlot(minTime, amount);
1496	 withdrawalTimestamps[account] = 0;
1497	 withdrawalAmounts[account] = 0;
1498	 balances[account] = balances[account].sub(amount);
1499	 IXVIX(token).rebase();
1500	 IERC20(token).transfer(_receiver, amount);
1501	 emit Withdraw(account, amount);
1502	 }
1503	 function balanceOf(address account) public view returns (uint256) {
1504	 return balances[account];
1505	 }
1506	 function getWithdrawalSlot(uint256 _time) public pure returns (uint256) {
1507	 return _time.div(WITHDRAWAL_WINDOW);
1508	 }
1509	 function _increaseWithdrawalSlot(uint256 _time, uint256 _amount) private {
1510	 uint256 slot = getWithdrawalSlot(_time);
1511	 withdrawalSlots[slot] = withdrawalSlots[slot].add(_amount);
1512	 }
1513	 function _decreaseWithdrawalSlot(uint256 _time, uint256 _amount) private {
1514	 if (_time == 0 || _amount == 0) {
1515	 return;
1516	 }
1517	 uint256 slot = getWithdrawalSlot(_time);
1518	 if (_amount > withdrawalSlots[slot]) {
1519	 withdrawalSlots[slot] = 0;
1520	 return;
1521	 }
1522	 withdrawalSlots[slot] = withdrawalSlots[slot].sub(_amount);
1523	 }
1524	 }
1525	 pragma solidity 0.6.12;
1526	 contract DAI is IERC20 {
1527	 using SafeMath for uint256;
1528	 mapping (address => uint256) private _balances;
1529	 mapping (address => mapping (address => uint256)) private _allowances;
1530	 uint256 private _totalSupply;
1531	 string private _name;
1532	 string private _symbol;
1533	 uint8 private _decimals;
1534	 constructor () public {
1535	 _name = "Dai Stablecoin";
1536	 _symbol = "DAI";
1537	 _decimals = 18;
1538	 }
1539	 function mint(address _account, uint256 _amount) public {
1540	 _mint(_account, _amount);
1541	 }
1542	 function withdraw(uint256 amount) public {
1543	 require(_balances[msg.sender] >= amount);
1544	 _balances[msg.sender] = _balances[msg.sender].sub(amount);
1545	 msg.sender.transfer(amount);
1546	 }
1547	 function name() public view returns (string memory) {
1548	 return _name;
1549	 }
1550	 function symbol() public view returns (string memory) {
1551	 return _symbol;
1552	 }
1553	 function decimals() public view returns (uint8) {
1554	 return _decimals;
1555	 }
1556	 function totalSupply() public view override returns (uint256) {
1557	 return _totalSupply;
1558	 }
1559	 function balanceOf(address account) public view override returns (uint256) {
1560	 return _balances[account];
1561	 }
1562	 function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
1563	 _transfer(_msgSender(), recipient, amount);
1564	 return true;
1565	 }
1566	 function allowance(address owner, address spender) public view virtual override returns (uint256) {
1567	 return _allowances[owner][spender];
1568	 }
1569	 function approve(address spender, uint256 amount) public virtual override returns (bool) {
1570	 _approve(_msgSender(), spender, amount);
1571	 return true;
1572	 }
1573	 function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
1574	 _transfer(sender, recipient, amount);
1575	 _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
1576	 return true;
1577	 }
1578	 function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
1579	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
1580	 return true;
1581	 }
1582	 function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
1583	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
1584	 return true;
1585	 }
1586	 function _transfer(address sender, address recipient, uint256 amount) internal virtual {
1587	 require(sender != address(0), "ERC20: transfer from the zero address");
1588	 require(recipient != address(0), "ERC20: transfer to the zero address");
1589	 _beforeTokenTransfer(sender, recipient, amount);
1590	 _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
1591	 _balances[recipient] = _balances[recipient].add(amount);
1592	 emit Transfer(sender, recipient, amount);
1593	 }
1594	 function _mint(address account, uint256 amount) internal virtual {
1595	 require(account != address(0), "ERC20: mint to the zero address");
1596	 _beforeTokenTransfer(address(0), account, amount);
1597	 _totalSupply = _totalSupply.add(amount);
1598	 _balances[account] = _balances[account].add(amount);
1599	 emit Transfer(address(0), account, amount);
1600	 }
1601	 function _burn(address account, uint256 amount) internal virtual {
1602	 require(account != address(0), "ERC20: burn from the zero address");
1603	 _beforeTokenTransfer(account, address(0), amount);
1604	 _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
1605	 _totalSupply = _totalSupply.sub(amount);
1606	 emit Transfer(account, address(0), amount);
1607	 }
1608	 function _approve(address owner, address spender, uint256 amount) internal virtual {
1609	 require(owner != address(0), "ERC20: approve from the zero address");
1610	 require(spender != address(0), "ERC20: approve to the zero address");
1611	 _allowances[owner][spender] = amount;
1612	 emit Approval(owner, spender, amount);
1613	 }
1614	 function _setupDecimals(uint8 decimals_) internal {
1615	 _decimals = decimals_;
1616	 }
1617	 function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {
1618	 }
1619	 function _msgSender() internal view virtual returns (address payable) {
1620	 return msg.sender;
1621	 }
1622	 }
1623	 pragma solidity 0.6.12;
1624	 contract WETH is IERC20 {
1625	 using SafeMath for uint256;
1626	 mapping (address => uint256) private _balances;
1627	 mapping (address => mapping (address => uint256)) private _allowances;
1628	 uint256 private _totalSupply;
1629	 string private _name;
1630	 string private _symbol;
1631	 uint8 private _decimals;
1632	 constructor () public {
1633	 _name = "Wrapped ETH";
1634	 _symbol = "WETH";
1635	 _decimals = 18;
1636	 }
1637	 function deposit() public payable {
1638	 _balances[msg.sender] = _balances[msg.sender].add(msg.value);
1639	 }
1640	 function withdraw(uint256 amount) public {
1641	 require(_balances[msg.sender] >= amount);
1642	 _balances[msg.sender] = _balances[msg.sender].sub(amount);
1643	 msg.sender.transfer(amount);
1644	 }
1645	 function name() public view returns (string memory) {
1646	 return _name;
1647	 }
1648	 function symbol() public view returns (string memory) {
1649	 return _symbol;
1650	 }
1651	 function decimals() public view returns (uint8) {
1652	 return _decimals;
1653	 }
1654	 function totalSupply() public view override returns (uint256) {
1655	 return _totalSupply;
1656	 }
1657	 function balanceOf(address account) public view override returns (uint256) {
1658	 return _balances[account];
1659	 }
1660	 function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
1661	 _transfer(_msgSender(), recipient, amount);
1662	 return true;
1663	 }
1664	 function allowance(address owner, address spender) public view virtual override returns (uint256) {
1665	 return _allowances[owner][spender];
1666	 }
1667	 function approve(address spender, uint256 amount) public virtual override returns (bool) {
1668	 _approve(_msgSender(), spender, amount);
1669	 return true;
1670	 }
1671	 function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
1672	 _transfer(sender, recipient, amount);
1673	 _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
1674	 return true;
1675	 }
1676	 function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
1677	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
1678	 return true;
1679	 }
1680	 function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
1681	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
1682	 return true;
1683	 }
1684	 function _transfer(address sender, address recipient, uint256 amount) internal virtual {
1685	 require(sender != address(0), "ERC20: transfer from the zero address");
1686	 require(recipient != address(0), "ERC20: transfer to the zero address");
1687	 _beforeTokenTransfer(sender, recipient, amount);
1688	 _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
1689	 _balances[recipient] = _balances[recipient].add(amount);
1690	 emit Transfer(sender, recipient, amount);
1691	 }
1692	 function _mint(address account, uint256 amount) internal virtual {
1693	 require(account != address(0), "ERC20: mint to the zero address");
1694	 _beforeTokenTransfer(address(0), account, amount);
1695	 _totalSupply = _totalSupply.add(amount);
1696	 _balances[account] = _balances[account].add(amount);
1697	 emit Transfer(address(0), account, amount);
1698	 }
1699	 function _burn(address account, uint256 amount) internal virtual {
1700	 require(account != address(0), "ERC20: burn from the zero address");
1701	 _beforeTokenTransfer(account, address(0), amount);
1702	 _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
1703	 _totalSupply = _totalSupply.sub(amount);
1704	 emit Transfer(account, address(0), amount);
1705	 }
1706	 function _approve(address owner, address spender, uint256 amount) internal virtual {
1707	 require(owner != address(0), "ERC20: approve from the zero address");
1708	 require(spender != address(0), "ERC20: approve to the zero address");
1709	 _allowances[owner][spender] = amount;
1710	 emit Approval(owner, spender, amount);
1711	 }
1712	 function _setupDecimals(uint8 decimals_) internal {
1713	 _decimals = decimals_;
1714	 }
1715	 function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {
1716	 }
1717	 function _msgSender() internal view virtual returns (address payable) {
1718	 return msg.sender;
1719	 }
1720	 }
1721	 pragma solidity 0.6.12;
1722	 library TransferHelper {
1723	 function safeApprove(address token, address to, uint value) internal {
1724	 (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));
1725	 require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');
1726	 }
1727	 function safeTransfer(address token, address to, uint value) internal {
1728	 (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));
1729	 require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');
1730	 }
1731	 function safeTransferFrom(address token, address from, address to, uint value) internal {
1732	 (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));
1733	 require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');
1734	 }
1735	 function safeTransferETH(address to, uint value) internal {
1736	 (bool success,) = to.call{
1737	 value:value}
1738	 (new bytes(0));
1739	 require(success, 'TransferHelper: ETH_TRANSFER_FAILED');
1740	 }
1741	 }
1742	 pragma solidity 0.6.12;
1743	 contract UniswapV2Factory is IUniswapV2Factory {
1744	 address public override feeTo;
1745	 address public override feeToSetter;
1746	 mapping(address => mapping(address => address)) public override getPair;
1747	 address[] public override allPairs;
1748	 event PairCreated(address indexed token0, address indexed token1, address pair, uint);
1749	 constructor(address _feeToSetter) public {
1750	 feeToSetter = _feeToSetter;
1751	 }
1752	 function allPairsLength() external override view returns (uint) {
1753	 return allPairs.length;
1754	 }
1755	 function createPair(address tokenA, address tokenB) external override returns (address pair) {
1756	 require(tokenA != tokenB, 'UniswapV2: IDENTICAL_ADDRESSES');
1757	 (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
1758	 require(token0 != address(0), 'UniswapV2: ZERO_ADDRESS');
1759	 require(getPair[token0][token1] == address(0), 'UniswapV2: PAIR_EXISTS');
1760	 bytes memory bytecode = type(UniswapV2Pair).creationCode;
1761	 bytes32 salt = keccak256(abi.encodePacked(token0, token1));
1762	 assembly {
1763	 pair := create2(0, add(bytecode, 32), mload(bytecode), salt) }
1764	 IUniswapV2Pair(pair).initialize(token0, token1);
1765	 getPair[token0][token1] = pair;
1766	 getPair[token1][token0] = pair;
1767	 allPairs.push(pair);
1768	 emit PairCreated(token0, token1, pair, allPairs.length);
1769	 }
1770	 function setFeeTo(address _feeTo) external override {
1771	 require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');
1772	 feeTo = _feeTo;
1773	 }
1774	 function setFeeToSetter(address _feeToSetter) external override {
1775	 require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');
1776	 feeToSetter = _feeToSetter;
1777	 }
1778	 }
1779	 pragma solidity 0.6.12;
1780	 contract UniswapV2Pair is IUniswapV2Pair, UniswapV2ERC20 {
1781	 using SafeMath for uint;
1782	 using UQ112x112 for uint224;
1783	 uint public constant override MINIMUM_LIQUIDITY = 10**3;
1784	 bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));
1785	 address public override factory;
1786	 address public override token0;
1787	 address public override token1;
1788	 uint112 private reserve0;
1789	 uint112 private reserve1;
1790	 uint32 private blockTimestampLast;
1791	 uint public override price0CumulativeLast;
1792	 uint public override price1CumulativeLast;
1793	 uint public override kLast;
1794	 uint private unlocked = 1;
1795	 modifier lock() {
1796	 require(unlocked == 1, 'UniswapV2: LOCKED');
1797	 unlocked = 0;
1798	 _;
1799	 unlocked = 1;
1800	 }
1801	 function getReserves() public override view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {
1802	 _reserve0 = reserve0;
1803	 _reserve1 = reserve1;
1804	 _blockTimestampLast = blockTimestampLast;
1805	 }
1806	 function _safeTransfer(address token, address to, uint value) private {
1807	 (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));
1808	 require(success && (data.length == 0 || abi.decode(data, (bool))), 'UniswapV2: TRANSFER_FAILED');
1809	 }
1810	 event Mint(address indexed sender, uint amount0, uint amount1);
1811	 event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
1812	 event Swap( address indexed sender, uint amount0In, uint amount1In, uint amount0Out, uint amount1Out, address indexed to );
1813	 event Sync(uint112 reserve0, uint112 reserve1);
1814	 constructor() public {
1815	 factory = msg.sender;
1816	 }
1817	 function initialize(address _token0, address _token1) external override {
1818	 require(msg.sender == factory, 'UniswapV2: FORBIDDEN');
1819	 token0 = _token0;
1820	 token1 = _token1;
1821	 }
1822	 function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {
1823	 require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'UniswapV2: OVERFLOW');
1824	 uint32 blockTimestamp = uint32(block.timestamp % 2**32);
1825	 uint32 timeElapsed = blockTimestamp - blockTimestampLast;
1826	 if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {
1827	 price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;
1828	 price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;
1829	 }
1830	 reserve0 = uint112(balance0);
1831	 reserve1 = uint112(balance1);
1832	 blockTimestampLast = blockTimestamp;
1833	 emit Sync(reserve0, reserve1);
1834	 }
1835	 function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {
1836	 address feeTo = IUniswapV2Factory(factory).feeTo();
1837	 feeOn = feeTo != address(0);
1838	 uint _kLast = kLast;
1839	 if (feeOn) {
1840	 if (_kLast != 0) {
1841	 uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));
1842	 uint rootKLast = Math.sqrt(_kLast);
1843	 if (rootK > rootKLast) {
1844	 uint numerator = totalSupply().mul(rootK.sub(rootKLast));
1845	 uint denominator = rootK.mul(5).add(rootKLast);
1846	 uint liquidity = numerator / denominator;
1847	 if (liquidity > 0) _mint(feeTo, liquidity);
1848	 }
1849	 }
1850	 }
1851	 else if (_kLast != 0) {
1852	 kLast = 0;
1853	 }
1854	 }
1855	 function mint(address to) external override lock returns (uint liquidity) {
1856	 (uint112 _reserve0, uint112 _reserve1,) = getReserves();
1857	 uint balance0 = IERC20(token0).balanceOf(address(this));
1858	 uint balance1 = IERC20(token1).balanceOf(address(this));
1859	 uint amount0 = balance0.sub(_reserve0);
1860	 uint amount1 = balance1.sub(_reserve1);
1861	 bool feeOn = _mintFee(_reserve0, _reserve1);
1862	 uint _totalSupply = totalSupply();
1863	 if (_totalSupply == 0) {
1864	 liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);
1865	 _mint(address(0), MINIMUM_LIQUIDITY);
1866	 }
1867	 else {
1868	 liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);
1869	 }
1870	 require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');
1871	 _mint(to, liquidity);
1872	 _update(balance0, balance1, _reserve0, _reserve1);
1873	 if (feeOn) kLast = uint(reserve0).mul(reserve1);
1874	 emit Mint(msg.sender, amount0, amount1);
1875	 }
1876	 function burn(address to) external override lock returns (uint amount0, uint amount1) {
1877	 (uint112 _reserve0, uint112 _reserve1,) = getReserves();
1878	 address _token0 = token0;
1879	 address _token1 = token1;
1880	 uint balance0 = IERC20(_token0).balanceOf(address(this));
1881	 uint balance1 = IERC20(_token1).balanceOf(address(this));
1882	 uint liquidity = balanceOf(address(this));
1883	 bool feeOn = _mintFee(_reserve0, _reserve1);
1884	 uint _totalSupply = totalSupply();
1885	 amount0 = liquidity.mul(balance0) / _totalSupply;
1886	 amount1 = liquidity.mul(balance1) / _totalSupply;
1887	 require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');
1888	 _burn(address(this), liquidity);
1889	 _safeTransfer(_token0, to, amount0);
1890	 _safeTransfer(_token1, to, amount1);
1891	 balance0 = IERC20(_token0).balanceOf(address(this));
1892	 balance1 = IERC20(_token1).balanceOf(address(this));
1893	 _update(balance0, balance1, _reserve0, _reserve1);
1894	 if (feeOn) kLast = uint(reserve0).mul(reserve1);
1895	 emit Burn(msg.sender, amount0, amount1, to);
1896	 }
1897	 function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external override lock {
1898	 require(amount0Out > 0 || amount1Out > 0, 'UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT');
1899	 (uint112 _reserve0, uint112 _reserve1,) = getReserves();
1900	 require(amount0Out < _reserve0 && amount1Out < _reserve1, 'UniswapV2: INSUFFICIENT_LIQUIDITY');
1901	 uint balance0;
1902	 uint balance1;
1903	 {
1904	 address _token0 = token0;
1905	 address _token1 = token1;
1906	 require(to != _token0 && to != _token1, 'UniswapV2: INVALID_TO');
1907	 if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out);
1908	 if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out);
1909	 if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);
1910	 balance0 = IERC20(_token0).balanceOf(address(this));
1911	 balance1 = IERC20(_token1).balanceOf(address(this));
1912	 }
1913	 uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;
1914	 uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;
1915	 require(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');
1916	 {
1917	 uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));
1918	 uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));
1919	 require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K');
1920	 }
1921	 _update(balance0, balance1, _reserve0, _reserve1);
1922	 emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);
1923	 }
1924	 function skim(address to) external override lock {
1925	 address _token0 = token0;
1926	 address _token1 = token1;
1927	 _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));
1928	 _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));
1929	 }
1930	 function sync() external override lock {
1931	 _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);
1932	 }
1933	 }
1934	 pragma solidity 0.6.12;
1935	 contract UniswapV2Router is IUniswapV2Router {
1936	 using SafeMath for uint;
1937	 address public immutable factory;
1938	 address public immutable WETH;
1939	 modifier ensure(uint deadline) {
1940	 require(deadline >= block.timestamp, 'UniswapV2Router: EXPIRED');
1941	 _;
1942	 }
1943	 constructor(address _factory, address _WETH) public {
1944	 factory = _factory;
1945	 WETH = _WETH;
1946	 }
1947	 receive() external payable {
1948	 assert(msg.sender == WETH);
1949	 }
1950	 function _addLiquidity( address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin ) internal virtual returns (uint amountA, uint amountB) {
1951	 if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {
1952	 IUniswapV2Factory(factory).createPair(tokenA, tokenB);
1953	 }
1954	 (uint reserveA, uint reserveB) = UniswapV2LibraryMock.getReserves(factory, tokenA, tokenB);
1955	 if (reserveA == 0 && reserveB == 0) {
1956	 (amountA, amountB) = (amountADesired, amountBDesired);
1957	 }
1958	 else {
1959	 uint amountBOptimal = UniswapV2LibraryMock.quote(amountADesired, reserveA, reserveB);
1960	 if (amountBOptimal <= amountBDesired) {
1961	 require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');
1962	 (amountA, amountB) = (amountADesired, amountBOptimal);
1963	 }
1964	 else {
1965	 uint amountAOptimal = UniswapV2LibraryMock.quote(amountBDesired, reserveB, reserveA);
1966	 assert(amountAOptimal <= amountADesired);
1967	 require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');
1968	 (amountA, amountB) = (amountAOptimal, amountBDesired);
1969	 }
1970	 }
1971	 }
1972	 function addLiquidity( address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {
1973	 (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);
1974	 address pair = UniswapV2LibraryMock.pairFor(factory, tokenA, tokenB);
1975	 TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);
1976	 TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);
1977	 liquidity = IUniswapV2Pair(pair).mint(to);
1978	 }
1979	 function addLiquidityETH( address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) external virtual override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {
1980	 (amountToken, amountETH) = _addLiquidity( token, WETH, amountTokenDesired, msg.value, amountTokenMin, amountETHMin );
1981	 address pair = UniswapV2LibraryMock.pairFor(factory, token, WETH);
1982	 TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);
1983	 IWETH(WETH).deposit{
1984	 value: amountETH}
1985	 ();
1986	 assert(IWETH(WETH).transfer(pair, amountETH));
1987	 liquidity = IUniswapV2Pair(pair).mint(to);
1988	 if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);
1989	 }
1990	 function removeLiquidity( address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) {
1991	 address pair = UniswapV2LibraryMock.pairFor(factory, tokenA, tokenB);
1992	 IUniswapV2ERC20(pair).transferFrom(msg.sender, pair, liquidity);
1993	 (uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to);
1994	 (address token0,) = UniswapV2LibraryMock.sortTokens(tokenA, tokenB);
1995	 (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);
1996	 require(amountA >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');
1997	 require(amountB >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');
1998	 }
1999	 function removeLiquidityETH( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) {
2000	 (amountToken, amountETH) = removeLiquidity( token, WETH, liquidity, amountTokenMin, amountETHMin, address(this), deadline );
2001	 TransferHelper.safeTransfer(token, to, amountToken);
2002	 IWETH(WETH).withdraw(amountETH);
2003	 TransferHelper.safeTransferETH(to, amountETH);
2004	 }
2005	 function removeLiquidityETHSupportingFeeOnTransferTokens( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) public virtual ensure(deadline) returns (uint amountETH) {
2006	 (, amountETH) = removeLiquidity( token, WETH, liquidity, amountTokenMin, amountETHMin, address(this), deadline );
2007	 TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));
2008	 IWETH(WETH).withdraw(amountETH);
2009	 TransferHelper.safeTransferETH(to, amountETH);
2010	 }
2011	 function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual {
2012	 for (uint i; i < path.length - 1; i++) {
2013	 (address input, address output) = (path[i], path[i + 1]);
2014	 (address token0,) = UniswapV2LibraryMock.sortTokens(input, output);
2015	 uint amountOut = amounts[i + 1];
2016	 (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));
2017	 address to = i < path.length - 2 ? UniswapV2LibraryMock.pairFor(factory, output, path[i + 2]) : _to;
2018	 IUniswapV2Pair(UniswapV2LibraryMock.pairFor(factory, input, output)).swap( amount0Out, amount1Out, to, new bytes(0) );
2019	 }
2020	 }
2021	 function swapExactTokensForTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external virtual ensure(deadline) returns (uint[] memory amounts) {
2022	 amounts = UniswapV2LibraryMock.getAmountsOut(factory, amountIn, path);
2023	 require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');
2024	 TransferHelper.safeTransferFrom( path[0], msg.sender, UniswapV2LibraryMock.pairFor(factory, path[0], path[1]), amounts[0] );
2025	 _swap(amounts, path, to);
2026	 }
2027	 function swapTokensForExactTokens( uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline ) external virtual ensure(deadline) returns (uint[] memory amounts) {
2028	 amounts = UniswapV2LibraryMock.getAmountsIn(factory, amountOut, path);
2029	 require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');
2030	 TransferHelper.safeTransferFrom( path[0], msg.sender, UniswapV2LibraryMock.pairFor(factory, path[0], path[1]), amounts[0] );
2031	 _swap(amounts, path, to);
2032	 }
2033	 function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external virtual override payable ensure(deadline) returns (uint[] memory amounts) {
2034	 require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');
2035	 amounts = UniswapV2LibraryMock.getAmountsOut(factory, msg.value, path);
2036	 require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');
2037	 IWETH(WETH).deposit{
2038	 value: amounts[0]}
2039	 ();
2040	 assert(IWETH(WETH).transfer(UniswapV2LibraryMock.pairFor(factory, path[0], path[1]), amounts[0]));
2041	 _swap(amounts, path, to);
2042	 }
2043	 function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external virtual ensure(deadline) returns (uint[] memory amounts) {
2044	 require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');
2045	 amounts = UniswapV2LibraryMock.getAmountsIn(factory, amountOut, path);
2046	 require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');
2047	 TransferHelper.safeTransferFrom( path[0], msg.sender, UniswapV2LibraryMock.pairFor(factory, path[0], path[1]), amounts[0] );
2048	 _swap(amounts, path, address(this));
2049	 IWETH(WETH).withdraw(amounts[amounts.length - 1]);
2050	 TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);
2051	 }
2052	 function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external override virtual ensure(deadline) returns (uint[] memory amounts) {
2053	 require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');
2054	 amounts = UniswapV2LibraryMock.getAmountsOut(factory, amountIn, path);
2055	 require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');
2056	 TransferHelper.safeTransferFrom( path[0], msg.sender, UniswapV2LibraryMock.pairFor(factory, path[0], path[1]), amounts[0] );
2057	 _swap(amounts, path, address(this));
2058	 IWETH(WETH).withdraw(amounts[amounts.length - 1]);
2059	 TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);
2060	 }
2061	 function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) external virtual override payable ensure(deadline) returns (uint[] memory amounts) {
2062	 require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');
2063	 amounts = UniswapV2LibraryMock.getAmountsIn(factory, amountOut, path);
2064	 require(amounts[0] <= msg.value, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');
2065	 IWETH(WETH).deposit{
2066	 value: amounts[0]}
2067	 ();
2068	 assert(IWETH(WETH).transfer(UniswapV2LibraryMock.pairFor(factory, path[0], path[1]), amounts[0]));
2069	 _swap(amounts, path, to);
2070	 if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);
2071	 }
2072	 function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual {
2073	 for (uint i; i < path.length - 1; i++) {
2074	 (address input, address output) = (path[i], path[i + 1]);
2075	 (address token0,) = UniswapV2LibraryMock.sortTokens(input, output);
2076	 IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2LibraryMock.pairFor(factory, input, output));
2077	 uint amountInput;
2078	 uint amountOutput;
2079	 {
2080	 (uint reserve0, uint reserve1,) = pair.getReserves();
2081	 (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);
2082	 amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);
2083	 amountOutput = UniswapV2LibraryMock.getAmountOut(amountInput, reserveInput, reserveOutput);
2084	 }
2085	 (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));
2086	 address to = i < path.length - 2 ? UniswapV2LibraryMock.pairFor(factory, output, path[i + 2]) : _to;
2087	 pair.swap(amount0Out, amount1Out, to, new bytes(0));
2088	 }
2089	 }
2090	 function swapExactTokensForTokensSupportingFeeOnTransferTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external virtual ensure(deadline) {
2091	 TransferHelper.safeTransferFrom( path[0], msg.sender, UniswapV2LibraryMock.pairFor(factory, path[0], path[1]), amountIn );
2092	 uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);
2093	 _swapSupportingFeeOnTransferTokens(path, to);
2094	 require( IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT' );
2095	 }
2096	 function swapExactETHForTokensSupportingFeeOnTransferTokens( uint amountOutMin, address[] calldata path, address to, uint deadline ) external virtual payable ensure(deadline) {
2097	 require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');
2098	 uint amountIn = msg.value;
2099	 IWETH(WETH).deposit{
2100	 value: amountIn}
2101	 ();
2102	 assert(IWETH(WETH).transfer(UniswapV2LibraryMock.pairFor(factory, path[0], path[1]), amountIn));
2103	 uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);
2104	 _swapSupportingFeeOnTransferTokens(path, to);
2105	 require( IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT' );
2106	 }
2107	 function swapExactTokensForETHSupportingFeeOnTransferTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external override virtual ensure(deadline) {
2108	 require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');
2109	 TransferHelper.safeTransferFrom( path[0], msg.sender, UniswapV2LibraryMock.pairFor(factory, path[0], path[1]), amountIn );
2110	 _swapSupportingFeeOnTransferTokens(path, address(this));
2111	 uint amountOut = IERC20(WETH).balanceOf(address(this));
2112	 require(amountOut >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');
2113	 IWETH(WETH).withdraw(amountOut);
2114	 TransferHelper.safeTransferETH(to, amountOut);
2115	 }
2116	 function quote(uint amountA, uint reserveA, uint reserveB) public pure virtual returns (uint amountB) {
2117	 return UniswapV2LibraryMock.quote(amountA, reserveA, reserveB);
2118	 }
2119	 function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) public pure virtual returns (uint amountOut) {
2120	 return UniswapV2LibraryMock.getAmountOut(amountIn, reserveIn, reserveOut);
2121	 }
2122	 function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) public pure virtual returns (uint amountIn) {
2123	 return UniswapV2LibraryMock.getAmountIn(amountOut, reserveIn, reserveOut);
2124	 }
2125	 function getAmountsOut(uint amountIn, address[] memory path) public view virtual returns (uint[] memory amounts) {
2126	 return UniswapV2LibraryMock.getAmountsOut(factory, amountIn, path);
2127	 }
2128	 function getAmountsIn(uint amountOut, address[] memory path) public view virtual returns (uint[] memory amounts) {
2129	 return UniswapV2LibraryMock.getAmountsIn(factory, amountOut, path);
2130	 }
2131	 }
2132	 pragma solidity 0.6.12;
2133	 contract XvixRouter {
2134	 using SafeMath for uint;
2135	 address public immutable factory;
2136	 address public immutable WETH;
2137	 address public immutable uniFarm;
2138	 modifier ensure(uint deadline) {
2139	 require(deadline >= block.timestamp, 'UniswapV2Router: EXPIRED');
2140	 _;
2141	 }
2142	 constructor(address _factory, address _WETH, address _uniFarm) public {
2143	 factory = _factory;
2144	 WETH = _WETH;
2145	 uniFarm = _uniFarm;
2146	 }
2147	 receive() external payable {
2148	 assert(msg.sender == WETH);
2149	 }
2150	 function _addLiquidity( address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin ) internal virtual returns (uint amountA, uint amountB) {
2151	 if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {
2152	 IUniswapV2Factory(factory).createPair(tokenA, tokenB);
2153	 }
2154	 (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);
2155	 if (reserveA == 0 && reserveB == 0) {
2156	 (amountA, amountB) = (amountADesired, amountBDesired);
2157	 }
2158	 else {
2159	 uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);
2160	 if (amountBOptimal <= amountBDesired) {
2161	 require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');
2162	 (amountA, amountB) = (amountADesired, amountBOptimal);
2163	 }
2164	 else {
2165	 uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);
2166	 assert(amountAOptimal <= amountADesired);
2167	 require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');
2168	 (amountA, amountB) = (amountAOptimal, amountBDesired);
2169	 }
2170	 }
2171	 }
2172	 function addLiquidityETH( address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) external virtual payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {
2173	 (amountToken, amountETH) = _addLiquidity( token, WETH, amountTokenDesired, msg.value, amountTokenMin, amountETHMin );
2174	 address pair = UniswapV2Library.pairFor(factory, token, WETH);
2175	 TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);
2176	 IWETH(WETH).deposit{
2177	 value: amountETH}
2178	 ();
2179	 assert(IWETH(WETH).transfer(pair, amountETH));
2180	 liquidity = IUniswapV2Pair(pair).mint(to);
2181	 if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);
2182	 }
2183	 function addLiquidityETHAndStake( address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) external virtual payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {
2184	 (amountToken, amountETH) = _addLiquidity( token, WETH, amountTokenDesired, msg.value, amountTokenMin, amountETHMin );
2185	 address pair = UniswapV2Library.pairFor(factory, token, WETH);
2186	 TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);
2187	 IWETH(WETH).deposit{
2188	 value: amountETH}
2189	 ();
2190	 assert(IWETH(WETH).transfer(pair, amountETH));
2191	 liquidity = IUniswapV2Pair(pair).mint(address(this));
2192	 IERC20(pair).approve(uniFarm, liquidity);
2193	 IUniFarm(uniFarm).deposit(liquidity, to);
2194	 if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);
2195	 }
2196	 function removeLiquidity( address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline ) public virtual ensure(deadline) returns (uint amountA, uint amountB) {
2197	 address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);
2198	 IUniswapV2ERC20(pair).transferFrom(msg.sender, pair, liquidity);
2199	 (uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to);
2200	 (address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB);
2201	 (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);
2202	 require(amountA >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');
2203	 require(amountB >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');
2204	 }
2205	 function removeLiquidityETH( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) public virtual ensure(deadline) returns (uint amountToken, uint amountETH) {
2206	 IXVIX(token).rebase();
2207	 (amountToken, amountETH) = removeLiquidity( token, WETH, liquidity, amountTokenMin, amountETHMin, address(this), deadline );
2208	 TransferHelper.safeTransfer(token, to, amountToken);
2209	 IWETH(WETH).withdraw(amountETH);
2210	 TransferHelper.safeTransferETH(to, amountETH);
2211	 }
2212	 function removeLiquidityETHSupportingFeeOnTransferTokens( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) public virtual ensure(deadline) returns (uint amountETH) {
2213	 IXVIX(token).rebase();
2214	 (, amountETH) = removeLiquidity( token, WETH, liquidity, amountTokenMin, amountETHMin, address(this), deadline );
2215	 TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));
2216	 IWETH(WETH).withdraw(amountETH);
2217	 TransferHelper.safeTransferETH(to, amountETH);
2218	 }
2219	 }
2220	 pragma solidity 0.6.12;
2221	 contract XVIX is IERC20, IXVIX {
2222	 using SafeMath for uint256;
2223	 struct TransferConfig {
2224	 bool active;
2225	 uint256 senderBurnBasisPoints;
2226	 uint256 senderFundBasisPoints;
2227	 uint256 receiverBurnBasisPoints;
2228	 uint256 receiverFundBasisPoints;
2229	 }
2230	 uint256 public constant BASIS_POINTS_DIVISOR = 10000;
2231	 uint256 public constant MAX_FUND_BASIS_POINTS = 20;
2232	 uint256 public constant MAX_BURN_BASIS_POINTS = 500;
2233	 uint256 public constant MIN_REBASE_INTERVAL = 30 minutes;
2234	 uint256 public constant MAX_REBASE_INTERVAL = 1 weeks;
2235	 uint256 public constant MAX_INTERVALS_PER_REBASE = 10;
2236	 uint256 public constant MAX_REBASE_BASIS_POINTS = 500;
2237	 uint256 public constant MAX_NORMAL_DIVISOR = 10**23;
2238	 uint256 public constant SAFE_DIVISOR = 10**8;
2239	 string public constant name = "XVIX";
2240	 string public constant symbol = "XVIX";
2241	 uint8 public constant decimals = 18;
2242	 string public website = "https: address public gov;
2243	 address public minter;
2244	 address public floor;
2245	 address public distributor;
2246	 address public fund;
2247	 uint256 public _normalSupply;
2248	 uint256 public _safeSupply;
2249	 uint256 public override maxSupply;
2250	 uint256 public normalDivisor = 10**8;
2251	 uint256 public rebaseInterval = 1 hours;
2252	 uint256 public rebaseBasisPoints = 2;
2253	 uint256 public nextRebaseTime = 0;
2254	 uint256 public defaultSenderBurnBasisPoints = 0;
2255	 uint256 public defaultSenderFundBasisPoints = 0;
2256	 uint256 public defaultReceiverBurnBasisPoints = 43;
2257	 uint256 public defaultReceiverFundBasisPoints = 7;
2258	 uint256 public govHandoverTime;
2259	 mapping (address => uint256) public balances;
2260	 mapping (address => mapping (address => uint256)) public allowances;
2261	 mapping (address => TransferConfig) public transferConfigs;
2262	 mapping (address => bool) public safes;
2263	 event Toast(address indexed account, uint256 value, uint256 maxSupply);
2264	 event FloorPrice(uint256 capital, uint256 supply);
2265	 event Rebase(uint256 normalDivisor, uint256 nextRebaseTime);
2266	 event GovChange(address gov);
2267	 event CreateSafe(address safe, uint256 balance);
2268	 event DestroySafe(address safe, uint256 balance);
2269	 event RebaseConfigChange(uint256 rebaseInterval, uint256 rebaseBasisPoints);
2270	 event DefaultTransferConfigChange( uint256 senderBasisPoints, uint256 senderFundBasisPoints, uint256 receiverBurnBasisPoints, uint256 receiverFundBasisPoints );
2271	 event SetTransferConfig( address indexed msgSender, uint256 senderBasisPoints, uint256 senderFundBasisPoints, uint256 receiverBurnBasisPoints, uint256 receiverFundBasisPoints );
2272	 event ClearTransferConfig(address indexed msgSender);
2273	 modifier onlyGov() {
2274	 require(msg.sender == gov, "XVIX: forbidden");
2275	 _;
2276	 }
2277	 modifier onlyAfterHandover() {
2278	 require(block.timestamp > govHandoverTime, "XVIX: handover time has not passed");
2279	 _;
2280	 }
2281	 modifier enforceMaxSupply() {
2282	 _;
2283	 require(totalSupply() <= maxSupply, "XVIX: max supply exceeded");
2284	 }
2285	 constructor(uint256 _initialSupply, uint256 _maxSupply, uint256 _govHandoverTime) public {
2286	 gov = msg.sender;
2287	 govHandoverTime = _govHandoverTime;
2288	 maxSupply = _maxSupply;
2289	 _mint(msg.sender, _initialSupply);
2290	 _setNextRebaseTime();
2291	 }
2292	 function setGov(address _gov) public override onlyGov {
2293	 gov = _gov;
2294	 emit GovChange(_gov);
2295	 }
2296	 function setWebsite(string memory _website) public onlyGov {
2297	 website = _website;
2298	 }
2299	 function setMinter(address _minter) public onlyGov {
2300	 require(minter == address(0), "XVIX: minter already set");
2301	 minter = _minter;
2302	 }
2303	 function setFloor(address _floor) public onlyGov {
2304	 require(floor == address(0), "XVIX: floor already set");
2305	 floor = _floor;
2306	 }
2307	 function setDistributor(address _distributor) public onlyGov {
2308	 require(distributor == address(0), "XVIX: distributor already set");
2309	 distributor = _distributor;
2310	 }
2311	 function setFund(address _fund) public override onlyGov {
2312	 fund = _fund;
2313	 }
2314	 function createSafe(address _account) public override onlyGov enforceMaxSupply {
2315	 require(!safes[_account], "XVIX: account is already a safe");
2316	 safes[_account] = true;
2317	 uint256 balance = balances[_account];
2318	 _normalSupply = _normalSupply.sub(balance);
2319	 uint256 safeBalance = balance.mul(SAFE_DIVISOR).div(normalDivisor);
2320	 balances[_account] = safeBalance;
2321	 _safeSupply = _safeSupply.add(safeBalance);
2322	 emit CreateSafe(_account, balanceOf(_account));
2323	 }
2324	 function destroySafe(address _account) public onlyGov onlyAfterHandover enforceMaxSupply {
2325	 require(safes[_account], "XVIX: account is not a safe");
2326	 safes[_account] = false;
2327	 uint256 balance = balances[_account];
2328	 _safeSupply = _safeSupply.sub(balance);
2329	 uint256 normalBalance = balance.mul(normalDivisor).div(SAFE_DIVISOR);
2330	 balances[_account] = normalBalance;
2331	 _normalSupply = _normalSupply.add(normalBalance);
2332	 emit DestroySafe(_account, balanceOf(_account));
2333	 }
2334	 function setRebaseConfig( uint256 _rebaseInterval, uint256 _rebaseBasisPoints ) public onlyGov onlyAfterHandover {
2335	 require(_rebaseInterval >= MIN_REBASE_INTERVAL, "XVIX: rebaseInterval below limit");
2336	 require(_rebaseInterval <= MAX_REBASE_INTERVAL, "XVIX: rebaseInterval exceeds limit");
2337	 require(_rebaseBasisPoints <= MAX_REBASE_BASIS_POINTS, "XVIX: rebaseBasisPoints exceeds limit");
2338	 rebaseInterval = _rebaseInterval;
2339	 rebaseBasisPoints = _rebaseBasisPoints;
2340	 emit RebaseConfigChange(_rebaseInterval, _rebaseBasisPoints);
2341	 }
2342	 function setDefaultTransferConfig( uint256 _senderBurnBasisPoints, uint256 _senderFundBasisPoints, uint256 _receiverBurnBasisPoints, uint256 _receiverFundBasisPoints ) public onlyGov onlyAfterHandover {
2343	 _validateTransferConfig( _senderBurnBasisPoints, _senderFundBasisPoints, _receiverBurnBasisPoints, _receiverFundBasisPoints );
2344	 defaultSenderBurnBasisPoints = _senderBurnBasisPoints;
2345	 defaultSenderFundBasisPoints = _senderFundBasisPoints;
2346	 defaultReceiverBurnBasisPoints = _receiverBurnBasisPoints;
2347	 defaultReceiverFundBasisPoints = _receiverFundBasisPoints;
2348	 emit DefaultTransferConfigChange( _senderBurnBasisPoints, _senderFundBasisPoints, _receiverBurnBasisPoints, _receiverFundBasisPoints );
2349	 }
2350	 function setTransferConfig( address _msgSender, uint256 _senderBurnBasisPoints, uint256 _senderFundBasisPoints, uint256 _receiverBurnBasisPoints, uint256 _receiverFundBasisPoints ) public override onlyGov {
2351	 require(_msgSender != address(0), "XVIX: cannot set zero address");
2352	 _validateTransferConfig( _senderBurnBasisPoints, _senderFundBasisPoints, _receiverBurnBasisPoints, _receiverFundBasisPoints );
2353	 transferConfigs[_msgSender] = TransferConfig( true, _senderBurnBasisPoints, _senderFundBasisPoints, _receiverBurnBasisPoints, _receiverFundBasisPoints );
2354	 emit SetTransferConfig( _msgSender, _senderBurnBasisPoints, _senderFundBasisPoints, _receiverBurnBasisPoints, _receiverFundBasisPoints );
2355	 }
2356	 function clearTransferConfig(address _msgSender) public onlyGov onlyAfterHandover {
2357	 delete transferConfigs[_msgSender];
2358	 emit ClearTransferConfig(_msgSender);
2359	 }
2360	 function rebase() public override returns (bool) {
2361	 if (block.timestamp < nextRebaseTime) {
2362	 return false;
2363	 }
2364	 uint256 timeDiff = block.timestamp.sub(nextRebaseTime);
2365	 uint256 intervals = timeDiff.div(rebaseInterval).add(1);
2366	 if (intervals > MAX_INTERVALS_PER_REBASE) {
2367	 intervals = MAX_INTERVALS_PER_REBASE;
2368	 }
2369	 _setNextRebaseTime();
2370	 if (rebaseBasisPoints == 0) {
2371	 return false;
2372	 }
2373	 uint256 multiplier = BASIS_POINTS_DIVISOR.add(rebaseBasisPoints) ** intervals;
2374	 uint256 divider = BASIS_POINTS_DIVISOR ** intervals;
2375	 uint256 nextDivisor = normalDivisor.mul(multiplier).div(divider);
2376	 if (nextDivisor > MAX_NORMAL_DIVISOR) {
2377	 return false;
2378	 }
2379	 normalDivisor = nextDivisor;
2380	 emit Rebase(normalDivisor, nextRebaseTime);
2381	 return true;
2382	 }
2383	 function mint(address _account, uint256 _amount) public override returns (bool) {
2384	 require(msg.sender == minter, "XVIX: forbidden");
2385	 _mint(_account, _amount);
2386	 return true;
2387	 }
2388	 function toast(uint256 _amount) public override returns (bool) {
2389	 require(msg.sender == distributor, "XVIX: forbidden");
2390	 if (_amount == 0) {
2391	 return false;
2392	 }
2393	 _burn(msg.sender, _amount);
2394	 maxSupply = maxSupply.sub(_amount);
2395	 emit Toast(msg.sender, _amount, maxSupply);
2396	 return true;
2397	 }
2398	 function burn(address _account, uint256 _amount) public override returns (bool) {
2399	 require(msg.sender == floor, "XVIX: forbidden");
2400	 _burn(_account, _amount);
2401	 return true;
2402	 }
2403	 function balanceOf(address _account) public view override returns (uint256) {
2404	 if (safes[_account]) {
2405	 return balances[_account].div(SAFE_DIVISOR);
2406	 }
2407	 return balances[_account].div(normalDivisor);
2408	 }
2409	 function transfer(address _recipient, uint256 _amount) public override returns (bool) {
2410	 _transfer(msg.sender, _recipient, _amount);
2411	 rebase();
2412	 return true;
2413	 }
2414	 function allowance(address _owner, address _spender) public view override returns (uint256) {
2415	 return allowances[_owner][_spender];
2416	 }
2417	 function approve(address _spender, uint256 _amount) public override returns (bool) {
2418	 _approve(msg.sender, _spender, _amount);
2419	 return true;
2420	 }
2421	 function transferFrom(address _sender, address _recipient, uint256 _amount) public override returns (bool) {
2422	 uint256 nextAllowance = allowances[_sender][msg.sender].sub(_amount, "XVIX: transfer amount exceeds allowance");
2423	 _approve(_sender, msg.sender, nextAllowance);
2424	 _transfer(_sender, _recipient, _amount);
2425	 rebase();
2426	 return true;
2427	 }
2428	 function normalSupply() public view returns (uint256) {
2429	 return _normalSupply.div(normalDivisor);
2430	 }
2431	 function safeSupply() public view returns (uint256) {
2432	 return _safeSupply.div(SAFE_DIVISOR);
2433	 }
2434	 function totalSupply() public view override returns (uint256) {
2435	 return normalSupply().add(safeSupply());
2436	 }
2437	 function _validateTransferConfig( uint256 _senderBurnBasisPoints, uint256 _senderFundBasisPoints, uint256 _receiverBurnBasisPoints, uint256 _receiverFundBasisPoints ) private pure {
2438	 require(_senderBurnBasisPoints <= MAX_BURN_BASIS_POINTS, "XVIX: senderBurnBasisPoints exceeds limit");
2439	 require(_senderFundBasisPoints <= MAX_FUND_BASIS_POINTS, "XVIX: senderFundBasisPoints exceeds limit");
2440	 require(_receiverBurnBasisPoints <= MAX_BURN_BASIS_POINTS, "XVIX: receiverBurnBasisPoints exceeds limit");
2441	 require(_receiverFundBasisPoints <= MAX_FUND_BASIS_POINTS, "XVIX: receiverFundBasisPoints exceeds limit");
2442	 }
2443	 function _setNextRebaseTime() private {
2444	 uint256 roundedTime = block.timestamp.div(rebaseInterval).mul(rebaseInterval);
2445	 nextRebaseTime = roundedTime.add(rebaseInterval);
2446	 }
2447	 function _transfer(address _sender, address _recipient, uint256 _amount) private {
2448	 require(_sender != address(0), "XVIX: transfer from the zero address");
2449	 require(_recipient != address(0), "XVIX: transfer to the zero address");
2450	 (uint256 senderBurn, uint256 senderFund, uint256 receiverBurn, uint256 receiverFund) = _getTransferConfig();
2451	 uint256 senderAmount = _amount;
2452	 uint256 senderBasisPoints = senderBurn.add(senderFund);
2453	 if (senderBasisPoints > 0) {
2454	 uint256 senderTax = _amount.mul(senderBasisPoints).div(BASIS_POINTS_DIVISOR);
2455	 senderAmount = senderAmount.add(senderTax);
2456	 }
2457	 uint256 receiverAmount = _amount;
2458	 uint256 receiverBasisPoints = receiverBurn.add(receiverFund);
2459	 if (receiverBasisPoints > 0) {
2460	 uint256 receiverTax = _amount.mul(receiverBasisPoints).div(BASIS_POINTS_DIVISOR);
2461	 receiverAmount = receiverAmount.sub(receiverTax);
2462	 }
2463	 _decreaseBalance(_sender, senderAmount);
2464	 _increaseBalance(_recipient, receiverAmount);
2465	 emit Transfer(_sender, _recipient, receiverAmount);
2466	 uint256 fundBasisPoints = senderFund.add(receiverFund);
2467	 uint256 fundAmount = _amount.mul(fundBasisPoints).div(BASIS_POINTS_DIVISOR);
2468	 if (fundAmount > 0) {
2469	 _increaseBalance(fund, fundAmount);
2470	 emit Transfer(_sender, fund, fundAmount);
2471	 }
2472	 uint256 burnAmount = senderAmount.sub(receiverAmount).sub(fundAmount);
2473	 if (burnAmount > 0) {
2474	 emit Transfer(_sender, address(0), burnAmount);
2475	 }
2476	 _emitFloorPrice();
2477	 }
2478	 function _getTransferConfig() private view returns (uint256, uint256, uint256, uint256) {
2479	 uint256 senderBurn = defaultSenderBurnBasisPoints;
2480	 uint256 senderFund = defaultSenderFundBasisPoints;
2481	 uint256 receiverBurn = defaultReceiverBurnBasisPoints;
2482	 uint256 receiverFund = defaultReceiverFundBasisPoints;
2483	 TransferConfig memory config = transferConfigs[msg.sender];
2484	 if (config.active) {
2485	 senderBurn = config.senderBurnBasisPoints;
2486	 senderFund = config.senderFundBasisPoints;
2487	 receiverBurn = config.receiverBurnBasisPoints;
2488	 receiverFund = config.receiverFundBasisPoints;
2489	 }
2490	 return (senderBurn, senderFund, receiverBurn, receiverFund);
2491	 }
2492	 function _approve(address _owner, address _spender, uint256 _amount) private {
2493	 require(_owner != address(0), "XVIX: approve from the zero address");
2494	 require(_spender != address(0), "XVIX: approve to the zero address");
2495	 allowances[_owner][_spender] = _amount;
2496	 emit Approval(_owner, _spender, _amount);
2497	 }
2498	 function _mint(address _account, uint256 _amount) private {
2499	 require(_account != address(0), "XVIX: mint to the zero address");
2500	 if (_amount == 0) {
2501	 return;
2502	 }
2503	 _increaseBalance(_account, _amount);
2504	 emit Transfer(address(0), _account, _amount);
2505	 _emitFloorPrice();
2506	 }
2507	 function _burn(address _account, uint256 _amount) private {
2508	 require(_account != address(0), "XVIX: burn from the zero address");
2509	 if (_amount == 0) {
2510	 return;
2511	 }
2512	 _decreaseBalance(_account, _amount);
2513	 emit Transfer(_account, address(0), _amount);
2514	 _emitFloorPrice();
2515	 }
2516	 function _increaseBalance(address _account, uint256 _amount) private enforceMaxSupply {
2517	 if (_amount == 0) {
2518	 return;
2519	 }
2520	 if (safes[_account]) {
2521	 uint256 safeAmount = _amount.mul(SAFE_DIVISOR);
2522	 balances[_account] = balances[_account].add(safeAmount);
2523	 _safeSupply = _safeSupply.add(safeAmount);
2524	 return;
2525	 }
2526	 uint256 normalAmount = _amount.mul(normalDivisor);
2527	 balances[_account] = balances[_account].add(normalAmount);
2528	 _normalSupply = _normalSupply.add(normalAmount);
2529	 }
2530	 function _decreaseBalance(address _account, uint256 _amount) private {
2531	 if (_amount == 0) {
2532	 return;
2533	 }
2534	 if (safes[_account]) {
2535	 uint256 safeAmount = _amount.mul(SAFE_DIVISOR);
2536	 balances[_account] = balances[_account].sub(safeAmount, "XVIX: subtraction amount exceeds balance");
2537	 _safeSupply = _safeSupply.sub(safeAmount);
2538	 return;
2539	 }
2540	 uint256 normalAmount = _amount.mul(normalDivisor);
2541	 balances[_account] = balances[_account].sub(normalAmount, "XVIX: subtraction amount exceeds balance");
2542	 _normalSupply = _normalSupply.sub(normalAmount);
2543	 }
2544	 function _emitFloorPrice() private {
2545	 if (_isContract(floor)) {
2546	 emit FloorPrice(IFloor(floor).capital(), totalSupply());
2547	 }
2548	 }
2549	 function _isContract(address account) private view returns (bool) {
2550	 uint256 size;
2551	 assembly {
2552	 size := extcodesize(account) }
2553	 return size > 0;
2554	 }
2555	 }
