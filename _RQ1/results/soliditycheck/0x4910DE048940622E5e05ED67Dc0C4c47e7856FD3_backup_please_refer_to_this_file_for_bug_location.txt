row number 
1	         pragma solidity >=0.6.0 <0.8.0;
2	 interface IERC20 {
3	 function totalSupply() external view returns (uint256);
4	 function balanceOf(address account) external view returns (uint256);
5	 function transfer(address recipient, uint256 amount) external returns (bool);
6	 function allowance(address owner, address spender) external view returns (uint256);
7	 function approve(address spender, uint256 amount) external returns (bool);
8	 function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
9	 event Transfer(address indexed from, address indexed to, uint256 value);
10	 event Approval(address indexed owner, address indexed spender, uint256 value);
11	 }
12	 pragma solidity >=0.6.0 <0.8.0;
13	 abstract contract Context {
14	 function _msgSender() internal view virtual returns (address payable) {
15	 return msg.sender;
16	 }
17	 function _msgData() internal view virtual returns (bytes memory) {
18	 this;
19	 return msg.data;
20	 }
21	 }
22	 pragma solidity 0.7.6;
23	 interface IStrategy {
24	 function rebalance() external;
25	 function shouldRebalance() external view returns (bool);
26	 }
27	 pragma solidity >=0.5.0;
28	 interface IUniswapV3PoolImmutables {
29	 function factory() external view returns (address);
30	 function token0() external view returns (address);
31	 function token1() external view returns (address);
32	 function fee() external view returns (uint24);
33	 function tickSpacing() external view returns (int24);
34	 function maxLiquidityPerTick() external view returns (uint128);
35	 }
36	 pragma solidity >=0.5.0;
37	 interface IUniswapV3PoolState {
38	 function slot0() external view returns ( uint160 sqrtPriceX96, int24 tick, uint16 observationIndex, uint16 observationCardinality, uint16 observationCardinalityNext, uint8 feeProtocol, bool unlocked );
39	 function feeGrowthGlobal0X128() external view returns (uint256);
40	 function feeGrowthGlobal1X128() external view returns (uint256);
41	 function protocolFees() external view returns (uint128 token0, uint128 token1);
42	 function liquidity() external view returns (uint128);
43	 function ticks(int24 tick) external view returns ( uint128 liquidityGross, int128 liquidityNet, uint256 feeGrowthOutside0X128, uint256 feeGrowthOutside1X128, int56 tickCumulativeOutside, uint160 secondsPerLiquidityOutsideX128, uint32 secondsOutside, bool initialized );
44	 function tickBitmap(int16 wordPosition) external view returns (uint256);
45	 function positions(bytes32 key) external view returns ( uint128 _liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, uint128 tokensOwed0, uint128 tokensOwed1 );
46	 function observations(uint256 index) external view returns ( uint32 blockTimestamp, int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128, bool initialized );
47	 }
48	 pragma solidity >=0.5.0;
49	 interface IUniswapV3PoolDerivedState {
50	 function observe(uint32[] calldata secondsAgos) external view returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);
51	 function snapshotCumulativesInside(int24 tickLower, int24 tickUpper) external view returns ( int56 tickCumulativeInside, uint160 secondsPerLiquidityInsideX128, uint32 secondsInside );
52	 }
53	 pragma solidity >=0.5.0;
54	 interface IUniswapV3PoolActions {
55	 function initialize(uint160 sqrtPriceX96) external;
56	 function mint( address recipient, int24 tickLower, int24 tickUpper, uint128 amount, bytes calldata data ) external returns (uint256 amount0, uint256 amount1);
57	 function collect( address recipient, int24 tickLower, int24 tickUpper, uint128 amount0Requested, uint128 amount1Requested ) external returns (uint128 amount0, uint128 amount1);
58	 function burn( int24 tickLower, int24 tickUpper, uint128 amount ) external returns (uint256 amount0, uint256 amount1);
59	 function swap( address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes calldata data ) external returns (int256 amount0, int256 amount1);
60	 function flash( address recipient, uint256 amount0, uint256 amount1, bytes calldata data ) external;
61	 function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;
62	 }
63	 pragma solidity >=0.5.0;
64	 interface IUniswapV3PoolOwnerActions {
65	 function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;
66	 function collectProtocol( address recipient, uint128 amount0Requested, uint128 amount1Requested ) external returns (uint128 amount0, uint128 amount1);
67	 }
68	 pragma solidity >=0.5.0;
69	 interface IUniswapV3PoolEvents {
70	 event Initialize(uint160 sqrtPriceX96, int24 tick);
71	 event Mint( address sender, address indexed owner, int24 indexed tickLower, int24 indexed tickUpper, uint128 amount, uint256 amount0, uint256 amount1 );
72	 event Collect( address indexed owner, address recipient, int24 indexed tickLower, int24 indexed tickUpper, uint128 amount0, uint128 amount1 );
73	 event Burn( address indexed owner, int24 indexed tickLower, int24 indexed tickUpper, uint128 amount, uint256 amount0, uint256 amount1 );
74	 event Swap( address indexed sender, address indexed recipient, int256 amount0, int256 amount1, uint160 sqrtPriceX96, uint128 liquidity, int24 tick );
75	 event Flash( address indexed sender, address indexed recipient, uint256 amount0, uint256 amount1, uint256 paid0, uint256 paid1 );
76	 event IncreaseObservationCardinalityNext( uint16 observationCardinalityNextOld, uint16 observationCardinalityNextNew );
77	 event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);
78	 event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);
79	 }
80	 pragma solidity >=0.6.0 <0.8.0;
81	 contract ERC20 is Context, IERC20 {
82	 using SafeMath for uint256;
83	 mapping (address => uint256) private _balances;
84	 mapping (address => mapping (address => uint256)) private _allowances;
85	 uint256 private _totalSupply;
86	 string private _name;
87	 string private _symbol;
88	 uint8 private _decimals;
89	 constructor (string memory name_, string memory symbol_) public {
90	 _name = name_;
91	 _symbol = symbol_;
92	 _decimals = 18;
93	 }
94	 function name() public view virtual returns (string memory) {
95	 return _name;
96	 }
97	 function symbol() public view virtual returns (string memory) {
98	 return _symbol;
99	 }
100	 function decimals() public view virtual returns (uint8) {
101	 return _decimals;
102	 }
103	 function totalSupply() public view virtual override returns (uint256) {
104	 return _totalSupply;
105	 }
106	 function balanceOf(address account) public view virtual override returns (uint256) {
107	 return _balances[account];
108	 }
109	 function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
110	 _transfer(_msgSender(), recipient, amount);
111	 return true;
112	 }
113	 function allowance(address owner, address spender) public view virtual override returns (uint256) {
114	 return _allowances[owner][spender];
115	 }
116	 function approve(address spender, uint256 amount) public virtual override returns (bool) {
117	 _approve(_msgSender(), spender, amount);
118	 return true;
119	 }
120	 function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
121	 _transfer(sender, recipient, amount);
122	 _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
123	 return true;
124	 }
125	 function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
126	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
127	 return true;
128	 }
129	 function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
130	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
131	 return true;
132	 }
133	 function _transfer(address sender, address recipient, uint256 amount) internal virtual {
134	 require(sender != address(0), "ERC20: transfer from the zero address");
135	 require(recipient != address(0), "ERC20: transfer to the zero address");
136	 _beforeTokenTransfer(sender, recipient, amount);
137	 _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
138	 _balances[recipient] = _balances[recipient].add(amount);
139	 emit Transfer(sender, recipient, amount);
140	 }
141	 function _mint(address account, uint256 amount) internal virtual {
142	 require(account != address(0), "ERC20: mint to the zero address");
143	 _beforeTokenTransfer(address(0), account, amount);
144	 _totalSupply = _totalSupply.add(amount);
145	 _balances[account] = _balances[account].add(amount);
146	 emit Transfer(address(0), account, amount);
147	 }
148	 function _burn(address account, uint256 amount) internal virtual {
149	 require(account != address(0), "ERC20: burn from the zero address");
150	 _beforeTokenTransfer(account, address(0), amount);
151	 _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
152	 _totalSupply = _totalSupply.sub(amount);
153	 emit Transfer(account, address(0), amount);
154	 }
155	 function _approve(address owner, address spender, uint256 amount) internal virtual {
156	 require(owner != address(0), "ERC20: approve from the zero address");
157	 require(spender != address(0), "ERC20: approve to the zero address");
158	 _allowances[owner][spender] = amount;
159	 emit Approval(owner, spender, amount);
160	 }
161	 function _setupDecimals(uint8 decimals_) internal virtual {
162	 _decimals = decimals_;
163	 }
164	 function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {
165	 }
166	 }
167	 pragma solidity >=0.6.0 <0.8.0;
168	 abstract contract ReentrancyGuard {
169	 uint256 private constant _NOT_ENTERED = 1;
170	 uint256 private constant _ENTERED = 2;
171	 uint256 private _status;
172	 constructor () internal {
173	 _status = _NOT_ENTERED;
174	 }
175	 modifier nonReentrant() {
176	 require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
177	 _status = _ENTERED;
178	 _;
179	 _status = _NOT_ENTERED;
180	 }
181	 }
182	 pragma solidity >=0.5.0;
183	 interface IUniswapV3MintCallback {
184	 function uniswapV3MintCallback( uint256 amount0Owed, uint256 amount1Owed, bytes calldata data ) external;
185	 }
186	 pragma solidity >=0.5.0;
187	 interface IUniswapV3SwapCallback {
188	 function uniswapV3SwapCallback( int256 amount0Delta, int256 amount1Delta, bytes calldata data ) external;
189	 }
190	 pragma solidity 0.7.6;
191	 interface IVault {
192	 function deposit( uint256, uint256, uint256, uint256, address ) external returns ( uint256, uint256, uint256 );
193	 function withdraw( uint256, uint256, uint256, address ) external returns (uint256, uint256);
194	 function getTotalAmounts() external view returns (uint256, uint256);
195	 }
196	 pragma solidity 0.7.6;
197	 contract PassiveStrategy is IStrategy {
198	 using SafeMath for uint256;
199	 UpbotVault public immutable vault;
200	 IUniswapV3Pool public immutable pool;
201	 int24 public immutable tickSpacing;
202	 int24 public baseThreshold;
203	 int24 public limitThreshold;
204	 uint256 public period;
205	 int24 public minTickMove;
206	 int24 public maxTwapDeviation;
207	 uint32 public twapDuration;
208	 address public keeper;
209	 uint256 public lastTimestamp;
210	 int24 public lastTick;
211	 constructor( address _vault, int24 _baseThreshold, int24 _limitThreshold, uint256 _period, int24 _minTickMove, int24 _maxTwapDeviation, uint32 _twapDuration, address _keeper ) {
212	 IUniswapV3Pool _pool = UpbotVault(_vault).pool();
213	 int24 _tickSpacing = _pool.tickSpacing();
214	 vault = UpbotVault(_vault);
215	 pool = _pool;
216	 tickSpacing = _tickSpacing;
217	 baseThreshold = _baseThreshold;
218	 limitThreshold = _limitThreshold;
219	 period = _period;
220	 minTickMove = _minTickMove;
221	 maxTwapDeviation = _maxTwapDeviation;
222	 twapDuration = _twapDuration;
223	 keeper = _keeper;
224	 _checkThreshold(_baseThreshold, _tickSpacing);
225	 _checkThreshold(_limitThreshold, _tickSpacing);
226	 require(_minTickMove >= 0, "minTickMove must be >= 0");
227	 require(_maxTwapDeviation >= 0, "maxTwapDeviation must be >= 0");
228	 require(_twapDuration > 0, "twapDuration must be > 0");
229	 (, lastTick, , , , , ) = _pool.slot0();
230	 }
231	 function rebalance() external override {
232	 require(shouldRebalance(), "cannot rebalance");
233	 (, int24 tick, , , , , ) = pool.slot0();
234	 int24 tickFloor = _floor(tick);
235	 int24 tickCeil = tickFloor + tickSpacing;
236	 vault.rebalance( 0, 0, tickFloor - baseThreshold, tickCeil + baseThreshold, tickFloor - limitThreshold, tickFloor, tickCeil, tickCeil + limitThreshold );
237	 lastTimestamp = block.timestamp;
238	 lastTick = tick;
239	 }
240	 function shouldRebalance() public view override returns (bool) {
241	 if (msg.sender != keeper) {
242	 return false;
243	 }
244	 if (block.timestamp < lastTimestamp.add(period)) {
245	 return false;
246	 }
247	 (, int24 tick, , , , , ) = pool.slot0();
248	 int24 tickMove = tick > lastTick ? tick - lastTick : lastTick - tick;
249	 if (tickMove < minTickMove) {
250	 return false;
251	 }
252	 int24 twap = getTwap();
253	 int24 twapDeviation = tick > twap ? tick - twap : twap - tick;
254	 if (twapDeviation > maxTwapDeviation) {
255	 return false;
256	 }
257	 int24 maxThreshold = baseThreshold > limitThreshold ? baseThreshold : limitThreshold;
258	 if ( tick < TickMath.MIN_TICK + maxThreshold + tickSpacing || tick > TickMath.MAX_TICK - maxThreshold - tickSpacing ) {
259	 return false;
260	 }
261	 return true;
262	 }
263	 function getTwap() public view returns (int24) {
264	 uint32 _twapDuration = twapDuration;
265	 uint32[] memory secondsAgo = new uint32[](2);
266	 secondsAgo[0] = _twapDuration;
267	 secondsAgo[1] = 0;
268	 (int56[] memory tickCumulatives, ) = pool.observe(secondsAgo);
269	 return int24((tickCumulatives[1] - tickCumulatives[0]) / _twapDuration);
270	 }
271	 function _floor(int24 tick) internal view returns (int24) {
272	 int24 compressed = tick / tickSpacing;
273	 if (tick < 0 && tick % tickSpacing != 0) compressed--;
274	 return compressed * tickSpacing;
275	 }
276	 function _checkThreshold(int24 threshold, int24 _tickSpacing) internal pure {
277	 require(threshold > 0, "threshold must be > 0");
278	 require(threshold <= TickMath.MAX_TICK, "threshold too high");
279	 require(threshold % _tickSpacing == 0, "threshold must be multiple of tickSpacing");
280	 }
281	 function setKeeper(address _keeper) external onlyGovernance {
282	 keeper = _keeper;
283	 }
284	 function setBaseThreshold(int24 _baseThreshold) external onlyGovernance {
285	 _checkThreshold(_baseThreshold, tickSpacing);
286	 baseThreshold = _baseThreshold;
287	 }
288	 function setLimitThreshold(int24 _limitThreshold) external onlyGovernance {
289	 _checkThreshold(_limitThreshold, tickSpacing);
290	 limitThreshold = _limitThreshold;
291	 }
292	 function setPeriod(uint256 _period) external onlyGovernance {
293	 period = _period;
294	 }
295	 function setMinTickMove(int24 _minTickMove) external onlyGovernance {
296	 require(_minTickMove >= 0, "minTickMove must be >= 0");
297	 minTickMove = _minTickMove;
298	 }
299	 function setMaxTwapDeviation(int24 _maxTwapDeviation) external onlyGovernance {
300	 require(_maxTwapDeviation >= 0, "maxTwapDeviation must be >= 0");
301	 maxTwapDeviation = _maxTwapDeviation;
302	 }
303	 function setTwapDuration(uint32 _twapDuration) external onlyGovernance {
304	 require(_twapDuration > 0, "twapDuration must be > 0");
305	 twapDuration = _twapDuration;
306	 }
307	 modifier onlyGovernance {
308	 require(msg.sender == vault.governance(), "governance");
309	 _;
310	 }
311	 }
312	 pragma solidity >=0.6.0 <0.8.0;
313	 library SafeMath {
314	 function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
315	 uint256 c = a + b;
316	 if (c < a) return (false, 0);
317	 return (true, c);
318	 }
319	 function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
320	 if (b > a) return (false, 0);
321	 return (true, a - b);
322	 }
323	 function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
324	 if (a == 0) return (true, 0);
325	 uint256 c = a * b;
326	 if (c / a != b) return (false, 0);
327	 return (true, c);
328	 }
329	 function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
330	 if (b == 0) return (false, 0);
331	 return (true, a / b);
332	 }
333	 function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
334	 if (b == 0) return (false, 0);
335	 return (true, a % b);
336	 }
337	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
338	 uint256 c = a + b;
339	 require(c >= a, "SafeMath: addition overflow");
340	 return c;
341	 }
342	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
343	 require(b <= a, "SafeMath: subtraction overflow");
344	 return a - b;
345	 }
346	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
347	 if (a == 0) return 0;
348	 uint256 c = a * b;
349	 require(c / a == b, "SafeMath: multiplication overflow");
350	 return c;
351	 }
352	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
353	 require(b > 0, "SafeMath: division by zero");
354	 return a / b;
355	 }
356	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
357	 require(b > 0, "SafeMath: modulo by zero");
358	 return a % b;
359	 }
360	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
361	 require(b <= a, errorMessage);
362	 return a - b;
363	 }
364	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
365	 require(b > 0, errorMessage);
366	 return a / b;
367	 }
368	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
369	 require(b > 0, errorMessage);
370	 return a % b;
371	 }
372	 }
373	 pragma solidity >=0.5.0;
374	 interface IUniswapV3Pool is IUniswapV3PoolImmutables, IUniswapV3PoolState, IUniswapV3PoolDerivedState, IUniswapV3PoolActions, IUniswapV3PoolOwnerActions, IUniswapV3PoolEvents {
375	 }
376	 pragma solidity >=0.5.0 <0.8.0;
377	 library TickMath {
378	 int24 internal constant MIN_TICK = -887272;
379	 int24 internal constant MAX_TICK = -MIN_TICK;
380	 uint160 internal constant MIN_SQRT_RATIO = 4295128739;
381	 uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;
382	 function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {
383	 uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));
384	 require(absTick <= uint256(MAX_TICK), 'T');
385	 uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;
386	 if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;
387	 if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;
388	 if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;
389	 if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;
390	 if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;
391	 if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;
392	 if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;
393	 if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;
394	 if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;
395	 if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;
396	 if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;
397	 if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;
398	 if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;
399	 if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;
400	 if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;
401	 if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;
402	 if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;
403	 if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;
404	 if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;
405	 if (tick > 0) ratio = type(uint256).max / ratio;
406	 sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));
407	 }
408	 function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {
409	 require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');
410	 uint256 ratio = uint256(sqrtPriceX96) << 32;
411	 uint256 r = ratio;
412	 uint256 msb = 0;
413	 assembly {
414	 let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) msb := or(msb, f) r := shr(f, r) }
415	 assembly {
416	 let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF)) msb := or(msb, f) r := shr(f, r) }
417	 assembly {
418	 let f := shl(5, gt(r, 0xFFFFFFFF)) msb := or(msb, f) r := shr(f, r) }
419	 assembly {
420	 let f := shl(4, gt(r, 0xFFFF)) msb := or(msb, f) r := shr(f, r) }
421	 assembly {
422	 let f := shl(3, gt(r, 0xFF)) msb := or(msb, f) r := shr(f, r) }
423	 assembly {
424	 let f := shl(2, gt(r, 0xF)) msb := or(msb, f) r := shr(f, r) }
425	 assembly {
426	 let f := shl(1, gt(r, 0x3)) msb := or(msb, f) r := shr(f, r) }
427	 assembly {
428	 let f := gt(r, 0x1) msb := or(msb, f) }
429	 if (msb >= 128) r = ratio >> (msb - 127);
430	 else r = ratio << (127 - msb);
431	 int256 log_2 = (int256(msb) - 128) << 64;
432	 assembly {
433	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(63, f)) r := shr(f, r) }
434	 assembly {
435	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(62, f)) r := shr(f, r) }
436	 assembly {
437	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(61, f)) r := shr(f, r) }
438	 assembly {
439	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(60, f)) r := shr(f, r) }
440	 assembly {
441	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(59, f)) r := shr(f, r) }
442	 assembly {
443	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(58, f)) r := shr(f, r) }
444	 assembly {
445	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(57, f)) r := shr(f, r) }
446	 assembly {
447	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(56, f)) r := shr(f, r) }
448	 assembly {
449	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(55, f)) r := shr(f, r) }
450	 assembly {
451	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(54, f)) r := shr(f, r) }
452	 assembly {
453	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(53, f)) r := shr(f, r) }
454	 assembly {
455	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(52, f)) r := shr(f, r) }
456	 assembly {
457	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(51, f)) r := shr(f, r) }
458	 assembly {
459	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(50, f)) }
460	 int256 log_sqrt10001 = log_2 * 255738958999603826347141;
461	 int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);
462	 int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);
463	 tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;
464	 }
465	 }
466	 pragma solidity 0.7.6;
467	 contract UpbotVault is IVault, IUniswapV3MintCallback, IUniswapV3SwapCallback, ERC20, ReentrancyGuard {
468	 using SafeERC20 for IERC20;
469	 using SafeMath for uint256;
470	 event Deposit( address indexed sender, address indexed to, uint256 shares, uint256 amount0, uint256 amount1 );
471	 event Withdraw( address indexed sender, address indexed to, uint256 shares, uint256 amount0, uint256 amount1 );
472	 event CollectFees( uint256 feesToVault0, uint256 feesToVault1, uint256 feesToProtocol0, uint256 feesToProtocol1 );
473	 event Snapshot(int24 tick, uint256 totalAmount0, uint256 totalAmount1, uint256 totalSupply);
474	 IUniswapV3Pool public immutable pool;
475	 IERC20 public immutable token0;
476	 IERC20 public immutable token1;
477	 int24 public immutable tickSpacing;
478	 uint256 public protocolFee;
479	 uint256 public maxTotalSupply;
480	 address public strategy;
481	 address public governance;
482	 address public pendingGovernance;
483	 int24 public baseLower;
484	 int24 public baseUpper;
485	 int24 public limitLower;
486	 int24 public limitUpper;
487	 uint256 public accruedProtocolFees0;
488	 uint256 public accruedProtocolFees1;
489	 constructor( address _pool, uint256 _protocolFee, uint256 _maxTotalSupply ) ERC20("Upbot Vault", "UV") {
490	 pool = IUniswapV3Pool(_pool);
491	 token0 = IERC20(IUniswapV3Pool(_pool).token0());
492	 token1 = IERC20(IUniswapV3Pool(_pool).token1());
493	 tickSpacing = IUniswapV3Pool(_pool).tickSpacing();
494	 protocolFee = _protocolFee;
495	 maxTotalSupply = _maxTotalSupply;
496	 governance = msg.sender;
497	 require(_protocolFee < 1e6, "protocolFee");
498	 }
499	 function deposit( uint256 amount0Desired, uint256 amount1Desired, uint256 amount0Min, uint256 amount1Min, address to ) external override nonReentrant returns ( uint256 shares, uint256 amount0, uint256 amount1 ) {
500	 require(amount0Desired > 0 || amount1Desired > 0, "amount0Desired or amount1Desired");
501	 require(to != address(0) && to != address(this), "to");
502	 _poke(baseLower, baseUpper);
503	 _poke(limitLower, limitUpper);
504	 (shares, amount0, amount1) = _calcSharesAndAmounts(amount0Desired, amount1Desired);
505	 require(shares > 0, "shares");
506	 require(amount0 >= amount0Min, "amount0Min");
507	 require(amount1 >= amount1Min, "amount1Min");
508	 if (amount0 > 0) token0.safeTransferFrom(msg.sender, address(this), amount0);
509	 if (amount1 > 0) token1.safeTransferFrom(msg.sender, address(this), amount1);
510	 _mint(to, shares);
511	 emit Deposit(msg.sender, to, shares, amount0, amount1);
512	 require(totalSupply() <= maxTotalSupply, "maxTotalSupply");
513	 }
514	 function _poke(int24 tickLower, int24 tickUpper) internal {
515	 (uint128 liquidity, , , , ) = _position(tickLower, tickUpper);
516	 if (liquidity > 0) {
517	 pool.burn(tickLower, tickUpper, 0);
518	 }
519	 }
520	 function _calcSharesAndAmounts(uint256 amount0Desired, uint256 amount1Desired) internal view returns ( uint256 shares, uint256 amount0, uint256 amount1 ) {
521	 uint256 totalSupply = totalSupply();
522	 (uint256 total0, uint256 total1) = getTotalAmounts();
523	 assert(totalSupply == 0 || total0 > 0 || total1 > 0);
524	 if (totalSupply == 0) {
525	 amount0 = amount0Desired;
526	 amount1 = amount1Desired;
527	 shares = Math.max(amount0, amount1);
528	 }
529	 else if (total0 == 0) {
530	 amount1 = amount1Desired;
531	 shares = amount1.mul(totalSupply).div(total1);
532	 }
533	 else if (total1 == 0) {
534	 amount0 = amount0Desired;
535	 shares = amount0.mul(totalSupply).div(total0);
536	 }
537	 else {
538	 uint256 cross = Math.min(amount0Desired.mul(total1), amount1Desired.mul(total0));
539	 require(cross > 0, "cross");
540	 amount0 = cross.sub(1).div(total1).add(1);
541	 amount1 = cross.sub(1).div(total0).add(1);
542	 shares = cross.mul(totalSupply).div(total0).div(total1);
543	 }
544	 }
545	 function withdraw( uint256 shares, uint256 amount0Min, uint256 amount1Min, address to ) external override nonReentrant returns (uint256 amount0, uint256 amount1) {
546	 require(shares > 0, "shares");
547	 require(to != address(0) && to != address(this), "to");
548	 uint256 totalSupply = totalSupply();
549	 _burn(msg.sender, shares);
550	 uint256 unusedAmount0 = getBalance0().mul(shares).div(totalSupply);
551	 uint256 unusedAmount1 = getBalance1().mul(shares).div(totalSupply);
552	 (uint256 baseAmount0, uint256 baseAmount1) = _burnLiquidityShare(baseLower, baseUpper, shares, totalSupply);
553	 (uint256 limitAmount0, uint256 limitAmount1) = _burnLiquidityShare(limitLower, limitUpper, shares, totalSupply);
554	 amount0 = unusedAmount0.add(baseAmount0).add(limitAmount0);
555	 amount1 = unusedAmount1.add(baseAmount1).add(limitAmount1);
556	 require(amount0 >= amount0Min, "amount0Min");
557	 require(amount1 >= amount1Min, "amount1Min");
558	 if (amount0 > 0) token0.safeTransfer(to, amount0);
559	 if (amount1 > 0) token1.safeTransfer(to, amount1);
560	 emit Withdraw(msg.sender, to, shares, amount0, amount1);
561	 }
562	 function _burnLiquidityShare( int24 tickLower, int24 tickUpper, uint256 shares, uint256 totalSupply ) internal returns (uint256 amount0, uint256 amount1) {
563	 (uint128 totalLiquidity, , , , ) = _position(tickLower, tickUpper);
564	 uint256 liquidity = uint256(totalLiquidity).mul(shares).div(totalSupply);
565	 if (liquidity > 0) {
566	 (uint256 burned0, uint256 burned1, uint256 fees0, uint256 fees1) = _burnAndCollect(tickLower, tickUpper, _toUint128(liquidity));
567	 amount0 = burned0.add(fees0.mul(shares).div(totalSupply));
568	 amount1 = burned1.add(fees1.mul(shares).div(totalSupply));
569	 }
570	 }
571	 function rebalance( int256 swapAmount, uint160 sqrtPriceLimitX96, int24 _baseLower, int24 _baseUpper, int24 _bidLower, int24 _bidUpper, int24 _askLower, int24 _askUpper ) external nonReentrant {
572	 require(msg.sender == strategy, "strategy");
573	 _checkRange(_baseLower, _baseUpper);
574	 _checkRange(_bidLower, _bidUpper);
575	 _checkRange(_askLower, _askUpper);
576	 (, int24 tick, , , , , ) = pool.slot0();
577	 require(_bidUpper <= tick, "bidUpper");
578	 require(_askLower > tick, "askLower");
579	 {
580	 (uint128 baseLiquidity, , , , ) = _position(baseLower, baseUpper);
581	 (uint128 limitLiquidity, , , , ) = _position(limitLower, limitUpper);
582	 _burnAndCollect(baseLower, baseUpper, baseLiquidity);
583	 _burnAndCollect(limitLower, limitUpper, limitLiquidity);
584	 }
585	 uint256 balance0 = getBalance0();
586	 uint256 balance1 = getBalance1();
587	 emit Snapshot(tick, balance0, balance1, totalSupply());
588	 if (swapAmount != 0) {
589	 pool.swap( address(this), swapAmount > 0, swapAmount > 0 ? swapAmount : -swapAmount, sqrtPriceLimitX96, "" );
590	 balance0 = getBalance0();
591	 balance1 = getBalance1();
592	 }
593	 uint128 liquidity = _liquidityForAmounts(_baseLower, _baseUpper, balance0, balance1);
594	 _mintLiquidity(_baseLower, _baseUpper, liquidity);
595	 (baseLower, baseUpper) = (_baseLower, _baseUpper);
596	 balance0 = getBalance0();
597	 balance1 = getBalance1();
598	 uint128 bidLiquidity = _liquidityForAmounts(_bidLower, _bidUpper, balance0, balance1);
599	 uint128 askLiquidity = _liquidityForAmounts(_askLower, _askUpper, balance0, balance1);
600	 if (bidLiquidity > askLiquidity) {
601	 _mintLiquidity(_bidLower, _bidUpper, bidLiquidity);
602	 (limitLower, limitUpper) = (_bidLower, _bidUpper);
603	 }
604	 else {
605	 _mintLiquidity(_askLower, _askUpper, askLiquidity);
606	 (limitLower, limitUpper) = (_askLower, _askUpper);
607	 }
608	 }
609	 function _checkRange(int24 tickLower, int24 tickUpper) internal view {
610	 int24 _tickSpacing = tickSpacing;
611	 require(tickLower < tickUpper, "tickLower < tickUpper");
612	 require(tickLower >= TickMath.MIN_TICK, "tickLower too low");
613	 require(tickUpper <= TickMath.MAX_TICK, "tickUpper too high");
614	 require(tickLower % _tickSpacing == 0, "tickLower % tickSpacing");
615	 require(tickUpper % _tickSpacing == 0, "tickUpper % tickSpacing");
616	 }
617	 function _burnAndCollect( int24 tickLower, int24 tickUpper, uint128 liquidity ) internal returns ( uint256 burned0, uint256 burned1, uint256 feesToVault0, uint256 feesToVault1 ) {
618	 if (liquidity > 0) {
619	 (burned0, burned1) = pool.burn(tickLower, tickUpper, liquidity);
620	 }
621	 (uint256 collect0, uint256 collect1) = pool.collect( address(this), tickLower, tickUpper, type(uint128).max, type(uint128).max );
622	 feesToVault0 = collect0.sub(burned0);
623	 feesToVault1 = collect1.sub(burned1);
624	 uint256 feesToProtocol0;
625	 uint256 feesToProtocol1;
626	 uint256 _protocolFee = protocolFee;
627	 if (_protocolFee > 0) {
628	 feesToProtocol0 = feesToVault0.mul(_protocolFee).div(1e6);
629	 feesToProtocol1 = feesToVault1.mul(_protocolFee).div(1e6);
630	 feesToVault0 = feesToVault0.sub(feesToProtocol0);
631	 feesToVault1 = feesToVault1.sub(feesToProtocol1);
632	 accruedProtocolFees0 = accruedProtocolFees0.add(feesToProtocol0);
633	 accruedProtocolFees1 = accruedProtocolFees1.add(feesToProtocol1);
634	 }
635	 emit CollectFees(feesToVault0, feesToVault1, feesToProtocol0, feesToProtocol1);
636	 }
637	 function _mintLiquidity( int24 tickLower, int24 tickUpper, uint128 liquidity ) internal {
638	 if (liquidity > 0) {
639	 pool.mint(address(this), tickLower, tickUpper, liquidity, "");
640	 }
641	 }
642	 function getTotalAmounts() public view override returns (uint256 total0, uint256 total1) {
643	 (uint256 baseAmount0, uint256 baseAmount1) = getPositionAmounts(baseLower, baseUpper);
644	 (uint256 limitAmount0, uint256 limitAmount1) = getPositionAmounts(limitLower, limitUpper);
645	 total0 = getBalance0().add(baseAmount0).add(limitAmount0);
646	 total1 = getBalance1().add(baseAmount1).add(limitAmount1);
647	 }
648	 function getPositionAmounts(int24 tickLower, int24 tickUpper) public view returns (uint256 amount0, uint256 amount1) {
649	 (uint128 liquidity, , , uint128 tokensOwed0, uint128 tokensOwed1) = _position(tickLower, tickUpper);
650	 (amount0, amount1) = _amountsForLiquidity(tickLower, tickUpper, liquidity);
651	 uint256 oneMinusFee = uint256(1e6).sub(protocolFee);
652	 amount0 = amount0.add(uint256(tokensOwed0).mul(oneMinusFee).div(1e6));
653	 amount1 = amount1.add(uint256(tokensOwed1).mul(oneMinusFee).div(1e6));
654	 }
655	 function getBalance0() public view returns (uint256) {
656	 return token0.balanceOf(address(this)).sub(accruedProtocolFees0);
657	 }
658	 function getBalance1() public view returns (uint256) {
659	 return token1.balanceOf(address(this)).sub(accruedProtocolFees1);
660	 }
661	 function _position(int24 tickLower, int24 tickUpper) internal view returns ( uint128, uint256, uint256, uint128, uint128 ) {
662	 bytes32 positionKey = PositionKey.compute(address(this), tickLower, tickUpper);
663	 return pool.positions(positionKey);
664	 }
665	 function _amountsForLiquidity( int24 tickLower, int24 tickUpper, uint128 liquidity ) internal view returns (uint256, uint256) {
666	 (uint160 sqrtRatioX96, , , , , , ) = pool.slot0();
667	 return LiquidityAmounts.getAmountsForLiquidity( sqrtRatioX96, TickMath.getSqrtRatioAtTick(tickLower), TickMath.getSqrtRatioAtTick(tickUpper), liquidity );
668	 }
669	 function _liquidityForAmounts( int24 tickLower, int24 tickUpper, uint256 amount0, uint256 amount1 ) internal view returns (uint128) {
670	 (uint160 sqrtRatioX96, , , , , , ) = pool.slot0();
671	 return LiquidityAmounts.getLiquidityForAmounts( sqrtRatioX96, TickMath.getSqrtRatioAtTick(tickLower), TickMath.getSqrtRatioAtTick(tickUpper), amount0, amount1 );
672	 }
673	 function _toUint128(uint256 x) internal pure returns (uint128) {
674	 assert(x <= type(uint128).max);
675	 return uint128(x);
676	 }
677	 function uniswapV3MintCallback( uint256 amount0, uint256 amount1, bytes calldata data ) external override {
678	 require(msg.sender == address(pool));
679	 if (amount0 > 0) token0.safeTransfer(msg.sender, amount0);
680	 if (amount1 > 0) token1.safeTransfer(msg.sender, amount1);
681	 }
682	 function uniswapV3SwapCallback( int256 amount0Delta, int256 amount1Delta, bytes calldata data ) external override {
683	 require(msg.sender == address(pool));
684	 if (amount0Delta > 0) token0.safeTransfer(msg.sender, uint256(amount0Delta));
685	 if (amount1Delta > 0) token1.safeTransfer(msg.sender, uint256(amount1Delta));
686	 }
687	 function collectProtocol( uint256 amount0, uint256 amount1, address to ) external onlyGovernance {
688	 accruedProtocolFees0 = accruedProtocolFees0.sub(amount0);
689	 accruedProtocolFees1 = accruedProtocolFees1.sub(amount1);
690	 if (amount0 > 0) token0.safeTransfer(to, amount0);
691	 if (amount1 > 0) token1.safeTransfer(to, amount1);
692	 }
693	 function sweep( IERC20 token, uint256 amount, address to ) external onlyGovernance {
694	 require(token != token0 && token != token1, "token");
695	 token.safeTransfer(to, amount);
696	 }
697	 function setStrategy(address _strategy) external onlyGovernance {
698	 strategy = _strategy;
699	 }
700	 function setProtocolFee(uint256 _protocolFee) external onlyGovernance {
701	 require(_protocolFee < 1e6, "protocolFee");
702	 protocolFee = _protocolFee;
703	 }
704	 function setMaxTotalSupply(uint256 _maxTotalSupply) external onlyGovernance {
705	 maxTotalSupply = _maxTotalSupply;
706	 }
707	 function emergencyBurn( int24 tickLower, int24 tickUpper, uint128 liquidity ) external onlyGovernance {
708	 pool.burn(tickLower, tickUpper, liquidity);
709	 pool.collect(address(this), tickLower, tickUpper, type(uint128).max, type(uint128).max);
710	 }
711	 function setGovernance(address _governance) external onlyGovernance {
712	 pendingGovernance = _governance;
713	 }
714	 function acceptGovernance() external {
715	 require(msg.sender == pendingGovernance, "pendingGovernance");
716	 governance = msg.sender;
717	 }
718	 modifier onlyGovernance {
719	 require(msg.sender == governance, "governance");
720	 _;
721	 }
722	 }
723	 pragma solidity >=0.6.0 <0.8.0;
724	 library Math {
725	 function max(uint256 a, uint256 b) internal pure returns (uint256) {
726	 return a >= b ? a : b;
727	 }
728	 function min(uint256 a, uint256 b) internal pure returns (uint256) {
729	 return a < b ? a : b;
730	 }
731	 function average(uint256 a, uint256 b) internal pure returns (uint256) {
732	 return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);
733	 }
734	 }
735	 pragma solidity >=0.6.0 <0.8.0;
736	 library SafeERC20 {
737	 using SafeMath for uint256;
738	 using Address for address;
739	 function safeTransfer(IERC20 token, address to, uint256 value) internal {
740	 _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
741	 }
742	 function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
743	 _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
744	 }
745	 function safeApprove(IERC20 token, address spender, uint256 value) internal {
746	 require((value == 0) || (token.allowance(address(this), spender) == 0), "SafeERC20: approve from non-zero to non-zero allowance" );
747	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
748	 }
749	 function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
750	 uint256 newAllowance = token.allowance(address(this), spender).add(value);
751	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
752	 }
753	 function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
754	 uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
755	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
756	 }
757	 function _callOptionalReturn(IERC20 token, bytes memory data) private {
758	 bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
759	 if (returndata.length > 0) {
760	 require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
761	 }
762	 }
763	 }
764	 pragma solidity >=0.5.0;
765	 library LiquidityAmounts {
766	 function toUint128(uint256 x) private pure returns (uint128 y) {
767	 require((y = uint128(x)) == x);
768	 }
769	 function getLiquidityForAmount0( uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint256 amount0 ) internal pure returns (uint128 liquidity) {
770	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
771	 uint256 intermediate = FullMath.mulDiv(sqrtRatioAX96, sqrtRatioBX96, FixedPoint96.Q96);
772	 return toUint128(FullMath.mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));
773	 }
774	 function getLiquidityForAmount1( uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint256 amount1 ) internal pure returns (uint128 liquidity) {
775	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
776	 return toUint128(FullMath.mulDiv(amount1, FixedPoint96.Q96, sqrtRatioBX96 - sqrtRatioAX96));
777	 }
778	 function getLiquidityForAmounts( uint160 sqrtRatioX96, uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint256 amount0, uint256 amount1 ) internal pure returns (uint128 liquidity) {
779	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
780	 if (sqrtRatioX96 <= sqrtRatioAX96) {
781	 liquidity = getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);
782	 }
783	 else if (sqrtRatioX96 < sqrtRatioBX96) {
784	 uint128 liquidity0 = getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);
785	 uint128 liquidity1 = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);
786	 liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;
787	 }
788	 else {
789	 liquidity = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);
790	 }
791	 }
792	 function getAmount0ForLiquidity( uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity ) internal pure returns (uint256 amount0) {
793	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
794	 return FullMath.mulDiv( uint256(liquidity) << FixedPoint96.RESOLUTION, sqrtRatioBX96 - sqrtRatioAX96, sqrtRatioBX96 ) / sqrtRatioAX96;
795	 }
796	 function getAmount1ForLiquidity( uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity ) internal pure returns (uint256 amount1) {
797	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
798	 return FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);
799	 }
800	 function getAmountsForLiquidity( uint160 sqrtRatioX96, uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity ) internal pure returns (uint256 amount0, uint256 amount1) {
801	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
802	 if (sqrtRatioX96 <= sqrtRatioAX96) {
803	 amount0 = getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);
804	 }
805	 else if (sqrtRatioX96 < sqrtRatioBX96) {
806	 amount0 = getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);
807	 amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);
808	 }
809	 else {
810	 amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);
811	 }
812	 }
813	 }
814	 pragma solidity >=0.5.0;
815	 library PositionKey {
816	 function compute( address owner, int24 tickLower, int24 tickUpper ) internal pure returns (bytes32) {
817	 return keccak256(abi.encodePacked(owner, tickLower, tickUpper));
818	 }
819	 }
820	 pragma solidity >=0.6.2 <0.8.0;
821	 library Address {
822	 function isContract(address account) internal view returns (bool) {
823	 uint256 size;
824	 assembly {
825	 size := extcodesize(account) }
826	 return size > 0;
827	 }
828	 function sendValue(address payable recipient, uint256 amount) internal {
829	 require(address(this).balance >= amount, "Address: insufficient balance");
830	 (bool success, ) = recipient.call{
831	 value: amount }
832	 ("");
833	 require(success, "Address: unable to send value, recipient may have reverted");
834	 }
835	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
836	 return functionCall(target, data, "Address: low-level call failed");
837	 }
838	 function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
839	 return functionCallWithValue(target, data, 0, errorMessage);
840	 }
841	 function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
842	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
843	 }
844	 function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
845	 require(address(this).balance >= value, "Address: insufficient balance for call");
846	 require(isContract(target), "Address: call to non-contract");
847	 (bool success, bytes memory returndata) = target.call{
848	 value: value }
849	 (data);
850	 return _verifyCallResult(success, returndata, errorMessage);
851	 }
852	 function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
853	 return functionStaticCall(target, data, "Address: low-level static call failed");
854	 }
855	 function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
856	 require(isContract(target), "Address: static call to non-contract");
857	 (bool success, bytes memory returndata) = target.staticcall(data);
858	 return _verifyCallResult(success, returndata, errorMessage);
859	 }
860	 function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
861	 return functionDelegateCall(target, data, "Address: low-level delegate call failed");
862	 }
863	 function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
864	 require(isContract(target), "Address: delegate call to non-contract");
865	 (bool success, bytes memory returndata) = target.delegatecall(data);
866	 return _verifyCallResult(success, returndata, errorMessage);
867	 }
868	 function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
869	 if (success) {
870	 return returndata;
871	 }
872	 else {
873	 if (returndata.length > 0) {
874	 assembly {
875	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
876	 }
877	 else {
878	 revert(errorMessage);
879	 }
880	 }
881	 }
882	 }
883	 pragma solidity >=0.4.0 <0.8.0;
884	 library FullMath {
885	 function mulDiv( uint256 a, uint256 b, uint256 denominator ) internal pure returns (uint256 result) {
886	 uint256 prod0;
887	 uint256 prod1;
888	 assembly {
889	 let mm := mulmod(a, b, not(0)) prod0 := mul(a, b) prod1 := sub(sub(mm, prod0), lt(mm, prod0)) }
890	 if (prod1 == 0) {
891	 require(denominator > 0);
892	 assembly {
893	 result := div(prod0, denominator) }
894	 return result;
895	 }
896	 require(denominator > prod1);
897	 uint256 remainder;
898	 assembly {
899	 remainder := mulmod(a, b, denominator) }
900	 assembly {
901	 prod1 := sub(prod1, gt(remainder, prod0)) prod0 := sub(prod0, remainder) }
902	 uint256 twos = -denominator & denominator;
903	 assembly {
904	 denominator := div(denominator, twos) }
905	 assembly {
906	 prod0 := div(prod0, twos) }
907	 assembly {
908	 twos := add(div(sub(0, twos), twos), 1) }
909	 prod0 |= prod1 * twos;
910	 uint256 inv = (3 * denominator) ^ 2;
911	 inv *= 2 - denominator * inv;
912	 inv *= 2 - denominator * inv;
913	 inv *= 2 - denominator * inv;
914	 inv *= 2 - denominator * inv;
915	 inv *= 2 - denominator * inv;
916	 inv *= 2 - denominator * inv;
917	 result = prod0 * inv;
918	 return result;
919	 }
920	 function mulDivRoundingUp( uint256 a, uint256 b, uint256 denominator ) internal pure returns (uint256 result) {
921	 result = mulDiv(a, b, denominator);
922	 if (mulmod(a, b, denominator) > 0) {
923	 require(result < type(uint256).max);
924	 result++;
925	 }
926	 }
927	 }
928	 pragma solidity >=0.4.0;
929	 library FixedPoint96 {
930	 uint8 internal constant RESOLUTION = 96;
931	 uint256 internal constant Q96 = 0x1000000000000000000000000;
932	 }
