row number 
1	  pragma experimental ABIEncoderV2;
2	 pragma solidity ^0.5.0;
3	 contract Context {
4	 constructor () internal {
5	 }
6	 function _msgSender() internal view returns (address payable) {
7	 return msg.sender;
8	 }
9	 function _msgData() internal view returns (bytes memory) {
10	 this;
11	 return msg.data;
12	 }
13	 }
14	 pragma solidity ^0.5.0;
15	 contract Ownable is Context {
16	 address private _owner;
17	 event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
18	 constructor () internal {
19	 address msgSender = _msgSender();
20	 _owner = msgSender;
21	 emit OwnershipTransferred(address(0), msgSender);
22	 }
23	 function owner() public view returns (address) {
24	 return _owner;
25	 }
26	 modifier onlyOwner() {
27	 require(isOwner(), "Ownable: caller is not the owner");
28	 _;
29	 }
30	 function isOwner() public view returns (bool) {
31	 return _msgSender() == _owner;
32	 }
33	 function renounceOwnership() public onlyOwner {
34	 emit OwnershipTransferred(_owner, address(0));
35	 _owner = address(0);
36	 }
37	 function transferOwnership(address newOwner) public onlyOwner {
38	 _transferOwnership(newOwner);
39	 }
40	 function _transferOwnership(address newOwner) internal {
41	 require(newOwner != address(0), "Ownable: new owner is the zero address");
42	 emit OwnershipTransferred(_owner, newOwner);
43	 _owner = newOwner;
44	 }
45	 }
46	 pragma solidity 0.5.17;
47	 contract StakingConstantsV2 {
48	 address internal constant ZERO_ADDRESS = address(0);
49	 address public constant BZRX = 0x56d811088235F11C8920698a204A5010a788f4b3;
50	 address public constant OOKI = 0x0De05F6447ab4D22c8827449EE4bA2D5C288379B;
51	 address public constant vBZRX = 0xB72B31907C1C95F3650b64b2469e08EdACeE5e8F;
52	 address public constant iOOKI = 0x05d5160cbc6714533ef44CEd6dd32112d56Ad7da;
53	 address public constant OOKI_ETH_LP = 0xEaaddE1E14C587a7Fb4Ba78eA78109BB32975f1e;
54	 uint256 internal constant cliffDuration = 15768000;
55	 uint256 internal constant vestingDuration = 126144000;
56	 uint256 internal constant vestingDurationAfterCliff = 110376000;
57	 uint256 internal constant vestingStartTimestamp = 1594648800;
58	 uint256 internal constant vestingCliffTimestamp = vestingStartTimestamp + cliffDuration;
59	 uint256 internal constant vestingEndTimestamp = vestingStartTimestamp + vestingDuration;
60	 uint256 internal constant _startingVBZRXBalance = 8893899330e18;
61	 address internal constant SUSHI_MASTERCHEF = 0xc2EdaD668740f1aA35E4D8f227fB8E17dcA888Cd;
62	 uint256 internal constant OOKI_ETH_SUSHI_MASTERCHEF_PID = 335;
63	 address public constant SUSHI = 0x6B3595068778DD592e39A122f4f5a5cF09C90fE2;
64	 ICurve3Pool public constant curve3pool = ICurve3Pool(0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7);
65	 IERC20 public constant curve3Crv = IERC20(0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490);
66	 ICurveMinter public constant curveMinter = ICurveMinter(0xd061D61a4d941c39E5453435B6345Dc261C2fcE0);
67	 IBZRXv2Converter public constant CONVERTER = IBZRXv2Converter(0x6BE9B7406260B6B6db79a1D4997e7f8f5c9D7400);
68	 event Stake(address indexed user, address indexed token, address indexed delegate, uint256 amount);
69	 event Unstake(address indexed user, address indexed token, address indexed delegate, uint256 amount);
70	 event Claim(address indexed user, uint256 ookiAmount, uint256 stableCoinAmount);
71	 event AddAltRewards(address indexed sender, address indexed token, uint256 amount);
72	 event ClaimAltRewards(address indexed user, address indexed token, uint256 amount);
73	 event AddRewards(address indexed sender, uint256 ookiAmount, uint256 stableCoinAmount);
74	 }
75	 pragma solidity 0.5.17;
76	 contract StakingStateV2 is StakingConstantsV2, Ownable {
77	 using SafeMath for uint256;
78	 using SafeERC20 for IERC20;
79	 using EnumerableBytes32Set for EnumerableBytes32Set.Bytes32Set;
80	 mapping(bytes4 => address) public logicTargets;
81	 EnumerableBytes32Set.Bytes32Set internal logicTargetsSet;
82	 mapping(address => uint256) public _totalSupplyPerToken;
83	 mapping(address => mapping(address => uint256)) internal _balancesPerToken;
84	 uint256 public ookiPerTokenStored;
85	 mapping(address => uint256) public ookiRewardsPerTokenPaid;
86	 mapping(address => uint256) public ookiRewards;
87	 mapping(address => uint256) public bzrxVesting;
88	 uint256 public stableCoinPerTokenStored;
89	 mapping(address => uint256) public stableCoinRewardsPerTokenPaid;
90	 mapping(address => uint256) public stableCoinRewards;
91	 mapping(address => uint256) public stableCoinVesting;
92	 uint256 public vBZRXWeightStored;
93	 uint256 public iOOKIWeightStored;
94	 uint256 public LPTokenWeightStored;
95	 uint256 public lastRewardsAddTime;
96	 mapping(address => uint256) public vestingLastSync;
97	 struct ProposalState {
98	 uint256 proposalTime;
99	 uint256 iOOKIWeight;
100	 uint256 lpOOKIBalance;
101	 uint256 lpTotalSupply;
102	 }
103	 address public governor;
104	 mapping(uint256 => ProposalState) internal _proposalState;
105	 mapping(address => uint256[]) public altRewardsRounds;
106	 mapping(address => uint256) public altRewardsPerShare;
107	 mapping(address => mapping(address => IStakingV2.AltRewardsUserInfo)) public userAltRewardsPerShare;
108	 address public voteDelegator;
109	 function _setTarget(bytes4 sig, address target) internal {
110	 logicTargets[sig] = target;
111	 if (target != address(0)) {
112	 logicTargetsSet.addBytes32(bytes32(sig));
113	 }
114	 else {
115	 logicTargetsSet.removeBytes32(bytes32(sig));
116	 }
117	 }
118	 }
119	 pragma solidity 0.5.17;
120	 contract PausableGuardian is Ownable {
121	 bytes32 internal constant Pausable_FunctionPause = 0xa7143c84d793a15503da6f19bf9119a2dac94448ca45d77c8bf08f57b2e91047;
122	 bytes32 internal constant Pausable_GuardianAddress = 0x80e6706973d0c59541550537fd6a33b971efad732635e6c3b99fb01006803cdf;
123	 modifier pausable {
124	 require(!_isPaused(msg.sig), "paused");
125	 _;
126	 }
127	 function _isPaused(bytes4 sig) public view returns (bool isPaused) {
128	 bytes32 slot = keccak256(abi.encodePacked(sig, Pausable_FunctionPause));
129	 assembly {
130	 isPaused := sload(slot) }
131	 }
132	 function toggleFunctionPause(bytes4 sig) public {
133	 require(msg.sender == getGuardian() || msg.sender == owner(), "unauthorized");
134	 bytes32 slot = keccak256(abi.encodePacked(sig, Pausable_FunctionPause));
135	 assembly {
136	 sstore(slot, 1) }
137	 }
138	 function toggleFunctionUnPause(bytes4 sig) public {
139	 require(msg.sender == getGuardian() || msg.sender == owner(), "unauthorized");
140	 bytes32 slot = keccak256(abi.encodePacked(sig, Pausable_FunctionPause));
141	 assembly {
142	 sstore(slot, 0) }
143	 }
144	 function changeGuardian(address newGuardian) public {
145	 require(msg.sender == getGuardian() || msg.sender == owner(), "unauthorized");
146	 assembly {
147	 sstore(Pausable_GuardianAddress, newGuardian) }
148	 }
149	 function getGuardian() public view returns (address guardian) {
150	 assembly {
151	 guardian := sload(Pausable_GuardianAddress) }
152	 }
153	 }
154	 contract GovernorBravoDelegatorStorage {
155	 address public admin;
156	 address public pendingAdmin;
157	 address public implementation;
158	 address public guardian;
159	 }
160	 pragma solidity 0.5.17;
161	 contract VoteDelegationUpgradeable is Ownable {
162	 address public implementation;
163	 }
164	 pragma solidity ^0.5.0;
165	 interface IERC20 {
166	 function totalSupply() external view returns (uint256);
167	 function balanceOf(address account) external view returns (uint256);
168	 function transfer(address recipient, uint256 amount) external returns (bool);
169	 function allowance(address owner, address spender) external view returns (uint256);
170	 function approve(address spender, uint256 amount) external returns (bool);
171	 function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
172	 event Transfer(address indexed from, address indexed to, uint256 value);
173	 event Approval(address indexed owner, address indexed spender, uint256 value);
174	 }
175	 pragma solidity ^0.5.16;
176	 contract GovernorBravoEvents {
177	 event ProposalCreated(uint id, address proposer, address[] targets, uint[] values, string[] signatures, bytes[] calldatas, uint startBlock, uint endBlock, string description);
178	 event VoteCast(address indexed voter, uint proposalId, uint8 support, uint votes, string reason);
179	 event ProposalCanceled(uint id);
180	 event ProposalQueued(uint id, uint eta);
181	 event ProposalExecuted(uint id);
182	 event VotingDelaySet(uint oldVotingDelay, uint newVotingDelay);
183	 event VotingPeriodSet(uint oldVotingPeriod, uint newVotingPeriod);
184	 event NewImplementation(address oldImplementation, address newImplementation);
185	 event QuorumPercentageSet(uint oldQuorumPercentage, uint newQuorumPercentage);
186	 event StakingAddressSet(address oldStaking, address newStaking);
187	 event ProposalThresholdSet(uint oldProposalThreshold, uint newProposalThreshold);
188	 event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);
189	 event NewAdmin(address oldAdmin, address newAdmin);
190	 }
191	 contract GovernorBravoDelegateStorageV1 is GovernorBravoDelegatorStorage {
192	 uint public votingDelay;
193	 uint public votingPeriod;
194	 uint public proposalThresholdPercentage;
195	 uint public initialProposalId;
196	 uint public proposalCount;
197	 TimelockInterface public timelock;
198	 StakingInterface public staking;
199	 uint public quorumPercentage;
200	 mapping (uint => Proposal) public proposals;
201	 mapping (address => uint) public latestProposalIds;
202	 mapping (uint => uint) public quorumVotesForProposal;
203	 struct Proposal {
204	 uint id;
205	 address proposer;
206	 uint eta;
207	 address[] targets;
208	 uint[] values;
209	 string[] signatures;
210	 bytes[] calldatas;
211	 uint startBlock;
212	 uint endBlock;
213	 uint forVotes;
214	 uint againstVotes;
215	 uint abstainVotes;
216	 bool canceled;
217	 bool executed;
218	 mapping (address => Receipt) receipts;
219	 }
220	 struct Receipt {
221	 bool hasVoted;
222	 uint8 support;
223	 uint96 votes;
224	 }
225	 enum ProposalState {
226	 Pending, Active, Canceled, Defeated, Succeeded, Queued, Expired, Executed }
227	 }
228	 pragma solidity 0.5.17;
229	 contract VoteDelegatorState is VoteDelegationUpgradeable {
230	 mapping (address => address) internal _delegates;
231	 struct Checkpoint {
232	 uint32 fromBlock;
233	 uint256 votes;
234	 }
235	 mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;
236	 mapping (address => uint32) public numCheckpoints;
237	 bytes32 public constant DOMAIN_TYPEHASH = keccak256("EIP712Domain(string name,uint256 chainId,address verifyingContract)");
238	 bytes32 public constant DELEGATION_TYPEHASH = keccak256("Delegation(address delegatee,uint256 nonce,uint256 expiry)");
239	 mapping (address => uint) public nonces;
240	 mapping (address => uint256) public totalDelegators;
241	 IStakingV2 staking;
242	 }
243	 pragma solidity 0.5.17;
244	 contract VoteDelegatorConstants {
245	 address internal constant ZERO_ADDRESS = address(0);
246	 event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
247	 event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);
248	 }
249	 pragma solidity 0.5.17;
250	 contract Common is StakingStateV2, PausableGuardian {
251	 using MathUtil for uint256;
252	 function _getProposalState() internal view returns (ProposalState memory) {
253	 return ProposalState({
254	 proposalTime: block.timestamp - 1, iOOKIWeight: _calcIOOKIWeight(), lpOOKIBalance: 0, lpTotalSupply: 0 }
255	 );
256	 }
257	 function _calcIOOKIWeight() internal view returns (uint256) {
258	 uint256 total = IERC20(iOOKI).totalSupply();
259	 if(total != 0) return IERC20(OOKI).balanceOf(iOOKI).mul(1e50).div(total);
260	 return 0;
261	 }
262	 function vestedBalanceForAmount( uint256 tokenBalance, uint256 lastUpdate, uint256 vestingEndTime ) public view returns (uint256 vested) {
263	 vestingEndTime = vestingEndTime.min256(block.timestamp);
264	 if (vestingEndTime > lastUpdate) {
265	 if (vestingEndTime <= vestingCliffTimestamp || lastUpdate >= vestingEndTimestamp) {
266	 return 0;
267	 }
268	 if (lastUpdate < vestingCliffTimestamp) {
269	 lastUpdate = vestingCliffTimestamp;
270	 }
271	 if (vestingEndTime > vestingEndTimestamp) {
272	 vestingEndTime = vestingEndTimestamp;
273	 }
274	 uint256 timeSinceClaim = vestingEndTime.sub(lastUpdate);
275	 vested = tokenBalance.mul(timeSinceClaim) / vestingDurationAfterCliff;
276	 }
277	 }
278	 function _votingFromStakedBalanceOf( address account, ProposalState memory proposal, bool skipVestingLastSyncCheck ) internal view returns (uint256 totalVotes) {
279	 uint256 _vestingLastSync = vestingLastSync[account];
280	 if (proposal.proposalTime == 0 || (!skipVestingLastSyncCheck && _vestingLastSync > proposal.proposalTime - 1)) {
281	 return 0;
282	 }
283	 uint256 _vOOKIBalance = _balancesPerToken[vBZRX][account] * 10;
284	 if (_vOOKIBalance != 0) {
285	 if (vestingEndTimestamp > proposal.proposalTime && vestingCliffTimestamp < proposal.proposalTime) {
286	 totalVotes = _vOOKIBalance * (vestingEndTimestamp - proposal.proposalTime) / vestingDurationAfterCliff;
287	 }
288	 totalVotes = vestedBalanceForAmount( _vOOKIBalance, _vestingLastSync, proposal.proposalTime ).add(totalVotes);
289	 }
290	 totalVotes = _balancesPerToken[OOKI][account].add(ookiRewards[account]).add(totalVotes);
291	 totalVotes = _balancesPerToken[iOOKI][account].mul(proposal.iOOKIWeight).div(1e50).add(totalVotes);
292	 }
293	 }
294	 pragma solidity 0.5.17;
295	 contract StakeUnstake is Common {
296	 function initialize(address target) external onlyOwner {
297	 _setTarget(this.totalSupplyByAsset.selector, target);
298	 _setTarget(this.stake.selector, target);
299	 _setTarget(this.unstake.selector, target);
300	 _setTarget(this.claim.selector, target);
301	 _setTarget(this.claimAltRewards.selector, target);
302	 _setTarget(this.claimBzrx.selector, target);
303	 _setTarget(this.claim3Crv.selector, target);
304	 _setTarget(this.claimSushi.selector, target);
305	 _setTarget(this.earned.selector, target);
306	 _setTarget(this.addAltRewards.selector, target);
307	 _setTarget(this.balanceOfByAsset.selector, target);
308	 _setTarget(this.balanceOfByAssets.selector, target);
309	 _setTarget(this.balanceOfStored.selector, target);
310	 _setTarget(this.vestedBalanceForAmount.selector, target);
311	 _setTarget(this.exit.selector, target);
312	 }
313	 function totalSupplyByAsset( address token) external view returns (uint256) {
314	 return _totalSupplyPerToken[token];
315	 }
316	 function _pendingSushiRewards(address _user) internal view returns (uint256) {
317	 uint256 pendingSushi = IMasterChefSushi(SUSHI_MASTERCHEF).pendingSushi(OOKI_ETH_SUSHI_MASTERCHEF_PID, address(this));
318	 uint256 totalSupply = _totalSupplyPerToken[OOKI_ETH_LP];
319	 return _pendingAltRewards(SUSHI, _user, balanceOfByAsset(OOKI_ETH_LP, _user), totalSupply != 0 ? pendingSushi.mul(1e12).div(totalSupply) : 0);
320	 }
321	 function _pendingAltRewards( address token, address _user, uint256 userSupply, uint256 extraRewardsPerShare ) internal view returns (uint256) {
322	 uint256 _altRewardsPerShare = altRewardsPerShare[token].add(extraRewardsPerShare);
323	 if (_altRewardsPerShare == 0) return 0;
324	 IStakingV2.AltRewardsUserInfo memory altRewardsUserInfo = userAltRewardsPerShare[_user][token];
325	 return altRewardsUserInfo.pendingRewards.add((_altRewardsPerShare.sub(altRewardsUserInfo.rewardsPerShare)).mul(userSupply).div(1e12));
326	 }
327	 function _depositToSushiMasterchef(uint256 amount) internal {
328	 uint256 sushiBalanceBefore = IERC20(SUSHI).balanceOf(address(this));
329	 IMasterChefSushi(SUSHI_MASTERCHEF).deposit(OOKI_ETH_SUSHI_MASTERCHEF_PID, amount);
330	 uint256 sushiRewards = IERC20(SUSHI).balanceOf(address(this)) - sushiBalanceBefore;
331	 if (sushiRewards != 0) {
332	 _addAltRewards(SUSHI, sushiRewards);
333	 }
334	 }
335	 function _withdrawFromSushiMasterchef(uint256 amount) internal {
336	 uint256 sushiBalanceBefore = IERC20(SUSHI).balanceOf(address(this));
337	 IMasterChefSushi(SUSHI_MASTERCHEF).withdraw(OOKI_ETH_SUSHI_MASTERCHEF_PID, amount);
338	 uint256 sushiRewards = IERC20(SUSHI).balanceOf(address(this)) - sushiBalanceBefore;
339	 if (sushiRewards != 0) {
340	 _addAltRewards(SUSHI, sushiRewards);
341	 }
342	 }
343	 function stake(address[] memory tokens, uint256[] memory values) public pausable updateRewards(msg.sender) {
344	 require(tokens.length == values.length, "count mismatch");
345	 VoteDelegator _voteDelegator = VoteDelegator(voteDelegator);
346	 address currentDelegate = _voteDelegator.delegates(msg.sender);
347	 ProposalState memory _proposalState = _getProposalState();
348	 uint256 votingBalanceBefore = _votingFromStakedBalanceOf(msg.sender, _proposalState, true);
349	 for (uint256 i = 0; i < tokens.length; i++) {
350	 address token = tokens[i];
351	 require(token == OOKI || token == vBZRX || token == iOOKI || token == OOKI_ETH_LP, "invalid token");
352	 uint256 stakeAmount = values[i];
353	 if (stakeAmount == 0) {
354	 continue;
355	 }
356	 uint256 pendingBefore = (token == OOKI_ETH_LP) ? _pendingSushiRewards(msg.sender) : 0;
357	 _balancesPerToken[token][msg.sender] = _balancesPerToken[token][msg.sender].add(stakeAmount);
358	 _totalSupplyPerToken[token] = _totalSupplyPerToken[token].add(stakeAmount);
359	 IERC20(token).safeTransferFrom(msg.sender, address(this), stakeAmount);
360	 if (token == OOKI_ETH_LP) {
361	 _depositToSushiMasterchef(IERC20(OOKI_ETH_LP).balanceOf(address(this)));
362	 userAltRewardsPerShare[msg.sender][SUSHI] = IStakingV2.AltRewardsUserInfo({
363	 rewardsPerShare: altRewardsPerShare[SUSHI], pendingRewards: pendingBefore}
364	 );
365	 }
366	 emit Stake(msg.sender, token, currentDelegate, stakeAmount);
367	 }
368	 _voteDelegator.moveDelegatesByVotingBalance(votingBalanceBefore, _votingFromStakedBalanceOf(msg.sender, _proposalState, true), msg.sender);
369	 }
370	 function unstake(address[] memory tokens, uint256[] memory values) public pausable updateRewards(msg.sender) {
371	 require(tokens.length == values.length, "count mismatch");
372	 VoteDelegator _voteDelegator = VoteDelegator(voteDelegator);
373	 address currentDelegate = _voteDelegator.delegates(msg.sender);
374	 ProposalState memory _proposalState = _getProposalState();
375	 uint256 votingBalanceBefore = _votingFromStakedBalanceOf(msg.sender, _proposalState, true);
376	 for (uint256 i = 0; i < tokens.length; i++) {
377	 address token = tokens[i];
378	 require(token == OOKI || token == vBZRX || token == iOOKI || token == OOKI_ETH_LP, "invalid token");
379	 uint256 unstakeAmount = values[i];
380	 uint256 stakedAmount = _balancesPerToken[token][msg.sender];
381	 if (unstakeAmount == 0 || stakedAmount == 0) {
382	 continue;
383	 }
384	 if (unstakeAmount > stakedAmount) {
385	 unstakeAmount = stakedAmount;
386	 }
387	 if (token == OOKI_ETH_LP) {
388	 _withdrawFromSushiMasterchef(unstakeAmount);
389	 userAltRewardsPerShare[msg.sender][SUSHI] = IStakingV2.AltRewardsUserInfo({
390	 rewardsPerShare: altRewardsPerShare[SUSHI], pendingRewards: _pendingSushiRewards(msg.sender)}
391	 );
392	 }
393	 _balancesPerToken[token][msg.sender] = stakedAmount - unstakeAmount;
394	 _totalSupplyPerToken[token] = _totalSupplyPerToken[token] - unstakeAmount;
395	 if (token == OOKI && IERC20(OOKI).balanceOf(address(this)) < unstakeAmount) {
396	 IVestingToken(vBZRX).claim();
397	 CONVERTER.convert(address(this), IERC20(BZRX).balanceOf(address(this)));
398	 }
399	 IERC20(token).safeTransfer(msg.sender, unstakeAmount);
400	 emit Unstake(msg.sender, token, currentDelegate, unstakeAmount);
401	 }
402	 _voteDelegator.moveDelegatesByVotingBalance(votingBalanceBefore, _votingFromStakedBalanceOf(msg.sender, _proposalState, true), msg.sender);
403	 }
404	 function claim(bool restake) external pausable updateRewards(msg.sender) returns (uint256 ookiRewardsEarned, uint256 stableCoinRewardsEarned) {
405	 return _claim(restake);
406	 }
407	 function claimAltRewards() external pausable returns (uint256 sushiRewardsEarned, uint256 crvRewardsEarned) {
408	 sushiRewardsEarned = _claimSushi();
409	 if (sushiRewardsEarned != 0) {
410	 emit ClaimAltRewards(msg.sender, SUSHI, sushiRewardsEarned);
411	 }
412	 }
413	 function claimBzrx() external pausable updateRewards(msg.sender) returns (uint256 ookiRewardsEarned) {
414	 ookiRewardsEarned = _claimBzrx(false);
415	 emit Claim(msg.sender, ookiRewardsEarned, 0);
416	 }
417	 function claim3Crv() external pausable updateRewards(msg.sender) returns (uint256 stableCoinRewardsEarned) {
418	 stableCoinRewardsEarned = _claim3Crv();
419	 emit Claim(msg.sender, 0, stableCoinRewardsEarned);
420	 }
421	 function claimSushi() external pausable returns (uint256 sushiRewardsEarned) {
422	 sushiRewardsEarned = _claimSushi();
423	 if (sushiRewardsEarned != 0) {
424	 emit ClaimAltRewards(msg.sender, SUSHI, sushiRewardsEarned);
425	 }
426	 }
427	 function _claim(bool restake) internal returns (uint256 ookiRewardsEarned, uint256 stableCoinRewardsEarned) {
428	 ookiRewardsEarned = _claimBzrx(restake);
429	 stableCoinRewardsEarned = _claim3Crv();
430	 emit Claim(msg.sender, ookiRewardsEarned, stableCoinRewardsEarned);
431	 }
432	 function _claimBzrx(bool restake) internal returns (uint256 ookiRewardsEarned) {
433	 ProposalState memory _proposalState = _getProposalState();
434	 uint256 votingBalanceBefore = _votingFromStakedBalanceOf(msg.sender, _proposalState, true);
435	 ookiRewardsEarned = ookiRewards[msg.sender];
436	 if (ookiRewardsEarned != 0) {
437	 ookiRewards[msg.sender] = 0;
438	 if (restake) {
439	 _restakeBZRX(msg.sender, ookiRewardsEarned);
440	 }
441	 else {
442	 if (IERC20(OOKI).balanceOf(address(this)) < ookiRewardsEarned) {
443	 IVestingToken(vBZRX).claim();
444	 CONVERTER.convert(address(this), IERC20(BZRX).balanceOf(address(this)));
445	 }
446	 IERC20(OOKI).transfer(msg.sender, ookiRewardsEarned);
447	 }
448	 }
449	 VoteDelegator(voteDelegator).moveDelegatesByVotingBalance(votingBalanceBefore, _votingFromStakedBalanceOf(msg.sender, _proposalState, true), msg.sender);
450	 }
451	 function _claim3Crv() internal returns (uint256 stableCoinRewardsEarned) {
452	 stableCoinRewardsEarned = stableCoinRewards[msg.sender];
453	 if (stableCoinRewardsEarned != 0) {
454	 uint256 curve3CrvBalance = curve3Crv.balanceOf(address(this));
455	 stableCoinRewards[msg.sender] = 0;
456	 curve3Crv.transfer(msg.sender, stableCoinRewardsEarned);
457	 }
458	 }
459	 function _claimSushi() internal returns (uint256) {
460	 address _user = msg.sender;
461	 uint256 lptUserSupply = balanceOfByAsset(OOKI_ETH_LP, _user);
462	 _depositToSushiMasterchef(IERC20(OOKI_ETH_LP).balanceOf(address(this)));
463	 uint256 pendingSushi = _pendingAltRewards(SUSHI, _user, lptUserSupply, 0);
464	 userAltRewardsPerShare[_user][SUSHI] = IStakingV2.AltRewardsUserInfo({
465	 rewardsPerShare: altRewardsPerShare[SUSHI], pendingRewards: 0}
466	 );
467	 if (pendingSushi != 0) {
468	 IERC20(SUSHI).safeTransfer(_user, pendingSushi);
469	 }
470	 return pendingSushi;
471	 }
472	 function _restakeBZRX(address account, uint256 amount) internal {
473	 _balancesPerToken[OOKI][account] = _balancesPerToken[OOKI][account].add(amount);
474	 _totalSupplyPerToken[OOKI] = _totalSupplyPerToken[OOKI].add(amount);
475	 emit Stake( account, OOKI, account, amount );
476	 }
477	 modifier updateRewards(address account) {
478	 uint256 _ookiPerTokenStored = ookiPerTokenStored;
479	 uint256 _stableCoinPerTokenStored = stableCoinPerTokenStored;
480	 (uint256 ookiRewardsEarned, uint256 stableCoinRewardsEarned, uint256 ookiRewardsVesting, uint256 stableCoinRewardsVesting) = _earned( account, _ookiPerTokenStored, _stableCoinPerTokenStored );
481	 ookiRewardsPerTokenPaid[account] = _ookiPerTokenStored;
482	 stableCoinRewardsPerTokenPaid[account] = _stableCoinPerTokenStored;
483	 bzrxVesting[account] = ookiRewardsVesting;
484	 stableCoinVesting[account] = stableCoinRewardsVesting;
485	 (ookiRewards[account], stableCoinRewards[account]) = _syncVesting(account, ookiRewardsEarned, stableCoinRewardsEarned, ookiRewardsVesting, stableCoinRewardsVesting);
486	 vestingLastSync[account] = block.timestamp;
487	 _;
488	 }
489	 function earned(address account) external returns ( uint256 ookiRewardsEarned, uint256 stableCoinRewardsEarned, uint256 ookiRewardsVesting, uint256 stableCoinRewardsVesting, uint256 sushiRewardsEarned ) {
490	 (ookiRewardsEarned, stableCoinRewardsEarned, ookiRewardsVesting, stableCoinRewardsVesting) = _earned(account, ookiPerTokenStored, stableCoinPerTokenStored);
491	 (ookiRewardsEarned, stableCoinRewardsEarned) = _syncVesting(account, ookiRewardsEarned, stableCoinRewardsEarned, ookiRewardsVesting, stableCoinRewardsVesting);
492	 uint256 multiplier = vestedBalanceForAmount(1e36, 0, block.timestamp);
493	 ookiRewardsVesting = ookiRewardsVesting.sub(ookiRewardsVesting.mul(multiplier).div(1e36));
494	 stableCoinRewardsVesting = stableCoinRewardsVesting.sub(stableCoinRewardsVesting.mul(multiplier).div(1e36));
495	 uint256 pendingSushi = IMasterChefSushi(SUSHI_MASTERCHEF).pendingSushi(OOKI_ETH_SUSHI_MASTERCHEF_PID, address(this));
496	 sushiRewardsEarned = _pendingAltRewards( SUSHI, account, balanceOfByAsset(OOKI_ETH_LP, account), (_totalSupplyPerToken[OOKI_ETH_LP] != 0) ? pendingSushi.mul(1e12).div(_totalSupplyPerToken[OOKI_ETH_LP]) : 0 );
497	 }
498	 function _earned( address account, uint256 _ookiPerToken, uint256 _stableCoinPerToken ) internal returns ( uint256 ookiRewardsEarned, uint256 stableCoinRewardsEarned, uint256 ookiRewardsVesting, uint256 stableCoinRewardsVesting ) {
499	 uint256 ookiPerTokenUnpaid = _ookiPerToken.sub(ookiRewardsPerTokenPaid[account]);
500	 uint256 stableCoinPerTokenUnpaid = _stableCoinPerToken.sub(stableCoinRewardsPerTokenPaid[account]);
501	 ookiRewardsEarned = ookiRewards[account];
502	 stableCoinRewardsEarned = stableCoinRewards[account];
503	 ookiRewardsVesting = bzrxVesting[account];
504	 stableCoinRewardsVesting = stableCoinVesting[account];
505	 if (ookiPerTokenUnpaid != 0 || stableCoinPerTokenUnpaid != 0) {
506	 uint256 value;
507	 uint256 multiplier;
508	 uint256 lastSync;
509	 (uint256 vestedBalance, uint256 vestingBalance) = balanceOfStored(account);
510	 value = vestedBalance.mul(ookiPerTokenUnpaid);
511	 value /= 1e36;
512	 ookiRewardsEarned = value.add(ookiRewardsEarned);
513	 value = vestedBalance.mul(stableCoinPerTokenUnpaid);
514	 value /= 1e36;
515	 stableCoinRewardsEarned = value.add(stableCoinRewardsEarned);
516	 if (vestingBalance != 0 && ookiPerTokenUnpaid != 0) {
517	 value = vestingBalance.mul(ookiPerTokenUnpaid);
518	 value /= 1e36;
519	 ookiRewardsVesting = ookiRewardsVesting.add(value);
520	 lastSync = vestingLastSync[account];
521	 multiplier = vestedBalanceForAmount(1e36, 0, lastSync);
522	 value = value.mul(multiplier);
523	 value /= 1e36;
524	 ookiRewardsEarned = ookiRewardsEarned.add(value);
525	 }
526	 if (vestingBalance != 0 && stableCoinPerTokenUnpaid != 0) {
527	 value = vestingBalance.mul(stableCoinPerTokenUnpaid);
528	 value /= 1e36;
529	 stableCoinRewardsVesting = stableCoinRewardsVesting.add(value);
530	 if (lastSync == 0) {
531	 lastSync = vestingLastSync[account];
532	 multiplier = vestedBalanceForAmount(1e36, 0, lastSync);
533	 }
534	 value = value.mul(multiplier);
535	 value /= 1e36;
536	 stableCoinRewardsEarned = stableCoinRewardsEarned.add(value);
537	 }
538	 }
539	 }
540	 function _syncVesting( address account, uint256 ookiRewardsEarned, uint256 stableCoinRewardsEarned, uint256 ookiRewardsVesting, uint256 stableCoinRewardsVesting ) internal view returns (uint256, uint256) {
541	 uint256 lastVestingSync = vestingLastSync[account];
542	 if (lastVestingSync != block.timestamp) {
543	 uint256 rewardsVested;
544	 uint256 multiplier = vestedBalanceForAmount(1e36, lastVestingSync, block.timestamp);
545	 if (ookiRewardsVesting != 0) {
546	 rewardsVested = ookiRewardsVesting.mul(multiplier).div(1e36);
547	 ookiRewardsEarned += rewardsVested;
548	 }
549	 if (stableCoinRewardsVesting != 0) {
550	 rewardsVested = stableCoinRewardsVesting.mul(multiplier).div(1e36);
551	 stableCoinRewardsEarned += rewardsVested;
552	 }
553	 uint256 vBZRXBalance = _balancesPerToken[vBZRX][account];
554	 if (vBZRXBalance != 0) {
555	 rewardsVested = vBZRXBalance.mul(multiplier) .div(1e35);
556	 ookiRewardsEarned += rewardsVested;
557	 }
558	 }
559	 return (ookiRewardsEarned, stableCoinRewardsEarned);
560	 }
561	 function addAltRewards(address token, uint256 amount) public {
562	 if (amount != 0) {
563	 _addAltRewards(token, amount);
564	 IERC20(token).transferFrom(msg.sender, address(this), amount);
565	 }
566	 }
567	 function _addAltRewards(address token, uint256 amount) internal {
568	 address poolAddress = token == SUSHI ? OOKI_ETH_LP : token;
569	 uint256 totalSupply = _totalSupplyPerToken[poolAddress];
570	 require(totalSupply != 0, "no deposits");
571	 altRewardsPerShare[token] = altRewardsPerShare[token].add(amount.mul(1e12).div(totalSupply));
572	 emit AddAltRewards(msg.sender, token, amount);
573	 }
574	 function balanceOfByAsset(address token, address account) public view returns (uint256 balance) {
575	 balance = _balancesPerToken[token][account];
576	 }
577	 function balanceOfByAssets(address account) external view returns ( uint256 ookiBalance, uint256 iBZRXBalance, uint256 vBZRXBalance, uint256 LPTokenBalance ) {
578	 return (balanceOfByAsset(OOKI, account), balanceOfByAsset(iOOKI, account), balanceOfByAsset(vBZRX, account), balanceOfByAsset(OOKI_ETH_LP, account));
579	 }
580	 function balanceOfStored(address account) public view returns (uint256 vestedBalance, uint256 vestingBalance) {
581	 uint256 balance = _balancesPerToken[vBZRX][account];
582	 if (balance != 0) {
583	 vestingBalance = balance.mul(vBZRXWeightStored) .div(1e17);
584	 }
585	 vestedBalance = _balancesPerToken[OOKI][account];
586	 balance = _balancesPerToken[iOOKI][account];
587	 if (balance != 0) {
588	 vestedBalance = balance.mul(iOOKIWeightStored).div(1e50).add(vestedBalance);
589	 }
590	 balance = _balancesPerToken[OOKI_ETH_LP][account];
591	 if (balance != 0) {
592	 vestedBalance = balance.mul(LPTokenWeightStored).div(1e18).add(vestedBalance);
593	 }
594	 }
595	 function exit() public {
596	 address[] memory tokens = new address[](4);
597	 uint256[] memory values = new uint256[](4);
598	 tokens[0] = iOOKI;
599	 tokens[1] = OOKI_ETH_LP;
600	 tokens[2] = vBZRX;
601	 tokens[3] = OOKI;
602	 values[0] = uint256(-1);
603	 values[1] = uint256(-1);
604	 values[2] = uint256(-1);
605	 values[3] = uint256(-1);
606	 unstake(tokens, values);
607	 _claim(false);
608	 }
609	 }
610	 pragma solidity ^0.5.0;
611	 library SafeMath {
612	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
613	 uint256 c = a + b;
614	 require(c >= a, "SafeMath: addition overflow");
615	 return c;
616	 }
617	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
618	 return sub(a, b, "SafeMath: subtraction overflow");
619	 }
620	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
621	 require(b <= a, errorMessage);
622	 uint256 c = a - b;
623	 return c;
624	 }
625	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
626	 if (a == 0) {
627	 return 0;
628	 }
629	 uint256 c = a * b;
630	 require(c / a == b, "SafeMath: multiplication overflow");
631	 return c;
632	 }
633	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
634	 return div(a, b, "SafeMath: division by zero");
635	 }
636	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
637	 require(b > 0, errorMessage);
638	 uint256 c = a / b;
639	 return c;
640	 }
641	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
642	 return mod(a, b, "SafeMath: modulo by zero");
643	 }
644	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
645	 require(b != 0, errorMessage);
646	 return a % b;
647	 }
648	 }
649	 pragma solidity ^0.5.0;
650	 library SafeERC20 {
651	 using SafeMath for uint256;
652	 using Address for address;
653	 function safeTransfer(IERC20 token, address to, uint256 value) internal {
654	 callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
655	 }
656	 function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
657	 callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
658	 }
659	 function safeApprove(IERC20 token, address spender, uint256 value) internal {
660	 require((value == 0) || (token.allowance(address(this), spender) == 0), "SafeERC20: approve from non-zero to non-zero allowance" );
661	 callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
662	 }
663	 function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
664	 uint256 newAllowance = token.allowance(address(this), spender).add(value);
665	 callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
666	 }
667	 function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
668	 uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
669	 callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
670	 }
671	 function callOptionalReturn(IERC20 token, bytes memory data) private {
672	 require(address(token).isContract(), "SafeERC20: call to non-contract");
673	 (bool success, bytes memory returndata) = address(token).call(data);
674	 require(success, "SafeERC20: low-level call failed");
675	 if (returndata.length > 0) {
676	 require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
677	 }
678	 }
679	 }
680	 pragma solidity ^0.5.5;
681	 library Address {
682	 function isContract(address account) internal view returns (bool) {
683	 bytes32 codehash;
684	 bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
685	 assembly {
686	 codehash := extcodehash(account) }
687	 return (codehash != accountHash && codehash != 0x0);
688	 }
689	 function toPayable(address account) internal pure returns (address payable) {
690	 return address(uint160(account));
691	 }
692	 function sendValue(address payable recipient, uint256 amount) internal {
693	 require(address(this).balance >= amount, "Address: insufficient balance");
694	 (bool success, ) = recipient.call.value(amount)("");
695	 require(success, "Address: unable to send value, recipient may have reverted");
696	 }
697	 }
698	 pragma solidity 0.5.17;
699	 library EnumerableBytes32Set {
700	 struct Bytes32Set {
701	 mapping (bytes32 => uint256) index;
702	 bytes32[] values;
703	 }
704	 function addAddress(Bytes32Set storage set, address addrvalue) internal returns (bool) {
705	 bytes32 value;
706	 assembly {
707	 value := addrvalue }
708	 return addBytes32(set, value);
709	 }
710	 function addBytes32(Bytes32Set storage set, bytes32 value) internal returns (bool) {
711	 if (!contains(set, value)){
712	 set.index[value] = set.values.push(value);
713	 return true;
714	 }
715	 else {
716	 return false;
717	 }
718	 }
719	 function removeAddress(Bytes32Set storage set, address addrvalue) internal returns (bool) {
720	 bytes32 value;
721	 assembly {
722	 value := addrvalue }
723	 return removeBytes32(set, value);
724	 }
725	 function removeBytes32(Bytes32Set storage set, bytes32 value) internal returns (bool) {
726	 if (contains(set, value)){
727	 uint256 toDeleteIndex = set.index[value] - 1;
728	 uint256 lastIndex = set.values.length - 1;
729	 if (lastIndex != toDeleteIndex) {
730	 bytes32 lastValue = set.values[lastIndex];
731	 set.values[toDeleteIndex] = lastValue;
732	 set.index[lastValue] = toDeleteIndex + 1;
733	 }
734	 delete set.index[value];
735	 set.values.pop();
736	 return true;
737	 }
738	 else {
739	 return false;
740	 }
741	 }
742	 function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {
743	 return set.index[value] != 0;
744	 }
745	 function containsAddress(Bytes32Set storage set, address addrvalue) internal view returns (bool) {
746	 bytes32 value;
747	 assembly {
748	 value := addrvalue }
749	 return set.index[value] != 0;
750	 }
751	 function enumerate(Bytes32Set storage set, uint256 start, uint256 count) internal view returns (bytes32[] memory output) {
752	 uint256 end = start + count;
753	 require(end >= start, "addition overflow");
754	 end = set.values.length < end ? set.values.length : end;
755	 if (end == 0 || start >= end) {
756	 return output;
757	 }
758	 output = new bytes32[](end-start);
759	 for (uint256 i = start; i < end; i++) {
760	 output[i-start] = set.values[i];
761	 }
762	 return output;
763	 }
764	 function length(Bytes32Set storage set) internal view returns (uint256) {
765	 return set.values.length;
766	 }
767	 function get(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {
768	 return set.values[index];
769	 }
770	 function getAddress(Bytes32Set storage set, uint256 index) internal view returns (address) {
771	 bytes32 value = set.values[index];
772	 address addrvalue;
773	 assembly {
774	 addrvalue := value }
775	 return addrvalue;
776	 }
777	 }
778	 pragma solidity >=0.5.0 <=0.8.4;
779	 interface IStakingV2 {
780	 struct ProposalState {
781	 uint256 proposalTime;
782	 uint256 iOOKIWeight;
783	 uint256 lpOOKIBalance;
784	 uint256 lpTotalSupply;
785	 }
786	 struct AltRewardsUserInfo {
787	 uint256 rewardsPerShare;
788	 uint256 pendingRewards;
789	 }
790	 function getCurrentFeeTokens() external view returns (address[] memory);
791	 function maxUniswapDisagreement() external view returns (uint256);
792	 function fundsWallet() external view returns (address);
793	 function callerRewardDivisor() external view returns (uint256);
794	 function maxCurveDisagreement() external view returns (uint256);
795	 function rewardPercent() external view returns (uint256);
796	 function addRewards(uint256 newOOKI, uint256 newStableCoin) external;
797	 function stake(address[] calldata tokens, uint256[] calldata values) external;
798	 function unstake(address[] calldata tokens, uint256[] calldata values) external;
799	 function earned(address account) external view returns ( uint256 bzrxRewardsEarned, uint256 stableCoinRewardsEarned, uint256 bzrxRewardsVesting, uint256 stableCoinRewardsVesting, uint256 sushiRewardsEarned );
800	 function pendingCrvRewards(address account) external view returns ( uint256 bzrxRewardsEarned, uint256 stableCoinRewardsEarned, uint256 bzrxRewardsVesting, uint256 stableCoinRewardsVesting, uint256 sushiRewardsEarned );
801	 function getVariableWeights() external view returns ( uint256 vBZRXWeight, uint256 iOOKIWeight, uint256 LPTokenWeight );
802	 function balanceOfByAsset(address token, address account) external view returns (uint256 balance);
803	 function balanceOfByAssets(address account) external view returns ( uint256 bzrxBalance, uint256 iOOKIBalance, uint256 vBZRXBalance, uint256 LPTokenBalance );
804	 function balanceOfStored(address account) external view returns (uint256 vestedBalance, uint256 vestingBalance);
805	 function totalSupplyStored() external view returns (uint256 supply);
806	 function vestedBalanceForAmount( uint256 tokenBalance, uint256 lastUpdate, uint256 vestingEndTime ) external view returns (uint256 vested);
807	 function votingBalanceOf(address account, uint256 proposalId) external view returns (uint256 totalVotes);
808	 function votingBalanceOfNow(address account) external view returns (uint256 totalVotes);
809	 function votingFromStakedBalanceOf(address account) external view returns (uint256 totalVotes);
810	 function _setProposalVals(address account, uint256 proposalId) external returns (uint256);
811	 function exit() external;
812	 function addAltRewards(address token, uint256 amount) external;
813	 function governor() external view returns (address);
814	 function owner() external view returns (address);
815	 function transferOwnership(address newOwner) external;
816	 function claim(bool restake) external;
817	 function claimAltRewards() external;
818	 function _totalSupplyPerToken(address) external view returns(uint256);
819	 function _isPaused(bytes4 sig) external view returns (bool isPaused);
820	 function toggleFunctionPause(bytes4 sig) external;
821	 function toggleFunctionUnPause(bytes4 sig) external;
822	 function changeGuardian(address newGuardian) external;
823	 function getGuardian() external view returns (address guardian);
824	 function exitSushi() external;
825	 function setGovernor(address _governor) external;
826	 function setApprovals( address _token, address _spender, uint256 _value ) external;
827	 function setVoteDelegator(address stakingGovernance) external;
828	 function updateSettings(address settingsTarget, bytes calldata callData) external;
829	 function claimSushi() external returns (uint256 sushiRewardsEarned);
830	 function totalSupplyByAsset(address token) external view returns (uint256);
831	 }
832	 pragma solidity 0.5.17;
833	 interface IUniswapV2Router {
834	 function swapExactTokensForTokens( uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external returns (uint256[] memory amounts);
835	 function swapTokensForExactTokens( uint256 amountOut, uint256 amountInMax, address[] calldata path, address to, uint256 deadline) external returns (uint256[] memory amounts);
836	 function getAmountsIn( uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);
837	 function getAmountsOut( uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);
838	 }
839	 pragma solidity >=0.5.0 <=0.8.4;
840	 interface ICurve3Pool {
841	 function add_liquidity( uint256[3] calldata amounts, uint256 min_mint_amount) external;
842	 function get_virtual_price() external view returns (uint256);
843	 }
844	 pragma solidity >=0.5.0 <=0.8.4;
845	 interface ICurveMinter {
846	 function mint( address _addr ) external;
847	 }
848	 pragma solidity >=0.5.0 <=0.8.4;
849	 interface ICurve3PoolGauge {
850	 function balanceOf( address _addr ) external view returns (uint256);
851	 function working_balances(address) external view returns (uint256);
852	 function claimable_tokens(address) external returns (uint256);
853	 function deposit( uint256 _amount ) external;
854	 function deposit( uint256 _amount, address _addr ) external;
855	 function withdraw( uint256 _amount ) external;
856	 function set_approve_deposit( address _addr, bool can_deposit ) external;
857	 }
858	 pragma solidity >=0.5.0 <=0.8.4;
859	 interface IBZx {
860	 function replaceContract(address target) external;
861	 function setTargets( string[] calldata sigsArr, address[] calldata targetsArr ) external;
862	 function getTarget(string calldata sig) external view returns (address);
863	 function setPriceFeedContract(address newContract) external;
864	 function setSwapsImplContract(address newContract) external;
865	 function setLoanPool(address[] calldata pools, address[] calldata assets) external;
866	 function setSupportedTokens( address[] calldata addrs, bool[] calldata toggles, bool withApprovals ) external;
867	 function setLendingFeePercent(uint256 newValue) external;
868	 function setTradingFeePercent(uint256 newValue) external;
869	 function setBorrowingFeePercent(uint256 newValue) external;
870	 function setAffiliateFeePercent(uint256 newValue) external;
871	 function setLiquidationIncentivePercent( address[] calldata loanTokens, address[] calldata collateralTokens, uint256[] calldata amounts ) external;
872	 function setMaxDisagreement(uint256 newAmount) external;
873	 function setSourceBufferPercent(uint256 newAmount) external;
874	 function setMaxSwapSize(uint256 newAmount) external;
875	 function setFeesController(address newController) external;
876	 function withdrawFees( address[] calldata tokens, address receiver, FeeClaimType feeType ) external returns (uint256[] memory amounts);
877	 function withdrawProtocolToken(address receiver, uint256 amount) external returns (address rewardToken, uint256 withdrawAmount);
878	 function depositProtocolToken(uint256 amount) external;
879	 function grantRewards(address[] calldata users, uint256[] calldata amounts) external returns (uint256 totalAmount);
880	 function queryFees(address[] calldata tokens, FeeClaimType feeType) external view returns (uint256[] memory amountsHeld, uint256[] memory amountsPaid);
881	 function priceFeeds() external view returns (address);
882	 function swapsImpl() external view returns (address);
883	 function logicTargets(bytes4) external view returns (address);
884	 function loans(bytes32) external view returns (Loan memory);
885	 function loanParams(bytes32) external view returns (LoanParams memory);
886	 function delegatedManagers(bytes32, address) external view returns (bool);
887	 function lenderInterest(address, address) external view returns (LenderInterest memory);
888	 function loanInterest(bytes32) external view returns (LoanInterest memory);
889	 function feesController() external view returns (address);
890	 function lendingFeePercent() external view returns (uint256);
891	 function lendingFeeTokensHeld(address) external view returns (uint256);
892	 function lendingFeeTokensPaid(address) external view returns (uint256);
893	 function borrowingFeePercent() external view returns (uint256);
894	 function borrowingFeeTokensHeld(address) external view returns (uint256);
895	 function borrowingFeeTokensPaid(address) external view returns (uint256);
896	 function protocolTokenHeld() external view returns (uint256);
897	 function protocolTokenPaid() external view returns (uint256);
898	 function affiliateFeePercent() external view returns (uint256);
899	 function liquidationIncentivePercent(address, address) external view returns (uint256);
900	 function loanPoolToUnderlying(address) external view returns (address);
901	 function underlyingToLoanPool(address) external view returns (address);
902	 function supportedTokens(address) external view returns (bool);
903	 function maxDisagreement() external view returns (uint256);
904	 function sourceBufferPercent() external view returns (uint256);
905	 function maxSwapSize() external view returns (uint256);
906	 function getLoanPoolsList(uint256 start, uint256 count) external view returns (address[] memory loanPoolsList);
907	 function isLoanPool(address loanPool) external view returns (bool);
908	 function setupLoanParams(LoanParams[] calldata loanParamsList) external returns (bytes32[] memory loanParamsIdList);
909	 function disableLoanParams(bytes32[] calldata loanParamsIdList) external;
910	 function getLoanParams(bytes32[] calldata loanParamsIdList) external view returns (LoanParams[] memory loanParamsList);
911	 function getLoanParamsList( address owner, uint256 start, uint256 count ) external view returns (bytes32[] memory loanParamsList);
912	 function getTotalPrincipal(address lender, address loanToken) external view returns (uint256);
913	 function borrowOrTradeFromPool( bytes32 loanParamsId, bytes32 loanId, bool isTorqueLoan, uint256 initialMargin, address[4] calldata sentAddresses, uint256[5] calldata sentValues, bytes calldata loanDataBytes ) external payable returns (LoanOpenData memory);
914	 function setDelegatedManager( bytes32 loanId, address delegated, bool toggle ) external;
915	 function getEstimatedMarginExposure( address loanToken, address collateralToken, uint256 loanTokenSent, uint256 collateralTokenSent, uint256 interestRate, uint256 newPrincipal ) external view returns (uint256);
916	 function getRequiredCollateral( address loanToken, address collateralToken, uint256 newPrincipal, uint256 marginAmount, bool isTorqueLoan ) external view returns (uint256 collateralAmountRequired);
917	 function getRequiredCollateralByParams( bytes32 loanParamsId, uint256 newPrincipal ) external view returns (uint256 collateralAmountRequired);
918	 function getBorrowAmount( address loanToken, address collateralToken, uint256 collateralTokenAmount, uint256 marginAmount, bool isTorqueLoan ) external view returns (uint256 borrowAmount);
919	 function getBorrowAmountByParams( bytes32 loanParamsId, uint256 collateralTokenAmount ) external view returns (uint256 borrowAmount);
920	 function liquidate( bytes32 loanId, address receiver, uint256 closeAmount ) external payable returns ( uint256 loanCloseAmount, uint256 seizedAmount, address seizedToken );
921	 function rollover(bytes32 loanId, bytes calldata loanDataBytes) external returns (address rebateToken, uint256 gasRebate);
922	 function closeWithDeposit( bytes32 loanId, address receiver, uint256 depositAmount ) external payable returns ( uint256 loanCloseAmount, uint256 withdrawAmount, address withdrawToken );
923	 function closeWithSwap( bytes32 loanId, address receiver, uint256 swapAmount, bool returnTokenIsCollateral, bytes calldata loanDataBytes ) external returns ( uint256 loanCloseAmount, uint256 withdrawAmount, address withdrawToken );
924	 function liquidateWithGasToken( bytes32 loanId, address receiver, address gasTokenUser, uint256 closeAmount ) external payable returns ( uint256 loanCloseAmount, uint256 seizedAmount, address seizedToken );
925	 function rolloverWithGasToken( bytes32 loanId, address gasTokenUser, bytes calldata ) external returns (address rebateToken, uint256 gasRebate);
926	 function closeWithDepositWithGasToken( bytes32 loanId, address receiver, address gasTokenUser, uint256 depositAmount ) external payable returns ( uint256 loanCloseAmount, uint256 withdrawAmount, address withdrawToken );
927	 function closeWithSwapWithGasToken( bytes32 loanId, address receiver, address gasTokenUser, uint256 swapAmount, bool returnTokenIsCollateral, bytes calldata loanDataBytes ) external returns ( uint256 loanCloseAmount, uint256 withdrawAmount, address withdrawToken );
928	 function depositCollateral(bytes32 loanId, uint256 depositAmount) external payable;
929	 function withdrawCollateral( bytes32 loanId, address receiver, uint256 withdrawAmount ) external returns (uint256 actualWithdrawAmount);
930	 function withdrawAccruedInterest(address loanToken) external;
931	 function extendLoanDuration( bytes32 loanId, uint256 depositAmount, bool useCollateral, bytes calldata ) external payable returns (uint256 secondsExtended);
932	 function reduceLoanDuration( bytes32 loanId, address receiver, uint256 withdrawAmount ) external returns (uint256 secondsReduced);
933	 function setDepositAmount( bytes32 loanId, uint256 depositValueAsLoanToken, uint256 depositValueAsCollateralToken ) external;
934	 function claimRewards(address receiver) external returns (uint256 claimAmount);
935	 function transferLoan(bytes32 loanId, address newOwner) external;
936	 function rewardsBalanceOf(address user) external view returns (uint256 rewardsBalance);
937	 function getLenderInterestData(address lender, address loanToken) external view returns ( uint256 interestPaid, uint256 interestPaidDate, uint256 interestOwedPerDay, uint256 interestUnPaid, uint256 interestFeePercent, uint256 principalTotal );
938	 function getLoanInterestData(bytes32 loanId) external view returns ( address loanToken, uint256 interestOwedPerDay, uint256 interestDepositTotal, uint256 interestDepositRemaining );
939	 function getUserLoans( address user, uint256 start, uint256 count, LoanType loanType, bool isLender, bool unsafeOnly ) external view returns (LoanReturnData[] memory loansData);
940	 function getUserLoansCount(address user, bool isLender) external view returns (uint256);
941	 function getLoan(bytes32 loanId) external view returns (LoanReturnData memory loanData);
942	 function getActiveLoans( uint256 start, uint256 count, bool unsafeOnly ) external view returns (LoanReturnData[] memory loansData);
943	 function getActiveLoansAdvanced( uint256 start, uint256 count, bool unsafeOnly, bool isLiquidatable ) external view returns (LoanReturnData[] memory loansData);
944	 function getActiveLoansCount() external view returns (uint256);
945	 function swapExternal( address sourceToken, address destToken, address receiver, address returnToSender, uint256 sourceTokenAmount, uint256 requiredDestTokenAmount, bytes calldata swapData ) external payable returns ( uint256 destTokenAmountReceived, uint256 sourceTokenAmountUsed );
946	 function swapExternalWithGasToken( address sourceToken, address destToken, address receiver, address returnToSender, address gasTokenUser, uint256 sourceTokenAmount, uint256 requiredDestTokenAmount, bytes calldata swapData ) external payable returns ( uint256 destTokenAmountReceived, uint256 sourceTokenAmountUsed );
947	 function getSwapExpectedReturn( address sourceToken, address destToken, uint256 sourceTokenAmount ) external view returns (uint256);
948	 function owner() external view returns (address);
949	 function transferOwnership(address newOwner) external;
950	 function _isPaused(bytes4 sig) external view returns (bool isPaused);
951	 function toggleFunctionPause(bytes4 sig) external;
952	 function toggleFunctionUnPause(bytes4 sig) external;
953	 function changeGuardian(address newGuardian) external;
954	 function getGuardian() external view returns (address guardian);
955	 function cleanupLoans( address loanToken, bytes32[] calldata loanIds) external payable returns (uint256 totalPrincipalIn);
956	 struct LoanParams {
957	 bytes32 id;
958	 bool active;
959	 address owner;
960	 address loanToken;
961	 address collateralToken;
962	 uint256 minInitialMargin;
963	 uint256 maintenanceMargin;
964	 uint256 maxLoanTerm;
965	 }
966	 struct LoanOpenData {
967	 bytes32 loanId;
968	 uint256 principal;
969	 uint256 collateral;
970	 }
971	 enum LoanType {
972	 All, Margin, NonMargin }
973	 struct LoanReturnData {
974	 bytes32 loanId;
975	 uint96 endTimestamp;
976	 address loanToken;
977	 address collateralToken;
978	 uint256 principal;
979	 uint256 collateral;
980	 uint256 interestOwedPerDay;
981	 uint256 interestDepositRemaining;
982	 uint256 startRate;
983	 uint256 startMargin;
984	 uint256 maintenanceMargin;
985	 uint256 currentMargin;
986	 uint256 maxLoanTerm;
987	 uint256 maxLiquidatable;
988	 uint256 maxSeizable;
989	 uint256 depositValueAsLoanToken;
990	 uint256 depositValueAsCollateralToken;
991	 }
992	 enum FeeClaimType {
993	 All, Lending, Trading, Borrowing }
994	 struct Loan {
995	 bytes32 id;
996	 bytes32 loanParamsId;
997	 bytes32 pendingTradesId;
998	 uint256 principal;
999	 uint256 collateral;
1000	 uint256 startTimestamp;
1001	 uint256 endTimestamp;
1002	 uint256 startMargin;
1003	 uint256 startRate;
1004	 address borrower;
1005	 address lender;
1006	 bool active;
1007	 }
1008	 struct LenderInterest {
1009	 uint256 principalTotal;
1010	 uint256 owedPerDay;
1011	 uint256 owedTotal;
1012	 uint256 paidTotal;
1013	 uint256 updatedTimestamp;
1014	 }
1015	 struct LoanInterest {
1016	 uint256 owedPerDay;
1017	 uint256 depositTotal;
1018	 uint256 updatedTimestamp;
1019	 }
1020	 }
1021	 pragma solidity >=0.5.0 <=0.8.4;
1022	 interface IBZRXv2Converter {
1023	 function convert(address receiver, uint256 _tokenAmount) external;
1024	 }
1025	 pragma solidity 0.5.17;
1026	 contract StakingPausableGuardian is StakingStateV2, PausableGuardian {
1027	 function initialize( address target) external onlyOwner {
1028	 _setTarget(this._isPaused.selector, target);
1029	 _setTarget(this.toggleFunctionPause.selector, target);
1030	 _setTarget(this.toggleFunctionUnPause.selector, target);
1031	 _setTarget(this.changeGuardian.selector, target);
1032	 _setTarget(this.getGuardian.selector, target);
1033	 }
1034	 }
1035	 pragma solidity >=0.5.0 <=0.8.4;
1036	 interface IMasterChefSushi {
1037	 struct UserInfo {
1038	 uint256 amount;
1039	 uint256 rewardDebt;
1040	 }
1041	 function deposit(uint256 _pid, uint256 _amount) external;
1042	 function withdraw(uint256 _pid, uint256 _amount) external;
1043	 function userInfo(uint256, address) external view returns (UserInfo memory);
1044	 function pendingSushi(uint256 _pid, address _user) external view returns (uint256);
1045	 function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) external;
1046	 function updatePool(uint256 _pid) external;
1047	 function owner() external view returns (address);
1048	 }
1049	 pragma solidity 0.5.17;
1050	 contract VoteDelegator is VoteDelegatorState, VoteDelegatorConstants, PausableGuardian {
1051	 using SafeMath for uint256;
1052	 using SafeERC20 for IERC20;
1053	 function delegates(address delegator) external view returns (address) {
1054	 return _delegates[delegator];
1055	 }
1056	 function delegate(address delegatee) pausable external {
1057	 if(delegatee == msg.sender){
1058	 delegatee = ZERO_ADDRESS;
1059	 }
1060	 return _delegate(msg.sender, delegatee);
1061	 }
1062	 function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) pausable external {
1063	 if(delegatee == msg.sender){
1064	 delegatee = ZERO_ADDRESS;
1065	 }
1066	 bytes32 domainSeparator = keccak256( abi.encode( DOMAIN_TYPEHASH, keccak256(bytes("STAKING")), getChainId(), address(this) ) );
1067	 bytes32 structHash = keccak256( abi.encode( DELEGATION_TYPEHASH, delegatee, nonce, expiry ) );
1068	 bytes32 digest = keccak256( abi.encodePacked( "\x19\x01", domainSeparator, structHash ) );
1069	 address signatory = ecrecover(digest, v, r, s);
1070	 require(signatory != ZERO_ADDRESS, "Staking::delegateBySig: invalid signature");
1071	 require(nonce == nonces[signatory]++, "Staking::delegateBySig: invalid nonce");
1072	 require(now <= expiry, "Staking::delegateBySig: signature expired");
1073	 return _delegate(signatory, delegatee);
1074	 }
1075	 function getCurrentVotes(address account) external view returns (uint256) {
1076	 uint32 nCheckpoints = numCheckpoints[account];
1077	 return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;
1078	 }
1079	 function getPriorVotes(address account, uint blockNumber) public view returns (uint256) {
1080	 require(blockNumber < block.number, "Staking::getPriorVotes: not yet determined");
1081	 uint32 nCheckpoints = numCheckpoints[account];
1082	 if (nCheckpoints == 0) {
1083	 return 0;
1084	 }
1085	 if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {
1086	 return checkpoints[account][nCheckpoints - 1].votes;
1087	 }
1088	 if (checkpoints[account][0].fromBlock > blockNumber) {
1089	 return 0;
1090	 }
1091	 uint32 lower = 0;
1092	 uint32 upper = nCheckpoints - 1;
1093	 while (upper > lower) {
1094	 uint32 center = upper - (upper - lower) / 2;
1095	 Checkpoint memory cp = checkpoints[account][center];
1096	 if (cp.fromBlock == blockNumber) {
1097	 return cp.votes;
1098	 }
1099	 else if (cp.fromBlock < blockNumber) {
1100	 lower = center;
1101	 }
1102	 else {
1103	 upper = center - 1;
1104	 }
1105	 }
1106	 return checkpoints[account][lower].votes;
1107	 }
1108	 function _delegate(address delegator, address delegatee) internal {
1109	 if(delegatee == delegator || delegator == ZERO_ADDRESS) return;
1110	 address oldDelegate = _delegates[delegator];
1111	 uint256 delegatorBalance = staking.votingFromStakedBalanceOf(delegator);
1112	 _delegates[delegator] = delegatee;
1113	 if(delegatee == ZERO_ADDRESS && oldDelegate != ZERO_ADDRESS){
1114	 if(totalDelegators[oldDelegate] > 0) totalDelegators[oldDelegate]--;
1115	 if(totalDelegators[oldDelegate] == 0 && oldDelegate != ZERO_ADDRESS){
1116	 uint32 dstRepNum = numCheckpoints[oldDelegate];
1117	 uint256 dstRepOld = dstRepNum > 0 ? checkpoints[oldDelegate][dstRepNum - 1].votes : 0;
1118	 uint256 dstRepNew = 0;
1119	 _writeCheckpoint(oldDelegate, dstRepNum, dstRepOld, dstRepNew);
1120	 return;
1121	 }
1122	 }
1123	 else if(delegatee != ZERO_ADDRESS){
1124	 totalDelegators[delegatee]++;
1125	 if(totalDelegators[oldDelegate] > 0) totalDelegators[oldDelegate]--;
1126	 }
1127	 emit DelegateChanged(delegator, oldDelegate, delegatee);
1128	 _moveDelegates(oldDelegate, delegatee, delegatorBalance);
1129	 }
1130	 function moveDelegates( address srcRep, address dstRep, uint256 amount ) public {
1131	 require(msg.sender == address(staking), "unauthorized");
1132	 _moveDelegates(srcRep, dstRep, amount);
1133	 }
1134	 function moveDelegatesByVotingBalance( uint256 votingBalanceBefore, uint256 votingBalanceAfter, address account ) public {
1135	 require(msg.sender == address(staking), "unauthorized");
1136	 address currentDelegate = _delegates[account];
1137	 if(currentDelegate == ZERO_ADDRESS) return;
1138	 if(votingBalanceBefore > votingBalanceAfter){
1139	 _moveDelegates(currentDelegate, ZERO_ADDRESS, votingBalanceBefore.sub(votingBalanceAfter) );
1140	 }
1141	 else{
1142	 _moveDelegates(ZERO_ADDRESS, currentDelegate, votingBalanceAfter.sub(votingBalanceBefore) );
1143	 }
1144	 }
1145	 function _moveDelegates(address srcRep, address dstRep, uint256 amount) internal {
1146	 if (srcRep != dstRep && amount > 0) {
1147	 if (srcRep != ZERO_ADDRESS) {
1148	 uint32 srcRepNum = numCheckpoints[srcRep];
1149	 uint256 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;
1150	 uint256 srcRepNew = srcRepOld.sub((amount > srcRepOld)? srcRepOld : amount);
1151	 _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);
1152	 }
1153	 if (dstRep != ZERO_ADDRESS) {
1154	 uint32 dstRepNum = numCheckpoints[dstRep];
1155	 uint256 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;
1156	 uint256 dstRepNew = dstRepOld.add(amount);
1157	 _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);
1158	 }
1159	 }
1160	 }
1161	 function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint256 oldVotes, uint256 newVotes) internal {
1162	 uint32 blockNumber = safe32(block.number, "Staking::_writeCheckpoint: block number exceeds 32 bits");
1163	 if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {
1164	 checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;
1165	 }
1166	 else {
1167	 checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);
1168	 numCheckpoints[delegatee] = nCheckpoints + 1;
1169	 }
1170	 emit DelegateVotesChanged(delegatee, oldVotes, newVotes);
1171	 }
1172	 function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {
1173	 require(n < 2**32, errorMessage);
1174	 return uint32(n);
1175	 }
1176	 function getChainId() internal pure returns (uint) {
1177	 uint256 chainId;
1178	 assembly {
1179	 chainId := chainid() }
1180	 return chainId;
1181	 }
1182	 function setStaking(address _staking) public onlyOwner {
1183	 staking = IStakingV2(_staking);
1184	 }
1185	 }
1186	 pragma solidity ^0.5.16;
1187	 contract GovernorBravoDelegate is GovernorBravoDelegateStorageV1, GovernorBravoEvents {
1188	 string public constant name = "Ooki Governor Bravo";
1189	 uint public constant MIN_PROPOSAL_THRESHOLD = 0.5e18;
1190	 uint public constant MAX_PROPOSAL_THRESHOLD = 2e18;
1191	 uint public constant MIN_VOTING_PERIOD = 5760;
1192	 uint public constant MAX_VOTING_PERIOD = 80640;
1193	 uint public constant MIN_VOTING_DELAY = 1;
1194	 uint public constant MAX_VOTING_DELAY = 40320;
1195	 uint public constant MIN_QUORUM_PERCENTAGE = 2e18;
1196	 uint public constant MAX_QUORUM_PERCENTAGE = 6e18;
1197	 uint public constant proposalMaxOperations = 100;
1198	 bytes32 public constant DOMAIN_TYPEHASH = keccak256("EIP712Domain(string name,uint256 chainId,address verifyingContract)");
1199	 bytes32 public constant BALLOT_TYPEHASH = keccak256("Ballot(uint256 proposalId,uint8 support)");
1200	 function initialize(address timelock_, address staking_, uint votingPeriod_, uint votingDelay_, uint proposalThresholdPercentage_, uint quorumPercentage_) public {
1201	 require(address(timelock) == address(0), "GovernorBravo::initialize: can only initialize once");
1202	 require(msg.sender == admin, "GovernorBravo::initialize: admin only");
1203	 require(timelock_ != address(0), "GovernorBravo::initialize: invalid timelock address");
1204	 require(staking_ != address(0), "GovernorBravo::initialize: invalid STAKING address");
1205	 require(votingPeriod_ >= MIN_VOTING_PERIOD && votingPeriod_ <= MAX_VOTING_PERIOD, "GovernorBravo::initialize: invalid voting period");
1206	 require(votingDelay_ >= MIN_VOTING_DELAY && votingDelay_ <= MAX_VOTING_DELAY, "GovernorBravo::initialize: invalid voting delay");
1207	 require(proposalThresholdPercentage_ >= MIN_PROPOSAL_THRESHOLD && proposalThresholdPercentage_ <= MAX_PROPOSAL_THRESHOLD, "GovernorBravo::initialize: invalid proposal threshold");
1208	 require(quorumPercentage_ >= MIN_QUORUM_PERCENTAGE && quorumPercentage_ <= MAX_QUORUM_PERCENTAGE, "GovernorBravo::initialize: invalid quorum percentage");
1209	 timelock = TimelockInterface(timelock_);
1210	 staking = StakingInterface(staking_);
1211	 votingPeriod = votingPeriod_;
1212	 votingDelay = votingDelay_;
1213	 proposalThresholdPercentage = proposalThresholdPercentage_;
1214	 quorumPercentage = quorumPercentage_;
1215	 guardian = msg.sender;
1216	 }
1217	 function propose(address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description) public returns (uint) {
1218	 require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, "GovernorBravo::propose: proposal function information arity mismatch");
1219	 require(targets.length != 0, "GovernorBravo::propose: must provide actions");
1220	 require(targets.length <= proposalMaxOperations, "GovernorBravo::propose: too many actions");
1221	 uint latestProposalId = latestProposalIds[msg.sender];
1222	 if (latestProposalId != 0) {
1223	 ProposalState proposersLatestProposalState = state(latestProposalId);
1224	 require(proposersLatestProposalState != ProposalState.Active, "GovernorBravo::propose: one live proposal per proposer, found an already active proposal");
1225	 require(proposersLatestProposalState != ProposalState.Pending, "GovernorBravo::propose: one live proposal per proposer, found an already pending proposal");
1226	 }
1227	 uint proposalId = proposalCount + 1;
1228	 require(staking._setProposalVals(msg.sender, proposalId) > proposalThreshold(), "GovernorBravo::propose: proposer votes below proposal threshold");
1229	 proposalCount = proposalId;
1230	 uint startBlock = add256(block.number, votingDelay);
1231	 uint endBlock = add256(startBlock, votingPeriod);
1232	 Proposal memory newProposal = Proposal({
1233	 id: proposalId, proposer: msg.sender, eta: 0, targets: targets, values: values, signatures: signatures, calldatas: calldatas, startBlock: startBlock, endBlock: endBlock, forVotes: 0, againstVotes: 0, abstainVotes: 0, canceled: false, executed: false }
1234	 );
1235	 proposals[proposalId] = newProposal;
1236	 latestProposalIds[msg.sender] = proposalId;
1237	 quorumVotesForProposal[proposalId] = quorumVotes();
1238	 emit ProposalCreated(proposalId, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description);
1239	 return proposalId;
1240	 }
1241	 function queue(uint proposalId) external {
1242	 require(state(proposalId) == ProposalState.Succeeded, "GovernorBravo::queue: proposal can only be queued if it is succeeded");
1243	 Proposal storage proposal = proposals[proposalId];
1244	 uint eta = add256(block.timestamp, timelock.delay());
1245	 for (uint i = 0; i < proposal.targets.length; i++) {
1246	 queueOrRevertInternal(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);
1247	 }
1248	 proposal.eta = eta;
1249	 emit ProposalQueued(proposalId, eta);
1250	 }
1251	 function queueOrRevertInternal(address target, uint value, string memory signature, bytes memory data, uint eta) internal {
1252	 require(!timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))), "GovernorBravo::queueOrRevertInternal: identical proposal action already queued at eta");
1253	 timelock.queueTransaction(target, value, signature, data, eta);
1254	 }
1255	 function execute(uint proposalId) external payable {
1256	 require(state(proposalId) == ProposalState.Queued, "GovernorBravo::execute: proposal can only be executed if it is queued");
1257	 Proposal storage proposal = proposals[proposalId];
1258	 proposal.executed = true;
1259	 for (uint i = 0; i < proposal.targets.length; i++) {
1260	 timelock.executeTransaction.value(proposal.values[i])(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);
1261	 }
1262	 emit ProposalExecuted(proposalId);
1263	 }
1264	 function cancel(uint proposalId) external {
1265	 require(state(proposalId) != ProposalState.Executed, "GovernorBravo::cancel: cannot cancel executed proposal");
1266	 Proposal storage proposal = proposals[proposalId];
1267	 require(msg.sender == proposal.proposer || staking.votingBalanceOfNow(proposal.proposer) < proposalThreshold() || msg.sender == guardian, "GovernorBravo::cancel: proposer above threshold");
1268	 proposal.canceled = true;
1269	 for (uint i = 0; i < proposal.targets.length; i++) {
1270	 timelock.cancelTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);
1271	 }
1272	 emit ProposalCanceled(proposalId);
1273	 }
1274	 function quorumVotes() public view returns (uint256) {
1275	 uint256 totalSupply = IERC20(0x0De05F6447ab4D22c8827449EE4bA2D5C288379B) .totalSupply();
1276	 return totalSupply * quorumPercentage / 1e20;
1277	 }
1278	 function proposalThreshold() public view returns (uint256) {
1279	 uint256 totalSupply = IERC20(0x0De05F6447ab4D22c8827449EE4bA2D5C288379B) .totalSupply();
1280	 return totalSupply * proposalThresholdPercentage / 1e20;
1281	 }
1282	 function getActions(uint proposalId) external view returns (address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas) {
1283	 Proposal storage p = proposals[proposalId];
1284	 return (p.targets, p.values, p.signatures, p.calldatas);
1285	 }
1286	 function getReceipt(uint proposalId, address voter) external view returns (Receipt memory) {
1287	 return proposals[proposalId].receipts[voter];
1288	 }
1289	 function state(uint proposalId) public view returns (ProposalState) {
1290	 require(proposalCount >= proposalId && proposalId > initialProposalId, "GovernorBravo::state: invalid proposal id");
1291	 Proposal storage proposal = proposals[proposalId];
1292	 if (proposal.canceled) {
1293	 return ProposalState.Canceled;
1294	 }
1295	 else if (block.number <= proposal.startBlock) {
1296	 return ProposalState.Pending;
1297	 }
1298	 else if (block.number <= proposal.endBlock) {
1299	 return ProposalState.Active;
1300	 }
1301	 else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotesForProposal[proposalId]) {
1302	 return ProposalState.Defeated;
1303	 }
1304	 else if (proposal.eta == 0) {
1305	 return ProposalState.Succeeded;
1306	 }
1307	 else if (proposal.executed) {
1308	 return ProposalState.Executed;
1309	 }
1310	 else if (block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())) {
1311	 return ProposalState.Expired;
1312	 }
1313	 else {
1314	 return ProposalState.Queued;
1315	 }
1316	 }
1317	 function castVote(uint proposalId, uint8 support) external {
1318	 emit VoteCast(msg.sender, proposalId, support, castVoteInternal(msg.sender, proposalId, support), "");
1319	 }
1320	 function castVoteWithReason(uint proposalId, uint8 support, string calldata reason) external {
1321	 emit VoteCast(msg.sender, proposalId, support, castVoteInternal(msg.sender, proposalId, support), reason);
1322	 }
1323	 function castVoteBySig(uint proposalId, uint8 support, uint8 v, bytes32 r, bytes32 s) public {
1324	 bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainIdInternal(), address(this)));
1325	 bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));
1326	 bytes32 digest = keccak256(abi.encodePacked("\x19\x01", domainSeparator, structHash));
1327	 address signatory = ecrecover(digest, v, r, s);
1328	 require(signatory != address(0), "GovernorBravo::castVoteBySig: invalid signature");
1329	 emit VoteCast(signatory, proposalId, support, castVoteInternal(signatory, proposalId, support), "");
1330	 }
1331	 function castVotes(uint[] calldata proposalIds, uint8[] calldata supportVals) external {
1332	 require(proposalIds.length == supportVals.length, "count mismatch");
1333	 for (uint256 i = 0; i < proposalIds.length; i++) {
1334	 emit VoteCast(msg.sender, proposalIds[i], supportVals[i], castVoteInternal(msg.sender, proposalIds[i], supportVals[i]), "");
1335	 }
1336	 }
1337	 function castVotesWithReason(uint[] calldata proposalIds, uint8[] calldata supportVals, string[] calldata reasons) external {
1338	 require(proposalIds.length == supportVals.length && proposalIds.length == reasons.length, "count mismatch");
1339	 for (uint256 i = 0; i < proposalIds.length; i++) {
1340	 emit VoteCast(msg.sender, proposalIds[i], supportVals[i], castVoteInternal(msg.sender, proposalIds[i], supportVals[i]), reasons[i]);
1341	 }
1342	 }
1343	 function castVotesBySig(uint[] calldata proposalIds, uint8[] calldata supportVals, uint8[] calldata vs, bytes32[] calldata rs, bytes32[] calldata ss) external {
1344	 require(proposalIds.length == supportVals.length && proposalIds.length == vs.length && proposalIds.length == rs.length && proposalIds.length == ss.length, "count mismatch");
1345	 for (uint256 i = 0; i < proposalIds.length; i++) {
1346	 castVoteBySig(proposalIds[i], supportVals[i], vs[i], rs[i], ss[i]);
1347	 }
1348	 }
1349	 function castVoteInternal(address voter, uint proposalId, uint8 support) internal returns (uint96) {
1350	 require(state(proposalId) == ProposalState.Active, "GovernorBravo::castVoteInternal: voting is closed");
1351	 require(support <= 2, "GovernorBravo::castVoteInternal: invalid vote type");
1352	 Proposal storage proposal = proposals[proposalId];
1353	 Receipt storage receipt = proposal.receipts[voter];
1354	 require(receipt.hasVoted == false, "GovernorBravo::castVoteInternal: voter already voted");
1355	 uint96 votes = uint96(staking.votingBalanceOf(voter, proposalId));
1356	 if (support == 0) {
1357	 proposal.againstVotes = add256(proposal.againstVotes, votes);
1358	 }
1359	 else if (support == 1) {
1360	 proposal.forVotes = add256(proposal.forVotes, votes);
1361	 }
1362	 else if (support == 2) {
1363	 proposal.abstainVotes = add256(proposal.abstainVotes, votes);
1364	 }
1365	 receipt.hasVoted = true;
1366	 receipt.support = support;
1367	 receipt.votes = votes;
1368	 return votes;
1369	 }
1370	 function __setVotingDelay(uint newVotingDelay) external {
1371	 require(msg.sender == admin, "GovernorBravo::__setVotingDelay: admin only");
1372	 require(newVotingDelay >= MIN_VOTING_DELAY && newVotingDelay <= MAX_VOTING_DELAY, "GovernorBravo::__setVotingDelay: invalid voting delay");
1373	 uint oldVotingDelay = votingDelay;
1374	 votingDelay = newVotingDelay;
1375	 emit VotingDelaySet(oldVotingDelay, votingDelay);
1376	 }
1377	 function __setVotingPeriod(uint newVotingPeriod) external {
1378	 require(msg.sender == admin, "GovernorBravo::__setVotingPeriod: admin only");
1379	 require(newVotingPeriod >= MIN_VOTING_PERIOD && newVotingPeriod <= MAX_VOTING_PERIOD, "GovernorBravo::__setVotingPeriod: invalid voting period");
1380	 uint oldVotingPeriod = votingPeriod;
1381	 votingPeriod = newVotingPeriod;
1382	 emit VotingPeriodSet(oldVotingPeriod, votingPeriod);
1383	 }
1384	 function __setQuorumPercentage(uint newQuorumPercentage) external {
1385	 require(msg.sender == admin, "GovernorBravo::__setQuorumPercentage: admin only");
1386	 require(newQuorumPercentage >= MIN_QUORUM_PERCENTAGE && newQuorumPercentage <= MAX_QUORUM_PERCENTAGE, "GovernorBravo::__setQuorumPercentage: invalid quorum percentage");
1387	 uint oldQuorumPercentage = quorumPercentage;
1388	 quorumPercentage = newQuorumPercentage;
1389	 emit QuorumPercentageSet(oldQuorumPercentage, newQuorumPercentage);
1390	 }
1391	 function __setStaking(address newStaking) external {
1392	 require(msg.sender == admin, "GovernorBravo::__setStaking: admin only");
1393	 require(newStaking != address(0) , "GovernorBravo::__setStaking: invalid address");
1394	 address oldStaking = address(staking);
1395	 staking = StakingInterface(newStaking);
1396	 emit StakingAddressSet(oldStaking, newStaking);
1397	 }
1398	 function __setProposalThresholdPercentage(uint newProposalThresholdPercentage) external {
1399	 require(msg.sender == admin, "GovernorBravo::__setProposalThreshold: admin only");
1400	 require(newProposalThresholdPercentage >= MIN_PROPOSAL_THRESHOLD && newProposalThresholdPercentage <= MAX_PROPOSAL_THRESHOLD, "GovernorBravo::__setProposalThreshold: invalid proposal threshold");
1401	 uint oldProposalThresholdPercentage = proposalThresholdPercentage;
1402	 proposalThresholdPercentage = newProposalThresholdPercentage;
1403	 emit ProposalThresholdSet(oldProposalThresholdPercentage, proposalThresholdPercentage);
1404	 }
1405	 function __setPendingLocalAdmin(address newPendingAdmin) external {
1406	 require(msg.sender == admin, "GovernorBravo:__setPendingLocalAdmin: admin only");
1407	 address oldPendingAdmin = pendingAdmin;
1408	 pendingAdmin = newPendingAdmin;
1409	 emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);
1410	 }
1411	 function __acceptLocalAdmin() external {
1412	 require(msg.sender == pendingAdmin && msg.sender != address(0), "GovernorBravo:__acceptLocalAdmin: pending admin only");
1413	 address oldAdmin = admin;
1414	 address oldPendingAdmin = pendingAdmin;
1415	 admin = pendingAdmin;
1416	 pendingAdmin = address(0);
1417	 emit NewAdmin(oldAdmin, admin);
1418	 emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);
1419	 }
1420	 function __changeGuardian(address guardian_) public {
1421	 require(msg.sender == guardian, "GovernorBravo::__changeGuardian: sender must be gov guardian");
1422	 require(guardian_ != address(0), "GovernorBravo::__changeGuardian: not allowed");
1423	 guardian = guardian_;
1424	 }
1425	 function __acceptAdmin() public {
1426	 require(msg.sender == guardian, "GovernorBravo::__acceptAdmin: sender must be gov guardian");
1427	 timelock.acceptAdmin();
1428	 }
1429	 function __abdicate() public {
1430	 require(msg.sender == guardian, "GovernorBravo::__abdicate: sender must be gov guardian");
1431	 guardian = address(0);
1432	 }
1433	 function __queueSetTimelockPendingAdmin(address newPendingAdmin, uint eta) public {
1434	 require(msg.sender == guardian, "GovernorBravo::__queueSetTimelockPendingAdmin: sender must be gov guardian");
1435	 timelock.queueTransaction(address(timelock), 0, "setPendingAdmin(address)", abi.encode(newPendingAdmin), eta);
1436	 }
1437	 function __executeSetTimelockPendingAdmin(address newPendingAdmin, uint eta) public {
1438	 require(msg.sender == guardian, "GovernorBravo::__executeSetTimelockPendingAdmin: sender must be gov guardian");
1439	 timelock.executeTransaction(address(timelock), 0, "setPendingAdmin(address)", abi.encode(newPendingAdmin), eta);
1440	 }
1441	 function add256(uint256 a, uint256 b) internal pure returns (uint) {
1442	 uint c = a + b;
1443	 require(c >= a, "addition overflow");
1444	 return c;
1445	 }
1446	 function sub256(uint256 a, uint256 b) internal pure returns (uint) {
1447	 require(b <= a, "subtraction underflow");
1448	 return a - b;
1449	 }
1450	 function getChainIdInternal() internal pure returns (uint) {
1451	 uint chainId;
1452	 assembly {
1453	 chainId := chainid() }
1454	 return chainId;
1455	 }
1456	 }
1457	 interface TimelockInterface {
1458	 function delay() external view returns (uint);
1459	 function GRACE_PERIOD() external view returns (uint);
1460	 function acceptAdmin() external;
1461	 function queuedTransactions(bytes32 hash) external view returns (bool);
1462	 function queueTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external returns (bytes32);
1463	 function cancelTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external;
1464	 function executeTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external payable returns (bytes memory);
1465	 }
1466	 interface StakingInterface {
1467	 function votingBalanceOf( address account, uint proposalCount) external view returns (uint totalVotes);
1468	 function votingBalanceOfNow( address account) external view returns (uint totalVotes);
1469	 function _setProposalVals( address account, uint proposalCount) external returns (uint);
1470	 }
1471	 interface GovernorAlpha {
1472	 function proposalCount() external returns (uint);
1473	 }
1474	 pragma solidity >=0.5.0 <0.6.0;
1475	 contract IVestingToken is IERC20 {
1476	 function claim() external;
1477	 function vestedBalanceOf( address _owner) external view returns (uint256);
1478	 function claimedBalanceOf( address _owner) external view returns (uint256);
1479	 }
1480	 pragma solidity >=0.5.0 <0.8.0;
1481	 library MathUtil {
1482	 function divCeil(uint256 a, uint256 b) internal pure returns (uint256) {
1483	 return divCeil(a, b, "SafeMath: division by zero");
1484	 }
1485	 function divCeil(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
1486	 require(b != 0, errorMessage);
1487	 if (a == 0) {
1488	 return 0;
1489	 }
1490	 uint256 c = ((a - 1) / b) + 1;
1491	 return c;
1492	 }
1493	 function min256(uint256 _a, uint256 _b) internal pure returns (uint256) {
1494	 return _a < _b ? _a : _b;
1495	 }
1496	 }
