row number 
1	          pragma solidity ^0.8.0;
2	 interface IERC165Upgradeable {
3	 function supportsInterface(bytes4 interfaceId) external view returns (bool);
4	 }
5	 pragma solidity ^0.8.2;
6	 abstract contract Initializable {
7	 uint8 private _initialized;
8	 bool private _initializing;
9	 event Initialized(uint8 version);
10	 modifier initializer() {
11	 bool isTopLevelCall = !_initializing;
12	 require( (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1), "Initializable: contract is already initialized" );
13	 _initialized = 1;
14	 if (isTopLevelCall) {
15	 _initializing = true;
16	 }
17	 _;
18	 if (isTopLevelCall) {
19	 _initializing = false;
20	 emit Initialized(1);
21	 }
22	 }
23	 modifier reinitializer(uint8 version) {
24	 require(!_initializing && _initialized < version, "Initializable: contract is already initialized");
25	 _initialized = version;
26	 _initializing = true;
27	 _;
28	 _initializing = false;
29	 emit Initialized(version);
30	 }
31	 modifier onlyInitializing() {
32	 require(_initializing, "Initializable: contract is not initializing");
33	 _;
34	 }
35	 function _disableInitializers() internal virtual {
36	 require(!_initializing, "Initializable: contract is initializing");
37	 if (_initialized < type(uint8).max) {
38	 _initialized = type(uint8).max;
39	 emit Initialized(type(uint8).max);
40	 }
41	 }
42	 function _getInitializedVersion() internal view returns (uint8) {
43	 return _initialized;
44	 }
45	 function _isInitializing() internal view returns (bool) {
46	 return _initializing;
47	 }
48	 }
49	 pragma solidity ^0.8.0;
50	 interface IERC721Upgradeable is IERC165Upgradeable {
51	 event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
52	 event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
53	 event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
54	 function balanceOf(address owner) external view returns (uint256 balance);
55	 function ownerOf(uint256 tokenId) external view returns (address owner);
56	 function safeTransferFrom( address from, address to, uint256 tokenId, bytes calldata data ) external;
57	 function safeTransferFrom( address from, address to, uint256 tokenId ) external;
58	 function transferFrom( address from, address to, uint256 tokenId ) external;
59	 function approve(address to, uint256 tokenId) external;
60	 function setApprovalForAll(address operator, bool _approved) external;
61	 function getApproved(uint256 tokenId) external view returns (address operator);
62	 function isApprovedForAll(address owner, address operator) external view returns (bool);
63	 }
64	 pragma solidity ^0.8.0;
65	 abstract contract ContextUpgradeable is Initializable {
66	 function __Context_init() internal onlyInitializing {
67	 }
68	 function __Context_init_unchained() internal onlyInitializing {
69	 }
70	 function _msgSender() internal view virtual returns (address) {
71	 return msg.sender;
72	 }
73	 function _msgData() internal view virtual returns (bytes calldata) {
74	 return msg.data;
75	 }
76	 uint256[50] private __gap;
77	 }
78	 pragma solidity ^0.8.0;
79	 abstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {
80	 function __ERC165_init() internal onlyInitializing {
81	 }
82	 function __ERC165_init_unchained() internal onlyInitializing {
83	 }
84	 function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
85	 return interfaceId == type(IERC165Upgradeable).interfaceId;
86	 }
87	 uint256[50] private __gap;
88	 }
89	 pragma solidity ^0.8.0;
90	 interface IERC721MetadataUpgradeable is IERC721Upgradeable {
91	 function name() external view returns (string memory);
92	 function symbol() external view returns (string memory);
93	 function tokenURI(uint256 tokenId) external view returns (string memory);
94	 }
95	 pragma solidity ^0.8.0;
96	 abstract contract Context {
97	 function _msgSender() internal view virtual returns (address) {
98	 return msg.sender;
99	 }
100	 function _msgData() internal view virtual returns (bytes calldata) {
101	 return msg.data;
102	 }
103	 }
104	 pragma solidity ^0.8.0;
105	 interface IERC721EnumerableUpgradeable is IERC721Upgradeable {
106	 function totalSupply() external view returns (uint256);
107	 function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);
108	 function tokenByIndex(uint256 index) external view returns (uint256);
109	 }
110	 pragma solidity ^0.8.0;
111	 contract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable {
112	 using AddressUpgradeable for address;
113	 using StringsUpgradeable for uint256;
114	 string private _name;
115	 string private _symbol;
116	 mapping(uint256 => address) private _owners;
117	 mapping(address => uint256) private _balances;
118	 mapping(uint256 => address) private _tokenApprovals;
119	 mapping(address => mapping(address => bool)) private _operatorApprovals;
120	 function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {
121	 __ERC721_init_unchained(name_, symbol_);
122	 }
123	 function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {
124	 _name = name_;
125	 _symbol = symbol_;
126	 }
127	 function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {
128	 return interfaceId == type(IERC721Upgradeable).interfaceId || interfaceId == type(IERC721MetadataUpgradeable).interfaceId || super.supportsInterface(interfaceId);
129	 }
130	 function balanceOf(address owner) public view virtual override returns (uint256) {
131	 require(owner != address(0), "ERC721: address zero is not a valid owner");
132	 return _balances[owner];
133	 }
134	 function ownerOf(uint256 tokenId) public view virtual override returns (address) {
135	 address owner = _ownerOf(tokenId);
136	 require(owner != address(0), "ERC721: invalid token ID");
137	 return owner;
138	 }
139	 function name() public view virtual override returns (string memory) {
140	 return _name;
141	 }
142	 function symbol() public view virtual override returns (string memory) {
143	 return _symbol;
144	 }
145	 function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
146	 _requireMinted(tokenId);
147	 string memory baseURI = _baseURI();
148	 return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";
149	 }
150	 function _baseURI() internal view virtual returns (string memory) {
151	 return "";
152	 }
153	 function approve(address to, uint256 tokenId) public virtual override {
154	 address owner = ERC721Upgradeable.ownerOf(tokenId);
155	 require(to != owner, "ERC721: approval to current owner");
156	 require( _msgSender() == owner || isApprovedForAll(owner, _msgSender()), "ERC721: approve caller is not token owner or approved for all" );
157	 _approve(to, tokenId);
158	 }
159	 function getApproved(uint256 tokenId) public view virtual override returns (address) {
160	 _requireMinted(tokenId);
161	 return _tokenApprovals[tokenId];
162	 }
163	 function setApprovalForAll(address operator, bool approved) public virtual override {
164	 _setApprovalForAll(_msgSender(), operator, approved);
165	 }
166	 function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
167	 return _operatorApprovals[owner][operator];
168	 }
169	 function transferFrom( address from, address to, uint256 tokenId ) public virtual override {
170	 require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");
171	 _transfer(from, to, tokenId);
172	 }
173	 function safeTransferFrom( address from, address to, uint256 tokenId ) public virtual override {
174	 safeTransferFrom(from, to, tokenId, "");
175	 }
176	 function safeTransferFrom( address from, address to, uint256 tokenId, bytes memory data ) public virtual override {
177	 require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");
178	 _safeTransfer(from, to, tokenId, data);
179	 }
180	 function _safeTransfer( address from, address to, uint256 tokenId, bytes memory data ) internal virtual {
181	 _transfer(from, to, tokenId);
182	 require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");
183	 }
184	 function _ownerOf(uint256 tokenId) internal view virtual returns (address) {
185	 return _owners[tokenId];
186	 }
187	 function _exists(uint256 tokenId) internal view virtual returns (bool) {
188	 return _ownerOf(tokenId) != address(0);
189	 }
190	 function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {
191	 address owner = ERC721Upgradeable.ownerOf(tokenId);
192	 return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);
193	 }
194	 function _safeMint(address to, uint256 tokenId) internal virtual {
195	 _safeMint(to, tokenId, "");
196	 }
197	 function _safeMint( address to, uint256 tokenId, bytes memory data ) internal virtual {
198	 _mint(to, tokenId);
199	 require( _checkOnERC721Received(address(0), to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer" );
200	 }
201	 function _mint(address to, uint256 tokenId) internal virtual {
202	 require(to != address(0), "ERC721: mint to the zero address");
203	 require(!_exists(tokenId), "ERC721: token already minted");
204	 _beforeTokenTransfer(address(0), to, tokenId);
205	 require(!_exists(tokenId), "ERC721: token already minted");
206	 unchecked {
207	 _balances[to] += 1;
208	 }
209	 _owners[tokenId] = to;
210	 emit Transfer(address(0), to, tokenId);
211	 _afterTokenTransfer(address(0), to, tokenId);
212	 }
213	 function _burn(uint256 tokenId) internal virtual {
214	 address owner = ERC721Upgradeable.ownerOf(tokenId);
215	 _beforeTokenTransfer(owner, address(0), tokenId);
216	 owner = ERC721Upgradeable.ownerOf(tokenId);
217	 delete _tokenApprovals[tokenId];
218	 unchecked {
219	 _balances[owner] -= 1;
220	 }
221	 delete _owners[tokenId];
222	 emit Transfer(owner, address(0), tokenId);
223	 _afterTokenTransfer(owner, address(0), tokenId);
224	 }
225	 function _transfer( address from, address to, uint256 tokenId ) internal virtual {
226	 require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");
227	 require(to != address(0), "ERC721: transfer to the zero address");
228	 _beforeTokenTransfer(from, to, tokenId);
229	 require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");
230	 delete _tokenApprovals[tokenId];
231	 unchecked {
232	 _balances[from] -= 1;
233	 _balances[to] += 1;
234	 }
235	 _owners[tokenId] = to;
236	 emit Transfer(from, to, tokenId);
237	 _afterTokenTransfer(from, to, tokenId);
238	 }
239	 function _approve(address to, uint256 tokenId) internal virtual {
240	 _tokenApprovals[tokenId] = to;
241	 emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);
242	 }
243	 function _setApprovalForAll( address owner, address operator, bool approved ) internal virtual {
244	 require(owner != operator, "ERC721: approve to caller");
245	 _operatorApprovals[owner][operator] = approved;
246	 emit ApprovalForAll(owner, operator, approved);
247	 }
248	 function _requireMinted(uint256 tokenId) internal view virtual {
249	 require(_exists(tokenId), "ERC721: invalid token ID");
250	 }
251	 function _checkOnERC721Received( address from, address to, uint256 tokenId, bytes memory data ) private returns (bool) {
252	 if (to.isContract()) {
253	 try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {
254	 return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;
255	 }
256	 catch (bytes memory reason) {
257	 if (reason.length == 0) {
258	 revert("ERC721: transfer to non ERC721Receiver implementer");
259	 }
260	 else {
261	 assembly {
262	 revert(add(32, reason), mload(reason)) }
263	 }
264	 }
265	 }
266	 else {
267	 return true;
268	 }
269	 }
270	 function _beforeTokenTransfer( address from, address to, uint256 tokenId ) internal virtual {
271	 }
272	 function _afterTokenTransfer( address from, address to, uint256 tokenId ) internal virtual {
273	 }
274	 function _beforeConsecutiveTokenTransfer( address from, address to, uint256, uint96 size ) internal virtual {
275	 if (from != address(0)) {
276	 _balances[from] -= size;
277	 }
278	 if (to != address(0)) {
279	 _balances[to] += size;
280	 }
281	 }
282	 function _afterConsecutiveTokenTransfer( address, address, uint256, uint96 ) internal virtual {
283	 }
284	 uint256[44] private __gap;
285	 }
286	 pragma solidity ^0.8.0;
287	 contract VRFRequestIDBase {
288	 function makeVRFInputSeed( bytes32 _keyHash, uint256 _userSeed, address _requester, uint256 _nonce ) internal pure returns (uint256) {
289	 return uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));
290	 }
291	 function makeRequestId(bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {
292	 return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));
293	 }
294	 }
295	 pragma solidity ^0.8.0;
296	 abstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {
297	 address private _owner;
298	 event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
299	 function __Ownable_init() internal onlyInitializing {
300	 __Ownable_init_unchained();
301	 }
302	 function __Ownable_init_unchained() internal onlyInitializing {
303	 _transferOwnership(_msgSender());
304	 }
305	 modifier onlyOwner() {
306	 _checkOwner();
307	 _;
308	 }
309	 function owner() public view virtual returns (address) {
310	 return _owner;
311	 }
312	 function _checkOwner() internal view virtual {
313	 require(owner() == _msgSender(), "Ownable: caller is not the owner");
314	 }
315	 function renounceOwnership() public virtual onlyOwner {
316	 _transferOwnership(address(0));
317	 }
318	 function transferOwnership(address newOwner) public virtual onlyOwner {
319	 require(newOwner != address(0), "Ownable: new owner is the zero address");
320	 _transferOwnership(newOwner);
321	 }
322	 function _transferOwnership(address newOwner) internal virtual {
323	 address oldOwner = _owner;
324	 _owner = newOwner;
325	 emit OwnershipTransferred(oldOwner, newOwner);
326	 }
327	 uint256[49] private __gap;
328	 }
329	 pragma solidity ^0.8.0;
330	 interface IERC2981Upgradeable is IERC165Upgradeable {
331	 function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address receiver, uint256 royaltyAmount);
332	 }
333	 pragma solidity ^0.8.0;
334	 abstract contract ERC721EnumerableUpgradeable is Initializable, ERC721Upgradeable, IERC721EnumerableUpgradeable {
335	 function __ERC721Enumerable_init() internal onlyInitializing {
336	 }
337	 function __ERC721Enumerable_init_unchained() internal onlyInitializing {
338	 }
339	 mapping(address => mapping(uint256 => uint256)) private _ownedTokens;
340	 mapping(uint256 => uint256) private _ownedTokensIndex;
341	 uint256[] private _allTokens;
342	 mapping(uint256 => uint256) private _allTokensIndex;
343	 function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165Upgradeable, ERC721Upgradeable) returns (bool) {
344	 return interfaceId == type(IERC721EnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);
345	 }
346	 function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {
347	 require(index < ERC721Upgradeable.balanceOf(owner), "ERC721Enumerable: owner index out of bounds");
348	 return _ownedTokens[owner][index];
349	 }
350	 function totalSupply() public view virtual override returns (uint256) {
351	 return _allTokens.length;
352	 }
353	 function tokenByIndex(uint256 index) public view virtual override returns (uint256) {
354	 require(index < ERC721EnumerableUpgradeable.totalSupply(), "ERC721Enumerable: global index out of bounds");
355	 return _allTokens[index];
356	 }
357	 function _beforeTokenTransfer( address from, address to, uint256 tokenId ) internal virtual override {
358	 super._beforeTokenTransfer(from, to, tokenId);
359	 if (from == address(0)) {
360	 _addTokenToAllTokensEnumeration(tokenId);
361	 }
362	 else if (from != to) {
363	 _removeTokenFromOwnerEnumeration(from, tokenId);
364	 }
365	 if (to == address(0)) {
366	 _removeTokenFromAllTokensEnumeration(tokenId);
367	 }
368	 else if (to != from) {
369	 _addTokenToOwnerEnumeration(to, tokenId);
370	 }
371	 }
372	 function _beforeConsecutiveTokenTransfer( address, address, uint256, uint96 size ) internal virtual override {
373	 if (size > 0) {
374	 revert("ERC721Enumerable: consecutive transfers not supported");
375	 }
376	 }
377	 function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {
378	 uint256 length = ERC721Upgradeable.balanceOf(to);
379	 _ownedTokens[to][length] = tokenId;
380	 _ownedTokensIndex[tokenId] = length;
381	 }
382	 function _addTokenToAllTokensEnumeration(uint256 tokenId) private {
383	 _allTokensIndex[tokenId] = _allTokens.length;
384	 _allTokens.push(tokenId);
385	 }
386	 function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {
387	 uint256 lastTokenIndex = ERC721Upgradeable.balanceOf(from) - 1;
388	 uint256 tokenIndex = _ownedTokensIndex[tokenId];
389	 if (tokenIndex != lastTokenIndex) {
390	 uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];
391	 _ownedTokens[from][tokenIndex] = lastTokenId;
392	 _ownedTokensIndex[lastTokenId] = tokenIndex;
393	 }
394	 delete _ownedTokensIndex[tokenId];
395	 delete _ownedTokens[from][lastTokenIndex];
396	 }
397	 function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {
398	 uint256 lastTokenIndex = _allTokens.length - 1;
399	 uint256 tokenIndex = _allTokensIndex[tokenId];
400	 uint256 lastTokenId = _allTokens[lastTokenIndex];
401	 _allTokens[tokenIndex] = lastTokenId;
402	 _allTokensIndex[lastTokenId] = tokenIndex;
403	 delete _allTokensIndex[tokenId];
404	 _allTokens.pop();
405	 }
406	 uint256[46] private __gap;
407	 }
408	 pragma solidity ^0.8.0;
409	 abstract contract Ownable is Context {
410	 address private _owner;
411	 event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
412	 constructor() {
413	 _transferOwnership(_msgSender());
414	 }
415	 modifier onlyOwner() {
416	 _checkOwner();
417	 _;
418	 }
419	 function owner() public view virtual returns (address) {
420	 return _owner;
421	 }
422	 function _checkOwner() internal view virtual {
423	 require(owner() == _msgSender(), "Ownable: caller is not the owner");
424	 }
425	 function renounceOwnership() public virtual onlyOwner {
426	 _transferOwnership(address(0));
427	 }
428	 function transferOwnership(address newOwner) public virtual onlyOwner {
429	 require(newOwner != address(0), "Ownable: new owner is the zero address");
430	 _transferOwnership(newOwner);
431	 }
432	 function _transferOwnership(address newOwner) internal virtual {
433	 address oldOwner = _owner;
434	 _owner = newOwner;
435	 emit OwnershipTransferred(oldOwner, newOwner);
436	 }
437	 }
438	 pragma solidity ^0.8.0;
439	 abstract contract VRFConsumerBase is VRFRequestIDBase {
440	 function fulfillRandomness(bytes32 requestId, uint256 randomness) internal virtual;
441	 uint256 private constant USER_SEED_PLACEHOLDER = 0;
442	 function requestRandomness(bytes32 _keyHash, uint256 _fee) internal returns (bytes32 requestId) {
443	 LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, USER_SEED_PLACEHOLDER));
444	 uint256 vRFSeed = makeVRFInputSeed(_keyHash, USER_SEED_PLACEHOLDER, address(this), nonces[_keyHash]);
445	 nonces[_keyHash] = nonces[_keyHash] + 1;
446	 return makeRequestId(_keyHash, vRFSeed);
447	 }
448	 LinkTokenInterface internal immutable LINK;
449	 address private immutable vrfCoordinator;
450	 mapping(bytes32 => uint256) private nonces;
451	 constructor(address _vrfCoordinator, address _link) {
452	 vrfCoordinator = _vrfCoordinator;
453	 LINK = LinkTokenInterface(_link);
454	 }
455	 function rawFulfillRandomness(bytes32 requestId, uint256 randomness) external {
456	 require(msg.sender == vrfCoordinator, "Only VRFCoordinator can fulfill");
457	 fulfillRandomness(requestId, randomness);
458	 }
459	 }
460	 pragma solidity ^0.8.4;
461	 contract CowardGambit is Initializable, OwnableUpgradeable {
462	 address public adminAddress;
463	 address public randomNumberAddress;
464	 address public SomAddress;
465	 address public ownerAddress;
466	 bool public isRandomNumber;
467	 uint256 public randomNumber;
468	 uint256 public constant DENOMINATOR = 100;
469	 bool public roundStarted = false;
470	 struct SOM {
471	 uint256 tokenId;
472	 uint256 state;
473	 }
474	 struct Round {
475	 uint256 roundId;
476	 uint256 deathPercent;
477	 }
478	 mapping(uint256 => Round) public rounds;
479	 SOM[] public joinItems;
480	 SOM[] public Coward;
481	 SOM[] public Mars;
482	 uint256 public currentRoundId = 0;
483	 uint256 public TimeLineID = 0;
484	 uint256 public ROUND_COUNT = 5;
485	 uint256 public MainWinner = 0;
486	 uint256 public CowardIndex = 0;
487	 uint256[] public CowardTokenIDs;
488	 bool[1001] public CowardFlg;
489	 bool[1001] public MarsFlg;
490	 bool public CowardHasWinner = true;
491	 uint256 public CowardWinner = 0;
492	 bool public CowardFinished = false;
493	 bool public MarsFinished = false;
494	 event setRandomNumber();
495	 function setSOMAddress(address _address) external onlySOM {
496	 SomAddress = _address;
497	 }
498	 function numbersDrawn( uint256 _randomNumber ) external {
499	 randomNumber = _randomNumber;
500	 isRandomNumber = true;
501	 emit setRandomNumber();
502	 }
503	 function initialize( address _randomNumberAddress, address _adminAddress ) public initializer {
504	 __Ownable_init();
505	 randomNumberAddress = _randomNumberAddress;
506	 adminAddress = _adminAddress;
507	 ownerAddress = msg.sender;
508	 for (uint256 i = 0; i < ROUND_COUNT; i++) {
509	 rounds[i + 1].roundId = i + 1;
510	 if(i == 0) rounds[i + 1].deathPercent = 20;
511	 if(i == 1) rounds[i + 1].deathPercent = 25;
512	 if(i == 2) rounds[i + 1].deathPercent = 33;
513	 if(i == 3) rounds[i + 1].deathPercent = 50;
514	 if(i == 4) rounds[i + 1].deathPercent = 75;
515	 }
516	 }
517	 modifier onlySOM() {
518	 require( adminAddress == msg.sender || ownerAddress == msg.sender || SomAddress == msg.sender, "RNG: Caller is not the SOM address" );
519	 _;
520	 }
521	 function setJoinItems(uint256 _tokenId, uint256 _state) external onlySOM {
522	 joinItems.push(SOM({
523	 tokenId: _tokenId, state: _state }
524	 ));
525	 }
526	 function endRound() external onlySOM {
527	 require(currentRoundId <= ROUND_COUNT + 1, "Game Finished!");
528	 TimeLineID ++;
529	 updateCowardList();
530	 if(currentRoundId == 0) {
531	 isRandomNumber = false;
532	 MainWinner = 0;
533	 currentRoundId++;
534	 RandomGenerator(randomNumberAddress).requestRandomNumber();
535	 }
536	 else if(currentRoundId == 6) {
537	 uint256 index = randomNumber % joinItems.length;
538	 MainWinner = joinItems[index].tokenId;
539	 if(SOMFactory(SomAddress).getSOMarray(MainWinner) == 17) {
540	 SOMFactory(SomAddress).setSOMarray(MainWinner, 19);
541	 }
542	 else {
543	 SOMFactory(SomAddress).setSOMarray(MainWinner, 18);
544	 }
545	 joinItems[index] = joinItems[joinItems.length - 1];
546	 joinItems.pop();
547	 uint256 deathAmount = joinItems.length;
548	 for(uint256 i = 0; i < deathAmount; i ++) {
549	 uint256 dead_index = randomNumber % joinItems.length;
550	 if(SOMFactory(SomAddress).getSOMarray(joinItems[dead_index].tokenId) != 17) {
551	 SOMFactory(SomAddress).setSOMarray(joinItems[dead_index].tokenId, 12);
552	 }
553	 joinItems[dead_index] = joinItems[joinItems.length - 1];
554	 joinItems.pop();
555	 }
556	 joinItems.push(SOM({
557	 tokenId: MainWinner, state: 1 }
558	 ));
559	 }
560	 else {
561	 uint256 deathAmount = uint256(joinItems.length * rounds[currentRoundId].deathPercent / DENOMINATOR);
562	 for (uint256 i = 0; i < deathAmount; i ++) {
563	 uint256 index = randomNumber % joinItems.length;
564	 if(currentRoundId == 1) SOMFactory(SomAddress).setSOMarray(joinItems[index].tokenId, 6);
565	 if(currentRoundId == 2) SOMFactory(SomAddress).setSOMarray(joinItems[index].tokenId, 5);
566	 if(currentRoundId == 3) {
567	 if(i < deathAmount / 2) SOMFactory(SomAddress).setSOMarray(joinItems[index].tokenId, 8);
568	 else SOMFactory(SomAddress).setSOMarray(joinItems[index].tokenId, 7);
569	 }
570	 if(currentRoundId == 4) {
571	 if(i < deathAmount / 2) SOMFactory(SomAddress).setSOMarray(joinItems[index].tokenId, 9);
572	 else SOMFactory(SomAddress).setSOMarray(joinItems[index].tokenId, 10);
573	 }
574	 if(currentRoundId == 5) {
575	 if(i < deathAmount / 2) SOMFactory(SomAddress).setSOMarray(joinItems[index].tokenId, 3);
576	 else SOMFactory(SomAddress).setSOMarray(joinItems[index].tokenId, 11);
577	 }
578	 joinItems[index] = joinItems[joinItems.length - 1];
579	 joinItems.pop();
580	 }
581	 currentRoundId ++;
582	 }
583	 roundStarted = false;
584	 }
585	 function setCoward(uint256 _tokenId) external {
586	 require(msg.sender == SOMFactory(SomAddress).ownerOf(_tokenId), "not yours");
587	 require(currentRoundId != 0, "Can't join Coward!");
588	 require(SOMFactory(SomAddress).getSOMarray(_tokenId) != 15, "Already Joined!");
589	 require(CowardFlg[_tokenId] == false, "Already joined!");
590	 CowardFlg[_tokenId] = true;
591	 CowardTokenIDs.push(_tokenId);
592	 }
593	 function updateCowardList() public {
594	 for(uint256 i = CowardIndex; i < CowardTokenIDs.length; i ++) {
595	 Coward.push(SOM({
596	 tokenId: CowardTokenIDs[i], state: 15 }
597	 ));
598	 SOMFactory(SomAddress).setSOMarray(CowardTokenIDs[i], 15);
599	 for (uint256 j = 0; j < joinItems.length; j ++) {
600	 if (joinItems[j].tokenId == CowardTokenIDs[i]) {
601	 joinItems[j] = joinItems[joinItems.length - 1];
602	 joinItems.pop();
603	 break;
604	 }
605	 }
606	 }
607	 CowardIndex = CowardTokenIDs.length;
608	 }
609	 function setFinishCoward() external onlySOM {
610	 CowardFinished = true;
611	 if(Coward.length > 200) {
612	 CowardHasWinner = false;
613	 }
614	 else {
615	 uint256 index = randomNumber % Coward.length;
616	 CowardWinner = Coward[index].tokenId;
617	 SOMFactory(SomAddress).setSOMarray(CowardWinner, 16);
618	 }
619	 }
620	 function setMars(uint256 _tokenId) external {
621	 require(MarsFlg[_tokenId] == false, "Already joined!");
622	 MarsFlg[_tokenId] = true;
623	 uint256 state = SOMFactory(SomAddress).getSOMarray(_tokenId);
624	 require(msg.sender == SOMFactory(SomAddress).ownerOf(_tokenId), "not yours");
625	 require(state != 1 && state != 15 && currentRoundId == 6, "Can't join Mars' Gambit!");
626	 Mars.push(SOM({
627	 tokenId: _tokenId, state: state }
628	 ));
629	 }
630	 function setFinishMars() external onlySOM {
631	 uint256 burnAmount = uint256(Mars.length * 90 / DENOMINATOR);
632	 MarsFinished = true;
633	 for (uint256 i = 0; i < burnAmount; i ++) {
634	 uint256 index = randomNumber % Mars.length;
635	 SOMFactory(SomAddress).Burn(Mars[index].tokenId);
636	 SOMFactory(SomAddress).setSOMarray(Mars[index].tokenId, 20);
637	 Mars[index] = Mars[Mars.length - 1];
638	 Mars.pop();
639	 }
640	 for (uint256 i = 0; i < Mars.length; i ++) {
641	 SOMFactory(SomAddress).setSOMarray(Mars[i].tokenId, 17);
642	 Mars[i].state = 17;
643	 joinItems.push(Mars[i]);
644	 }
645	 }
646	 function fetchCowardAmount() external view returns(uint256) {
647	 return Coward.length;
648	 }
649	 function fetchMarsAmount() external view returns(uint256) {
650	 return Mars.length;
651	 }
652	 function fetchTotalAliveAmount() external view returns(uint256) {
653	 return joinItems.length;
654	 }
655	 }
656	 pragma solidity ^0.8.6;
657	 contract RandomGenerator is VRFConsumerBase, Ownable {
658	 using Address for address;
659	 bytes32 internal keyHash;
660	 uint256 internal fee;
661	 address public SOMAddress;
662	 address public CowardAddress;
663	 bytes32 currentRequestID;
664	 mapping(bytes32 => uint256) public requestToRandom;
665	 mapping(bytes32 => bool) public hasReturned;
666	 event newSOM(address SOM);
667	 event randomNumberArrived( bool arrived, uint256 randomNumber, bytes32 batchID );
668	 modifier onlySOM() {
669	 require(SOMAddress == msg.sender, "RNG: Caller is not the SOM address");
670	 _;
671	 }
672	 constructor( address _vrfCoordinator, address _link, bytes32 _keyHash, uint256 _fee ) VRFConsumerBase( _vrfCoordinator, _link ) {
673	 keyHash = _keyHash;
674	 fee = _fee;
675	 }
676	 function requestRandomNumber() public returns (bytes32 requestID) {
677	 require( LINK.balanceOf(address(this)) >= fee, "RandomNumberConsumer: Not enough LINK - fill contract with faucet" );
678	 uint256 prevRandomNumber = requestToRandom[currentRequestID];
679	 emit randomNumberArrived(false, prevRandomNumber, currentRequestID);
680	 currentRequestID = requestRandomness(keyHash, fee);
681	 hasReturned[currentRequestID] = false;
682	 return currentRequestID;
683	 }
684	 function fulfillRandomness(bytes32 requestID, uint256 _randomness) internal override {
685	 requestToRandom[requestID] = _randomness;
686	 hasReturned[requestID] = true;
687	 CowardGambit(CowardAddress).numbersDrawn( _randomness );
688	 emit randomNumberArrived(true, _randomness, requestID);
689	 }
690	 function getVerifiedRandomNumber(bytes32 _reqeustId) public view onlySOM returns (uint256) {
691	 require( hasReturned[_reqeustId] == true, "RandomGenerator: Random number is not arrived yet" );
692	 return requestToRandom[_reqeustId];
693	 }
694	 function setSOMAddress(address _SOMAddr) public onlyOwner {
695	 require( _SOMAddr.isContract() == true, "RandomGenerator: This is not a Contract Address" );
696	 SOMAddress = _SOMAddr;
697	 }
698	 function setCowardAddress(address _address) public onlyOwner {
699	 require( _address.isContract() == true, "RandomGenerator: This is not a Contract Address" );
700	 CowardAddress = _address;
701	 }
702	 }
703	 pragma solidity ^0.8.4;
704	 contract SOMFactory is Initializable, ERC721EnumerableUpgradeable, OwnableUpgradeable, IERC2981Upgradeable {
705	 address public CowardAddress;
706	 using Counters for Counters.Counter;
707	 bool private isInitialized;
708	 Counters.Counter private _tokenIds;
709	 struct SOM {
710	 uint256 tokenId;
711	 uint256 state;
712	 }
713	 address public adminAddress;
714	 uint256 public constant DENOMINATOR = 100;
715	 uint256 public TotalMintCount = 0;
716	 uint256 public MINT_PRICE = 2500000000000000;
717	 address public BankAddress;
718	 address public devAddress;
719	 uint256[1001] private Randomorder;
720	 mapping(address => uint256) public NFTcountPerAddress;
721	 mapping(address => bool) public WhiteList;
722	 string public _baseTokenURI;
723	 string public _unrevealedURI;
724	 bool public isRevealed = false;
725	 bool public PublicSaleStarted = false;
726	 mapping(uint256 => SOM) public soms;
727	 event SOMMinted();
728	 function initialize( string memory baseTokenURI_, string memory unrevealedURI_, address _adminAddress, address _BankAddress, address _devAddress, uint256[] memory randomorder_ ) public initializer {
729	 __ERC721_init("Sons Of Mars", "SOM");
730	 __Ownable_init();
731	 _baseTokenURI = baseTokenURI_;
732	 _unrevealedURI = unrevealedURI_;
733	 isInitialized = true;
734	 adminAddress = _adminAddress;
735	 BankAddress = _BankAddress;
736	 devAddress = _devAddress;
737	 for (uint256 i = 0 ; i < randomorder_.length; i ++) {
738	 Randomorder[i] = randomorder_[i];
739	 }
740	 }
741	 modifier onlySOM() {
742	 require( adminAddress == msg.sender || owner() == msg.sender || CowardAddress == msg.sender, "RNG: Caller is not the SOM address" );
743	 _;
744	 }
745	 function isInitialize() external view returns(bool) {
746	 return isInitialized;
747	 }
748	 function _baseURI() internal view override returns (string memory) {
749	 return _baseTokenURI;
750	 }
751	 function setWhiteList(address[] memory _addresses) external onlySOM {
752	 for(uint256 i = 0; i < _addresses.length; i ++) {
753	 WhiteList[_addresses[i]] = true;
754	 }
755	 }
756	 function setStartPublicMint() external onlySOM {
757	 PublicSaleStarted = true;
758	 }
759	 function setRevealed() external onlySOM {
760	 isRevealed = true;
761	 CowardGambit(CowardAddress).endRound();
762	 }
763	 function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
764	 require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
765	 string memory currentBaseURI;
766	 if(isRevealed == true) {
767	 currentBaseURI = _baseURI();
768	 }
769	 else {
770	 currentBaseURI = _unrevealedURI;
771	 return currentBaseURI;
772	 }
773	 return bytes(currentBaseURI).length > 0 ? string(abi.encodePacked(currentBaseURI, Strings.toString((Randomorder[tokenId - 1] - 1) * 19 + soms[tokenId].state), "")) : "";
774	 }
775	 function setCowardAddress(address _address) external onlySOM {
776	 CowardAddress = _address;
777	 }
778	 function getSOMarray(uint256 _tokenId) onlySOM public view returns (uint256) {
779	 return soms[_tokenId].state;
780	 }
781	 function setSOMarray(uint256 _tokenId, uint256 _state) onlySOM public {
782	 soms[_tokenId].state = _state;
783	 }
784	 function mint(uint256 _mintAmount) external payable {
785	 require(_mintAmount + totalSupply() < 1001, "Overflow amount!");
786	 if(PublicSaleStarted == false) {
787	 require(WhiteList[msg.sender] == true, "You didn't join WhiteList!");
788	 }
789	 uint256 restAmount = 0;
790	 if(msg.sender != adminAddress) {
791	 require(msg.value >= MINT_PRICE * _mintAmount, "Invalid Amount");
792	 require(NFTcountPerAddress[msg.sender] + _mintAmount < 4, "Can't mint over 3 NFTs!");
793	 restAmount = msg.value - MINT_PRICE * _mintAmount;
794	 payable(BankAddress).transfer(MINT_PRICE * _mintAmount * 95 / DENOMINATOR);
795	 payable(devAddress).transfer(MINT_PRICE * _mintAmount * 5 / DENOMINATOR);
796	 payable(msg.sender).transfer(restAmount);
797	 }
798	 for (uint256 k = 0; k < _mintAmount; k++) {
799	 _tokenIds.increment();
800	 uint256 tokenId = _tokenIds.current();
801	 _safeMint(msg.sender, tokenId);
802	 soms[tokenId] = SOM({
803	 tokenId: tokenId, state: 1 }
804	 );
805	 TotalMintCount ++;
806	 CowardGambit(CowardAddress).setJoinItems(soms[tokenId].tokenId, soms[tokenId].state);
807	 NFTcountPerAddress[msg.sender] ++;
808	 }
809	 emit SOMMinted();
810	 }
811	 function royaltyInfo(uint256 _tokenId, uint256 _salePrice) external view override returns (address receiver, uint256 royaltyAmount) {
812	 uint256 payout = (_salePrice * 10) / DENOMINATOR;
813	 return (BankAddress, payout);
814	 }
815	 function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721EnumerableUpgradeable, IERC165Upgradeable) returns (bool) {
816	 return ( interfaceId == type(IERC2981Upgradeable).interfaceId || super.supportsInterface(interfaceId) );
817	 }
818	 function Burn(uint256 _tokenId) public {
819	 _burn(_tokenId);
820	 }
821	 function fetchSOMs() external view returns (SOM[] memory) {
822	 uint256 itemCount = _tokenIds.current();
823	 SOM[] memory items = new SOM[](itemCount);
824	 for (uint256 i = 0; i < itemCount; i++) {
825	 if(soms[i + 1].state == 20) continue;
826	 SOM memory currentItem = soms[i + 1];
827	 items[i] = currentItem;
828	 }
829	 return items;
830	 }
831	 function fetchMySOMs(address _address) external view returns(SOM[] memory) {
832	 uint256 itemCount = 0;
833	 for(uint256 i = 0; i < _tokenIds.current(); i++) {
834	 if(soms[i + 1].state == 20) continue;
835	 address owner = ownerOf(i + 1);
836	 if(owner == _address) itemCount ++;
837	 }
838	 SOM[] memory myItems = new SOM[](itemCount);
839	 itemCount = 0;
840	 for (uint256 i = 0; i < _tokenIds.current(); i++) {
841	 if(soms[i + 1].state == 20) continue;
842	 address owner = ownerOf(i + 1);
843	 if(owner == _address) {
844	 SOM memory item = soms[i + 1];
845	 myItems[itemCount ++] = item;
846	 }
847	 }
848	 return myItems;
849	 }
850	 }
851	 pragma solidity ^0.8.0;
852	 library Counters {
853	 struct Counter {
854	 uint256 _value;
855	 }
856	 function current(Counter storage counter) internal view returns (uint256) {
857	 return counter._value;
858	 }
859	 function increment(Counter storage counter) internal {
860	 unchecked {
861	 counter._value += 1;
862	 }
863	 }
864	 function decrement(Counter storage counter) internal {
865	 uint256 value = counter._value;
866	 require(value > 0, "Counter: decrement overflow");
867	 unchecked {
868	 counter._value = value - 1;
869	 }
870	 }
871	 function reset(Counter storage counter) internal {
872	 counter._value = 0;
873	 }
874	 }
875	 pragma solidity ^0.8.0;
876	 library Strings {
877	 bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";
878	 uint8 private constant _ADDRESS_LENGTH = 20;
879	 function toString(uint256 value) internal pure returns (string memory) {
880	 if (value == 0) {
881	 return "0";
882	 }
883	 uint256 temp = value;
884	 uint256 digits;
885	 while (temp != 0) {
886	 digits++;
887	 temp /= 10;
888	 }
889	 bytes memory buffer = new bytes(digits);
890	 while (value != 0) {
891	 digits -= 1;
892	 buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
893	 value /= 10;
894	 }
895	 return string(buffer);
896	 }
897	 function toHexString(uint256 value) internal pure returns (string memory) {
898	 if (value == 0) {
899	 return "0x00";
900	 }
901	 uint256 temp = value;
902	 uint256 length = 0;
903	 while (temp != 0) {
904	 length++;
905	 temp >>= 8;
906	 }
907	 return toHexString(value, length);
908	 }
909	 function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
910	 bytes memory buffer = new bytes(2 * length + 2);
911	 buffer[0] = "0";
912	 buffer[1] = "x";
913	 for (uint256 i = 2 * length + 1; i > 1; --i) {
914	 buffer[i] = _HEX_SYMBOLS[value & 0xf];
915	 value >>= 4;
916	 }
917	 require(value == 0, "Strings: hex length insufficient");
918	 return string(buffer);
919	 }
920	 function toHexString(address addr) internal pure returns (string memory) {
921	 return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);
922	 }
923	 }
924	 pragma solidity ^0.8.1;
925	 library Address {
926	 function isContract(address account) internal view returns (bool) {
927	 return account.code.length > 0;
928	 }
929	 function sendValue(address payable recipient, uint256 amount) internal {
930	 require(address(this).balance >= amount, "Address: insufficient balance");
931	 (bool success, ) = recipient.call{
932	 value: amount}
933	 ("");
934	 require(success, "Address: unable to send value, recipient may have reverted");
935	 }
936	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
937	 return functionCall(target, data, "Address: low-level call failed");
938	 }
939	 function functionCall( address target, bytes memory data, string memory errorMessage ) internal returns (bytes memory) {
940	 return functionCallWithValue(target, data, 0, errorMessage);
941	 }
942	 function functionCallWithValue( address target, bytes memory data, uint256 value ) internal returns (bytes memory) {
943	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
944	 }
945	 function functionCallWithValue( address target, bytes memory data, uint256 value, string memory errorMessage ) internal returns (bytes memory) {
946	 require(address(this).balance >= value, "Address: insufficient balance for call");
947	 require(isContract(target), "Address: call to non-contract");
948	 (bool success, bytes memory returndata) = target.call{
949	 value: value}
950	 (data);
951	 return verifyCallResult(success, returndata, errorMessage);
952	 }
953	 function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
954	 return functionStaticCall(target, data, "Address: low-level static call failed");
955	 }
956	 function functionStaticCall( address target, bytes memory data, string memory errorMessage ) internal view returns (bytes memory) {
957	 require(isContract(target), "Address: static call to non-contract");
958	 (bool success, bytes memory returndata) = target.staticcall(data);
959	 return verifyCallResult(success, returndata, errorMessage);
960	 }
961	 function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
962	 return functionDelegateCall(target, data, "Address: low-level delegate call failed");
963	 }
964	 function functionDelegateCall( address target, bytes memory data, string memory errorMessage ) internal returns (bytes memory) {
965	 require(isContract(target), "Address: delegate call to non-contract");
966	 (bool success, bytes memory returndata) = target.delegatecall(data);
967	 return verifyCallResult(success, returndata, errorMessage);
968	 }
969	 function verifyCallResult( bool success, bytes memory returndata, string memory errorMessage ) internal pure returns (bytes memory) {
970	 if (success) {
971	 return returndata;
972	 }
973	 else {
974	 if (returndata.length > 0) {
975	 assembly {
976	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
977	 }
978	 else {
979	 revert(errorMessage);
980	 }
981	 }
982	 }
983	 }
984	 pragma solidity ^0.8.1;
985	 library AddressUpgradeable {
986	 function isContract(address account) internal view returns (bool) {
987	 return account.code.length > 0;
988	 }
989	 function sendValue(address payable recipient, uint256 amount) internal {
990	 require(address(this).balance >= amount, "Address: insufficient balance");
991	 (bool success, ) = recipient.call{
992	 value: amount}
993	 ("");
994	 require(success, "Address: unable to send value, recipient may have reverted");
995	 }
996	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
997	 return functionCallWithValue(target, data, 0, "Address: low-level call failed");
998	 }
999	 function functionCall( address target, bytes memory data, string memory errorMessage ) internal returns (bytes memory) {
1000	 return functionCallWithValue(target, data, 0, errorMessage);
1001	 }
1002	 function functionCallWithValue( address target, bytes memory data, uint256 value ) internal returns (bytes memory) {
1003	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
1004	 }
1005	 function functionCallWithValue( address target, bytes memory data, uint256 value, string memory errorMessage ) internal returns (bytes memory) {
1006	 require(address(this).balance >= value, "Address: insufficient balance for call");
1007	 (bool success, bytes memory returndata) = target.call{
1008	 value: value}
1009	 (data);
1010	 return verifyCallResultFromTarget(target, success, returndata, errorMessage);
1011	 }
1012	 function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
1013	 return functionStaticCall(target, data, "Address: low-level static call failed");
1014	 }
1015	 function functionStaticCall( address target, bytes memory data, string memory errorMessage ) internal view returns (bytes memory) {
1016	 (bool success, bytes memory returndata) = target.staticcall(data);
1017	 return verifyCallResultFromTarget(target, success, returndata, errorMessage);
1018	 }
1019	 function verifyCallResultFromTarget( address target, bool success, bytes memory returndata, string memory errorMessage ) internal view returns (bytes memory) {
1020	 if (success) {
1021	 if (returndata.length == 0) {
1022	 require(isContract(target), "Address: call to non-contract");
1023	 }
1024	 return returndata;
1025	 }
1026	 else {
1027	 _revert(returndata, errorMessage);
1028	 }
1029	 }
1030	 function verifyCallResult( bool success, bytes memory returndata, string memory errorMessage ) internal pure returns (bytes memory) {
1031	 if (success) {
1032	 return returndata;
1033	 }
1034	 else {
1035	 _revert(returndata, errorMessage);
1036	 }
1037	 }
1038	 function _revert(bytes memory returndata, string memory errorMessage) private pure {
1039	 if (returndata.length > 0) {
1040	 assembly {
1041	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
1042	 }
1043	 else {
1044	 revert(errorMessage);
1045	 }
1046	 }
1047	 }
1048	 pragma solidity ^0.8.0;
1049	 interface LinkTokenInterface {
1050	 function allowance(address owner, address spender) external view returns (uint256 remaining);
1051	 function approve(address spender, uint256 value) external returns (bool success);
1052	 function balanceOf(address owner) external view returns (uint256 balance);
1053	 function decimals() external view returns (uint8 decimalPlaces);
1054	 function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);
1055	 function increaseApproval(address spender, uint256 subtractedValue) external;
1056	 function name() external view returns (string memory tokenName);
1057	 function symbol() external view returns (string memory tokenSymbol);
1058	 function totalSupply() external view returns (uint256 totalTokensIssued);
1059	 function transfer(address to, uint256 value) external returns (bool success);
1060	 function transferAndCall( address to, uint256 value, bytes calldata data ) external returns (bool success);
1061	 function transferFrom( address from, address to, uint256 value ) external returns (bool success);
1062	 }
1063	 pragma solidity ^0.8.0;
1064	 library StringsUpgradeable {
1065	 bytes16 private constant _SYMBOLS = "0123456789abcdef";
1066	 uint8 private constant _ADDRESS_LENGTH = 20;
1067	 function toString(uint256 value) internal pure returns (string memory) {
1068	 unchecked {
1069	 uint256 length = MathUpgradeable.log10(value) + 1;
1070	 string memory buffer = new string(length);
1071	 uint256 ptr;
1072	 assembly {
1073	 ptr := add(buffer, add(32, length)) }
1074	 while (true) {
1075	 ptr--;
1076	 assembly {
1077	 mstore8(ptr, byte(mod(value, 10), _SYMBOLS)) }
1078	 value /= 10;
1079	 if (value == 0) break;
1080	 }
1081	 return buffer;
1082	 }
1083	 }
1084	 function toHexString(uint256 value) internal pure returns (string memory) {
1085	 unchecked {
1086	 return toHexString(value, MathUpgradeable.log256(value) + 1);
1087	 }
1088	 }
1089	 function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
1090	 bytes memory buffer = new bytes(2 * length + 2);
1091	 buffer[0] = "0";
1092	 buffer[1] = "x";
1093	 for (uint256 i = 2 * length + 1; i > 1; --i) {
1094	 buffer[i] = _SYMBOLS[value & 0xf];
1095	 value >>= 4;
1096	 }
1097	 require(value == 0, "Strings: hex length insufficient");
1098	 return string(buffer);
1099	 }
1100	 function toHexString(address addr) internal pure returns (string memory) {
1101	 return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);
1102	 }
1103	 }
1104	 pragma solidity ^0.8.0;
1105	 interface IERC721ReceiverUpgradeable {
1106	 function onERC721Received( address operator, address from, uint256 tokenId, bytes calldata data ) external returns (bytes4);
1107	 }
1108	 pragma solidity ^0.8.0;
1109	 library MathUpgradeable {
1110	 enum Rounding {
1111	 Down, Up, Zero }
1112	 function max(uint256 a, uint256 b) internal pure returns (uint256) {
1113	 return a > b ? a : b;
1114	 }
1115	 function min(uint256 a, uint256 b) internal pure returns (uint256) {
1116	 return a < b ? a : b;
1117	 }
1118	 function average(uint256 a, uint256 b) internal pure returns (uint256) {
1119	 return (a & b) + (a ^ b) / 2;
1120	 }
1121	 function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
1122	 return a == 0 ? 0 : (a - 1) / b + 1;
1123	 }
1124	 function mulDiv( uint256 x, uint256 y, uint256 denominator ) internal pure returns (uint256 result) {
1125	 unchecked {
1126	 uint256 prod0;
1127	 uint256 prod1;
1128	 assembly {
1129	 let mm := mulmod(x, y, not(0)) prod0 := mul(x, y) prod1 := sub(sub(mm, prod0), lt(mm, prod0)) }
1130	 if (prod1 == 0) {
1131	 return prod0 / denominator;
1132	 }
1133	 require(denominator > prod1);
1134	 uint256 remainder;
1135	 assembly {
1136	 remainder := mulmod(x, y, denominator) prod1 := sub(prod1, gt(remainder, prod0)) prod0 := sub(prod0, remainder) }
1137	 uint256 twos = denominator & (~denominator + 1);
1138	 assembly {
1139	 denominator := div(denominator, twos) prod0 := div(prod0, twos) twos := add(div(sub(0, twos), twos), 1) }
1140	 prod0 |= prod1 * twos;
1141	 uint256 inverse = (3 * denominator) ^ 2;
1142	 inverse *= 2 - denominator * inverse;
1143	 inverse *= 2 - denominator * inverse;
1144	 inverse *= 2 - denominator * inverse;
1145	 inverse *= 2 - denominator * inverse;
1146	 inverse *= 2 - denominator * inverse;
1147	 inverse *= 2 - denominator * inverse;
1148	 result = prod0 * inverse;
1149	 return result;
1150	 }
1151	 }
1152	 function mulDiv( uint256 x, uint256 y, uint256 denominator, Rounding rounding ) internal pure returns (uint256) {
1153	 uint256 result = mulDiv(x, y, denominator);
1154	 if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
1155	 result += 1;
1156	 }
1157	 return result;
1158	 }
1159	 function sqrt(uint256 a) internal pure returns (uint256) {
1160	 if (a == 0) {
1161	 return 0;
1162	 }
1163	 uint256 result = 1 << (log2(a) >> 1);
1164	 unchecked {
1165	 result = (result + a / result) >> 1;
1166	 result = (result + a / result) >> 1;
1167	 result = (result + a / result) >> 1;
1168	 result = (result + a / result) >> 1;
1169	 result = (result + a / result) >> 1;
1170	 result = (result + a / result) >> 1;
1171	 result = (result + a / result) >> 1;
1172	 return min(result, a / result);
1173	 }
1174	 }
1175	 function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
1176	 unchecked {
1177	 uint256 result = sqrt(a);
1178	 return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);
1179	 }
1180	 }
1181	 function log2(uint256 value) internal pure returns (uint256) {
1182	 uint256 result = 0;
1183	 unchecked {
1184	 if (value >> 128 > 0) {
1185	 value >>= 128;
1186	 result += 128;
1187	 }
1188	 if (value >> 64 > 0) {
1189	 value >>= 64;
1190	 result += 64;
1191	 }
1192	 if (value >> 32 > 0) {
1193	 value >>= 32;
1194	 result += 32;
1195	 }
1196	 if (value >> 16 > 0) {
1197	 value >>= 16;
1198	 result += 16;
1199	 }
1200	 if (value >> 8 > 0) {
1201	 value >>= 8;
1202	 result += 8;
1203	 }
1204	 if (value >> 4 > 0) {
1205	 value >>= 4;
1206	 result += 4;
1207	 }
1208	 if (value >> 2 > 0) {
1209	 value >>= 2;
1210	 result += 2;
1211	 }
1212	 if (value >> 1 > 0) {
1213	 result += 1;
1214	 }
1215	 }
1216	 return result;
1217	 }
1218	 function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
1219	 unchecked {
1220	 uint256 result = log2(value);
1221	 return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);
1222	 }
1223	 }
1224	 function log10(uint256 value) internal pure returns (uint256) {
1225	 uint256 result = 0;
1226	 unchecked {
1227	 if (value >= 10**64) {
1228	 value /= 10**64;
1229	 result += 64;
1230	 }
1231	 if (value >= 10**32) {
1232	 value /= 10**32;
1233	 result += 32;
1234	 }
1235	 if (value >= 10**16) {
1236	 value /= 10**16;
1237	 result += 16;
1238	 }
1239	 if (value >= 10**8) {
1240	 value /= 10**8;
1241	 result += 8;
1242	 }
1243	 if (value >= 10**4) {
1244	 value /= 10**4;
1245	 result += 4;
1246	 }
1247	 if (value >= 10**2) {
1248	 value /= 10**2;
1249	 result += 2;
1250	 }
1251	 if (value >= 10**1) {
1252	 result += 1;
1253	 }
1254	 }
1255	 return result;
1256	 }
1257	 function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
1258	 unchecked {
1259	 uint256 result = log10(value);
1260	 return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);
1261	 }
1262	 }
1263	 function log256(uint256 value) internal pure returns (uint256) {
1264	 uint256 result = 0;
1265	 unchecked {
1266	 if (value >> 128 > 0) {
1267	 value >>= 128;
1268	 result += 16;
1269	 }
1270	 if (value >> 64 > 0) {
1271	 value >>= 64;
1272	 result += 8;
1273	 }
1274	 if (value >> 32 > 0) {
1275	 value >>= 32;
1276	 result += 4;
1277	 }
1278	 if (value >> 16 > 0) {
1279	 value >>= 16;
1280	 result += 2;
1281	 }
1282	 if (value >> 8 > 0) {
1283	 result += 1;
1284	 }
1285	 }
1286	 return result;
1287	 }
1288	 function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
1289	 unchecked {
1290	 uint256 result = log256(value);
1291	 return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);
1292	 }
1293	 }
1294	 }
