row number 
1	  pragma experimental ABIEncoderV2;
2	 struct AppStorage {
3	 uint8 index;
4	 int8[32] cases;
5	 bool paused;
6	 uint128 pausedAt;
7	 Storage.Season season;
8	 Storage.Contracts c;
9	 Storage.Field f;
10	 Storage.Governance g;
11	 Storage.Oracle co;
12	 Storage.Rain r;
13	 Storage.Silo s;
14	 uint256 reentrantStatus;
15	 Storage.Weather w;
16	 uint256 earnedBeans;
17	 uint256[14] depreciated;
18	 mapping (address => Account.State) a;
19	 uint32 bip0Start;
20	 uint32 hotFix3Start;
21	 mapping (uint32 => Storage.Fundraiser) fundraisers;
22	 uint32 fundraiserIndex;
23	 mapping (address => bool) isBudget;
24	 mapping(uint256 => bytes32) podListings;
25	 mapping(bytes32 => uint256) podOrders;
26	 mapping(address => Storage.AssetSilo) siloBalances;
27	 mapping(address => Storage.SiloSettings) ss;
28	 uint256[3] depreciated2;
29	 mapping (uint32 => uint256) sops;
30	 mapping(address => mapping(IERC20 => uint256)) internalTokenBalance;
31	 mapping(address => mapping(address => bool)) unripeClaimed;
32	 mapping(address => Storage.UnripeSettings) u;
33	 mapping(uint128 => uint256) fertilizer;
34	 mapping(uint128 => uint128) nextFid;
35	 uint256 activeFertilizer;
36	 uint256 fertilizedIndex;
37	 uint256 unfertilizedIndex;
38	 uint128 fFirst;
39	 uint128 fLast;
40	 uint128 bpf;
41	 uint256 recapitalized;
42	 uint256 isFarm;
43	 address ownerCandidate;
44	 }
45	 pragma solidity =0.7.6;
46	 abstract contract ReentrancyGuard {
47	 uint256 private constant _NOT_ENTERED = 1;
48	 uint256 private constant _ENTERED = 2;
49	 AppStorage internal s;
50	 modifier nonReentrant() {
51	 require(s.reentrantStatus != _ENTERED, "ReentrancyGuard: reentrant call");
52	 s.reentrantStatus = _ENTERED;
53	 _;
54	 s.reentrantStatus = _NOT_ENTERED;
55	 }
56	 }
57	 pragma solidity >=0.6.0 <0.8.0;
58	 interface IERC20 {
59	 function totalSupply() external view returns (uint256);
60	 function balanceOf(address account) external view returns (uint256);
61	 function transfer(address recipient, uint256 amount) external returns (bool);
62	 function allowance(address owner, address spender) external view returns (uint256);
63	 function approve(address spender, uint256 amount) external returns (bool);
64	 function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
65	 event Transfer(address indexed from, address indexed to, uint256 value);
66	 event Approval(address indexed owner, address indexed spender, uint256 value);
67	 }
68	 pragma solidity =0.7.6;
69	 contract TokenFacet is ReentrancyGuard {
70	 struct Balance {
71	 uint256 internalBalance;
72	 uint256 externalBalance;
73	 uint256 totalBalance;
74	 }
75	 using SafeERC20 for IERC20;
76	 using SafeMath for uint256;
77	 event InternalBalanceChanged( address indexed user, IERC20 indexed token, int256 delta );
78	 event TokenApproval( address indexed owner, address indexed spender, IERC20 token, uint256 amount );
79	 function transferToken( IERC20 token, address recipient, uint256 amount, LibTransfer.From fromMode, LibTransfer.To toMode ) external payable {
80	 LibTransfer.transferToken( token, msg.sender, recipient, amount, fromMode, toMode );
81	 }
82	 function transferInternalTokenFrom( IERC20 token, address sender, address recipient, uint256 amount, LibTransfer.To toMode ) external payable nonReentrant {
83	 LibTransfer.transferToken( token, sender, recipient, amount, LibTransfer.From.INTERNAL, toMode );
84	 if (sender != msg.sender) {
85	 LibTokenApprove.spendAllowance(sender, msg.sender, token, amount);
86	 }
87	 }
88	 function approveToken( address spender, IERC20 token, uint256 amount ) external payable nonReentrant {
89	 LibTokenApprove.approve(msg.sender, spender, token, amount);
90	 }
91	 function increaseTokenAllowance( address spender, IERC20 token, uint256 addedValue ) public virtual nonReentrant returns (bool) {
92	 LibTokenApprove.approve( msg.sender, spender, token, LibTokenApprove.allowance(msg.sender, spender, token).add(addedValue) );
93	 return true;
94	 }
95	 function tokenAllowance( address account, address spender, IERC20 token ) public view virtual returns (uint256) {
96	 return LibTokenApprove.allowance(account, spender, token);
97	 }
98	 function decreaseTokenAllowance( address spender, IERC20 token, uint256 subtractedValue ) public virtual nonReentrant returns (bool) {
99	 uint256 currentAllowance = LibTokenApprove.allowance( msg.sender, spender, token );
100	 require( currentAllowance >= subtractedValue, "Silo: decreased allowance below zero" );
101	 LibTokenApprove.approve( msg.sender, spender, token, currentAllowance.sub(subtractedValue) );
102	 return true;
103	 }
104	 function permitToken( address owner, address spender, address token, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s ) external payable nonReentrant {
105	 LibTokenPermit.permit(owner, spender, token, value, deadline, v, r, s);
106	 LibTokenApprove.approve(owner, spender, IERC20(token), value);
107	 }
108	 function tokenPermitNonces(address owner) public view virtual returns (uint256) {
109	 return LibTokenPermit.nonces(owner);
110	 }
111	 function tokenPermitDomainSeparator() external view returns (bytes32) {
112	 return LibTokenPermit._domainSeparatorV4();
113	 }
114	 function wrapEth(uint256 amount, LibTransfer.To mode) external payable {
115	 LibWeth.wrap(amount, mode);
116	 LibEth.refundEth();
117	 }
118	 function unwrapEth(uint256 amount, LibTransfer.From mode) external payable {
119	 LibWeth.unwrap(amount, mode);
120	 }
121	 function getInternalBalance(address account, IERC20 token) public view returns (uint256 balance) {
122	 balance = LibBalance.getInternalBalance(account, token);
123	 }
124	 function getInternalBalances(address account, IERC20[] memory tokens) external view returns (uint256[] memory balances) {
125	 balances = new uint256[](tokens.length);
126	 for (uint256 i; i < tokens.length; ++i) {
127	 balances[i] = getInternalBalance(account, tokens[i]);
128	 }
129	 }
130	 function getExternalBalance(address account, IERC20 token) public view returns (uint256 balance) {
131	 balance = token.balanceOf(account);
132	 }
133	 function getExternalBalances(address account, IERC20[] memory tokens) external view returns (uint256[] memory balances) {
134	 balances = new uint256[](tokens.length);
135	 for (uint256 i; i < tokens.length; ++i) {
136	 balances[i] = getExternalBalance(account, tokens[i]);
137	 }
138	 }
139	 function getBalance(address account, IERC20 token) public view returns (uint256 balance) {
140	 balance = LibBalance.getBalance(account, token);
141	 }
142	 function getBalances(address account, IERC20[] memory tokens) external view returns (uint256[] memory balances) {
143	 balances = new uint256[](tokens.length);
144	 for (uint256 i; i < tokens.length; ++i) {
145	 balances[i] = getBalance(account, tokens[i]);
146	 }
147	 }
148	 function getAllBalance(address account, IERC20 token) public view returns (Balance memory b) {
149	 b.internalBalance = getInternalBalance(account, token);
150	 b.externalBalance = getExternalBalance(account, token);
151	 b.totalBalance = b.internalBalance.add(b.externalBalance);
152	 }
153	 function getAllBalances(address account, IERC20[] memory tokens) external view returns (Balance[] memory balances) {
154	 balances = new Balance[](tokens.length);
155	 for (uint256 i; i < tokens.length; ++i) {
156	 balances[i] = getAllBalance(account, tokens[i]);
157	 }
158	 }
159	 }
160	 pragma solidity =0.7.6;
161	 contract Account {
162	 struct Field {
163	 mapping(uint256 => uint256) plots;
164	 mapping(address => uint256) podAllowances;
165	 }
166	 struct AssetSilo {
167	 mapping(uint32 => uint256) withdrawals;
168	 mapping(uint32 => uint256) deposits;
169	 mapping(uint32 => uint256) depositSeeds;
170	 }
171	 struct Deposit {
172	 uint128 amount;
173	 uint128 bdv;
174	 }
175	 struct Silo {
176	 uint256 stalk;
177	 uint256 seeds;
178	 }
179	 struct SeasonOfPlenty {
180	 uint256 roots;
181	 uint256 plentyPerRoot;
182	 uint256 plenty;
183	 }
184	 struct State {
185	 Field field;
186	 AssetSilo bean;
187	 AssetSilo lp;
188	 Silo s;
189	 uint32 votedUntil;
190	 uint32 lastUpdate;
191	 uint32 lastSop;
192	 uint32 lastRain;
193	 uint32 lastSIs;
194	 uint32 proposedUntil;
195	 SeasonOfPlenty deprecated;
196	 uint256 roots;
197	 uint256 wrappedBeans;
198	 mapping(address => mapping(uint32 => Deposit)) deposits;
199	 mapping(address => mapping(uint32 => uint256)) withdrawals;
200	 SeasonOfPlenty sop;
201	 mapping(address => mapping(address => uint256)) depositAllowances;
202	 mapping(address => mapping(IERC20 => uint256)) tokenAllowances;
203	 uint256 depositPermitNonces;
204	 uint256 tokenPermitNonces;
205	 }
206	 }
207	 contract Storage {
208	 struct Contracts {
209	 address bean;
210	 address pair;
211	 address pegPair;
212	 address weth;
213	 }
214	 struct Field {
215	 uint256 soil;
216	 uint256 pods;
217	 uint256 harvested;
218	 uint256 harvestable;
219	 }
220	 struct Bip {
221	 address proposer;
222	 uint32 start;
223	 uint32 period;
224	 bool executed;
225	 int pauseOrUnpause;
226	 uint128 timestamp;
227	 uint256 roots;
228	 uint256 endTotalRoots;
229	 }
230	 struct DiamondCut {
231	 IDiamondCut.FacetCut[] diamondCut;
232	 address initAddress;
233	 bytes initData;
234	 }
235	 struct Governance {
236	 uint32[] activeBips;
237	 uint32 bipIndex;
238	 mapping(uint32 => DiamondCut) diamondCuts;
239	 mapping(uint32 => mapping(address => bool)) voted;
240	 mapping(uint32 => Bip) bips;
241	 }
242	 struct AssetSilo {
243	 uint256 deposited;
244	 uint256 withdrawn;
245	 }
246	 struct Silo {
247	 uint256 stalk;
248	 uint256 seeds;
249	 uint256 roots;
250	 }
251	 struct Oracle {
252	 bool initialized;
253	 uint32 startSeason;
254	 uint256[2] balances;
255	 uint256 timestamp;
256	 }
257	 struct Rain {
258	 uint256 depreciated;
259	 uint256 pods;
260	 uint256 roots;
261	 }
262	 struct Season {
263	 uint32 current;
264	 uint32 lastSop;
265	 uint8 withdrawSeasons;
266	 uint32 lastSopSeason;
267	 uint32 rainStart;
268	 bool raining;
269	 bool fertilizing;
270	 uint256 start;
271	 uint256 period;
272	 uint256 timestamp;
273	 }
274	 struct Weather {
275	 uint256 startSoil;
276	 uint256 lastDSoil;
277	 uint96 lastSoilPercent;
278	 uint32 lastSowTime;
279	 uint32 nextSowTime;
280	 uint32 yield;
281	 bool didSowBelowMin;
282	 bool didSowFaster;
283	 }
284	 struct Fundraiser {
285	 address payee;
286	 address token;
287	 uint256 total;
288	 uint256 remaining;
289	 uint256 start;
290	 }
291	 struct SiloSettings {
292	 bytes4 selector;
293	 uint32 seeds;
294	 uint32 stalk;
295	 }
296	 struct UnripeSettings {
297	 address underlyingToken;
298	 uint256 balanceOfUnderlying;
299	 bytes32 merkleRoot;
300	 }
301	 }
302	 pragma solidity =0.7.6;
303	 library LibTransfer {
304	 using SafeERC20 for IERC20;
305	 using SafeMath for uint256;
306	 enum From {
307	 EXTERNAL, INTERNAL, EXTERNAL_INTERNAL, INTERNAL_TOLERANT }
308	 enum To {
309	 EXTERNAL, INTERNAL }
310	 function transferToken( IERC20 token, address sender, address recipient, uint256 amount, From fromMode, To toMode ) internal returns (uint256 transferredAmount) {
311	 if (fromMode == From.EXTERNAL && toMode == To.EXTERNAL) {
312	 uint256 beforeBalance = token.balanceOf(recipient);
313	 token.safeTransferFrom(sender, recipient, amount);
314	 return token.balanceOf(recipient).sub(beforeBalance);
315	 }
316	 amount = receiveToken(token, amount, sender, fromMode);
317	 sendToken(token, amount, recipient, toMode);
318	 return amount;
319	 }
320	 function receiveToken( IERC20 token, uint256 amount, address sender, From mode ) internal returns (uint256 receivedAmount) {
321	 if (amount == 0) return 0;
322	 if (mode != From.EXTERNAL) {
323	 receivedAmount = LibBalance.decreaseInternalBalance( sender, token, amount, mode != From.INTERNAL );
324	 if (amount == receivedAmount || mode == From.INTERNAL_TOLERANT) return receivedAmount;
325	 }
326	 uint256 beforeBalance = token.balanceOf(address(this));
327	 token.safeTransferFrom(sender, address(this), amount - receivedAmount);
328	 return receivedAmount.add(token.balanceOf(address(this)).sub(beforeBalance));
329	 }
330	 function sendToken( IERC20 token, uint256 amount, address recipient, To mode ) internal {
331	 if (amount == 0) return;
332	 if (mode == To.INTERNAL) LibBalance.increaseInternalBalance(recipient, token, amount);
333	 else token.safeTransfer(recipient, amount);
334	 }
335	 function burnToken( IBean token, uint256 amount, address sender, From mode ) internal returns (uint256 burnt) {
336	 if (mode == From.EXTERNAL) {
337	 token.burnFrom(sender, amount);
338	 burnt = amount;
339	 }
340	 else {
341	 burnt = LibTransfer.receiveToken(token, amount, sender, mode);
342	 token.burn(burnt);
343	 }
344	 }
345	 }
346	 pragma solidity =0.7.6;
347	 library LibTokenPermit {
348	 bytes32 private constant TOKEN_PERMIT_HASHED_NAME = keccak256(bytes("Token"));
349	 bytes32 private constant TOKEN_PERMIT_HASHED_VERSION = keccak256(bytes("1"));
350	 bytes32 private constant TOKEN_PERMIT_EIP712_TYPE_HASH = keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");
351	 bytes32 private constant TOKEN_PERMIT_TYPEHASH = keccak256("Permit(address owner,address spender,address token,uint256 value,uint256 nonce,uint256 deadline)");
352	 function permit( address owner, address spender, address token, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s ) internal {
353	 require(block.timestamp <= deadline, "Token: permit expired deadline");
354	 bytes32 structHash = keccak256(abi.encode(TOKEN_PERMIT_TYPEHASH, owner, spender, token, value, _useNonce(owner), deadline));
355	 bytes32 hash = _hashTypedDataV4(structHash);
356	 address signer = ECDSA.recover(hash, v, r, s);
357	 require(signer == owner, "Token: permit invalid signature");
358	 }
359	 function nonces(address owner) internal view returns (uint256) {
360	 AppStorage storage s = LibAppStorage.diamondStorage();
361	 return s.a[owner].tokenPermitNonces;
362	 }
363	 function _useNonce(address owner) internal returns (uint256 current) {
364	 AppStorage storage s = LibAppStorage.diamondStorage();
365	 current = s.a[owner].tokenPermitNonces;
366	 ++s.a[owner].tokenPermitNonces;
367	 }
368	 function _domainSeparatorV4() internal view returns (bytes32) {
369	 return _buildDomainSeparator(TOKEN_PERMIT_EIP712_TYPE_HASH, TOKEN_PERMIT_HASHED_NAME, TOKEN_PERMIT_HASHED_VERSION);
370	 }
371	 function _buildDomainSeparator(bytes32 typeHash, bytes32 name, bytes32 version) internal view returns (bytes32) {
372	 return keccak256( abi.encode( typeHash, name, version, C.getChainId(), address(this) ) );
373	 }
374	 function _hashTypedDataV4(bytes32 structHash) internal view returns (bytes32) {
375	 return keccak256(abi.encodePacked("\x19\x01", _domainSeparatorV4(), structHash));
376	 }
377	 }
378	 pragma solidity =0.7.6;
379	 library LibWeth {
380	 address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
381	 function wrap(uint256 amount, LibTransfer.To mode) internal {
382	 deposit(amount);
383	 LibTransfer.sendToken(IERC20(WETH), amount, msg.sender, mode);
384	 }
385	 function unwrap(uint256 amount, LibTransfer.From mode) internal {
386	 amount = LibTransfer.receiveToken(IERC20(WETH), amount, msg.sender, mode);
387	 withdraw(amount);
388	 (bool success, ) = msg.sender.call{
389	 value: amount}
390	 (new bytes(0));
391	 require(success, "Weth: unwrap failed");
392	 }
393	 function deposit(uint256 amount) private {
394	 IWETH(WETH).deposit{
395	 value: amount}
396	 ();
397	 }
398	 function withdraw(uint256 amount) private {
399	 IWETH(WETH).withdraw(amount);
400	 }
401	 }
402	 pragma solidity =0.7.6;
403	 library LibTokenApprove {
404	 event TokenApproval( address indexed owner, address indexed spender, IERC20 token, uint256 amount );
405	 function approve( address account, address spender, IERC20 token, uint256 amount ) internal {
406	 AppStorage storage s = LibAppStorage.diamondStorage();
407	 s.a[account].tokenAllowances[spender][token] = amount;
408	 emit TokenApproval(account, spender, token, amount);
409	 }
410	 function allowance( address account, address spender, IERC20 token ) internal view returns (uint256) {
411	 AppStorage storage s = LibAppStorage.diamondStorage();
412	 return s.a[account].tokenAllowances[spender][token];
413	 }
414	 function spendAllowance( address owner, address spender, IERC20 token, uint256 amount ) internal {
415	 uint256 currentAllowance = allowance(owner, spender, token);
416	 if (currentAllowance != type(uint256).max) {
417	 require( currentAllowance >= amount, "Token: insufficient allowance" );
418	 approve(owner, spender, token, currentAllowance - amount);
419	 }
420	 }
421	 }
422	 pragma solidity ^0.7.6;
423	 library LibEth {
424	 function refundEth() internal {
425	 AppStorage storage s = LibAppStorage.diamondStorage();
426	 if (address(this).balance > 0 && s.isFarm != 2) {
427	 (bool success, ) = msg.sender.call{
428	 value: address(this).balance}
429	 ( new bytes(0) );
430	 require(success, "Eth transfer Failed.");
431	 }
432	 }
433	 }
434	 pragma solidity =0.7.6;
435	 interface IDiamondCut {
436	 enum FacetCutAction {
437	 Add, Replace, Remove}
438	 struct FacetCut {
439	 address facetAddress;
440	 FacetCutAction action;
441	 bytes4[] functionSelectors;
442	 }
443	 function diamondCut( FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata ) external;
444	 event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);
445	 }
446	 pragma solidity >=0.6.0 <0.8.0;
447	 library Counters {
448	 using SafeMath for uint256;
449	 struct Counter {
450	 uint256 _value;
451	 }
452	 function current(Counter storage counter) internal view returns (uint256) {
453	 return counter._value;
454	 }
455	 function increment(Counter storage counter) internal {
456	 counter._value += 1;
457	 }
458	 function decrement(Counter storage counter) internal {
459	 counter._value = counter._value.sub(1);
460	 }
461	 }
462	 pragma solidity >=0.6.0 <0.8.0;
463	 library SafeMath {
464	 function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
465	 uint256 c = a + b;
466	 if (c < a) return (false, 0);
467	 return (true, c);
468	 }
469	 function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
470	 if (b > a) return (false, 0);
471	 return (true, a - b);
472	 }
473	 function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
474	 if (a == 0) return (true, 0);
475	 uint256 c = a * b;
476	 if (c / a != b) return (false, 0);
477	 return (true, c);
478	 }
479	 function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
480	 if (b == 0) return (false, 0);
481	 return (true, a / b);
482	 }
483	 function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
484	 if (b == 0) return (false, 0);
485	 return (true, a % b);
486	 }
487	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
488	 uint256 c = a + b;
489	 require(c >= a, "SafeMath: addition overflow");
490	 return c;
491	 }
492	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
493	 require(b <= a, "SafeMath: subtraction overflow");
494	 return a - b;
495	 }
496	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
497	 if (a == 0) return 0;
498	 uint256 c = a * b;
499	 require(c / a == b, "SafeMath: multiplication overflow");
500	 return c;
501	 }
502	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
503	 require(b > 0, "SafeMath: division by zero");
504	 return a / b;
505	 }
506	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
507	 require(b > 0, "SafeMath: modulo by zero");
508	 return a % b;
509	 }
510	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
511	 require(b <= a, errorMessage);
512	 return a - b;
513	 }
514	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
515	 require(b > 0, errorMessage);
516	 return a / b;
517	 }
518	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
519	 require(b > 0, errorMessage);
520	 return a % b;
521	 }
522	 }
523	 pragma solidity =0.7.6;
524	 abstract contract IBean is IERC20 {
525	 function burn(uint256 amount) public virtual;
526	 function burnFrom(address account, uint256 amount) public virtual;
527	 function mint(address account, uint256 amount) public virtual;
528	 }
529	 pragma solidity ^0.7.6;
530	 library LibBalance {
531	 using SafeERC20 for IERC20;
532	 using SafeMath for uint256;
533	 using SafeCast for uint256;
534	 event InternalBalanceChanged( address indexed account, IERC20 indexed token, int256 delta );
535	 function getBalance(address account, IERC20 token) internal view returns (uint256 combined_balance) {
536	 combined_balance = token.balanceOf(account).add( getInternalBalance(account, token) );
537	 return combined_balance;
538	 }
539	 function increaseInternalBalance( address account, IERC20 token, uint256 amount ) internal {
540	 uint256 currentBalance = getInternalBalance(account, token);
541	 uint256 newBalance = currentBalance.add(amount);
542	 setInternalBalance(account, token, newBalance, amount.toInt256());
543	 }
544	 function decreaseInternalBalance( address account, IERC20 token, uint256 amount, bool allowPartial ) internal returns (uint256 deducted) {
545	 uint256 currentBalance = getInternalBalance(account, token);
546	 require( allowPartial || (currentBalance >= amount), "Balance: Insufficient internal balance" );
547	 deducted = Math.min(currentBalance, amount);
548	 uint256 newBalance = currentBalance - deducted;
549	 setInternalBalance(account, token, newBalance, -(deducted.toInt256()));
550	 }
551	 function setInternalBalance( address account, IERC20 token, uint256 newBalance, int256 delta ) private {
552	 AppStorage storage s = LibAppStorage.diamondStorage();
553	 s.internalTokenBalance[account][token] = newBalance;
554	 emit InternalBalanceChanged(account, token, delta);
555	 }
556	 function getInternalBalance(address account, IERC20 token) internal view returns (uint256) {
557	 AppStorage storage s = LibAppStorage.diamondStorage();
558	 return s.internalTokenBalance[account][token];
559	 }
560	 }
561	 pragma solidity >=0.6.0 <0.8.0;
562	 library SafeERC20 {
563	 using SafeMath for uint256;
564	 using Address for address;
565	 function safeTransfer(IERC20 token, address to, uint256 value) internal {
566	 _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
567	 }
568	 function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
569	 _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
570	 }
571	 function safeApprove(IERC20 token, address spender, uint256 value) internal {
572	 require((value == 0) || (token.allowance(address(this), spender) == 0), "SafeERC20: approve from non-zero to non-zero allowance" );
573	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
574	 }
575	 function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
576	 uint256 newAllowance = token.allowance(address(this), spender).add(value);
577	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
578	 }
579	 function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
580	 uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
581	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
582	 }
583	 function _callOptionalReturn(IERC20 token, bytes memory data) private {
584	 bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
585	 if (returndata.length > 0) {
586	 require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
587	 }
588	 }
589	 }
590	 pragma solidity =0.7.6;
591	 library LibAppStorage {
592	 function diamondStorage() internal pure returns (AppStorage storage ds) {
593	 assembly {
594	 ds.slot := 0 }
595	 }
596	 }
597	 pragma solidity >=0.6.0 <0.8.0;
598	 library SafeCast {
599	 function toUint128(uint256 value) internal pure returns (uint128) {
600	 require(value < 2**128, "SafeCast: value doesn\'t fit in 128 bits");
601	 return uint128(value);
602	 }
603	 function toUint64(uint256 value) internal pure returns (uint64) {
604	 require(value < 2**64, "SafeCast: value doesn\'t fit in 64 bits");
605	 return uint64(value);
606	 }
607	 function toUint32(uint256 value) internal pure returns (uint32) {
608	 require(value < 2**32, "SafeCast: value doesn\'t fit in 32 bits");
609	 return uint32(value);
610	 }
611	 function toUint16(uint256 value) internal pure returns (uint16) {
612	 require(value < 2**16, "SafeCast: value doesn\'t fit in 16 bits");
613	 return uint16(value);
614	 }
615	 function toUint8(uint256 value) internal pure returns (uint8) {
616	 require(value < 2**8, "SafeCast: value doesn\'t fit in 8 bits");
617	 return uint8(value);
618	 }
619	 function toUint256(int256 value) internal pure returns (uint256) {
620	 require(value >= 0, "SafeCast: value must be positive");
621	 return uint256(value);
622	 }
623	 function toInt128(int256 value) internal pure returns (int128) {
624	 require(value >= -2**127 && value < 2**127, "SafeCast: value doesn\'t fit in 128 bits");
625	 return int128(value);
626	 }
627	 function toInt64(int256 value) internal pure returns (int64) {
628	 require(value >= -2**63 && value < 2**63, "SafeCast: value doesn\'t fit in 64 bits");
629	 return int64(value);
630	 }
631	 function toInt32(int256 value) internal pure returns (int32) {
632	 require(value >= -2**31 && value < 2**31, "SafeCast: value doesn\'t fit in 32 bits");
633	 return int32(value);
634	 }
635	 function toInt16(int256 value) internal pure returns (int16) {
636	 require(value >= -2**15 && value < 2**15, "SafeCast: value doesn\'t fit in 16 bits");
637	 return int16(value);
638	 }
639	 function toInt8(int256 value) internal pure returns (int8) {
640	 require(value >= -2**7 && value < 2**7, "SafeCast: value doesn\'t fit in 8 bits");
641	 return int8(value);
642	 }
643	 function toInt256(uint256 value) internal pure returns (int256) {
644	 require(value < 2**255, "SafeCast: value doesn't fit in an int256");
645	 return int256(value);
646	 }
647	 }
648	 pragma solidity >=0.6.0 <0.8.0;
649	 library Math {
650	 function max(uint256 a, uint256 b) internal pure returns (uint256) {
651	 return a >= b ? a : b;
652	 }
653	 function min(uint256 a, uint256 b) internal pure returns (uint256) {
654	 return a < b ? a : b;
655	 }
656	 function average(uint256 a, uint256 b) internal pure returns (uint256) {
657	 return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);
658	 }
659	 }
660	 pragma solidity >=0.6.2 <0.8.0;
661	 library Address {
662	 function isContract(address account) internal view returns (bool) {
663	 uint256 size;
664	 assembly {
665	 size := extcodesize(account) }
666	 return size > 0;
667	 }
668	 function sendValue(address payable recipient, uint256 amount) internal {
669	 require(address(this).balance >= amount, "Address: insufficient balance");
670	 (bool success, ) = recipient.call{
671	 value: amount }
672	 ("");
673	 require(success, "Address: unable to send value, recipient may have reverted");
674	 }
675	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
676	 return functionCall(target, data, "Address: low-level call failed");
677	 }
678	 function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
679	 return functionCallWithValue(target, data, 0, errorMessage);
680	 }
681	 function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
682	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
683	 }
684	 function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
685	 require(address(this).balance >= value, "Address: insufficient balance for call");
686	 require(isContract(target), "Address: call to non-contract");
687	 (bool success, bytes memory returndata) = target.call{
688	 value: value }
689	 (data);
690	 return _verifyCallResult(success, returndata, errorMessage);
691	 }
692	 function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
693	 return functionStaticCall(target, data, "Address: low-level static call failed");
694	 }
695	 function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
696	 require(isContract(target), "Address: static call to non-contract");
697	 (bool success, bytes memory returndata) = target.staticcall(data);
698	 return _verifyCallResult(success, returndata, errorMessage);
699	 }
700	 function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
701	 return functionDelegateCall(target, data, "Address: low-level delegate call failed");
702	 }
703	 function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
704	 require(isContract(target), "Address: delegate call to non-contract");
705	 (bool success, bytes memory returndata) = target.delegatecall(data);
706	 return _verifyCallResult(success, returndata, errorMessage);
707	 }
708	 function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
709	 if (success) {
710	 return returndata;
711	 }
712	 else {
713	 if (returndata.length > 0) {
714	 assembly {
715	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
716	 }
717	 else {
718	 revert(errorMessage);
719	 }
720	 }
721	 }
722	 }
723	 pragma solidity =0.7.6;
724	 library C {
725	 using Decimal for Decimal.D256;
726	 using SafeMath for uint256;
727	 uint256 private constant PERCENT_BASE = 1e18;
728	 uint256 private constant PRECISION = 1e18;
729	 uint256 private constant CHAIN_ID = 1;
730	 uint256 private constant CURRENT_SEASON_PERIOD = 3600;
731	 uint256 private constant BASE_ADVANCE_INCENTIVE = 100e6;
732	 uint256 private constant SOP_PRECISION = 1e24;
733	 uint256 private constant FERTILIZER_DENOMINATOR = 3;
734	 uint256 private constant HARVEST_DENOMINATOR = 2;
735	 uint256 private constant SOIL_COEFFICIENT_HIGH = 0.5e18;
736	 uint256 private constant SOIL_COEFFICIENT_LOW = 1.5e18;
737	 uint256 private constant POD_RATE_LOWER_BOUND = 0.05e18;
738	 uint256 private constant OPTIMAL_POD_RATE = 0.15e18;
739	 uint256 private constant POD_RATE_UPPER_BOUND = 0.25e18;
740	 uint32 private constant STEADY_SOW_TIME = 60;
741	 uint256 private constant DELTA_POD_DEMAND_LOWER_BOUND = 0.95e18;
742	 uint256 private constant DELTA_POD_DEMAND_UPPER_BOUND = 1.05e18;
743	 uint256 private constant SEEDS_PER_BEAN = 2;
744	 uint256 private constant STALK_PER_BEAN = 10000;
745	 uint256 private constant ROOTS_BASE = 1e12;
746	 uint256 private constant UNRIPE_LP_PER_DOLLAR = 1884592;
747	 uint256 private constant ADD_LP_RATIO = 866616;
748	 uint256 private constant INITIAL_HAIRCUT = 185564685220298701;
749	 address private constant BEAN = 0xBEA0000029AD1c77D3d5D23Ba2D8893dB9d1Efab;
750	 address private constant CURVE_BEAN_METAPOOL = 0xc9C32cd16Bf7eFB85Ff14e0c8603cc90F6F2eE49;
751	 address private constant CURVE_3_POOL = 0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7;
752	 address private constant THREE_CRV = 0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490;
753	 address private constant UNRIPE_BEAN = 0x1BEA0050E63e05FBb5D8BA2f10cf5800B6224449;
754	 address private constant UNRIPE_LP = 0x1BEA3CcD22F4EBd3d37d731BA31Eeca95713716D;
755	 address private constant FERTILIZER = 0x402c84De2Ce49aF88f5e2eF3710ff89bFED36cB6;
756	 address private constant FERTILIZER_ADMIN = 0xfECB01359263C12Aa9eD838F878A596F0064aa6e;
757	 address private constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
758	 address private constant TRI_CRYPTO = 0xc4AD29ba4B3c580e6D59105FFf484999997675Ff;
759	 address private constant TRI_CRYPTO_POOL = 0xD51a44d3FaE010294C616388b506AcdA1bfAAE46;
760	 address private constant CURVE_ZAP = 0xA79828DF1850E8a3A3064576f380D90aECDD3359;
761	 address private constant UNRIPE_CURVE_BEAN_LUSD_POOL = 0xD652c40fBb3f06d6B58Cb9aa9CFF063eE63d465D;
762	 address private constant UNRIPE_CURVE_BEAN_METAPOOL = 0x3a70DfA7d2262988064A2D051dd47521E43c9BdD;
763	 function getSeasonPeriod() internal pure returns (uint256) {
764	 return CURRENT_SEASON_PERIOD;
765	 }
766	 function getAdvanceIncentive() internal pure returns (uint256) {
767	 return BASE_ADVANCE_INCENTIVE;
768	 }
769	 function getFertilizerDenominator() internal pure returns (uint256) {
770	 return FERTILIZER_DENOMINATOR;
771	 }
772	 function getHarvestDenominator() internal pure returns (uint256) {
773	 return HARVEST_DENOMINATOR;
774	 }
775	 function getChainId() internal pure returns (uint256) {
776	 return CHAIN_ID;
777	 }
778	 function getOptimalPodRate() internal pure returns (Decimal.D256 memory) {
779	 return Decimal.ratio(OPTIMAL_POD_RATE, PERCENT_BASE);
780	 }
781	 function getUpperBoundPodRate() internal pure returns (Decimal.D256 memory) {
782	 return Decimal.ratio(POD_RATE_UPPER_BOUND, PERCENT_BASE);
783	 }
784	 function getLowerBoundPodRate() internal pure returns (Decimal.D256 memory) {
785	 return Decimal.ratio(POD_RATE_LOWER_BOUND, PERCENT_BASE);
786	 }
787	 function getUpperBoundDPD() internal pure returns (Decimal.D256 memory) {
788	 return Decimal.ratio(DELTA_POD_DEMAND_UPPER_BOUND, PERCENT_BASE);
789	 }
790	 function getLowerBoundDPD() internal pure returns (Decimal.D256 memory) {
791	 return Decimal.ratio(DELTA_POD_DEMAND_LOWER_BOUND, PERCENT_BASE);
792	 }
793	 function getSteadySowTime() internal pure returns (uint32) {
794	 return STEADY_SOW_TIME;
795	 }
796	 function getSeedsPerBean() internal pure returns (uint256) {
797	 return SEEDS_PER_BEAN;
798	 }
799	 function getStalkPerBean() internal pure returns (uint256) {
800	 return STALK_PER_BEAN;
801	 }
802	 function getRootsBase() internal pure returns (uint256) {
803	 return ROOTS_BASE;
804	 }
805	 function getSopPrecision() internal pure returns (uint256) {
806	 return SOP_PRECISION;
807	 }
808	 function beanAddress() internal pure returns (address) {
809	 return BEAN;
810	 }
811	 function curveMetapoolAddress() internal pure returns (address) {
812	 return CURVE_BEAN_METAPOOL;
813	 }
814	 function unripeLPPool1() internal pure returns (address) {
815	 return UNRIPE_CURVE_BEAN_METAPOOL;
816	 }
817	 function unripeLPPool2() internal pure returns (address) {
818	 return UNRIPE_CURVE_BEAN_LUSD_POOL;
819	 }
820	 function unripeBeanAddress() internal pure returns (address) {
821	 return UNRIPE_BEAN;
822	 }
823	 function unripeLPAddress() internal pure returns (address) {
824	 return UNRIPE_LP;
825	 }
826	 function unripeBean() internal pure returns (IERC20) {
827	 return IERC20(UNRIPE_BEAN);
828	 }
829	 function unripeLP() internal pure returns (IERC20) {
830	 return IERC20(UNRIPE_LP);
831	 }
832	 function bean() internal pure returns (IBean) {
833	 return IBean(BEAN);
834	 }
835	 function usdc() internal pure returns (IERC20) {
836	 return IERC20(USDC);
837	 }
838	 function curveMetapool() internal pure returns (ICurvePool) {
839	 return ICurvePool(CURVE_BEAN_METAPOOL);
840	 }
841	 function curve3Pool() internal pure returns (I3Curve) {
842	 return I3Curve(CURVE_3_POOL);
843	 }
844	 function curveZap() internal pure returns (ICurveZap) {
845	 return ICurveZap(CURVE_ZAP);
846	 }
847	 function curveZapAddress() internal pure returns (address) {
848	 return CURVE_ZAP;
849	 }
850	 function curve3PoolAddress() internal pure returns (address) {
851	 return CURVE_3_POOL;
852	 }
853	 function threeCrv() internal pure returns (IERC20) {
854	 return IERC20(THREE_CRV);
855	 }
856	 function fertilizer() internal pure returns (IFertilizer) {
857	 return IFertilizer(FERTILIZER);
858	 }
859	 function fertilizerAddress() internal pure returns (address) {
860	 return FERTILIZER;
861	 }
862	 function fertilizerAdmin() internal pure returns (IProxyAdmin) {
863	 return IProxyAdmin(FERTILIZER_ADMIN);
864	 }
865	 function triCryptoPoolAddress() internal pure returns (address) {
866	 return TRI_CRYPTO_POOL;
867	 }
868	 function triCrypto() internal pure returns (IERC20) {
869	 return IERC20(TRI_CRYPTO);
870	 }
871	 function unripeLPPerDollar() internal pure returns (uint256) {
872	 return UNRIPE_LP_PER_DOLLAR;
873	 }
874	 function dollarPerUnripeLP() internal pure returns (uint256) {
875	 return 1e12/UNRIPE_LP_PER_DOLLAR;
876	 }
877	 function exploitAddLPRatio() internal pure returns (uint256) {
878	 return ADD_LP_RATIO;
879	 }
880	 function precision() internal pure returns (uint256) {
881	 return PRECISION;
882	 }
883	 function initialRecap() internal pure returns (uint256) {
884	 return INITIAL_HAIRCUT;
885	 }
886	 function soilCoefficientHigh() internal pure returns (uint256) {
887	 return SOIL_COEFFICIENT_HIGH;
888	 }
889	 function soilCoefficientLow() internal pure returns (uint256) {
890	 return SOIL_COEFFICIENT_LOW;
891	 }
892	 }
893	 pragma solidity >=0.6.0 <0.8.0;
894	 library ECDSA {
895	 function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {
896	 if (signature.length != 65) {
897	 revert("ECDSA: invalid signature length");
898	 }
899	 bytes32 r;
900	 bytes32 s;
901	 uint8 v;
902	 assembly {
903	 r := mload(add(signature, 0x20)) s := mload(add(signature, 0x40)) v := byte(0, mload(add(signature, 0x60))) }
904	 return recover(hash, v, r, s);
905	 }
906	 function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {
907	 require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, "ECDSA: invalid signature 's' value");
908	 require(v == 27 || v == 28, "ECDSA: invalid signature 'v' value");
909	 address signer = ecrecover(hash, v, r, s);
910	 require(signer != address(0), "ECDSA: invalid signature");
911	 return signer;
912	 }
913	 function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {
914	 return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
915	 }
916	 }
917	 pragma solidity =0.7.6;
918	 interface IFertilizer {
919	 struct Balance {
920	 uint128 amount;
921	 uint128 lastBpf;
922	 }
923	 function beanstalkUpdate( address account, uint256[] memory ids, uint128 bpf ) external returns (uint256);
924	 function beanstalkMint(address account, uint256 id, uint128 amount, uint128 bpf) external;
925	 function balanceOfFertilized(address account, uint256[] memory ids) external view returns (uint256);
926	 function balanceOfUnfertilized(address account, uint256[] memory ids) external view returns (uint256);
927	 function lastBalanceOf(address account, uint256 id) external view returns (Balance memory);
928	 function lastBalanceOfBatch(address[] memory account, uint256[] memory id) external view returns (Balance[] memory);
929	 function setURI(string calldata newuri) external;
930	 }
931	 pragma solidity =0.7.6;
932	 interface ICurvePool {
933	 function A_precise() external view returns (uint256);
934	 function get_balances() external view returns (uint256[2] memory);
935	 function totalSupply() external view returns (uint256);
936	 function add_liquidity(uint256[2] memory amounts, uint256 min_mint_amount) external returns (uint256);
937	 function remove_liquidity_one_coin(uint256 _token_amount, int128 i, uint256 min_amount) external returns (uint256);
938	 function balances(int128 i) external view returns (uint256);
939	 function fee() external view returns (uint256);
940	 function coins(uint256 i) external view returns (address);
941	 function get_virtual_price() external view returns (uint256);
942	 function calc_token_amount(uint256[2] calldata amounts, bool deposit) external view returns (uint256);
943	 function calc_withdraw_one_coin(uint256 _token_amount, int128 i) external view returns (uint256);
944	 function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external returns (uint256);
945	 function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy) external returns (uint256);
946	 function transfer(address recipient, uint256 amount) external returns (bool);
947	 }
948	 interface ICurveZap {
949	 function add_liquidity(address _pool, uint256[4] memory _deposit_amounts, uint256 _min_mint_amount) external returns (uint256);
950	 function calc_token_amount(address _pool, uint256[4] memory _amounts, bool _is_deposit) external returns (uint256);
951	 }
952	 interface ICurvePoolR {
953	 function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);
954	 function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);
955	 function remove_liquidity_one_coin(uint256 _token_amount, int128 i, uint256 min_amount, address receiver) external returns (uint256);
956	 }
957	 interface ICurvePool2R {
958	 function add_liquidity(uint256[2] memory amounts, uint256 min_mint_amount, address reciever) external returns (uint256);
959	 function remove_liquidity(uint256 _burn_amount, uint256[2] memory _min_amounts, address reciever) external returns (uint256[2] calldata);
960	 function remove_liquidity_imbalance(uint256[2] memory _amounts, uint256 _max_burn_amount, address reciever) external returns (uint256);
961	 }
962	 interface ICurvePool3R {
963	 function add_liquidity(uint256[3] memory amounts, uint256 min_mint_amount, address reciever) external returns (uint256);
964	 function remove_liquidity(uint256 _burn_amount, uint256[3] memory _min_amounts, address reciever) external returns (uint256[3] calldata);
965	 function remove_liquidity_imbalance(uint256[3] memory _amounts, uint256 _max_burn_amount, address reciever) external returns (uint256);
966	 }
967	 interface ICurvePool4R {
968	 function add_liquidity(uint256[4] memory amounts, uint256 min_mint_amount, address reciever) external returns (uint256);
969	 function remove_liquidity(uint256 _burn_amount, uint256[4] memory _min_amounts, address reciever) external returns (uint256[4] calldata);
970	 function remove_liquidity_imbalance(uint256[4] memory _amounts, uint256 _max_burn_amount, address reciever) external returns (uint256);
971	 }
972	 interface I3Curve {
973	 function get_virtual_price() external view returns (uint256);
974	 }
975	 interface ICurveFactory {
976	 function get_coins(address _pool) external view returns (address[4] calldata);
977	 function get_underlying_coins(address _pool) external view returns (address[8] calldata);
978	 }
979	 interface ICurveCryptoFactory {
980	 function get_coins(address _pool) external view returns (address[8] calldata);
981	 }
982	 interface ICurvePoolC {
983	 function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external returns (uint256);
984	 }
985	 interface ICurvePoolNoReturn {
986	 function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external;
987	 function add_liquidity(uint256[3] memory amounts, uint256 min_mint_amount) external;
988	 function remove_liquidity(uint256 _burn_amount, uint256[3] memory _min_amounts) external;
989	 function remove_liquidity_imbalance(uint256[3] memory _amounts, uint256 _max_burn_amount) external;
990	 function remove_liquidity_one_coin(uint256 _token_amount, uint256 i, uint256 min_amount) external;
991	 }
992	 interface ICurvePoolNoReturn128 {
993	 function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external;
994	 function remove_liquidity_one_coin(uint256 _token_amount, int128 i, uint256 min_amount) external;
995	 }
996	 pragma solidity =0.7.6;
997	 interface IProxyAdmin {
998	 function upgrade(address proxy, address implementation) external;
999	 }
1000	 pragma solidity =0.7.6;
1001	 library Decimal {
1002	 using SafeMath for uint256;
1003	 uint256 constant BASE = 10**18;
1004	 struct D256 {
1005	 uint256 value;
1006	 }
1007	 function zero() internal pure returns (D256 memory) {
1008	 return D256({
1009	 value: 0 }
1010	 );
1011	 }
1012	 function one() internal pure returns (D256 memory) {
1013	 return D256({
1014	 value: BASE }
1015	 );
1016	 }
1017	 function from( uint256 a ) internal pure returns (D256 memory) {
1018	 return D256({
1019	 value: a.mul(BASE) }
1020	 );
1021	 }
1022	 function ratio( uint256 a, uint256 b ) internal pure returns (D256 memory) {
1023	 return D256({
1024	 value: getPartial(a, BASE, b) }
1025	 );
1026	 }
1027	 function add( D256 memory self, uint256 b ) internal pure returns (D256 memory) {
1028	 return D256({
1029	 value: self.value.add(b.mul(BASE)) }
1030	 );
1031	 }
1032	 function sub( D256 memory self, uint256 b ) internal pure returns (D256 memory) {
1033	 return D256({
1034	 value: self.value.sub(b.mul(BASE)) }
1035	 );
1036	 }
1037	 function sub( D256 memory self, uint256 b, string memory reason ) internal pure returns (D256 memory) {
1038	 return D256({
1039	 value: self.value.sub(b.mul(BASE), reason) }
1040	 );
1041	 }
1042	 function mul( D256 memory self, uint256 b ) internal pure returns (D256 memory) {
1043	 return D256({
1044	 value: self.value.mul(b) }
1045	 );
1046	 }
1047	 function div( D256 memory self, uint256 b ) internal pure returns (D256 memory) {
1048	 return D256({
1049	 value: self.value.div(b) }
1050	 );
1051	 }
1052	 function pow( D256 memory self, uint256 b ) internal pure returns (D256 memory) {
1053	 if (b == 0) {
1054	 return one();
1055	 }
1056	 D256 memory temp = D256({
1057	 value: self.value }
1058	 );
1059	 for (uint256 i = 1; i < b; ++i) {
1060	 temp = mul(temp, self);
1061	 }
1062	 return temp;
1063	 }
1064	 function add( D256 memory self, D256 memory b ) internal pure returns (D256 memory) {
1065	 return D256({
1066	 value: self.value.add(b.value) }
1067	 );
1068	 }
1069	 function sub( D256 memory self, D256 memory b ) internal pure returns (D256 memory) {
1070	 return D256({
1071	 value: self.value.sub(b.value) }
1072	 );
1073	 }
1074	 function sub( D256 memory self, D256 memory b, string memory reason ) internal pure returns (D256 memory) {
1075	 return D256({
1076	 value: self.value.sub(b.value, reason) }
1077	 );
1078	 }
1079	 function mul( D256 memory self, D256 memory b ) internal pure returns (D256 memory) {
1080	 return D256({
1081	 value: getPartial(self.value, b.value, BASE) }
1082	 );
1083	 }
1084	 function div( D256 memory self, D256 memory b ) internal pure returns (D256 memory) {
1085	 return D256({
1086	 value: getPartial(self.value, BASE, b.value) }
1087	 );
1088	 }
1089	 function equals(D256 memory self, D256 memory b) internal pure returns (bool) {
1090	 return self.value == b.value;
1091	 }
1092	 function greaterThan(D256 memory self, D256 memory b) internal pure returns (bool) {
1093	 return compareTo(self, b) == 2;
1094	 }
1095	 function lessThan(D256 memory self, D256 memory b) internal pure returns (bool) {
1096	 return compareTo(self, b) == 0;
1097	 }
1098	 function greaterThanOrEqualTo(D256 memory self, D256 memory b) internal pure returns (bool) {
1099	 return compareTo(self, b) > 0;
1100	 }
1101	 function lessThanOrEqualTo(D256 memory self, D256 memory b) internal pure returns (bool) {
1102	 return compareTo(self, b) < 2;
1103	 }
1104	 function isZero(D256 memory self) internal pure returns (bool) {
1105	 return self.value == 0;
1106	 }
1107	 function asUint256(D256 memory self) internal pure returns (uint256) {
1108	 return self.value.div(BASE);
1109	 }
1110	 function getPartial( uint256 target, uint256 numerator, uint256 denominator ) private pure returns (uint256) {
1111	 return target.mul(numerator).div(denominator);
1112	 }
1113	 function compareTo( D256 memory a, D256 memory b ) private pure returns (uint256) {
1114	 if (a.value == b.value) {
1115	 return 1;
1116	 }
1117	 return a.value > b.value ? 2 : 0;
1118	 }
1119	 }
1120	 pragma solidity ^0.7.6;
1121	 interface IWETH is IERC20 {
1122	 function deposit() external payable;
1123	 function withdraw(uint) external;
1124	 }
