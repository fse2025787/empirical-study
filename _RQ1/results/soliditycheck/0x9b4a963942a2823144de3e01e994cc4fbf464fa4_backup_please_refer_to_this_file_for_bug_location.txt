row number 
1	       pragma solidity >=0.5.0;
2	 interface IUniswapV3PoolImmutables {
3	 function factory() external view returns (address);
4	 function token0() external view returns (address);
5	 function token1() external view returns (address);
6	 function fee() external view returns (uint24);
7	 function tickSpacing() external view returns (int24);
8	 function maxLiquidityPerTick() external view returns (uint128);
9	 }
10	 pragma solidity >=0.5.0;
11	 interface IUniswapV3PoolState {
12	 function slot0() external view returns ( uint160 sqrtPriceX96, int24 tick, uint16 observationIndex, uint16 observationCardinality, uint16 observationCardinalityNext, uint8 feeProtocol, bool unlocked );
13	 function feeGrowthGlobal0X128() external view returns (uint256);
14	 function feeGrowthGlobal1X128() external view returns (uint256);
15	 function protocolFees() external view returns (uint128 token0, uint128 token1);
16	 function liquidity() external view returns (uint128);
17	 function ticks(int24 tick) external view returns ( uint128 liquidityGross, int128 liquidityNet, uint256 feeGrowthOutside0X128, uint256 feeGrowthOutside1X128, int56 tickCumulativeOutside, uint160 secondsPerLiquidityOutsideX128, uint32 secondsOutside, bool initialized );
18	 function tickBitmap(int16 wordPosition) external view returns (uint256);
19	 function positions(bytes32 key) external view returns ( uint128 _liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, uint128 tokensOwed0, uint128 tokensOwed1 );
20	 function observations(uint256 index) external view returns ( uint32 blockTimestamp, int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128, bool initialized );
21	 }
22	 pragma solidity >=0.5.0;
23	 interface IUniswapV3PoolDerivedState {
24	 function observe(uint32[] calldata secondsAgos) external view returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);
25	 function snapshotCumulativesInside(int24 tickLower, int24 tickUpper) external view returns ( int56 tickCumulativeInside, uint160 secondsPerLiquidityInsideX128, uint32 secondsInside );
26	 }
27	 pragma solidity >=0.5.0;
28	 interface IUniswapV3PoolActions {
29	 function initialize(uint160 sqrtPriceX96) external;
30	 function mint( address recipient, int24 tickLower, int24 tickUpper, uint128 amount, bytes calldata data ) external returns (uint256 amount0, uint256 amount1);
31	 function collect( address recipient, int24 tickLower, int24 tickUpper, uint128 amount0Requested, uint128 amount1Requested ) external returns (uint128 amount0, uint128 amount1);
32	 function burn( int24 tickLower, int24 tickUpper, uint128 amount ) external returns (uint256 amount0, uint256 amount1);
33	 function swap( address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes calldata data ) external returns (int256 amount0, int256 amount1);
34	 function flash( address recipient, uint256 amount0, uint256 amount1, bytes calldata data ) external;
35	 function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;
36	 }
37	 pragma solidity >=0.5.0;
38	 interface IUniswapV3PoolOwnerActions {
39	 function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;
40	 function collectProtocol( address recipient, uint128 amount0Requested, uint128 amount1Requested ) external returns (uint128 amount0, uint128 amount1);
41	 }
42	 pragma solidity >=0.5.0;
43	 interface IUniswapV3PoolEvents {
44	 event Initialize(uint160 sqrtPriceX96, int24 tick);
45	 event Mint( address sender, address indexed owner, int24 indexed tickLower, int24 indexed tickUpper, uint128 amount, uint256 amount0, uint256 amount1 );
46	 event Collect( address indexed owner, address recipient, int24 indexed tickLower, int24 indexed tickUpper, uint128 amount0, uint128 amount1 );
47	 event Burn( address indexed owner, int24 indexed tickLower, int24 indexed tickUpper, uint128 amount, uint256 amount0, uint256 amount1 );
48	 event Swap( address indexed sender, address indexed recipient, int256 amount0, int256 amount1, uint160 sqrtPriceX96, uint128 liquidity, int24 tick );
49	 event Flash( address indexed sender, address indexed recipient, uint256 amount0, uint256 amount1, uint256 paid0, uint256 paid1 );
50	 event IncreaseObservationCardinalityNext( uint16 observationCardinalityNextOld, uint16 observationCardinalityNextNew );
51	 event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);
52	 event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);
53	 }
54	 pragma solidity >=0.5.0;
55	 interface IUniswapV3Pool is IUniswapV3PoolImmutables, IUniswapV3PoolState, IUniswapV3PoolDerivedState, IUniswapV3PoolActions, IUniswapV3PoolOwnerActions, IUniswapV3PoolEvents {
56	 }
57	 pragma solidity =0.7.6;
58	 abstract contract NoDelegateCall {
59	 address private immutable original;
60	 constructor() {
61	 original = address(this);
62	 }
63	 function checkNotDelegateCall() private view {
64	 require(address(this) == original);
65	 }
66	 modifier noDelegateCall() {
67	 checkNotDelegateCall();
68	 _;
69	 }
70	 }
71	 pragma solidity =0.7.6;
72	 contract UniswapV3Pool is IUniswapV3Pool, NoDelegateCall {
73	 using LowGasSafeMath for uint256;
74	 using LowGasSafeMath for int256;
75	 using SafeCast for uint256;
76	 using SafeCast for int256;
77	 using Tick for mapping(int24 => Tick.Info);
78	 using TickBitmap for mapping(int16 => uint256);
79	 using Position for mapping(bytes32 => Position.Info);
80	 using Position for Position.Info;
81	 using Oracle for Oracle.Observation[65535];
82	 address public immutable override factory;
83	 address public immutable override token0;
84	 address public immutable override token1;
85	 uint24 public immutable override fee;
86	 int24 public immutable override tickSpacing;
87	 uint128 public immutable override maxLiquidityPerTick;
88	 struct Slot0 {
89	 uint160 sqrtPriceX96;
90	 int24 tick;
91	 uint16 observationIndex;
92	 uint16 observationCardinality;
93	 uint16 observationCardinalityNext;
94	 uint8 feeProtocol;
95	 bool unlocked;
96	 }
97	 Slot0 public override slot0;
98	 uint256 public override feeGrowthGlobal0X128;
99	 uint256 public override feeGrowthGlobal1X128;
100	 struct ProtocolFees {
101	 uint128 token0;
102	 uint128 token1;
103	 }
104	 ProtocolFees public override protocolFees;
105	 uint128 public override liquidity;
106	 mapping(int24 => Tick.Info) public override ticks;
107	 mapping(int16 => uint256) public override tickBitmap;
108	 mapping(bytes32 => Position.Info) public override positions;
109	 Oracle.Observation[65535] public override observations;
110	 modifier lock() {
111	 require(slot0.unlocked, 'LOK');
112	 slot0.unlocked = false;
113	 _;
114	 slot0.unlocked = true;
115	 }
116	 modifier onlyFactoryOwner() {
117	 require(msg.sender == IUniswapV3Factory(factory).owner());
118	 _;
119	 }
120	 constructor() {
121	 int24 _tickSpacing;
122	 (factory, token0, token1, fee, _tickSpacing) = IUniswapV3PoolDeployer(msg.sender).parameters();
123	 tickSpacing = _tickSpacing;
124	 maxLiquidityPerTick = Tick.tickSpacingToMaxLiquidityPerTick(_tickSpacing);
125	 }
126	 function checkTicks(int24 tickLower, int24 tickUpper) private pure {
127	 require(tickLower < tickUpper, 'TLU');
128	 require(tickLower >= TickMath.MIN_TICK, 'TLM');
129	 require(tickUpper <= TickMath.MAX_TICK, 'TUM');
130	 }
131	 function _blockTimestamp() internal view virtual returns (uint32) {
132	 return uint32(block.timestamp);
133	 }
134	 function balance0() private view returns (uint256) {
135	 (bool success, bytes memory data) = token0.staticcall(abi.encodeWithSelector(IERC20Minimal.balanceOf.selector, address(this)));
136	 require(success && data.length >= 32);
137	 return abi.decode(data, (uint256));
138	 }
139	 function balance1() private view returns (uint256) {
140	 (bool success, bytes memory data) = token1.staticcall(abi.encodeWithSelector(IERC20Minimal.balanceOf.selector, address(this)));
141	 require(success && data.length >= 32);
142	 return abi.decode(data, (uint256));
143	 }
144	 function snapshotCumulativesInside(int24 tickLower, int24 tickUpper) external view override noDelegateCall returns ( int56 tickCumulativeInside, uint160 secondsPerLiquidityInsideX128, uint32 secondsInside ) {
145	 checkTicks(tickLower, tickUpper);
146	 int56 tickCumulativeLower;
147	 int56 tickCumulativeUpper;
148	 uint160 secondsPerLiquidityOutsideLowerX128;
149	 uint160 secondsPerLiquidityOutsideUpperX128;
150	 uint32 secondsOutsideLower;
151	 uint32 secondsOutsideUpper;
152	 {
153	 Tick.Info storage lower = ticks[tickLower];
154	 Tick.Info storage upper = ticks[tickUpper];
155	 bool initializedLower;
156	 (tickCumulativeLower, secondsPerLiquidityOutsideLowerX128, secondsOutsideLower, initializedLower) = ( lower.tickCumulativeOutside, lower.secondsPerLiquidityOutsideX128, lower.secondsOutside, lower.initialized );
157	 require(initializedLower);
158	 bool initializedUpper;
159	 (tickCumulativeUpper, secondsPerLiquidityOutsideUpperX128, secondsOutsideUpper, initializedUpper) = ( upper.tickCumulativeOutside, upper.secondsPerLiquidityOutsideX128, upper.secondsOutside, upper.initialized );
160	 require(initializedUpper);
161	 }
162	 Slot0 memory _slot0 = slot0;
163	 if (_slot0.tick < tickLower) {
164	 return ( tickCumulativeLower - tickCumulativeUpper, secondsPerLiquidityOutsideLowerX128 - secondsPerLiquidityOutsideUpperX128, secondsOutsideLower - secondsOutsideUpper );
165	 }
166	 else if (_slot0.tick < tickUpper) {
167	 uint32 time = _blockTimestamp();
168	 (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) = observations.observeSingle( time, 0, _slot0.tick, _slot0.observationIndex, liquidity, _slot0.observationCardinality );
169	 return ( tickCumulative - tickCumulativeLower - tickCumulativeUpper, secondsPerLiquidityCumulativeX128 - secondsPerLiquidityOutsideLowerX128 - secondsPerLiquidityOutsideUpperX128, time - secondsOutsideLower - secondsOutsideUpper );
170	 }
171	 else {
172	 return ( tickCumulativeUpper - tickCumulativeLower, secondsPerLiquidityOutsideUpperX128 - secondsPerLiquidityOutsideLowerX128, secondsOutsideUpper - secondsOutsideLower );
173	 }
174	 }
175	 function observe(uint32[] calldata secondsAgos) external view override noDelegateCall returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s) {
176	 return observations.observe( _blockTimestamp(), secondsAgos, slot0.tick, slot0.observationIndex, liquidity, slot0.observationCardinality );
177	 }
178	 function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external override lock noDelegateCall {
179	 uint16 observationCardinalityNextOld = slot0.observationCardinalityNext;
180	 uint16 observationCardinalityNextNew = observations.grow(observationCardinalityNextOld, observationCardinalityNext);
181	 slot0.observationCardinalityNext = observationCardinalityNextNew;
182	 if (observationCardinalityNextOld != observationCardinalityNextNew) emit IncreaseObservationCardinalityNext(observationCardinalityNextOld, observationCardinalityNextNew);
183	 }
184	 function initialize(uint160 sqrtPriceX96) external override {
185	 require(slot0.sqrtPriceX96 == 0, 'AI');
186	 int24 tick = TickMath.getTickAtSqrtRatio(sqrtPriceX96);
187	 (uint16 cardinality, uint16 cardinalityNext) = observations.initialize(_blockTimestamp());
188	 slot0 = Slot0({
189	 sqrtPriceX96: sqrtPriceX96, tick: tick, observationIndex: 0, observationCardinality: cardinality, observationCardinalityNext: cardinalityNext, feeProtocol: 0, unlocked: true }
190	 );
191	 emit Initialize(sqrtPriceX96, tick);
192	 }
193	 struct ModifyPositionParams {
194	 address owner;
195	 int24 tickLower;
196	 int24 tickUpper;
197	 int128 liquidityDelta;
198	 }
199	 function _modifyPosition(ModifyPositionParams memory params) private noDelegateCall returns ( Position.Info storage position, int256 amount0, int256 amount1 ) {
200	 checkTicks(params.tickLower, params.tickUpper);
201	 Slot0 memory _slot0 = slot0;
202	 position = _updatePosition( params.owner, params.tickLower, params.tickUpper, params.liquidityDelta, _slot0.tick );
203	 if (params.liquidityDelta != 0) {
204	 if (_slot0.tick < params.tickLower) {
205	 amount0 = SqrtPriceMath.getAmount0Delta( TickMath.getSqrtRatioAtTick(params.tickLower), TickMath.getSqrtRatioAtTick(params.tickUpper), params.liquidityDelta );
206	 }
207	 else if (_slot0.tick < params.tickUpper) {
208	 uint128 liquidityBefore = liquidity;
209	 (slot0.observationIndex, slot0.observationCardinality) = observations.write( _slot0.observationIndex, _blockTimestamp(), _slot0.tick, liquidityBefore, _slot0.observationCardinality, _slot0.observationCardinalityNext );
210	 amount0 = SqrtPriceMath.getAmount0Delta( _slot0.sqrtPriceX96, TickMath.getSqrtRatioAtTick(params.tickUpper), params.liquidityDelta );
211	 amount1 = SqrtPriceMath.getAmount1Delta( TickMath.getSqrtRatioAtTick(params.tickLower), _slot0.sqrtPriceX96, params.liquidityDelta );
212	 liquidity = LiquidityMath.addDelta(liquidityBefore, params.liquidityDelta);
213	 }
214	 else {
215	 amount1 = SqrtPriceMath.getAmount1Delta( TickMath.getSqrtRatioAtTick(params.tickLower), TickMath.getSqrtRatioAtTick(params.tickUpper), params.liquidityDelta );
216	 }
217	 }
218	 }
219	 function _updatePosition( address owner, int24 tickLower, int24 tickUpper, int128 liquidityDelta, int24 tick ) private returns (Position.Info storage position) {
220	 position = positions.get(owner, tickLower, tickUpper);
221	 uint256 _feeGrowthGlobal0X128 = feeGrowthGlobal0X128;
222	 uint256 _feeGrowthGlobal1X128 = feeGrowthGlobal1X128;
223	 bool flippedLower;
224	 bool flippedUpper;
225	 if (liquidityDelta != 0) {
226	 uint32 time = _blockTimestamp();
227	 (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) = observations.observeSingle( time, 0, slot0.tick, slot0.observationIndex, liquidity, slot0.observationCardinality );
228	 flippedLower = ticks.update( tickLower, tick, liquidityDelta, _feeGrowthGlobal0X128, _feeGrowthGlobal1X128, secondsPerLiquidityCumulativeX128, tickCumulative, time, false, maxLiquidityPerTick );
229	 flippedUpper = ticks.update( tickUpper, tick, liquidityDelta, _feeGrowthGlobal0X128, _feeGrowthGlobal1X128, secondsPerLiquidityCumulativeX128, tickCumulative, time, true, maxLiquidityPerTick );
230	 if (flippedLower) {
231	 tickBitmap.flipTick(tickLower, tickSpacing);
232	 }
233	 if (flippedUpper) {
234	 tickBitmap.flipTick(tickUpper, tickSpacing);
235	 }
236	 }
237	 (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) = ticks.getFeeGrowthInside(tickLower, tickUpper, tick, _feeGrowthGlobal0X128, _feeGrowthGlobal1X128);
238	 position.update(liquidityDelta, feeGrowthInside0X128, feeGrowthInside1X128);
239	 if (liquidityDelta < 0) {
240	 if (flippedLower) {
241	 ticks.clear(tickLower);
242	 }
243	 if (flippedUpper) {
244	 ticks.clear(tickUpper);
245	 }
246	 }
247	 }
248	 function mint( address recipient, int24 tickLower, int24 tickUpper, uint128 amount, bytes calldata data ) external override lock returns (uint256 amount0, uint256 amount1) {
249	 require(amount > 0);
250	 (, int256 amount0Int, int256 amount1Int) = _modifyPosition( ModifyPositionParams({
251	 owner: recipient, tickLower: tickLower, tickUpper: tickUpper, liquidityDelta: int256(amount).toInt128() }
252	 ) );
253	 amount0 = uint256(amount0Int);
254	 amount1 = uint256(amount1Int);
255	 uint256 balance0Before;
256	 uint256 balance1Before;
257	 if (amount0 > 0) balance0Before = balance0();
258	 if (amount1 > 0) balance1Before = balance1();
259	 IUniswapV3MintCallback(msg.sender).uniswapV3MintCallback(amount0, amount1, data);
260	 if (amount0 > 0) require(balance0Before.add(amount0) <= balance0(), 'M0');
261	 if (amount1 > 0) require(balance1Before.add(amount1) <= balance1(), 'M1');
262	 emit Mint(msg.sender, recipient, tickLower, tickUpper, amount, amount0, amount1);
263	 }
264	 function collect( address recipient, int24 tickLower, int24 tickUpper, uint128 amount0Requested, uint128 amount1Requested ) external override lock returns (uint128 amount0, uint128 amount1) {
265	 Position.Info storage position = positions.get(msg.sender, tickLower, tickUpper);
266	 amount0 = amount0Requested > position.tokensOwed0 ? position.tokensOwed0 : amount0Requested;
267	 amount1 = amount1Requested > position.tokensOwed1 ? position.tokensOwed1 : amount1Requested;
268	 if (amount0 > 0) {
269	 position.tokensOwed0 -= amount0;
270	 TransferHelper.safeTransfer(token0, recipient, amount0);
271	 }
272	 if (amount1 > 0) {
273	 position.tokensOwed1 -= amount1;
274	 TransferHelper.safeTransfer(token1, recipient, amount1);
275	 }
276	 emit Collect(msg.sender, recipient, tickLower, tickUpper, amount0, amount1);
277	 }
278	 function burn( int24 tickLower, int24 tickUpper, uint128 amount ) external override lock returns (uint256 amount0, uint256 amount1) {
279	 (Position.Info storage position, int256 amount0Int, int256 amount1Int) = _modifyPosition( ModifyPositionParams({
280	 owner: msg.sender, tickLower: tickLower, tickUpper: tickUpper, liquidityDelta: -int256(amount).toInt128() }
281	 ) );
282	 amount0 = uint256(-amount0Int);
283	 amount1 = uint256(-amount1Int);
284	 if (amount0 > 0 || amount1 > 0) {
285	 (position.tokensOwed0, position.tokensOwed1) = ( position.tokensOwed0 + uint128(amount0), position.tokensOwed1 + uint128(amount1) );
286	 }
287	 emit Burn(msg.sender, tickLower, tickUpper, amount, amount0, amount1);
288	 }
289	 struct SwapCache {
290	 uint8 feeProtocol;
291	 uint128 liquidityStart;
292	 uint32 blockTimestamp;
293	 int56 tickCumulative;
294	 uint160 secondsPerLiquidityCumulativeX128;
295	 bool computedLatestObservation;
296	 }
297	 struct SwapState {
298	 int256 amountSpecifiedRemaining;
299	 int256 amountCalculated;
300	 uint160 sqrtPriceX96;
301	 int24 tick;
302	 uint256 feeGrowthGlobalX128;
303	 uint128 protocolFee;
304	 uint128 liquidity;
305	 }
306	 struct StepComputations {
307	 uint160 sqrtPriceStartX96;
308	 int24 tickNext;
309	 bool initialized;
310	 uint160 sqrtPriceNextX96;
311	 uint256 amountIn;
312	 uint256 amountOut;
313	 uint256 feeAmount;
314	 }
315	 function swap( address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes calldata data ) external override noDelegateCall returns (int256 amount0, int256 amount1) {
316	 require(amountSpecified != 0, 'AS');
317	 Slot0 memory slot0Start = slot0;
318	 require(slot0Start.unlocked, 'LOK');
319	 require( zeroForOne ? sqrtPriceLimitX96 < slot0Start.sqrtPriceX96 && sqrtPriceLimitX96 > TickMath.MIN_SQRT_RATIO : sqrtPriceLimitX96 > slot0Start.sqrtPriceX96 && sqrtPriceLimitX96 < TickMath.MAX_SQRT_RATIO, 'SPL' );
320	 slot0.unlocked = false;
321	 SwapCache memory cache = SwapCache({
322	 liquidityStart: liquidity, blockTimestamp: _blockTimestamp(), feeProtocol: zeroForOne ? (slot0Start.feeProtocol % 16) : (slot0Start.feeProtocol >> 4), secondsPerLiquidityCumulativeX128: 0, tickCumulative: 0, computedLatestObservation: false }
323	 );
324	 bool exactInput = amountSpecified > 0;
325	 SwapState memory state = SwapState({
326	 amountSpecifiedRemaining: amountSpecified, amountCalculated: 0, sqrtPriceX96: slot0Start.sqrtPriceX96, tick: slot0Start.tick, feeGrowthGlobalX128: zeroForOne ? feeGrowthGlobal0X128 : feeGrowthGlobal1X128, protocolFee: 0, liquidity: cache.liquidityStart }
327	 );
328	 while (state.amountSpecifiedRemaining != 0 && state.sqrtPriceX96 != sqrtPriceLimitX96) {
329	 StepComputations memory step;
330	 step.sqrtPriceStartX96 = state.sqrtPriceX96;
331	 (step.tickNext, step.initialized) = tickBitmap.nextInitializedTickWithinOneWord( state.tick, tickSpacing, zeroForOne );
332	 if (step.tickNext < TickMath.MIN_TICK) {
333	 step.tickNext = TickMath.MIN_TICK;
334	 }
335	 else if (step.tickNext > TickMath.MAX_TICK) {
336	 step.tickNext = TickMath.MAX_TICK;
337	 }
338	 step.sqrtPriceNextX96 = TickMath.getSqrtRatioAtTick(step.tickNext);
339	 (state.sqrtPriceX96, step.amountIn, step.amountOut, step.feeAmount) = SwapMath.computeSwapStep( state.sqrtPriceX96, (zeroForOne ? step.sqrtPriceNextX96 < sqrtPriceLimitX96 : step.sqrtPriceNextX96 > sqrtPriceLimitX96) ? sqrtPriceLimitX96 : step.sqrtPriceNextX96, state.liquidity, state.amountSpecifiedRemaining, fee );
340	 if (exactInput) {
341	 state.amountSpecifiedRemaining -= (step.amountIn + step.feeAmount).toInt256();
342	 state.amountCalculated = state.amountCalculated.sub(step.amountOut.toInt256());
343	 }
344	 else {
345	 state.amountSpecifiedRemaining += step.amountOut.toInt256();
346	 state.amountCalculated = state.amountCalculated.add((step.amountIn + step.feeAmount).toInt256());
347	 }
348	 if (cache.feeProtocol > 0) {
349	 uint256 delta = step.feeAmount / cache.feeProtocol;
350	 step.feeAmount -= delta;
351	 state.protocolFee += uint128(delta);
352	 }
353	 if (state.liquidity > 0) state.feeGrowthGlobalX128 += FullMath.mulDiv(step.feeAmount, FixedPoint128.Q128, state.liquidity);
354	 if (state.sqrtPriceX96 == step.sqrtPriceNextX96) {
355	 if (step.initialized) {
356	 if (!cache.computedLatestObservation) {
357	 (cache.tickCumulative, cache.secondsPerLiquidityCumulativeX128) = observations.observeSingle( cache.blockTimestamp, 0, slot0Start.tick, slot0Start.observationIndex, cache.liquidityStart, slot0Start.observationCardinality );
358	 cache.computedLatestObservation = true;
359	 }
360	 int128 liquidityNet = ticks.cross( step.tickNext, (zeroForOne ? state.feeGrowthGlobalX128 : feeGrowthGlobal0X128), (zeroForOne ? feeGrowthGlobal1X128 : state.feeGrowthGlobalX128), cache.secondsPerLiquidityCumulativeX128, cache.tickCumulative, cache.blockTimestamp );
361	 if (zeroForOne) liquidityNet = -liquidityNet;
362	 state.liquidity = LiquidityMath.addDelta(state.liquidity, liquidityNet);
363	 }
364	 state.tick = zeroForOne ? step.tickNext - 1 : step.tickNext;
365	 }
366	 else if (state.sqrtPriceX96 != step.sqrtPriceStartX96) {
367	 state.tick = TickMath.getTickAtSqrtRatio(state.sqrtPriceX96);
368	 }
369	 }
370	 if (state.tick != slot0Start.tick) {
371	 (uint16 observationIndex, uint16 observationCardinality) = observations.write( slot0Start.observationIndex, cache.blockTimestamp, slot0Start.tick, cache.liquidityStart, slot0Start.observationCardinality, slot0Start.observationCardinalityNext );
372	 (slot0.sqrtPriceX96, slot0.tick, slot0.observationIndex, slot0.observationCardinality) = ( state.sqrtPriceX96, state.tick, observationIndex, observationCardinality );
373	 }
374	 else {
375	 slot0.sqrtPriceX96 = state.sqrtPriceX96;
376	 }
377	 if (cache.liquidityStart != state.liquidity) liquidity = state.liquidity;
378	 if (zeroForOne) {
379	 feeGrowthGlobal0X128 = state.feeGrowthGlobalX128;
380	 if (state.protocolFee > 0) protocolFees.token0 += state.protocolFee;
381	 }
382	 else {
383	 feeGrowthGlobal1X128 = state.feeGrowthGlobalX128;
384	 if (state.protocolFee > 0) protocolFees.token1 += state.protocolFee;
385	 }
386	 (amount0, amount1) = zeroForOne == exactInput ? (amountSpecified - state.amountSpecifiedRemaining, state.amountCalculated) : (state.amountCalculated, amountSpecified - state.amountSpecifiedRemaining);
387	 if (zeroForOne) {
388	 if (amount1 < 0) TransferHelper.safeTransfer(token1, recipient, uint256(-amount1));
389	 uint256 balance0Before = balance0();
390	 IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(amount0, amount1, data);
391	 require(balance0Before.add(uint256(amount0)) <= balance0(), 'IIA');
392	 }
393	 else {
394	 if (amount0 < 0) TransferHelper.safeTransfer(token0, recipient, uint256(-amount0));
395	 uint256 balance1Before = balance1();
396	 IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(amount0, amount1, data);
397	 require(balance1Before.add(uint256(amount1)) <= balance1(), 'IIA');
398	 }
399	 emit Swap(msg.sender, recipient, amount0, amount1, state.sqrtPriceX96, state.liquidity, state.tick);
400	 slot0.unlocked = true;
401	 }
402	 function flash( address recipient, uint256 amount0, uint256 amount1, bytes calldata data ) external override lock noDelegateCall {
403	 uint128 _liquidity = liquidity;
404	 require(_liquidity > 0, 'L');
405	 uint256 fee0 = FullMath.mulDivRoundingUp(amount0, fee, 1e6);
406	 uint256 fee1 = FullMath.mulDivRoundingUp(amount1, fee, 1e6);
407	 uint256 balance0Before = balance0();
408	 uint256 balance1Before = balance1();
409	 if (amount0 > 0) TransferHelper.safeTransfer(token0, recipient, amount0);
410	 if (amount1 > 0) TransferHelper.safeTransfer(token1, recipient, amount1);
411	 IUniswapV3FlashCallback(msg.sender).uniswapV3FlashCallback(fee0, fee1, data);
412	 uint256 balance0After = balance0();
413	 uint256 balance1After = balance1();
414	 require(balance0Before.add(fee0) <= balance0After, 'F0');
415	 require(balance1Before.add(fee1) <= balance1After, 'F1');
416	 uint256 paid0 = balance0After - balance0Before;
417	 uint256 paid1 = balance1After - balance1Before;
418	 if (paid0 > 0) {
419	 uint8 feeProtocol0 = slot0.feeProtocol % 16;
420	 uint256 fees0 = feeProtocol0 == 0 ? 0 : paid0 / feeProtocol0;
421	 if (uint128(fees0) > 0) protocolFees.token0 += uint128(fees0);
422	 feeGrowthGlobal0X128 += FullMath.mulDiv(paid0 - fees0, FixedPoint128.Q128, _liquidity);
423	 }
424	 if (paid1 > 0) {
425	 uint8 feeProtocol1 = slot0.feeProtocol >> 4;
426	 uint256 fees1 = feeProtocol1 == 0 ? 0 : paid1 / feeProtocol1;
427	 if (uint128(fees1) > 0) protocolFees.token1 += uint128(fees1);
428	 feeGrowthGlobal1X128 += FullMath.mulDiv(paid1 - fees1, FixedPoint128.Q128, _liquidity);
429	 }
430	 emit Flash(msg.sender, recipient, amount0, amount1, paid0, paid1);
431	 }
432	 function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external override lock onlyFactoryOwner {
433	 require( (feeProtocol0 == 0 || (feeProtocol0 >= 4 && feeProtocol0 <= 10)) && (feeProtocol1 == 0 || (feeProtocol1 >= 4 && feeProtocol1 <= 10)) );
434	 uint8 feeProtocolOld = slot0.feeProtocol;
435	 slot0.feeProtocol = feeProtocol0 + (feeProtocol1 << 4);
436	 emit SetFeeProtocol(feeProtocolOld % 16, feeProtocolOld >> 4, feeProtocol0, feeProtocol1);
437	 }
438	 function collectProtocol( address recipient, uint128 amount0Requested, uint128 amount1Requested ) external override lock onlyFactoryOwner returns (uint128 amount0, uint128 amount1) {
439	 amount0 = amount0Requested > protocolFees.token0 ? protocolFees.token0 : amount0Requested;
440	 amount1 = amount1Requested > protocolFees.token1 ? protocolFees.token1 : amount1Requested;
441	 if (amount0 > 0) {
442	 if (amount0 == protocolFees.token0) amount0--;
443	 protocolFees.token0 -= amount0;
444	 TransferHelper.safeTransfer(token0, recipient, amount0);
445	 }
446	 if (amount1 > 0) {
447	 if (amount1 == protocolFees.token1) amount1--;
448	 protocolFees.token1 -= amount1;
449	 TransferHelper.safeTransfer(token1, recipient, amount1);
450	 }
451	 emit CollectProtocol(msg.sender, recipient, amount0, amount1);
452	 }
453	 }
454	 pragma solidity >=0.7.0;
455	 library LowGasSafeMath {
456	 function add(uint256 x, uint256 y) internal pure returns (uint256 z) {
457	 require((z = x + y) >= x);
458	 }
459	 function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {
460	 require((z = x - y) <= x);
461	 }
462	 function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {
463	 require(x == 0 || (z = x * y) / x == y);
464	 }
465	 function add(int256 x, int256 y) internal pure returns (int256 z) {
466	 require((z = x + y) >= x == (y >= 0));
467	 }
468	 function sub(int256 x, int256 y) internal pure returns (int256 z) {
469	 require((z = x - y) <= x == (y >= 0));
470	 }
471	 }
472	 pragma solidity >=0.5.0;
473	 library SafeCast {
474	 function toUint160(uint256 y) internal pure returns (uint160 z) {
475	 require((z = uint160(y)) == y);
476	 }
477	 function toInt128(int256 y) internal pure returns (int128 z) {
478	 require((z = int128(y)) == y);
479	 }
480	 function toInt256(uint256 y) internal pure returns (int256 z) {
481	 require(y < 2**255);
482	 z = int256(y);
483	 }
484	 }
485	 pragma solidity >=0.5.0;
486	 library Tick {
487	 using LowGasSafeMath for int256;
488	 using SafeCast for int256;
489	 struct Info {
490	 uint128 liquidityGross;
491	 int128 liquidityNet;
492	 uint256 feeGrowthOutside0X128;
493	 uint256 feeGrowthOutside1X128;
494	 int56 tickCumulativeOutside;
495	 uint160 secondsPerLiquidityOutsideX128;
496	 uint32 secondsOutside;
497	 bool initialized;
498	 }
499	 function tickSpacingToMaxLiquidityPerTick(int24 tickSpacing) internal pure returns (uint128) {
500	 int24 minTick = (TickMath.MIN_TICK / tickSpacing) * tickSpacing;
501	 int24 maxTick = (TickMath.MAX_TICK / tickSpacing) * tickSpacing;
502	 uint24 numTicks = uint24((maxTick - minTick) / tickSpacing) + 1;
503	 return type(uint128).max / numTicks;
504	 }
505	 function getFeeGrowthInside( mapping(int24 => Tick.Info) storage self, int24 tickLower, int24 tickUpper, int24 tickCurrent, uint256 feeGrowthGlobal0X128, uint256 feeGrowthGlobal1X128 ) internal view returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) {
506	 Info storage lower = self[tickLower];
507	 Info storage upper = self[tickUpper];
508	 uint256 feeGrowthBelow0X128;
509	 uint256 feeGrowthBelow1X128;
510	 if (tickCurrent >= tickLower) {
511	 feeGrowthBelow0X128 = lower.feeGrowthOutside0X128;
512	 feeGrowthBelow1X128 = lower.feeGrowthOutside1X128;
513	 }
514	 else {
515	 feeGrowthBelow0X128 = feeGrowthGlobal0X128 - lower.feeGrowthOutside0X128;
516	 feeGrowthBelow1X128 = feeGrowthGlobal1X128 - lower.feeGrowthOutside1X128;
517	 }
518	 uint256 feeGrowthAbove0X128;
519	 uint256 feeGrowthAbove1X128;
520	 if (tickCurrent < tickUpper) {
521	 feeGrowthAbove0X128 = upper.feeGrowthOutside0X128;
522	 feeGrowthAbove1X128 = upper.feeGrowthOutside1X128;
523	 }
524	 else {
525	 feeGrowthAbove0X128 = feeGrowthGlobal0X128 - upper.feeGrowthOutside0X128;
526	 feeGrowthAbove1X128 = feeGrowthGlobal1X128 - upper.feeGrowthOutside1X128;
527	 }
528	 feeGrowthInside0X128 = feeGrowthGlobal0X128 - feeGrowthBelow0X128 - feeGrowthAbove0X128;
529	 feeGrowthInside1X128 = feeGrowthGlobal1X128 - feeGrowthBelow1X128 - feeGrowthAbove1X128;
530	 }
531	 function update( mapping(int24 => Tick.Info) storage self, int24 tick, int24 tickCurrent, int128 liquidityDelta, uint256 feeGrowthGlobal0X128, uint256 feeGrowthGlobal1X128, uint160 secondsPerLiquidityCumulativeX128, int56 tickCumulative, uint32 time, bool upper, uint128 maxLiquidity ) internal returns (bool flipped) {
532	 Tick.Info storage info = self[tick];
533	 uint128 liquidityGrossBefore = info.liquidityGross;
534	 uint128 liquidityGrossAfter = LiquidityMath.addDelta(liquidityGrossBefore, liquidityDelta);
535	 require(liquidityGrossAfter <= maxLiquidity, 'LO');
536	 flipped = (liquidityGrossAfter == 0) != (liquidityGrossBefore == 0);
537	 if (liquidityGrossBefore == 0) {
538	 if (tick <= tickCurrent) {
539	 info.feeGrowthOutside0X128 = feeGrowthGlobal0X128;
540	 info.feeGrowthOutside1X128 = feeGrowthGlobal1X128;
541	 info.secondsPerLiquidityOutsideX128 = secondsPerLiquidityCumulativeX128;
542	 info.tickCumulativeOutside = tickCumulative;
543	 info.secondsOutside = time;
544	 }
545	 info.initialized = true;
546	 }
547	 info.liquidityGross = liquidityGrossAfter;
548	 info.liquidityNet = upper ? int256(info.liquidityNet).sub(liquidityDelta).toInt128() : int256(info.liquidityNet).add(liquidityDelta).toInt128();
549	 }
550	 function clear(mapping(int24 => Tick.Info) storage self, int24 tick) internal {
551	 delete self[tick];
552	 }
553	 function cross( mapping(int24 => Tick.Info) storage self, int24 tick, uint256 feeGrowthGlobal0X128, uint256 feeGrowthGlobal1X128, uint160 secondsPerLiquidityCumulativeX128, int56 tickCumulative, uint32 time ) internal returns (int128 liquidityNet) {
554	 Tick.Info storage info = self[tick];
555	 info.feeGrowthOutside0X128 = feeGrowthGlobal0X128 - info.feeGrowthOutside0X128;
556	 info.feeGrowthOutside1X128 = feeGrowthGlobal1X128 - info.feeGrowthOutside1X128;
557	 info.secondsPerLiquidityOutsideX128 = secondsPerLiquidityCumulativeX128 - info.secondsPerLiquidityOutsideX128;
558	 info.tickCumulativeOutside = tickCumulative - info.tickCumulativeOutside;
559	 info.secondsOutside = time - info.secondsOutside;
560	 liquidityNet = info.liquidityNet;
561	 }
562	 }
563	 pragma solidity >=0.5.0;
564	 library TickBitmap {
565	 function position(int24 tick) private pure returns (int16 wordPos, uint8 bitPos) {
566	 wordPos = int16(tick >> 8);
567	 bitPos = uint8(tick % 256);
568	 }
569	 function flipTick( mapping(int16 => uint256) storage self, int24 tick, int24 tickSpacing ) internal {
570	 require(tick % tickSpacing == 0);
571	 (int16 wordPos, uint8 bitPos) = position(tick / tickSpacing);
572	 uint256 mask = 1 << bitPos;
573	 self[wordPos] ^= mask;
574	 }
575	 function nextInitializedTickWithinOneWord( mapping(int16 => uint256) storage self, int24 tick, int24 tickSpacing, bool lte ) internal view returns (int24 next, bool initialized) {
576	 int24 compressed = tick / tickSpacing;
577	 if (tick < 0 && tick % tickSpacing != 0) compressed--;
578	 if (lte) {
579	 (int16 wordPos, uint8 bitPos) = position(compressed);
580	 uint256 mask = (1 << bitPos) - 1 + (1 << bitPos);
581	 uint256 masked = self[wordPos] & mask;
582	 initialized = masked != 0;
583	 next = initialized ? (compressed - int24(bitPos - BitMath.mostSignificantBit(masked))) * tickSpacing : (compressed - int24(bitPos)) * tickSpacing;
584	 }
585	 else {
586	 (int16 wordPos, uint8 bitPos) = position(compressed + 1);
587	 uint256 mask = ~((1 << bitPos) - 1);
588	 uint256 masked = self[wordPos] & mask;
589	 initialized = masked != 0;
590	 next = initialized ? (compressed + 1 + int24(BitMath.leastSignificantBit(masked) - bitPos)) * tickSpacing : (compressed + 1 + int24(type(uint8).max - bitPos)) * tickSpacing;
591	 }
592	 }
593	 }
594	 pragma solidity >=0.5.0;
595	 library Position {
596	 struct Info {
597	 uint128 liquidity;
598	 uint256 feeGrowthInside0LastX128;
599	 uint256 feeGrowthInside1LastX128;
600	 uint128 tokensOwed0;
601	 uint128 tokensOwed1;
602	 }
603	 function get( mapping(bytes32 => Info) storage self, address owner, int24 tickLower, int24 tickUpper ) internal view returns (Position.Info storage position) {
604	 position = self[keccak256(abi.encodePacked(owner, tickLower, tickUpper))];
605	 }
606	 function update( Info storage self, int128 liquidityDelta, uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128 ) internal {
607	 Info memory _self = self;
608	 uint128 liquidityNext;
609	 if (liquidityDelta == 0) {
610	 require(_self.liquidity > 0, 'NP');
611	 liquidityNext = _self.liquidity;
612	 }
613	 else {
614	 liquidityNext = LiquidityMath.addDelta(_self.liquidity, liquidityDelta);
615	 }
616	 uint128 tokensOwed0 = uint128( FullMath.mulDiv( feeGrowthInside0X128 - _self.feeGrowthInside0LastX128, _self.liquidity, FixedPoint128.Q128 ) );
617	 uint128 tokensOwed1 = uint128( FullMath.mulDiv( feeGrowthInside1X128 - _self.feeGrowthInside1LastX128, _self.liquidity, FixedPoint128.Q128 ) );
618	 if (liquidityDelta != 0) self.liquidity = liquidityNext;
619	 self.feeGrowthInside0LastX128 = feeGrowthInside0X128;
620	 self.feeGrowthInside1LastX128 = feeGrowthInside1X128;
621	 if (tokensOwed0 > 0 || tokensOwed1 > 0) {
622	 self.tokensOwed0 += tokensOwed0;
623	 self.tokensOwed1 += tokensOwed1;
624	 }
625	 }
626	 }
627	 pragma solidity >=0.5.0;
628	 library Oracle {
629	 struct Observation {
630	 uint32 blockTimestamp;
631	 int56 tickCumulative;
632	 uint160 secondsPerLiquidityCumulativeX128;
633	 bool initialized;
634	 }
635	 function transform( Observation memory last, uint32 blockTimestamp, int24 tick, uint128 liquidity ) private pure returns (Observation memory) {
636	 uint32 delta = blockTimestamp - last.blockTimestamp;
637	 return Observation({
638	 blockTimestamp: blockTimestamp, tickCumulative: last.tickCumulative + int56(tick) * delta, secondsPerLiquidityCumulativeX128: last.secondsPerLiquidityCumulativeX128 + ((uint160(delta) << 128) / (liquidity > 0 ? liquidity : 1)), initialized: true }
639	 );
640	 }
641	 function initialize(Observation[65535] storage self, uint32 time) internal returns (uint16 cardinality, uint16 cardinalityNext) {
642	 self[0] = Observation({
643	 blockTimestamp: time, tickCumulative: 0, secondsPerLiquidityCumulativeX128: 0, initialized: true }
644	 );
645	 return (1, 1);
646	 }
647	 function write( Observation[65535] storage self, uint16 index, uint32 blockTimestamp, int24 tick, uint128 liquidity, uint16 cardinality, uint16 cardinalityNext ) internal returns (uint16 indexUpdated, uint16 cardinalityUpdated) {
648	 Observation memory last = self[index];
649	 if (last.blockTimestamp == blockTimestamp) return (index, cardinality);
650	 if (cardinalityNext > cardinality && index == (cardinality - 1)) {
651	 cardinalityUpdated = cardinalityNext;
652	 }
653	 else {
654	 cardinalityUpdated = cardinality;
655	 }
656	 indexUpdated = (index + 1) % cardinalityUpdated;
657	 self[indexUpdated] = transform(last, blockTimestamp, tick, liquidity);
658	 }
659	 function grow( Observation[65535] storage self, uint16 current, uint16 next ) internal returns (uint16) {
660	 require(current > 0, 'I');
661	 if (next <= current) return current;
662	 for (uint16 i = current; i < next; i++) self[i].blockTimestamp = 1;
663	 return next;
664	 }
665	 function lte( uint32 time, uint32 a, uint32 b ) private pure returns (bool) {
666	 if (a <= time && b <= time) return a <= b;
667	 uint256 aAdjusted = a > time ? a : a + 2**32;
668	 uint256 bAdjusted = b > time ? b : b + 2**32;
669	 return aAdjusted <= bAdjusted;
670	 }
671	 function binarySearch( Observation[65535] storage self, uint32 time, uint32 target, uint16 index, uint16 cardinality ) private view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {
672	 uint256 l = (index + 1) % cardinality;
673	 uint256 r = l + cardinality - 1;
674	 uint256 i;
675	 while (true) {
676	 i = (l + r) / 2;
677	 beforeOrAt = self[i % cardinality];
678	 if (!beforeOrAt.initialized) {
679	 l = i + 1;
680	 continue;
681	 }
682	 atOrAfter = self[(i + 1) % cardinality];
683	 bool targetAtOrAfter = lte(time, beforeOrAt.blockTimestamp, target);
684	 if (targetAtOrAfter && lte(time, target, atOrAfter.blockTimestamp)) break;
685	 if (!targetAtOrAfter) r = i - 1;
686	 else l = i + 1;
687	 }
688	 }
689	 function getSurroundingObservations( Observation[65535] storage self, uint32 time, uint32 target, int24 tick, uint16 index, uint128 liquidity, uint16 cardinality ) private view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {
690	 beforeOrAt = self[index];
691	 if (lte(time, beforeOrAt.blockTimestamp, target)) {
692	 if (beforeOrAt.blockTimestamp == target) {
693	 return (beforeOrAt, atOrAfter);
694	 }
695	 else {
696	 return (beforeOrAt, transform(beforeOrAt, target, tick, liquidity));
697	 }
698	 }
699	 beforeOrAt = self[(index + 1) % cardinality];
700	 if (!beforeOrAt.initialized) beforeOrAt = self[0];
701	 require(lte(time, beforeOrAt.blockTimestamp, target), 'OLD');
702	 return binarySearch(self, time, target, index, cardinality);
703	 }
704	 function observeSingle( Observation[65535] storage self, uint32 time, uint32 secondsAgo, int24 tick, uint16 index, uint128 liquidity, uint16 cardinality ) internal view returns (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) {
705	 if (secondsAgo == 0) {
706	 Observation memory last = self[index];
707	 if (last.blockTimestamp != time) last = transform(last, time, tick, liquidity);
708	 return (last.tickCumulative, last.secondsPerLiquidityCumulativeX128);
709	 }
710	 uint32 target = time - secondsAgo;
711	 (Observation memory beforeOrAt, Observation memory atOrAfter) = getSurroundingObservations(self, time, target, tick, index, liquidity, cardinality);
712	 if (target == beforeOrAt.blockTimestamp) {
713	 return (beforeOrAt.tickCumulative, beforeOrAt.secondsPerLiquidityCumulativeX128);
714	 }
715	 else if (target == atOrAfter.blockTimestamp) {
716	 return (atOrAfter.tickCumulative, atOrAfter.secondsPerLiquidityCumulativeX128);
717	 }
718	 else {
719	 uint32 observationTimeDelta = atOrAfter.blockTimestamp - beforeOrAt.blockTimestamp;
720	 uint32 targetDelta = target - beforeOrAt.blockTimestamp;
721	 return ( beforeOrAt.tickCumulative + ((atOrAfter.tickCumulative - beforeOrAt.tickCumulative) / observationTimeDelta) * targetDelta, beforeOrAt.secondsPerLiquidityCumulativeX128 + uint160( (uint256( atOrAfter.secondsPerLiquidityCumulativeX128 - beforeOrAt.secondsPerLiquidityCumulativeX128 ) * targetDelta) / observationTimeDelta ) );
722	 }
723	 }
724	 function observe( Observation[65535] storage self, uint32 time, uint32[] memory secondsAgos, int24 tick, uint16 index, uint128 liquidity, uint16 cardinality ) internal view returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s) {
725	 require(cardinality > 0, 'I');
726	 tickCumulatives = new int56[](secondsAgos.length);
727	 secondsPerLiquidityCumulativeX128s = new uint160[](secondsAgos.length);
728	 for (uint256 i = 0; i < secondsAgos.length; i++) {
729	 (tickCumulatives[i], secondsPerLiquidityCumulativeX128s[i]) = observeSingle( self, time, secondsAgos[i], tick, index, liquidity, cardinality );
730	 }
731	 }
732	 }
733	 pragma solidity >=0.4.0;
734	 library FullMath {
735	 function mulDiv( uint256 a, uint256 b, uint256 denominator ) internal pure returns (uint256 result) {
736	 uint256 prod0;
737	 uint256 prod1;
738	 assembly {
739	 let mm := mulmod(a, b, not(0)) prod0 := mul(a, b) prod1 := sub(sub(mm, prod0), lt(mm, prod0)) }
740	 if (prod1 == 0) {
741	 require(denominator > 0);
742	 assembly {
743	 result := div(prod0, denominator) }
744	 return result;
745	 }
746	 require(denominator > prod1);
747	 uint256 remainder;
748	 assembly {
749	 remainder := mulmod(a, b, denominator) }
750	 assembly {
751	 prod1 := sub(prod1, gt(remainder, prod0)) prod0 := sub(prod0, remainder) }
752	 uint256 twos = -denominator & denominator;
753	 assembly {
754	 denominator := div(denominator, twos) }
755	 assembly {
756	 prod0 := div(prod0, twos) }
757	 assembly {
758	 twos := add(div(sub(0, twos), twos), 1) }
759	 prod0 |= prod1 * twos;
760	 uint256 inv = (3 * denominator) ^ 2;
761	 inv *= 2 - denominator * inv;
762	 inv *= 2 - denominator * inv;
763	 inv *= 2 - denominator * inv;
764	 inv *= 2 - denominator * inv;
765	 inv *= 2 - denominator * inv;
766	 inv *= 2 - denominator * inv;
767	 result = prod0 * inv;
768	 return result;
769	 }
770	 function mulDivRoundingUp( uint256 a, uint256 b, uint256 denominator ) internal pure returns (uint256 result) {
771	 result = mulDiv(a, b, denominator);
772	 if (mulmod(a, b, denominator) > 0) {
773	 require(result < type(uint256).max);
774	 result++;
775	 }
776	 }
777	 }
778	 pragma solidity >=0.4.0;
779	 library FixedPoint128 {
780	 uint256 internal constant Q128 = 0x100000000000000000000000000000000;
781	 }
782	 pragma solidity >=0.6.0;
783	 library TransferHelper {
784	 function safeTransfer( address token, address to, uint256 value ) internal {
785	 (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20Minimal.transfer.selector, to, value));
786	 require(success && (data.length == 0 || abi.decode(data, (bool))), 'TF');
787	 }
788	 }
789	 pragma solidity >=0.5.0;
790	 library TickMath {
791	 int24 internal constant MIN_TICK = -887272;
792	 int24 internal constant MAX_TICK = -MIN_TICK;
793	 uint160 internal constant MIN_SQRT_RATIO = 4295128739;
794	 uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;
795	 function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {
796	 uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));
797	 require(absTick <= uint256(MAX_TICK), 'T');
798	 uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;
799	 if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;
800	 if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;
801	 if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;
802	 if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;
803	 if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;
804	 if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;
805	 if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;
806	 if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;
807	 if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;
808	 if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;
809	 if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;
810	 if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;
811	 if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;
812	 if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;
813	 if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;
814	 if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;
815	 if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;
816	 if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;
817	 if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;
818	 if (tick > 0) ratio = type(uint256).max / ratio;
819	 sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));
820	 }
821	 function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {
822	 require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');
823	 uint256 ratio = uint256(sqrtPriceX96) << 32;
824	 uint256 r = ratio;
825	 uint256 msb = 0;
826	 assembly {
827	 let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) msb := or(msb, f) r := shr(f, r) }
828	 assembly {
829	 let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF)) msb := or(msb, f) r := shr(f, r) }
830	 assembly {
831	 let f := shl(5, gt(r, 0xFFFFFFFF)) msb := or(msb, f) r := shr(f, r) }
832	 assembly {
833	 let f := shl(4, gt(r, 0xFFFF)) msb := or(msb, f) r := shr(f, r) }
834	 assembly {
835	 let f := shl(3, gt(r, 0xFF)) msb := or(msb, f) r := shr(f, r) }
836	 assembly {
837	 let f := shl(2, gt(r, 0xF)) msb := or(msb, f) r := shr(f, r) }
838	 assembly {
839	 let f := shl(1, gt(r, 0x3)) msb := or(msb, f) r := shr(f, r) }
840	 assembly {
841	 let f := gt(r, 0x1) msb := or(msb, f) }
842	 if (msb >= 128) r = ratio >> (msb - 127);
843	 else r = ratio << (127 - msb);
844	 int256 log_2 = (int256(msb) - 128) << 64;
845	 assembly {
846	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(63, f)) r := shr(f, r) }
847	 assembly {
848	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(62, f)) r := shr(f, r) }
849	 assembly {
850	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(61, f)) r := shr(f, r) }
851	 assembly {
852	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(60, f)) r := shr(f, r) }
853	 assembly {
854	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(59, f)) r := shr(f, r) }
855	 assembly {
856	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(58, f)) r := shr(f, r) }
857	 assembly {
858	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(57, f)) r := shr(f, r) }
859	 assembly {
860	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(56, f)) r := shr(f, r) }
861	 assembly {
862	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(55, f)) r := shr(f, r) }
863	 assembly {
864	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(54, f)) r := shr(f, r) }
865	 assembly {
866	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(53, f)) r := shr(f, r) }
867	 assembly {
868	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(52, f)) r := shr(f, r) }
869	 assembly {
870	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(51, f)) r := shr(f, r) }
871	 assembly {
872	 r := shr(127, mul(r, r)) let f := shr(128, r) log_2 := or(log_2, shl(50, f)) }
873	 int256 log_sqrt10001 = log_2 * 255738958999603826347141;
874	 int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);
875	 int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);
876	 tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;
877	 }
878	 }
879	 pragma solidity >=0.5.0;
880	 library LiquidityMath {
881	 function addDelta(uint128 x, int128 y) internal pure returns (uint128 z) {
882	 if (y < 0) {
883	 require((z = x - uint128(-y)) < x, 'LS');
884	 }
885	 else {
886	 require((z = x + uint128(y)) >= x, 'LA');
887	 }
888	 }
889	 }
890	 pragma solidity >=0.5.0;
891	 library SqrtPriceMath {
892	 using LowGasSafeMath for uint256;
893	 using SafeCast for uint256;
894	 function getNextSqrtPriceFromAmount0RoundingUp( uint160 sqrtPX96, uint128 liquidity, uint256 amount, bool add ) internal pure returns (uint160) {
895	 if (amount == 0) return sqrtPX96;
896	 uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;
897	 if (add) {
898	 uint256 product;
899	 if ((product = amount * sqrtPX96) / amount == sqrtPX96) {
900	 uint256 denominator = numerator1 + product;
901	 if (denominator >= numerator1) return uint160(FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator));
902	 }
903	 return uint160(UnsafeMath.divRoundingUp(numerator1, (numerator1 / sqrtPX96).add(amount)));
904	 }
905	 else {
906	 uint256 product;
907	 require((product = amount * sqrtPX96) / amount == sqrtPX96 && numerator1 > product);
908	 uint256 denominator = numerator1 - product;
909	 return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator).toUint160();
910	 }
911	 }
912	 function getNextSqrtPriceFromAmount1RoundingDown( uint160 sqrtPX96, uint128 liquidity, uint256 amount, bool add ) internal pure returns (uint160) {
913	 if (add) {
914	 uint256 quotient = ( amount <= type(uint160).max ? (amount << FixedPoint96.RESOLUTION) / liquidity : FullMath.mulDiv(amount, FixedPoint96.Q96, liquidity) );
915	 return uint256(sqrtPX96).add(quotient).toUint160();
916	 }
917	 else {
918	 uint256 quotient = ( amount <= type(uint160).max ? UnsafeMath.divRoundingUp(amount << FixedPoint96.RESOLUTION, liquidity) : FullMath.mulDivRoundingUp(amount, FixedPoint96.Q96, liquidity) );
919	 require(sqrtPX96 > quotient);
920	 return uint160(sqrtPX96 - quotient);
921	 }
922	 }
923	 function getNextSqrtPriceFromInput( uint160 sqrtPX96, uint128 liquidity, uint256 amountIn, bool zeroForOne ) internal pure returns (uint160 sqrtQX96) {
924	 require(sqrtPX96 > 0);
925	 require(liquidity > 0);
926	 return zeroForOne ? getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountIn, true) : getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountIn, true);
927	 }
928	 function getNextSqrtPriceFromOutput( uint160 sqrtPX96, uint128 liquidity, uint256 amountOut, bool zeroForOne ) internal pure returns (uint160 sqrtQX96) {
929	 require(sqrtPX96 > 0);
930	 require(liquidity > 0);
931	 return zeroForOne ? getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountOut, false) : getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountOut, false);
932	 }
933	 function getAmount0Delta( uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity, bool roundUp ) internal pure returns (uint256 amount0) {
934	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
935	 uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;
936	 uint256 numerator2 = sqrtRatioBX96 - sqrtRatioAX96;
937	 require(sqrtRatioAX96 > 0);
938	 return roundUp ? UnsafeMath.divRoundingUp( FullMath.mulDivRoundingUp(numerator1, numerator2, sqrtRatioBX96), sqrtRatioAX96 ) : FullMath.mulDiv(numerator1, numerator2, sqrtRatioBX96) / sqrtRatioAX96;
939	 }
940	 function getAmount1Delta( uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity, bool roundUp ) internal pure returns (uint256 amount1) {
941	 if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
942	 return roundUp ? FullMath.mulDivRoundingUp(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96) : FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);
943	 }
944	 function getAmount0Delta( uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, int128 liquidity ) internal pure returns (int256 amount0) {
945	 return liquidity < 0 ? -getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256() : getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();
946	 }
947	 function getAmount1Delta( uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, int128 liquidity ) internal pure returns (int256 amount1) {
948	 return liquidity < 0 ? -getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256() : getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();
949	 }
950	 }
951	 pragma solidity >=0.5.0;
952	 library SwapMath {
953	 function computeSwapStep( uint160 sqrtRatioCurrentX96, uint160 sqrtRatioTargetX96, uint128 liquidity, int256 amountRemaining, uint24 feePips ) internal pure returns ( uint160 sqrtRatioNextX96, uint256 amountIn, uint256 amountOut, uint256 feeAmount ) {
954	 bool zeroForOne = sqrtRatioCurrentX96 >= sqrtRatioTargetX96;
955	 bool exactIn = amountRemaining >= 0;
956	 if (exactIn) {
957	 uint256 amountRemainingLessFee = FullMath.mulDiv(uint256(amountRemaining), 1e6 - feePips, 1e6);
958	 amountIn = zeroForOne ? SqrtPriceMath.getAmount0Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, true) : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, true);
959	 if (amountRemainingLessFee >= amountIn) sqrtRatioNextX96 = sqrtRatioTargetX96;
960	 else sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromInput( sqrtRatioCurrentX96, liquidity, amountRemainingLessFee, zeroForOne );
961	 }
962	 else {
963	 amountOut = zeroForOne ? SqrtPriceMath.getAmount1Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, false) : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, false);
964	 if (uint256(-amountRemaining) >= amountOut) sqrtRatioNextX96 = sqrtRatioTargetX96;
965	 else sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromOutput( sqrtRatioCurrentX96, liquidity, uint256(-amountRemaining), zeroForOne );
966	 }
967	 bool max = sqrtRatioTargetX96 == sqrtRatioNextX96;
968	 if (zeroForOne) {
969	 amountIn = max && exactIn ? amountIn : SqrtPriceMath.getAmount0Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, true);
970	 amountOut = max && !exactIn ? amountOut : SqrtPriceMath.getAmount1Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, false);
971	 }
972	 else {
973	 amountIn = max && exactIn ? amountIn : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, true);
974	 amountOut = max && !exactIn ? amountOut : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, false);
975	 }
976	 if (!exactIn && amountOut > uint256(-amountRemaining)) {
977	 amountOut = uint256(-amountRemaining);
978	 }
979	 if (exactIn && sqrtRatioNextX96 != sqrtRatioTargetX96) {
980	 feeAmount = uint256(amountRemaining) - amountIn;
981	 }
982	 else {
983	 feeAmount = FullMath.mulDivRoundingUp(amountIn, feePips, 1e6 - feePips);
984	 }
985	 }
986	 }
987	 pragma solidity >=0.5.0;
988	 interface IUniswapV3PoolDeployer {
989	 function parameters() external view returns ( address factory, address token0, address token1, uint24 fee, int24 tickSpacing );
990	 }
991	 pragma solidity >=0.5.0;
992	 interface IUniswapV3Factory {
993	 event OwnerChanged(address indexed oldOwner, address indexed newOwner);
994	 event PoolCreated( address indexed token0, address indexed token1, uint24 indexed fee, int24 tickSpacing, address pool );
995	 event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);
996	 function owner() external view returns (address);
997	 function feeAmountTickSpacing(uint24 fee) external view returns (int24);
998	 function getPool( address tokenA, address tokenB, uint24 fee ) external view returns (address pool);
999	 function createPool( address tokenA, address tokenB, uint24 fee ) external returns (address pool);
1000	 function setOwner(address _owner) external;
1001	 function enableFeeAmount(uint24 fee, int24 tickSpacing) external;
1002	 }
1003	 pragma solidity >=0.5.0;
1004	 interface IERC20Minimal {
1005	 function balanceOf(address account) external view returns (uint256);
1006	 function transfer(address recipient, uint256 amount) external returns (bool);
1007	 function allowance(address owner, address spender) external view returns (uint256);
1008	 function approve(address spender, uint256 amount) external returns (bool);
1009	 function transferFrom( address sender, address recipient, uint256 amount ) external returns (bool);
1010	 event Transfer(address indexed from, address indexed to, uint256 value);
1011	 event Approval(address indexed owner, address indexed spender, uint256 value);
1012	 }
1013	 pragma solidity >=0.5.0;
1014	 interface IUniswapV3MintCallback {
1015	 function uniswapV3MintCallback( uint256 amount0Owed, uint256 amount1Owed, bytes calldata data ) external;
1016	 }
1017	 pragma solidity >=0.5.0;
1018	 interface IUniswapV3SwapCallback {
1019	 function uniswapV3SwapCallback( int256 amount0Delta, int256 amount1Delta, bytes calldata data ) external;
1020	 }
1021	 pragma solidity >=0.5.0;
1022	 interface IUniswapV3FlashCallback {
1023	 function uniswapV3FlashCallback( uint256 fee0, uint256 fee1, bytes calldata data ) external;
1024	 }
1025	 pragma solidity >=0.5.0;
1026	 library BitMath {
1027	 function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {
1028	 require(x > 0);
1029	 if (x >= 0x100000000000000000000000000000000) {
1030	 x >>= 128;
1031	 r += 128;
1032	 }
1033	 if (x >= 0x10000000000000000) {
1034	 x >>= 64;
1035	 r += 64;
1036	 }
1037	 if (x >= 0x100000000) {
1038	 x >>= 32;
1039	 r += 32;
1040	 }
1041	 if (x >= 0x10000) {
1042	 x >>= 16;
1043	 r += 16;
1044	 }
1045	 if (x >= 0x100) {
1046	 x >>= 8;
1047	 r += 8;
1048	 }
1049	 if (x >= 0x10) {
1050	 x >>= 4;
1051	 r += 4;
1052	 }
1053	 if (x >= 0x4) {
1054	 x >>= 2;
1055	 r += 2;
1056	 }
1057	 if (x >= 0x2) r += 1;
1058	 }
1059	 function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {
1060	 require(x > 0);
1061	 r = 255;
1062	 if (x & type(uint128).max > 0) {
1063	 r -= 128;
1064	 }
1065	 else {
1066	 x >>= 128;
1067	 }
1068	 if (x & type(uint64).max > 0) {
1069	 r -= 64;
1070	 }
1071	 else {
1072	 x >>= 64;
1073	 }
1074	 if (x & type(uint32).max > 0) {
1075	 r -= 32;
1076	 }
1077	 else {
1078	 x >>= 32;
1079	 }
1080	 if (x & type(uint16).max > 0) {
1081	 r -= 16;
1082	 }
1083	 else {
1084	 x >>= 16;
1085	 }
1086	 if (x & type(uint8).max > 0) {
1087	 r -= 8;
1088	 }
1089	 else {
1090	 x >>= 8;
1091	 }
1092	 if (x & 0xf > 0) {
1093	 r -= 4;
1094	 }
1095	 else {
1096	 x >>= 4;
1097	 }
1098	 if (x & 0x3 > 0) {
1099	 r -= 2;
1100	 }
1101	 else {
1102	 x >>= 2;
1103	 }
1104	 if (x & 0x1 > 0) r -= 1;
1105	 }
1106	 }
1107	 pragma solidity >=0.5.0;
1108	 library UnsafeMath {
1109	 function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {
1110	 assembly {
1111	 z := add(div(x, y), gt(mod(x, y), 0)) }
1112	 }
1113	 }
1114	 pragma solidity >=0.4.0;
1115	 library FixedPoint96 {
1116	 uint8 internal constant RESOLUTION = 96;
1117	 uint256 internal constant Q96 = 0x1000000000000000000000000;
1118	 }
