row number 
1	          pragma solidity ^0.6.0;
2	 library AddressUpgradeable {
3	 function isContract(address account) internal view returns (bool) {
4	 uint256 size;
5	 assembly {
6	 size := extcodesize(account) }
7	 return size > 0;
8	 }
9	 function sendValue(address payable recipient, uint256 amount) internal {
10	 require(address(this).balance >= amount, "Address: insufficient balance");
11	 (bool success, ) = recipient.call{
12	 value: amount }
13	 ("");
14	 require(success, "Address: unable to send value, recipient may have reverted");
15	 }
16	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
17	 return functionCall(target, data, "Address: low-level call failed");
18	 }
19	 function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
20	 return functionCallWithValue(target, data, 0, errorMessage);
21	 }
22	 function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
23	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
24	 }
25	 function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
26	 require(address(this).balance >= value, "Address: insufficient balance for call");
27	 require(isContract(target), "Address: call to non-contract");
28	 (bool success, bytes memory returndata) = target.call{
29	 value: value }
30	 (data);
31	 return _verifyCallResult(success, returndata, errorMessage);
32	 }
33	 function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
34	 return functionStaticCall(target, data, "Address: low-level static call failed");
35	 }
36	 function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
37	 require(isContract(target), "Address: static call to non-contract");
38	 (bool success, bytes memory returndata) = target.staticcall(data);
39	 return _verifyCallResult(success, returndata, errorMessage);
40	 }
41	 function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
42	 if (success) {
43	 return returndata;
44	 }
45	 else {
46	 if (returndata.length > 0) {
47	 assembly {
48	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
49	 }
50	 else {
51	 revert(errorMessage);
52	 }
53	 }
54	 }
55	 }
56	 library EnumerableSetUpgradeable {
57	 struct Set {
58	 bytes32[] _values;
59	 mapping (bytes32 => uint256) _indexes;
60	 }
61	 function _add(Set storage set, bytes32 value) private returns (bool) {
62	 if (!_contains(set, value)) {
63	 set._values.push(value);
64	 set._indexes[value] = set._values.length;
65	 return true;
66	 }
67	 else {
68	 return false;
69	 }
70	 }
71	 function _remove(Set storage set, bytes32 value) private returns (bool) {
72	 uint256 valueIndex = set._indexes[value];
73	 if (valueIndex != 0) {
74	 uint256 toDeleteIndex = valueIndex - 1;
75	 uint256 lastIndex = set._values.length - 1;
76	 bytes32 lastvalue = set._values[lastIndex];
77	 set._values[toDeleteIndex] = lastvalue;
78	 set._indexes[lastvalue] = toDeleteIndex + 1;
79	 set._values.pop();
80	 delete set._indexes[value];
81	 return true;
82	 }
83	 else {
84	 return false;
85	 }
86	 }
87	 function _contains(Set storage set, bytes32 value) private view returns (bool) {
88	 return set._indexes[value] != 0;
89	 }
90	 function _length(Set storage set) private view returns (uint256) {
91	 return set._values.length;
92	 }
93	 function _at(Set storage set, uint256 index) private view returns (bytes32) {
94	 require(set._values.length > index, "EnumerableSet: index out of bounds");
95	 return set._values[index];
96	 }
97	 struct Bytes32Set {
98	 Set _inner;
99	 }
100	 function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {
101	 return _add(set._inner, value);
102	 }
103	 function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {
104	 return _remove(set._inner, value);
105	 }
106	 function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {
107	 return _contains(set._inner, value);
108	 }
109	 function length(Bytes32Set storage set) internal view returns (uint256) {
110	 return _length(set._inner);
111	 }
112	 function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {
113	 return _at(set._inner, index);
114	 }
115	 struct AddressSet {
116	 Set _inner;
117	 }
118	 function add(AddressSet storage set, address value) internal returns (bool) {
119	 return _add(set._inner, bytes32(uint256(value)));
120	 }
121	 function remove(AddressSet storage set, address value) internal returns (bool) {
122	 return _remove(set._inner, bytes32(uint256(value)));
123	 }
124	 function contains(AddressSet storage set, address value) internal view returns (bool) {
125	 return _contains(set._inner, bytes32(uint256(value)));
126	 }
127	 function length(AddressSet storage set) internal view returns (uint256) {
128	 return _length(set._inner);
129	 }
130	 function at(AddressSet storage set, uint256 index) internal view returns (address) {
131	 return address(uint256(_at(set._inner, index)));
132	 }
133	 struct UintSet {
134	 Set _inner;
135	 }
136	 function add(UintSet storage set, uint256 value) internal returns (bool) {
137	 return _add(set._inner, bytes32(value));
138	 }
139	 function remove(UintSet storage set, uint256 value) internal returns (bool) {
140	 return _remove(set._inner, bytes32(value));
141	 }
142	 function contains(UintSet storage set, uint256 value) internal view returns (bool) {
143	 return _contains(set._inner, bytes32(value));
144	 }
145	 function length(UintSet storage set) internal view returns (uint256) {
146	 return _length(set._inner);
147	 }
148	 function at(UintSet storage set, uint256 index) internal view returns (uint256) {
149	 return uint256(_at(set._inner, index));
150	 }
151	 }
152	 library CountersUpgradeable {
153	 using SafeMathUpgradeable for uint256;
154	 struct Counter {
155	 uint256 _value;
156	 }
157	 function current(Counter storage counter) internal view returns (uint256) {
158	 return counter._value;
159	 }
160	 function increment(Counter storage counter) internal {
161	 counter._value += 1;
162	 }
163	 function decrement(Counter storage counter) internal {
164	 counter._value = counter._value.sub(1);
165	 }
166	 }
167	 library SafeMathUpgradeable {
168	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
169	 uint256 c = a + b;
170	 require(c >= a, "SafeMath: addition overflow");
171	 return c;
172	 }
173	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
174	 return sub(a, b, "SafeMath: subtraction overflow");
175	 }
176	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
177	 require(b <= a, errorMessage);
178	 uint256 c = a - b;
179	 return c;
180	 }
181	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
182	 if (a == 0) {
183	 return 0;
184	 }
185	 uint256 c = a * b;
186	 require(c / a == b, "SafeMath: multiplication overflow");
187	 return c;
188	 }
189	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
190	 return div(a, b, "SafeMath: division by zero");
191	 }
192	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
193	 require(b > 0, errorMessage);
194	 uint256 c = a / b;
195	 return c;
196	 }
197	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
198	 return mod(a, b, "SafeMath: modulo by zero");
199	 }
200	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
201	 require(b != 0, errorMessage);
202	 return a % b;
203	 }
204	 }
205	 abstract contract Initializable {
206	 bool private _initialized;
207	 bool private _initializing;
208	 modifier initializer() {
209	 require(_initializing || _isConstructor() || !_initialized, "Initializable: contract is already initialized");
210	 bool isTopLevelCall = !_initializing;
211	 if (isTopLevelCall) {
212	 _initializing = true;
213	 _initialized = true;
214	 }
215	 _;
216	 if (isTopLevelCall) {
217	 _initializing = false;
218	 }
219	 }
220	 function _isConstructor() private view returns (bool) {
221	 address self = address(this);
222	 uint256 cs;
223	 assembly {
224	 cs := extcodesize(self) }
225	 return cs == 0;
226	 }
227	 }
228	 abstract contract ContextUpgradeable is Initializable {
229	 function __Context_init() internal initializer {
230	 __Context_init_unchained();
231	 }
232	 function __Context_init_unchained() internal initializer {
233	 }
234	 function _msgSender() internal view virtual returns (address payable) {
235	 return msg.sender;
236	 }
237	 function _msgData() internal view virtual returns (bytes memory) {
238	 this;
239	 return msg.data;
240	 }
241	 uint256[50] private __gap;
242	 }
243	 abstract contract PausableUpgradeable is Initializable, ContextUpgradeable {
244	 event Paused(address account);
245	 event Unpaused(address account);
246	 bool private _paused;
247	 function __Pausable_init() internal initializer {
248	 __Context_init_unchained();
249	 __Pausable_init_unchained();
250	 }
251	 function __Pausable_init_unchained() internal initializer {
252	 _paused = false;
253	 }
254	 function paused() public view returns (bool) {
255	 return _paused;
256	 }
257	 modifier whenNotPaused() {
258	 require(!_paused, "Pausable: paused");
259	 _;
260	 }
261	 modifier whenPaused() {
262	 require(_paused, "Pausable: not paused");
263	 _;
264	 }
265	 function _pause() internal virtual whenNotPaused {
266	 _paused = true;
267	 emit Paused(_msgSender());
268	 }
269	 function _unpause() internal virtual whenPaused {
270	 _paused = false;
271	 emit Unpaused(_msgSender());
272	 }
273	 uint256[49] private __gap;
274	 }
275	 abstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable {
276	 function __AccessControl_init() internal initializer {
277	 __Context_init_unchained();
278	 __AccessControl_init_unchained();
279	 }
280	 function __AccessControl_init_unchained() internal initializer {
281	 }
282	 using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;
283	 using AddressUpgradeable for address;
284	 struct RoleData {
285	 EnumerableSetUpgradeable.AddressSet members;
286	 bytes32 adminRole;
287	 }
288	 mapping (bytes32 => RoleData) private _roles;
289	 bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;
290	 event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
291	 event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
292	 event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
293	 function hasRole(bytes32 role, address account) public view returns (bool) {
294	 return _roles[role].members.contains(account);
295	 }
296	 function getRoleMemberCount(bytes32 role) public view returns (uint256) {
297	 return _roles[role].members.length();
298	 }
299	 function getRoleMember(bytes32 role, uint256 index) public view returns (address) {
300	 return _roles[role].members.at(index);
301	 }
302	 function getRoleAdmin(bytes32 role) public view returns (bytes32) {
303	 return _roles[role].adminRole;
304	 }
305	 function grantRole(bytes32 role, address account) public virtual {
306	 require(hasRole(_roles[role].adminRole, _msgSender()), "AccessControl: sender must be an admin to grant");
307	 _grantRole(role, account);
308	 }
309	 function revokeRole(bytes32 role, address account) public virtual {
310	 require(hasRole(_roles[role].adminRole, _msgSender()), "AccessControl: sender must be an admin to revoke");
311	 _revokeRole(role, account);
312	 }
313	 function renounceRole(bytes32 role, address account) public virtual {
314	 require(account == _msgSender(), "AccessControl: can only renounce roles for self");
315	 _revokeRole(role, account);
316	 }
317	 function _setupRole(bytes32 role, address account) internal virtual {
318	 _grantRole(role, account);
319	 }
320	 function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
321	 emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);
322	 _roles[role].adminRole = adminRole;
323	 }
324	 function _grantRole(bytes32 role, address account) private {
325	 if (_roles[role].members.add(account)) {
326	 emit RoleGranted(role, account, _msgSender());
327	 }
328	 }
329	 function _revokeRole(bytes32 role, address account) private {
330	 if (_roles[role].members.remove(account)) {
331	 emit RoleRevoked(role, account, _msgSender());
332	 }
333	 }
334	 uint256[49] private __gap;
335	 }
336	 interface IERC20Upgradeable {
337	 function totalSupply() external view returns (uint256);
338	 function balanceOf(address account) external view returns (uint256);
339	 function transfer(address recipient, uint256 amount) external returns (bool);
340	 function allowance(address owner, address spender) external view returns (uint256);
341	 function approve(address spender, uint256 amount) external returns (bool);
342	 function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
343	 event Transfer(address indexed from, address indexed to, uint256 value);
344	 event Approval(address indexed owner, address indexed spender, uint256 value);
345	 }
346	 contract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable {
347	 using SafeMathUpgradeable for uint256;
348	 mapping (address => uint256) private _balances;
349	 mapping (address => mapping (address => uint256)) private _allowances;
350	 uint256 private _totalSupply;
351	 string private _name;
352	 string private _symbol;
353	 uint8 private _decimals;
354	 function __ERC20_init(string memory name_, string memory symbol_) internal initializer {
355	 __Context_init_unchained();
356	 __ERC20_init_unchained(name_, symbol_);
357	 }
358	 function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {
359	 _name = name_;
360	 _symbol = symbol_;
361	 _decimals = 18;
362	 }
363	 function name() public view returns (string memory) {
364	 return _name;
365	 }
366	 function symbol() public view returns (string memory) {
367	 return _symbol;
368	 }
369	 function decimals() public view returns (uint8) {
370	 return _decimals;
371	 }
372	 function totalSupply() public view override returns (uint256) {
373	 return _totalSupply;
374	 }
375	 function balanceOf(address account) public view override returns (uint256) {
376	 return _balances[account];
377	 }
378	 function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
379	 _transfer(_msgSender(), recipient, amount);
380	 return true;
381	 }
382	 function allowance(address owner, address spender) public view virtual override returns (uint256) {
383	 return _allowances[owner][spender];
384	 }
385	 function approve(address spender, uint256 amount) public virtual override returns (bool) {
386	 _approve(_msgSender(), spender, amount);
387	 return true;
388	 }
389	 function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
390	 _transfer(sender, recipient, amount);
391	 _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
392	 return true;
393	 }
394	 function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
395	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
396	 return true;
397	 }
398	 function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
399	 _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
400	 return true;
401	 }
402	 function _transfer(address sender, address recipient, uint256 amount) internal virtual {
403	 require(sender != address(0), "ERC20: transfer from the zero address");
404	 require(recipient != address(0), "ERC20: transfer to the zero address");
405	 _beforeTokenTransfer(sender, recipient, amount);
406	 _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
407	 _balances[recipient] = _balances[recipient].add(amount);
408	 emit Transfer(sender, recipient, amount);
409	 }
410	 function _mint(address account, uint256 amount) internal virtual {
411	 require(account != address(0), "ERC20: mint to the zero address");
412	 _beforeTokenTransfer(address(0), account, amount);
413	 _totalSupply = _totalSupply.add(amount);
414	 _balances[account] = _balances[account].add(amount);
415	 emit Transfer(address(0), account, amount);
416	 }
417	 function _burn(address account, uint256 amount) internal virtual {
418	 require(account != address(0), "ERC20: burn from the zero address");
419	 _beforeTokenTransfer(account, address(0), amount);
420	 _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
421	 _totalSupply = _totalSupply.sub(amount);
422	 emit Transfer(account, address(0), amount);
423	 }
424	 function _approve(address owner, address spender, uint256 amount) internal virtual {
425	 require(owner != address(0), "ERC20: approve from the zero address");
426	 require(spender != address(0), "ERC20: approve to the zero address");
427	 _allowances[owner][spender] = amount;
428	 emit Approval(owner, spender, amount);
429	 }
430	 function _setupDecimals(uint8 decimals_) internal {
431	 _decimals = decimals_;
432	 }
433	 function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {
434	 }
435	 uint256[44] private __gap;
436	 }
437	 abstract contract ERC20BurnableUpgradeable is Initializable, ContextUpgradeable, ERC20Upgradeable {
438	 function __ERC20Burnable_init() internal initializer {
439	 __Context_init_unchained();
440	 __ERC20Burnable_init_unchained();
441	 }
442	 function __ERC20Burnable_init_unchained() internal initializer {
443	 }
444	 using SafeMathUpgradeable for uint256;
445	 function burn(uint256 amount) public virtual {
446	 _burn(_msgSender(), amount);
447	 }
448	 function burnFrom(address account, uint256 amount) public virtual {
449	 uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, "ERC20: burn amount exceeds allowance");
450	 _approve(account, _msgSender(), decreasedAllowance);
451	 _burn(account, amount);
452	 }
453	 uint256[50] private __gap;
454	 }
455	 abstract contract ERC20PausableUpgradeable is Initializable, ERC20Upgradeable, PausableUpgradeable {
456	 function __ERC20Pausable_init() internal initializer {
457	 __Context_init_unchained();
458	 __Pausable_init_unchained();
459	 __ERC20Pausable_init_unchained();
460	 }
461	 function __ERC20Pausable_init_unchained() internal initializer {
462	 }
463	 function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {
464	 super._beforeTokenTransfer(from, to, amount);
465	 require(!paused(), "ERC20Pausable: token transfer while paused");
466	 }
467	 uint256[50] private __gap;
468	 }
469	 contract ERC20PresetMinterPauserUpgradeable is Initializable, ContextUpgradeable, AccessControlUpgradeable, ERC20BurnableUpgradeable, ERC20PausableUpgradeable {
470	 function initialize(string memory name, string memory symbol) public virtual initializer {
471	 __ERC20PresetMinterPauser_init(name, symbol);
472	 }
473	 bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
474	 bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
475	 function __ERC20PresetMinterPauser_init(string memory name, string memory symbol) internal initializer {
476	 __Context_init_unchained();
477	 __AccessControl_init_unchained();
478	 __ERC20_init_unchained(name, symbol);
479	 __ERC20Burnable_init_unchained();
480	 __Pausable_init_unchained();
481	 __ERC20Pausable_init_unchained();
482	 __ERC20PresetMinterPauser_init_unchained(name, symbol);
483	 }
484	 function __ERC20PresetMinterPauser_init_unchained(string memory name, string memory symbol) internal initializer {
485	 _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
486	 _setupRole(MINTER_ROLE, _msgSender());
487	 _setupRole(PAUSER_ROLE, _msgSender());
488	 }
489	 function mint(address to, uint256 amount) public virtual {
490	 require(hasRole(MINTER_ROLE, _msgSender()), "ERC20PresetMinterPauser: must have minter role to mint");
491	 _mint(to, amount);
492	 }
493	 function pause() public virtual {
494	 require(hasRole(PAUSER_ROLE, _msgSender()), "ERC20PresetMinterPauser: must have pauser role to pause");
495	 _pause();
496	 }
497	 function unpause() public virtual {
498	 require(hasRole(PAUSER_ROLE, _msgSender()), "ERC20PresetMinterPauser: must have pauser role to unpause");
499	 _unpause();
500	 }
501	 function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override(ERC20Upgradeable, ERC20PausableUpgradeable) {
502	 super._beforeTokenTransfer(from, to, amount);
503	 }
504	 uint256[50] private __gap;
505	 }
506	 interface IERC20PermitUpgradeable {
507	 function permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;
508	 function nonces(address owner) external view returns (uint256);
509	 function DOMAIN_SEPARATOR() external view returns (bytes32);
510	 }
511	 abstract contract EIP712Upgradeable is Initializable {
512	 bytes32 private _HASHED_NAME;
513	 bytes32 private _HASHED_VERSION;
514	 bytes32 private constant _TYPE_HASH = keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");
515	 function __EIP712_init(string memory name, string memory version) internal initializer {
516	 __EIP712_init_unchained(name, version);
517	 }
518	 function __EIP712_init_unchained(string memory name, string memory version) internal initializer {
519	 bytes32 hashedName = keccak256(bytes(name));
520	 bytes32 hashedVersion = keccak256(bytes(version));
521	 _HASHED_NAME = hashedName;
522	 _HASHED_VERSION = hashedVersion;
523	 }
524	 function _domainSeparatorV4() internal view returns (bytes32) {
525	 return _buildDomainSeparator(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash());
526	 }
527	 function _buildDomainSeparator(bytes32 typeHash, bytes32 name, bytes32 version) private view returns (bytes32) {
528	 return keccak256( abi.encode( typeHash, name, version, _getChainId(), address(this) ) );
529	 }
530	 function _hashTypedDataV4(bytes32 structHash) internal view returns (bytes32) {
531	 return keccak256(abi.encodePacked("\x19\x01", _domainSeparatorV4(), structHash));
532	 }
533	 function _getChainId() private view returns (uint256 chainId) {
534	 this;
535	 assembly {
536	 chainId := chainid() }
537	 }
538	 function _EIP712NameHash() internal virtual view returns (bytes32) {
539	 return _HASHED_NAME;
540	 }
541	 function _EIP712VersionHash() internal virtual view returns (bytes32) {
542	 return _HASHED_VERSION;
543	 }
544	 uint256[50] private __gap;
545	 }
546	 abstract contract ERC20PermitUpgradeable is Initializable, ERC20Upgradeable, IERC20PermitUpgradeable, EIP712Upgradeable {
547	 using CountersUpgradeable for CountersUpgradeable.Counter;
548	 mapping (address => CountersUpgradeable.Counter) private _nonces;
549	 bytes32 private _PERMIT_TYPEHASH;
550	 function __ERC20Permit_init(string memory name) internal initializer {
551	 __Context_init_unchained();
552	 __EIP712_init_unchained(name, "1");
553	 __ERC20Permit_init_unchained(name);
554	 }
555	 function __ERC20Permit_init_unchained(string memory name) internal initializer {
556	 _PERMIT_TYPEHASH = keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");
557	 }
558	 function permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public virtual override {
559	 require(block.timestamp <= deadline, "ERC20Permit: expired deadline");
560	 bytes32 structHash = keccak256( abi.encode( _PERMIT_TYPEHASH, owner, spender, amount, _nonces[owner].current(), deadline ) );
561	 bytes32 hash = _hashTypedDataV4(structHash);
562	 address signer = _recoverSigner(hash, v, r, s);
563	 require(signer == owner, "ERC20Permit: invalid signature");
564	 _nonces[owner].increment();
565	 _approve(owner, spender, amount);
566	 }
567	 function _recoverSigner(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {
568	 require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, "ECDSA: invalid signature 's' value");
569	 require(v == 27 || v == 28, "ECDSA: invalid signature 'v' value");
570	 address signer = ecrecover(hash, v, r, s);
571	 require(signer != address(0), "ECDSA: invalid signature");
572	 return signer;
573	 }
574	 function nonces(address owner) public view override returns (uint256) {
575	 return _nonces[owner].current();
576	 }
577	 function DOMAIN_SEPARATOR() external view override returns (bytes32) {
578	 return _domainSeparatorV4();
579	 }
580	 uint256[49] private __gap;
581	 }
582	 library Address {
583	 function isContract(address account) internal view returns (bool) {
584	 uint256 size;
585	 assembly {
586	 size := extcodesize(account) }
587	 return size > 0;
588	 }
589	 function sendValue(address payable recipient, uint256 amount) internal {
590	 require(address(this).balance >= amount, "Address: insufficient balance");
591	 (bool success, ) = recipient.call{
592	 value: amount }
593	 ("");
594	 require(success, "Address: unable to send value, recipient may have reverted");
595	 }
596	 function functionCall(address target, bytes memory data) internal returns (bytes memory) {
597	 return functionCall(target, data, "Address: low-level call failed");
598	 }
599	 function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
600	 return functionCallWithValue(target, data, 0, errorMessage);
601	 }
602	 function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
603	 return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
604	 }
605	 function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
606	 require(address(this).balance >= value, "Address: insufficient balance for call");
607	 require(isContract(target), "Address: call to non-contract");
608	 (bool success, bytes memory returndata) = target.call{
609	 value: value }
610	 (data);
611	 return _verifyCallResult(success, returndata, errorMessage);
612	 }
613	 function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
614	 return functionStaticCall(target, data, "Address: low-level static call failed");
615	 }
616	 function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
617	 require(isContract(target), "Address: static call to non-contract");
618	 (bool success, bytes memory returndata) = target.staticcall(data);
619	 return _verifyCallResult(success, returndata, errorMessage);
620	 }
621	 function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
622	 if (success) {
623	 return returndata;
624	 }
625	 else {
626	 if (returndata.length > 0) {
627	 assembly {
628	 let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) }
629	 }
630	 else {
631	 revert(errorMessage);
632	 }
633	 }
634	 }
635	 }
636	 library SafeMath {
637	 function add(uint256 a, uint256 b) internal pure returns (uint256) {
638	 uint256 c = a + b;
639	 require(c >= a, "SafeMath: addition overflow");
640	 return c;
641	 }
642	 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
643	 return sub(a, b, "SafeMath: subtraction overflow");
644	 }
645	 function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
646	 require(b <= a, errorMessage);
647	 uint256 c = a - b;
648	 return c;
649	 }
650	 function mul(uint256 a, uint256 b) internal pure returns (uint256) {
651	 if (a == 0) {
652	 return 0;
653	 }
654	 uint256 c = a * b;
655	 require(c / a == b, "SafeMath: multiplication overflow");
656	 return c;
657	 }
658	 function div(uint256 a, uint256 b) internal pure returns (uint256) {
659	 return div(a, b, "SafeMath: division by zero");
660	 }
661	 function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
662	 require(b > 0, errorMessage);
663	 uint256 c = a / b;
664	 return c;
665	 }
666	 function mod(uint256 a, uint256 b) internal pure returns (uint256) {
667	 return mod(a, b, "SafeMath: modulo by zero");
668	 }
669	 function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
670	 require(b != 0, errorMessage);
671	 return a % b;
672	 }
673	 }
674	 interface IERC20 {
675	 function totalSupply() external view returns (uint256);
676	 function balanceOf(address account) external view returns (uint256);
677	 function transfer(address recipient, uint256 amount) external returns (bool);
678	 function allowance(address owner, address spender) external view returns (uint256);
679	 function approve(address spender, uint256 amount) external returns (bool);
680	 function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
681	 event Transfer(address indexed from, address indexed to, uint256 value);
682	 event Approval(address indexed owner, address indexed spender, uint256 value);
683	 }
684	 library SafeERC20 {
685	 using SafeMath for uint256;
686	 using Address for address;
687	 function safeTransfer(IERC20 token, address to, uint256 value) internal {
688	 _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
689	 }
690	 function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
691	 _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
692	 }
693	 function safeApprove(IERC20 token, address spender, uint256 value) internal {
694	 require((value == 0) || (token.allowance(address(this), spender) == 0), "SafeERC20: approve from non-zero to non-zero allowance" );
695	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
696	 }
697	 function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
698	 uint256 newAllowance = token.allowance(address(this), spender).add(value);
699	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
700	 }
701	 function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
702	 uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
703	 _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
704	 }
705	 function _callOptionalReturn(IERC20 token, bytes memory data) private {
706	 bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
707	 if (returndata.length > 0) {
708	 require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
709	 }
710	 }
711	 }
712	 contract HHToken is ERC20PresetMinterPauserUpgradeable, ERC20PermitUpgradeable {
713	 using SafeERC20 for IERC20;
714	 function initialize(string memory name, string memory symbol) public override initializer {
715	 __Context_init_unchained();
716	 __AccessControl_init_unchained();
717	 __ERC20_init_unchained(name, symbol);
718	 __ERC20Burnable_init_unchained();
719	 __Pausable_init_unchained();
720	 __ERC20Pausable_init_unchained();
721	 __ERC20PresetMinterPauser_init_unchained(name, symbol);
722	 __ERC20Permit_init(name);
723	 }
724	 function uniqueIdentifier() public pure returns(string memory) {
725	 return "HolyheldToken";
726	 }
727	 function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override(ERC20PresetMinterPauserUpgradeable, ERC20Upgradeable) {
728	 super._beforeTokenTransfer(from, to, amount);
729	 }
730	 function emergencyTransfer(address _token, address _destination, uint256 _amount) public {
731	 require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), "Admin only");
732	 IERC20(_token).safeTransfer(_destination, _amount);
733	 }
734	 }
735	 interface IHolyPool {
736	 function getBaseAsset() external view returns(address);
737	 function depositOnBehalf(address beneficiary, uint256 amount) external;
738	 function withdraw(address beneficiary, uint256 amount) external;
739	 function borrowToInvest(uint256 amount) external returns(uint256);
740	 function returnInvested(uint256 amountCapitalBody) external;
741	 function harvestYield(uint256 amount) external;
742	 }
743	 interface IHolyWing {
744	 function executeSwap(address tokenFrom, address tokenTo, uint256 amount, bytes calldata data) external returns(uint256);
745	 }
746	 contract HolyHand is AccessControlUpgradeable {
747	 using SafeMath for uint256;
748	 using SafeERC20 for IERC20;
749	 uint256 private constant ALLOWANCE_SIZE = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;
750	 uint256 public depositFee;
751	 uint256 public exchangeFee;
752	 uint256 public withdrawFee;
753	 IHolyWing private exchangeProxyContract;
754	 address private yieldDistributorAddress;
755	 event TokenSwap(address indexed tokenFrom, address indexed tokenTo, address sender, uint256 amountFrom, uint256 expectedMinimumReceived, uint256 amountReceived);
756	 event FeeChanged(string indexed name, uint256 value);
757	 event EmergencyTransfer(address indexed token, address indexed destination, uint256 amount);
758	 function initialize() public initializer {
759	 _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
760	 depositFee = 0;
761	 exchangeFee = 0;
762	 withdrawFee = 0;
763	 }
764	 function setExchangeProxy(address _exchangeProxyContract) public {
765	 require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), "Admin only");
766	 exchangeProxyContract = IHolyWing(_exchangeProxyContract);
767	 }
768	 function setYieldDistributor(address _tokenAddress, address _distributorAddress) public {
769	 require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), "Admin only");
770	 yieldDistributorAddress = _distributorAddress;
771	 IERC20(_tokenAddress).approve(_distributorAddress, ALLOWANCE_SIZE);
772	 }
773	 function depositToPool(address _poolAddress, address _token, uint256 _amount, uint256 _expectedMinimumReceived, bytes memory convertData) public {
774	 IHolyPool holyPool = IHolyPool(_poolAddress);
775	 IERC20 poolToken = IERC20(holyPool.getBaseAsset());
776	 if (address(poolToken) == _token) {
777	 IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);
778	 if (poolToken.allowance(address(this), _poolAddress) < _amount) {
779	 poolToken.approve(_poolAddress, ALLOWANCE_SIZE);
780	 }
781	 if (depositFee > 0) {
782	 uint256 feeAmount = _amount.mul(depositFee).div(1e18);
783	 holyPool.depositOnBehalf(msg.sender, _amount.sub(feeAmount));
784	 }
785	 else {
786	 holyPool.depositOnBehalf(msg.sender, _amount);
787	 }
788	 return;
789	 }
790	 IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);
791	 if (IERC20(_token).allowance(address(this), address(exchangeProxyContract)) < _amount) {
792	 IERC20(_token).approve(address(exchangeProxyContract), ALLOWANCE_SIZE);
793	 }
794	 uint256 amountNew = exchangeProxyContract.executeSwap(_token, address(poolToken), _amount, convertData);
795	 require(amountNew >= _expectedMinimumReceived, "minimum swap amount not met");
796	 if (exchangeFee > 0 || depositFee > 0) {
797	 uint256 feeAmount = amountNew.mul(exchangeFee).div(1e18);
798	 feeAmount = feeAmount.add(feeAmount.mul(depositFee).div(1e18));
799	 amountNew = amountNew.sub(feeAmount);
800	 }
801	 if (poolToken.allowance(address(this), _poolAddress) < _amount) {
802	 poolToken.approve(_poolAddress, ALLOWANCE_SIZE);
803	 }
804	 holyPool.depositOnBehalf(msg.sender, amountNew);
805	 }
806	 function withdrawFromPool(address _poolAddress, uint256 _amount) public {
807	 IHolyPool holyPool = IHolyPool(_poolAddress);
808	 IERC20 poolToken = IERC20(holyPool.getBaseAsset());
809	 uint256 amountBefore = poolToken.balanceOf(address(this));
810	 holyPool.withdraw(msg.sender, _amount);
811	 uint256 withdrawnAmount = poolToken.balanceOf(address(this)).sub(amountBefore);
812	 if (withdrawFee > 0) {
813	 uint256 feeAmount = withdrawnAmount.mul(withdrawFee).div(1e18);
814	 poolToken.safeTransfer(msg.sender, withdrawnAmount.sub(feeAmount));
815	 }
816	 else {
817	 poolToken.safeTransfer(msg.sender, withdrawnAmount);
818	 }
819	 }
820	 function setDepositFee(uint256 _depositFee) public {
821	 require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), "Admin only");
822	 depositFee = _depositFee;
823	 emit FeeChanged("deposit", _depositFee);
824	 }
825	 function setExchangeFee(uint256 _exchangeFee) public {
826	 require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), "Admin only");
827	 exchangeFee = _exchangeFee;
828	 emit FeeChanged("exchange", _exchangeFee);
829	 }
830	 function setWithdrawFee(uint256 _withdrawFee) public {
831	 require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), "Admin only");
832	 withdrawFee = _withdrawFee;
833	 emit FeeChanged("withdraw", _withdrawFee);
834	 }
835	 function executeSwap(address _tokenFrom, address _tokenTo, uint256 _amountFrom, uint256 _expectedMinimumReceived, bytes memory convertData) public {
836	 require(_tokenFrom != _tokenTo, "Same tokens provided");
837	 IERC20(_tokenFrom).safeTransferFrom(msg.sender, address(this), _amountFrom);
838	 uint256 amountToSwap = _amountFrom;
839	 if (exchangeFee > 0 || depositFee > 0) {
840	 uint256 feeAmount = _amountFrom.mul(exchangeFee).div(1e18);
841	 feeAmount = feeAmount.add(feeAmount.mul(depositFee).div(1e18));
842	 amountToSwap = amountToSwap.sub(feeAmount);
843	 }
844	 if (IERC20(_tokenFrom).allowance(address(this), address(exchangeProxyContract)) < amountToSwap) {
845	 IERC20(_tokenFrom).approve(address(exchangeProxyContract), ALLOWANCE_SIZE);
846	 }
847	 uint256 amountReceived = exchangeProxyContract.executeSwap(_tokenFrom, _tokenTo, amountToSwap, convertData);
848	 require(amountReceived >= _expectedMinimumReceived, "minimum swap amount not met");
849	 IERC20(_tokenTo).safeTransfer(msg.sender, amountReceived);
850	 emit TokenSwap(_tokenFrom, _tokenTo, msg.sender, _amountFrom, _expectedMinimumReceived, amountReceived);
851	 }
852	 function emergencyTransfer(address _token, address _destination, uint256 _amount) public {
853	 require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), "Admin only");
854	 IERC20(_token).safeTransfer(_destination, _amount);
855	 emit EmergencyTransfer(_token, _destination, _amount);
856	 }
857	 function claimFees(address _token, uint256 _amount) public {
858	 require(msg.sender == yieldDistributorAddress, "yield distributor only");
859	 IERC20(_token).safeTransfer(msg.sender, _amount);
860	 }
861	 }
862	 contract HolyWing is AccessControlUpgradeable {
863	 using SafeMath for uint256;
864	 using SafeERC20 for IERC20;
865	 function initialize() public initializer {
866	 _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
867	 }
868	 uint256 private constant ALLOWANCE_SIZE = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;
869	 receive() external payable {
870	 }
871	 event ExecuteSwap(address indexed user, address indexed tokenFrom, address tokenTo, uint256 amount, uint256 amountReceived);
872	 event EmergencyTransfer(address indexed token, address indexed destination, uint256 amount);
873	 function slice( bytes memory _bytes, uint256 _start, uint256 _length ) internal pure returns (bytes memory) {
874	 require(_length + 31 >= _length, "slice_overflow");
875	 require(_start + _length >= _start, "slice_overflow");
876	 require(_bytes.length >= _start + _length, "slice_outOfBounds");
877	 bytes memory tempBytes;
878	 assembly {
879	 switch iszero(_length) case 0 {
880	 tempBytes := mload(0x40) let lengthmod := and(_length, 31) let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod))) let end := add(mc, _length) for {
881	 let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start) }
882	 lt(mc, end) {
883	 mc := add(mc, 0x20) cc := add(cc, 0x20) }
884	 {
885	 mstore(mc, mload(cc)) }
886	 mstore(tempBytes, _length) mstore(0x40, and(add(mc, 31), not(31))) }
887	 default {
888	 tempBytes := mload(0x40) mstore(tempBytes, 0) mstore(0x40, add(tempBytes, 0x20)) }
889	 }
890	 return tempBytes;
891	 }
892	 function executeSwap(address _tokenFrom, address _tokenTo, uint256 _amount, bytes memory _data) public returns(uint256) {
893	 address executorAddress;
894	 address spenderAddress;
895	 uint256 ethValue;
896	 bytes memory callData = slice(_data, 72, _data.length - 72);
897	 assembly {
898	 executorAddress := mload(add(_data, add(0x14, 0))) spenderAddress := mload(add(_data, add(0x14, 0x14))) ethValue := mload(add(_data, add(0x20, 0x28))) }
899	 IERC20(_tokenFrom).safeTransferFrom(msg.sender, address(this), _amount);
900	 if (spenderAddress != address(0) && IERC20(_tokenFrom).allowance(address(this), address(spenderAddress)) < _amount) {
901	 IERC20(_tokenFrom).approve(address(spenderAddress), ALLOWANCE_SIZE);
902	 }
903	 uint balanceBefore = IERC20(_tokenTo).balanceOf(address(this));
904	 (bool success,) = executorAddress.call{
905	 value: ethValue}
906	 (callData);
907	 require(success, "SWAP_CALL_FAILED");
908	 uint balanceAfter = IERC20(_tokenTo).balanceOf(address(this));
909	 uint256 amountReceived = balanceAfter - balanceBefore;
910	 emit ExecuteSwap(msg.sender, _tokenFrom, _tokenTo, _amount, amountReceived);
911	 IERC20(_tokenTo).safeTransfer(msg.sender, amountReceived);
912	 return amountReceived;
913	 }
914	 function emergencyTransfer(address _token, address _destination, uint256 _amount) public {
915	 require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), "Admin only");
916	 IERC20(_token).safeTransfer(_destination, _amount);
917	 emit EmergencyTransfer(_token, _destination, _amount);
918	 }
919	 }
920	 interface IHolyHand {
921	 }
922	 interface IHolyValor {
923	 function safeReclaimAmount() external view returns(uint256);
924	 function totalReclaimAmount() external view returns(uint256);
925	 function reclaimFunds(uint256 amount, bool _safeExecution) external returns(uint256);
926	 }
927	 contract HolyPool is AccessControlUpgradeable, IHolyPool {
928	 using SafeMath for uint256;
929	 using SafeERC20 for IERC20;
930	 bytes32 public constant FINMGMT_ROLE = keccak256("FINMGMT_ROLE");
931	 uint256 private constant lpPrecision = 1e3;
932	 event EmergencyTransferSet(address indexed token, address indexed destination, uint256 amount);
933	 event EmergencyTransferExecute(address indexed token, address indexed destination, uint256 amount);
934	 address private emergencyTransferToken;
935	 address private emergencyTransferDestination;
936	 uint256 private emergencyTransferTimestamp;
937	 uint256 private emergencyTransferAmount;
938	 address public baseAsset;
939	 IHolyHand public transferProxy;
940	 IHolyValor[] public investProxies;
941	 mapping(address => uint256) public investProxiesStatuses;
942	 uint256 public totalAssetAmount;
943	 uint256 public totalShareAmount;
944	 mapping(address => uint256) public shares;
945	 event Deposit(address indexed account, uint256 amount);
946	 event Withdraw(address indexed account, uint256 amountRequested, uint256 amountActual);
947	 event FundsInvested(address indexed investProxy, uint256 amount);
948	 event FundsDivested(address indexed investProxy, uint256 amount);
949	 event YieldRealized(uint256 amount);
950	 event ReclaimFunds(address indexed investProxy, uint256 amountRequested, uint256 amountReclaimed);
951	 bool depositsEnabled;
952	 uint256 public hotReserveTarget;
953	 uint256 public inceptionTimestamp;
954	 function initialize(address _baseAsset) public initializer {
955	 _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
956	 _setupRole(FINMGMT_ROLE, _msgSender());
957	 baseAsset = _baseAsset;
958	 totalShareAmount = 1e6;
959	 totalAssetAmount = 1e6;
960	 depositsEnabled = true;
961	 hotReserveTarget = 0;
962	 inceptionTimestamp = block.timestamp;
963	 }
964	 function getBaseAsset() public override view returns(address) {
965	 return baseAsset;
966	 }
967	 function getDepositBalance(address _beneficiary) public view returns (uint256) {
968	 return shares[_beneficiary].mul(baseAssetPerShare()).div(1e18);
969	 }
970	 function baseAssetPerShare() public view returns (uint256) {
971	 return totalAssetAmount.mul(1e18).div(totalShareAmount);
972	 }
973	 function setTransferProxy(address _transferProxy) public {
974	 require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), "Admin only");
975	 transferProxy = IHolyHand(_transferProxy);
976	 }
977	 function setReserveTarget(uint256 _reserveTarget) public {
978	 require(hasRole(FINMGMT_ROLE, msg.sender), "Finmgmt only");
979	 hotReserveTarget = _reserveTarget;
980	 }
981	 function addHolyValor(address _address) public {
982	 require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), "Admin only");
983	 investProxies.push(IHolyValor(_address));
984	 investProxiesStatuses[_address] = 1;
985	 }
986	 function setHolyValorStatus(address _address, uint256 _status) public {
987	 require(hasRole(FINMGMT_ROLE, msg.sender), "Finmgmt only");
988	 investProxiesStatuses[_address] = _status;
989	 }
990	 function setDepositsEnabled(bool _enabled) public {
991	 require(hasRole(FINMGMT_ROLE, msg.sender), "Finmgmt only");
992	 depositsEnabled = _enabled;
993	 }
994	 function depositOnBehalf(address _beneficiary, uint256 _amount) public override {
995	 require(msg.sender == address(transferProxy), "transfer proxy only");
996	 require(depositsEnabled, "deposits disabled");
997	 IERC20(baseAsset).safeTransferFrom(msg.sender, address(this), _amount);
998	 uint256 assetPerShare = baseAssetPerShare();
999	 uint256 sharesToDeposit = _amount.mul(1e18).div(assetPerShare);
1000	 totalShareAmount = totalShareAmount.add(sharesToDeposit);
1001	 totalAssetAmount = totalAssetAmount.add(_amount);
1002	 shares[_beneficiary] = shares[_beneficiary].add(sharesToDeposit);
1003	 emit Deposit(_beneficiary, _amount);
1004	 }
1005	 function withdraw(address _beneficiary, uint256 _amount) public override {
1006	 require(msg.sender == address(transferProxy), "transfer proxy only");
1007	 uint256 sharesAvailable = shares[_beneficiary];
1008	 uint256 assetPerShare = baseAssetPerShare();
1009	 uint256 assetsAvailable = sharesAvailable.mul(assetPerShare).div(1e18);
1010	 require(_amount <= assetsAvailable, "requested amount exceeds balance");
1011	 uint256 currentBalance = IERC20(baseAsset).balanceOf(address(this));
1012	 if (currentBalance >= _amount) {
1013	 performWithdraw(msg.sender, _beneficiary, _amount, _amount);
1014	 return;
1015	 }
1016	 uint256 amountToReclaim = _amount.sub(currentBalance);
1017	 uint256 reclaimedFunds = retrieveFunds(amountToReclaim);
1018	 if (reclaimedFunds >= amountToReclaim) {
1019	 performWithdraw(msg.sender, _beneficiary, _amount, _amount);
1020	 }
1021	 else {
1022	 performWithdraw(msg.sender, _beneficiary, _amount, currentBalance.add(reclaimedFunds));
1023	 }
1024	 }
1025	 function performWithdraw(address _addressProxy, address _beneficiary, uint256 _amountRequested, uint256 _amountActual) internal {
1026	 uint256 sharesToWithdraw = _amountRequested.mul(1e18).div(baseAssetPerShare());
1027	 require(sharesToWithdraw <= shares[_beneficiary], "requested pool share exceeded");
1028	 IERC20(baseAsset).safeTransfer(_addressProxy, _amountActual);
1029	 shares[_beneficiary] = shares[_beneficiary].sub(sharesToWithdraw);
1030	 totalShareAmount = totalShareAmount.sub(sharesToWithdraw);
1031	 totalAssetAmount = totalAssetAmount.sub(_amountRequested);
1032	 emit Withdraw(_beneficiary, _amountRequested, _amountActual);
1033	 }
1034	 function retrieveFunds(uint256 _amount) internal returns(uint256) {
1035	 uint256 safeAmountTotal = 0;
1036	 uint length = investProxies.length;
1037	 uint256[] memory safeAmounts = new uint[](length);
1038	 uint256[] memory indexes = new uint[](length);
1039	 for (uint256 i; i < length; i++) {
1040	 safeAmounts[i] = investProxies[i].safeReclaimAmount();
1041	 if (safeAmounts[i] >= _amount && investProxiesStatuses[address(investProxies[i])] > 0) {
1042	 uint256 amountToWithdraw = _amount.add(hotReserveTarget);
1043	 if (amountToWithdraw > safeAmounts[i]) {
1044	 amountToWithdraw = safeAmounts[i];
1045	 }
1046	 uint256 reclaimed = investProxies[i].reclaimFunds(amountToWithdraw, true);
1047	 require(reclaimed > amountToWithdraw.sub(lpPrecision) && reclaimed.sub(lpPrecision) < amountToWithdraw, "reclaim amount mismatch");
1048	 emit ReclaimFunds(address(investProxies[i]), _amount, amountToWithdraw);
1049	 return amountToWithdraw;
1050	 }
1051	 indexes[i] = i;
1052	 safeAmountTotal = safeAmountTotal.add(safeAmounts[i]);
1053	 }
1054	 for (uint256 i = length - 1; i >= 0; i--) {
1055	 uint256 picked = safeAmounts[i];
1056	 uint256 pickedIndex = indexes[i];
1057	 uint256 j = i + 1;
1058	 while ((j < length) && (safeAmounts[j] > picked)) {
1059	 safeAmounts[j - 1] = safeAmounts[j];
1060	 indexes[j - 1] = indexes[j];
1061	 j++;
1062	 }
1063	 safeAmounts[j - 1] = picked;
1064	 indexes[j - 1] = pickedIndex;
1065	 if (i == 0) {
1066	 break;
1067	 }
1068	 }
1069	 if (safeAmountTotal > _amount) {
1070	 uint256 totalReclaimed = 0;
1071	 for (uint256 i; i < length; i++) {
1072	 uint256 amountToWithdraw = safeAmounts[indexes[i]];
1073	 if (amountToWithdraw > _amount.sub(totalReclaimed).add(hotReserveTarget)) {
1074	 amountToWithdraw = _amount.sub(totalReclaimed).add(hotReserveTarget);
1075	 }
1076	 uint256 reclaimed = investProxies[indexes[i]].reclaimFunds(amountToWithdraw, true);
1077	 require(reclaimed > amountToWithdraw.sub(lpPrecision) && reclaimed.sub(lpPrecision) < amountToWithdraw, "reclaim amount mismatch");
1078	 totalReclaimed = totalReclaimed.add(amountToWithdraw);
1079	 emit ReclaimFunds(address(investProxies[indexes[i]]), _amount, amountToWithdraw);
1080	 if (totalReclaimed >= _amount) {
1081	 break;
1082	 }
1083	 }
1084	 return totalReclaimed;
1085	 }
1086	 uint256 totalReclaimedNoFees = 0;
1087	 uint256 totalActualReclaimed = 0;
1088	 for (uint256 i; i < length; i++) {
1089	 uint256 amountToWithdraw = _amount.sub(totalReclaimedNoFees);
1090	 uint256 totalAvailableInValor = investProxies[indexes[i]].totalReclaimAmount();
1091	 if (amountToWithdraw > totalAvailableInValor) {
1092	 amountToWithdraw = totalAvailableInValor;
1093	 }
1094	 uint256 actualReclaimed = investProxies[indexes[i]].reclaimFunds(amountToWithdraw, false);
1095	 totalReclaimedNoFees = totalReclaimedNoFees.add(amountToWithdraw);
1096	 totalActualReclaimed = totalActualReclaimed.add(actualReclaimed);
1097	 emit ReclaimFunds(address(investProxies[indexes[i]]), amountToWithdraw, actualReclaimed);
1098	 if (totalReclaimedNoFees >= _amount) {
1099	 break;
1100	 }
1101	 }
1102	 return totalActualReclaimed;
1103	 }
1104	 function getSafeWithdrawAmount() public view returns(uint256) {
1105	 uint256 safeAmount = IERC20(baseAsset).balanceOf(address(this));
1106	 uint length = investProxies.length;
1107	 for (uint256 i; i < length; i++) {
1108	 if (investProxiesStatuses[address(investProxies[i])] > 0) {
1109	 safeAmount = safeAmount.add(investProxies[i].safeReclaimAmount());
1110	 }
1111	 }
1112	 return safeAmount;
1113	 }
1114	 function borrowToInvest(uint256 _amount) override public returns(uint256) {
1115	 require(investProxiesStatuses[msg.sender] == 1, "active invest proxy only");
1116	 uint256 borrowableAmount = IERC20(baseAsset).balanceOf(address(this));
1117	 require(borrowableAmount > hotReserveTarget, "not enough funds");
1118	 borrowableAmount = borrowableAmount.sub(hotReserveTarget);
1119	 if (_amount > borrowableAmount) {
1120	 _amount = borrowableAmount;
1121	 }
1122	 IERC20(baseAsset).safeTransfer(msg.sender, _amount);
1123	 emit FundsInvested(msg.sender, _amount);
1124	 return _amount;
1125	 }
1126	 function returnInvested(uint256 _amountCapitalBody) override public {
1127	 require(investProxiesStatuses[msg.sender] > 0, "invest proxy only");
1128	 IERC20(baseAsset).safeTransferFrom(address(msg.sender), address(this), _amountCapitalBody);
1129	 emit FundsDivested(msg.sender, _amountCapitalBody);
1130	 }
1131	 function harvestYield(uint256 _amountYield) override public {
1132	 IERC20(baseAsset).safeTransferFrom(msg.sender, address(this), _amountYield);
1133	 totalAssetAmount = totalAssetAmount.add(_amountYield);
1134	 emit YieldRealized(_amountYield);
1135	 }
1136	 function getDailyAPY() public view returns(uint256) {
1137	 uint256 secondsFromInception = block.timestamp.sub(inceptionTimestamp);
1138	 return baseAssetPerShare().sub(1e18).mul(100) .mul(86400).div(secondsFromInception);
1139	 }
1140	 function emergencyTransferTimelockSet(address _token, address _destination, uint256 _amount) public {
1141	 require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), "Admin only");
1142	 emergencyTransferTimestamp = block.timestamp;
1143	 emergencyTransferToken = _token;
1144	 emergencyTransferDestination = _destination;
1145	 emergencyTransferAmount = _amount;
1146	 emit EmergencyTransferSet(_token, _destination, _amount);
1147	 }
1148	 function emergencyTransferExecute() public {
1149	 require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), "Admin only");
1150	 require(block.timestamp > emergencyTransferTimestamp + 24 * 3600, "timelock too early");
1151	 require(block.timestamp < emergencyTransferTimestamp + 72 * 3600, "timelock too late");
1152	 IERC20(emergencyTransferToken).safeTransfer(emergencyTransferDestination, emergencyTransferAmount);
1153	 emit EmergencyTransferExecute(emergencyTransferToken, emergencyTransferDestination, emergencyTransferAmount);
1154	 emergencyTransferTimestamp = 0;
1155	 emergencyTransferToken = address(0);
1156	 emergencyTransferDestination = address(0);
1157	 emergencyTransferAmount = 0;
1158	 }
1159	 }
